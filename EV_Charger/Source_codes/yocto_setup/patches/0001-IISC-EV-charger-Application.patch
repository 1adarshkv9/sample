From d481705131a8f1cf4f273f2408f978cbb55b35c3 Mon Sep 17 00:00:00 2001
From: saikrishnagv53 <sai.k@phytec.in>
Date: Wed, 29 Mar 2023 16:16:27 +0530
Subject: [PATCH] IISC EV charger Application

---
 meta-libraries/conf/layer.conf                |     1 +
 .../dbus-wrapper/dbus-wrapper_0.1.bb          |    41 +
 .../dbus-wrapper/files/CMakeLists.txt         |    27 +
 .../dbus-wrapper/files/inc/dbus_interface.h   |    59 +
 .../dbus-wrapper/files/inc/dbus_wrapper.h     |    71 +
 .../dbus-wrapper/files/src/dbus_wrapper.c     |   331 +
 meta-services/conf/layer.conf                 |     2 +-
 .../aws-iot-device-sdk-c_2.1.1.bb             |    71 +
 .../files/aws_iot_config.h                    |    60 +
 .../files/aws_iot_config.h_ganesh             |    56 +
 .../files/certs/AmazonRootCA1.pem             |    20 +
 .../files/certs/AmazonRootCA3.pem             |    12 +
 .../files/certs/README.txt                    |     4 +
 ...0f20915608e256c65375d8-certificate.pem.crt |    20 +
 ...f0510f20915608e256c65375d8-private.pem.key |    27 +
 ...af0510f20915608e256c65375d8-public.pem.key |     9 +
 .../files/certs/root-CA.crt                   |    20 +
 .../files/certs/switch.cert.pem               |    20 +
 .../files/certs/switch.private.key            |    27 +
 .../files/subscribe_publish_sample.c          |   262 +
 .../recipes-services/can-app/can-app_0.1.bb   |    29 +
 .../can-app/files/CMakeLists.txt              |    38 +
 .../recipes-services/can-app/files/inc/can.h  |    39 +
 .../can-app/files/inc/can_app.h               |   120 +
 .../recipes-services/can-app/files/inc/log.h  |    67 +
 .../can-app/files/scripts/can_up.sh           |     7 +
 .../recipes-services/can-app/files/src/can.c  |   117 +
 .../can-app/files/src/can_app.c               |   468 +
 .../can-app/files/src/can_app.c_bckup         |   432 +
 .../config-scripts/config-scripts_0.1.bb      |    29 +
 .../files/scripts/can_config.sh               |     7 +
 .../files/scripts/dbus_export.sh              |     2 +
 .../files/services/can_config.service         |    14 +
 .../files/services/dbus_export.service        |     9 +
 .../evcharger-app/evcharger-app_0.1.bb        |    36 +
 .../evcharger-app/files/CMakeLists.txt        |    24 +
 .../evcharger-app/files/inc/can.h             |    39 +
 .../evcharger-app/files/inc/log.h             |    67 +
 .../evcharger-app/files/src/can.c             |   117 +
 .../files/src/smart_charger_app.c             |   426 +
 .../lcd-app/files/GaugingSystem.pro           |    33 +
 .../lcd-app/files/GaugingSystem.pro.user      |   336 +
 .../files/GaugingSystem.pro.user.1b9615d      |   271 +
 .../lcd-app/files/componentdialog.cpp         |   106 +
 .../lcd-app/files/componentdialog.h           |    42 +
 .../lcd-app/files/gauge_system_master.xml     |    76 +
 .../lcd-app/files/gauge_system_master_1.xml   |   126 +
 .../lcd-app/files/gaugedata.h                 |    19 +
 .../lcd-app/files/gaugedatabasemanager.cpp    |   237 +
 .../lcd-app/files/gaugedatabasemanager.h      |    45 +
 .../recipes-services/lcd-app/files/include.h  |    49 +
 .../recipes-services/lcd-app/files/main.cpp   |    23 +
 .../lcd-app/files/mainwindow.cpp              |  1570 +
 .../lcd-app/files/mainwindow.h                |   189 +
 .../lcd-app/files/mysqltablemodel.cpp         |   151 +
 .../lcd-app/files/mysqltablemodel.h           |    43 +
 .../lcd-app/files/qcustomplot.cpp             | 23553 ++++++++++++++++
 .../lcd-app/files/qcustomplot.h               |  3768 +++
 .../lcd-app/files/release_note.txt            |    12 +
 .../lcd-app/files/sqltabledelegate.cpp        |   113 +
 .../lcd-app/files/sqltabledelegate.h          |    20 +
 .../recipes-services/lcd-app/files/tvs1.jpg   |   Bin 0 -> 6697 bytes
 .../recipes-services/lcd-app/files/tvs2.jpg   |   Bin 0 -> 6865 bytes
 .../recipes-services/lcd-app/files/tvs3.jpg   |   Bin 0 -> 5159 bytes
 .../lcd-app/files/tvs_horse.png               |   Bin 0 -> 4176 bytes
 .../lcd-app/files/tvs_logo.png                |   Bin 0 -> 8851 bytes
 .../lcd-app/files/tvs_spare.png               |   Bin 0 -> 44922 bytes
 .../recipes-services/lcd-app/lcd-app_0.1.bb   |    77 +
 .../qtexample/files/qtexample.cpp             |    10 +
 .../qtexample/files/qtexample.pro             |     2 +
 .../qtexample/qt_example_0.1.bb_bckup         |    12 +
 .../qtexample/qtexample_0.1.bb                |    83 +
 .../smart-app/files/CMakeLists.txt            |    33 +
 .../smart-app/files/inc/log.h                 |    67 +
 .../smart-app/files/inc/smart_app.h           |    61 +
 .../smart-app/files/src/smart_app.c           |   172 +
 .../smart-app/smart-app_0.1.bb                |    26 +
 meta-utils/conf/layer.conf                    |     2 +-
 .../dbus-example/dbus-example_0.1.bb          |    29 +
 .../dbus-example/files/CMakeLists.txt         |    42 +
 .../dbus-example/files/cmakelist_bckup        |    74 +
 .../dbus-example/files/inc/dbus_emitter.h     |    49 +
 .../dbus-example/files/inc/dbus_listener.h    |    41 +
 .../dbus-example/files/inc/log.h              |    67 +
 .../dbus-example/files/src/dbus_emitter.c     |   160 +
 .../dbus-example/files/src/dbus_listener.c    |   102 +
 .../files/src/dbus_reference_emitter.c        |    97 +
 .../files/src/dbus_reference_listener.c       |    97 +
 .../files/src/simple_dbus_emitter.c           |    39 +
 .../files/src/simple_dbus_listener.c          |   103 +
 .../files/src/test_dbus_emitter.c             |    44 +
 .../files/src/test_dbus_listener.c            |    56 +
 92 files changed, 35552 insertions(+), 2 deletions(-)
 create mode 100644 meta-libraries/recipes-libraries/dbus-wrapper/dbus-wrapper_0.1.bb
 create mode 100644 meta-libraries/recipes-libraries/dbus-wrapper/files/CMakeLists.txt
 create mode 100755 meta-libraries/recipes-libraries/dbus-wrapper/files/inc/dbus_interface.h
 create mode 100644 meta-libraries/recipes-libraries/dbus-wrapper/files/inc/dbus_wrapper.h
 create mode 100755 meta-libraries/recipes-libraries/dbus-wrapper/files/src/dbus_wrapper.c
 create mode 100644 meta-services/recipes-services/aws-iot-device-sdk-c/aws-iot-device-sdk-c_2.1.1.bb
 create mode 100644 meta-services/recipes-services/aws-iot-device-sdk-c/files/aws_iot_config.h
 create mode 100644 meta-services/recipes-services/aws-iot-device-sdk-c/files/aws_iot_config.h_ganesh
 create mode 100644 meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/AmazonRootCA1.pem
 create mode 100644 meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/AmazonRootCA3.pem
 create mode 100644 meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/README.txt
 create mode 100644 meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/e473d1a14a8e42a61040e4de7f89763f09669af0510f20915608e256c65375d8-certificate.pem.crt
 create mode 100644 meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/e473d1a14a8e42a61040e4de7f89763f09669af0510f20915608e256c65375d8-private.pem.key
 create mode 100644 meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/e473d1a14a8e42a61040e4de7f89763f09669af0510f20915608e256c65375d8-public.pem.key
 create mode 100644 meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/root-CA.crt
 create mode 100644 meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/switch.cert.pem
 create mode 100644 meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/switch.private.key
 create mode 100644 meta-services/recipes-services/aws-iot-device-sdk-c/files/subscribe_publish_sample.c
 create mode 100644 meta-services/recipes-services/can-app/can-app_0.1.bb
 create mode 100755 meta-services/recipes-services/can-app/files/CMakeLists.txt
 create mode 100644 meta-services/recipes-services/can-app/files/inc/can.h
 create mode 100644 meta-services/recipes-services/can-app/files/inc/can_app.h
 create mode 100644 meta-services/recipes-services/can-app/files/inc/log.h
 create mode 100644 meta-services/recipes-services/can-app/files/scripts/can_up.sh
 create mode 100644 meta-services/recipes-services/can-app/files/src/can.c
 create mode 100644 meta-services/recipes-services/can-app/files/src/can_app.c
 create mode 100644 meta-services/recipes-services/can-app/files/src/can_app.c_bckup
 create mode 100644 meta-services/recipes-services/config-scripts/config-scripts_0.1.bb
 create mode 100644 meta-services/recipes-services/config-scripts/files/scripts/can_config.sh
 create mode 100644 meta-services/recipes-services/config-scripts/files/scripts/dbus_export.sh
 create mode 100644 meta-services/recipes-services/config-scripts/files/services/can_config.service
 create mode 100644 meta-services/recipes-services/config-scripts/files/services/dbus_export.service
 create mode 100644 meta-services/recipes-services/evcharger-app/evcharger-app_0.1.bb
 create mode 100644 meta-services/recipes-services/evcharger-app/files/CMakeLists.txt
 create mode 100755 meta-services/recipes-services/evcharger-app/files/inc/can.h
 create mode 100644 meta-services/recipes-services/evcharger-app/files/inc/log.h
 create mode 100755 meta-services/recipes-services/evcharger-app/files/src/can.c
 create mode 100644 meta-services/recipes-services/evcharger-app/files/src/smart_charger_app.c
 create mode 100644 meta-services/recipes-services/lcd-app/files/GaugingSystem.pro
 create mode 100644 meta-services/recipes-services/lcd-app/files/GaugingSystem.pro.user
 create mode 100644 meta-services/recipes-services/lcd-app/files/GaugingSystem.pro.user.1b9615d
 create mode 100644 meta-services/recipes-services/lcd-app/files/componentdialog.cpp
 create mode 100644 meta-services/recipes-services/lcd-app/files/componentdialog.h
 create mode 100644 meta-services/recipes-services/lcd-app/files/gauge_system_master.xml
 create mode 100644 meta-services/recipes-services/lcd-app/files/gauge_system_master_1.xml
 create mode 100644 meta-services/recipes-services/lcd-app/files/gaugedata.h
 create mode 100644 meta-services/recipes-services/lcd-app/files/gaugedatabasemanager.cpp
 create mode 100644 meta-services/recipes-services/lcd-app/files/gaugedatabasemanager.h
 create mode 100644 meta-services/recipes-services/lcd-app/files/include.h
 create mode 100644 meta-services/recipes-services/lcd-app/files/main.cpp
 create mode 100644 meta-services/recipes-services/lcd-app/files/mainwindow.cpp
 create mode 100644 meta-services/recipes-services/lcd-app/files/mainwindow.h
 create mode 100644 meta-services/recipes-services/lcd-app/files/mysqltablemodel.cpp
 create mode 100644 meta-services/recipes-services/lcd-app/files/mysqltablemodel.h
 create mode 100644 meta-services/recipes-services/lcd-app/files/qcustomplot.cpp
 create mode 100644 meta-services/recipes-services/lcd-app/files/qcustomplot.h
 create mode 100644 meta-services/recipes-services/lcd-app/files/release_note.txt
 create mode 100644 meta-services/recipes-services/lcd-app/files/sqltabledelegate.cpp
 create mode 100644 meta-services/recipes-services/lcd-app/files/sqltabledelegate.h
 create mode 100644 meta-services/recipes-services/lcd-app/files/tvs1.jpg
 create mode 100644 meta-services/recipes-services/lcd-app/files/tvs2.jpg
 create mode 100644 meta-services/recipes-services/lcd-app/files/tvs3.jpg
 create mode 100644 meta-services/recipes-services/lcd-app/files/tvs_horse.png
 create mode 100644 meta-services/recipes-services/lcd-app/files/tvs_logo.png
 create mode 100644 meta-services/recipes-services/lcd-app/files/tvs_spare.png
 create mode 100644 meta-services/recipes-services/lcd-app/lcd-app_0.1.bb
 create mode 100644 meta-services/recipes-services/qtexample/files/qtexample.cpp
 create mode 100644 meta-services/recipes-services/qtexample/files/qtexample.pro
 create mode 100644 meta-services/recipes-services/qtexample/qt_example_0.1.bb_bckup
 create mode 100644 meta-services/recipes-services/qtexample/qtexample_0.1.bb
 create mode 100755 meta-services/recipes-services/smart-app/files/CMakeLists.txt
 create mode 100644 meta-services/recipes-services/smart-app/files/inc/log.h
 create mode 100644 meta-services/recipes-services/smart-app/files/inc/smart_app.h
 create mode 100644 meta-services/recipes-services/smart-app/files/src/smart_app.c
 create mode 100644 meta-services/recipes-services/smart-app/smart-app_0.1.bb
 create mode 100644 meta-utils/recipes-utils/dbus-example/dbus-example_0.1.bb
 create mode 100755 meta-utils/recipes-utils/dbus-example/files/CMakeLists.txt
 create mode 100755 meta-utils/recipes-utils/dbus-example/files/cmakelist_bckup
 create mode 100644 meta-utils/recipes-utils/dbus-example/files/inc/dbus_emitter.h
 create mode 100644 meta-utils/recipes-utils/dbus-example/files/inc/dbus_listener.h
 create mode 100644 meta-utils/recipes-utils/dbus-example/files/inc/log.h
 create mode 100644 meta-utils/recipes-utils/dbus-example/files/src/dbus_emitter.c
 create mode 100644 meta-utils/recipes-utils/dbus-example/files/src/dbus_listener.c
 create mode 100644 meta-utils/recipes-utils/dbus-example/files/src/dbus_reference_emitter.c
 create mode 100644 meta-utils/recipes-utils/dbus-example/files/src/dbus_reference_listener.c
 create mode 100644 meta-utils/recipes-utils/dbus-example/files/src/simple_dbus_emitter.c
 create mode 100644 meta-utils/recipes-utils/dbus-example/files/src/simple_dbus_listener.c
 create mode 100644 meta-utils/recipes-utils/dbus-example/files/src/test_dbus_emitter.c
 create mode 100644 meta-utils/recipes-utils/dbus-example/files/src/test_dbus_listener.c

diff --git a/meta-libraries/conf/layer.conf b/meta-libraries/conf/layer.conf
index ffe48ee..486ab3b 100644
--- a/meta-libraries/conf/layer.conf
+++ b/meta-libraries/conf/layer.conf
@@ -19,3 +19,4 @@ IMAGE_INSTALL_append = " mraa"
 IMAGE_INSTALL_append = " python3 python3-pip python3-paho-mqtt python3-pymodbus python3-pyserial python3-six python3-requests python3-flask python3-flup"
 IMAGE_INSTALL_append = " sqlite3 lighttpd wpa-supplicant libqmi"
 IMAGE_INSTALL_append = " libwebsockets ntp tzdata nodejs"
+IMAGE_INSTALL_append = " dbus-wrapper"
diff --git a/meta-libraries/recipes-libraries/dbus-wrapper/dbus-wrapper_0.1.bb b/meta-libraries/recipes-libraries/dbus-wrapper/dbus-wrapper_0.1.bb
new file mode 100644
index 0000000..da22c71
--- /dev/null
+++ b/meta-libraries/recipes-libraries/dbus-wrapper/dbus-wrapper_0.1.bb
@@ -0,0 +1,41 @@
+SUMMARY = "dbus wrapper library"
+SECTION = "dbus"
+LICENSE = "MIT"
+LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302"
+
+DEPENDS += " \
+    json-c \
+    libsocketcan \
+    dbus-glib\
+"
+
+SRC_URI = "\
+            file://CMakeLists.txt \
+            file://inc/dbus_interface.h\
+            file://inc/dbus_wrapper.h\
+            file://src/dbus_wrapper.c\
+"
+
+S = "${WORKDIR}"
+
+EXTRA_OECMAKE = " "
+
+INHIBIT_PACKAGE_STRIP = "1"
+INHIBIT_SYSROOT_STRIP = "1"
+SOLIBS = ".so*"
+SOLIBSDEV += ".so"
+FILES_SOLIBSDEV = ""
+
+inherit pkgconfig cmake
+
+do_install() {
+    install -d ${D}${libdir}
+    install -m 0755 libdbus-wrapper.so ${D}${libdir}
+
+    install -d ${D}${includedir}
+    install -m 0755 ${S}/inc/dbus_interface.h ${D}${includedir}
+    install -m 0755 ${S}/inc/dbus_wrapper.h ${D}${includedir}
+}
+
+
+FILES_${PN} += "${libdir} ${includedir}"
diff --git a/meta-libraries/recipes-libraries/dbus-wrapper/files/CMakeLists.txt b/meta-libraries/recipes-libraries/dbus-wrapper/files/CMakeLists.txt
new file mode 100644
index 0000000..c63f266
--- /dev/null
+++ b/meta-libraries/recipes-libraries/dbus-wrapper/files/CMakeLists.txt
@@ -0,0 +1,27 @@
+cmake_minimum_required(VERSION 3.5)
+project(dbus-wrapper)
+
+include_directories(
+    ${CMAKE_CURRENT_SOURCE_DIR}/inc}
+    )
+
+SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-unknown-pragmas -D_GNU_SOURCE -D_USINGLIBC -lrt -lpthread" )
+
+set(JSON_LIBRARY "-ljson-c" )
+find_package(PkgConfig REQUIRED)
+pkg_check_modules(DBUS_GLIB-1  REQUIRED IMPORTED_TARGET dbus-glib-1)
+pkg_check_modules(GLIB-2.0  REQUIRED IMPORTED_TARGET glib-2.0)
+pkg_check_modules(DBUS-1  REQUIRED IMPORTED_TARGET dbus-1)
+
+ADD_LIBRARY(dbus-wrapper SHARED
+    ${CMAKE_CURRENT_SOURCE_DIR}/src/dbus_wrapper.c
+    )
+
+include_directories(${JSON_INCLUDE_DIR})
+target_link_libraries(dbus-wrapper PUBLIC
+                      ${JSON_LIBRARY} 
+                      PkgConfig::DBUS_GLIB-1
+                      PkgConfig::GLIB-2.0
+                      PkgConfig::DBUS-1
+)
+
diff --git a/meta-libraries/recipes-libraries/dbus-wrapper/files/inc/dbus_interface.h b/meta-libraries/recipes-libraries/dbus-wrapper/files/inc/dbus_interface.h
new file mode 100755
index 0000000..34c1d3e
--- /dev/null
+++ b/meta-libraries/recipes-libraries/dbus-wrapper/files/inc/dbus_interface.h
@@ -0,0 +1,59 @@
+#ifndef __DBUS_INFRA_H__
+#define __DBUS_INFRA_H__
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* General Commands for D-Bus signal */
+#define REQUEST_SIGNAL                      0x2001
+#define RESPONSE_SIGNAL                     0x2002
+#define STATUS_SIGNAL                       0x2003
+#define ERROR_SIGNAL                        0x2004
+/*---------------------------------------------------------------------------------------------------------*/
+/* CAN SERVICE D-BUS signal command */
+#define CAN_OPEN_SOC_ERR_CMD                0x2600
+#define CAN_OPEN_SOC_BIND_ERR_CMD           0x2601
+#define CAN_SOC_SET_TIMEOUT_ERR_CMD         0x2602
+#define CAN_RX_ERR_CMD                      0x2603
+#define CAN_SOC_CAN_RAW_ERR_FILTER_ERR_CMD  0x2604
+
+/* CAN service event broadcast object and interface */
+#define CAN_SER_DATA_OBJECT        "/iisc/evstation/can"
+#define CAN_SER_DATA_INTERFACE     "iisc.evstation.can"
+#define CAN_SER_DATA_SIG_NAME      "can"
+#define CAN_SER_SIGNAL_ID          0x1001
+
+/* CAN Service event subscriber interface names */
+#define CAN_SER_DATA_RCVR          "type='signal',interface='iisc.evstation.can'"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* LCD service event broadcast object and interface */
+#define LCD_SER_DATA_OBJECT        "/iisc/evstation/lcd"
+#define LCD_SER_DATA_INTERFACE     "iisc.evstation.lcd"
+#define LCD_SER_DATA_SIG_NAME      "lcd"
+#define LCD_SER_SIGNAL_ID          0x1002
+
+/* LCD Service event subscriber interface names */
+#define LCD_SER_DATA_RCVR          "type='signal',interface='iisc.evstation.lcd'"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* AWS_MQTT_APP service event broadcast object and interface */
+#define AWS_MQTT_APP_SER_DATA_OBJECT        "/iisc/evstation/aws_mqtt_app"
+#define AWS_MQTT_APP_SER_DATA_INTERFACE     "iisc.evstation.aws_mqtt_app"
+#define AWS_MQTT_APP_SER_DATA_SIG_NAME      "aws_mqtt_app"
+#define AWS_MQTT_APP_SER_SIGNAL_ID          0x1003
+
+/* AWS_MQTT_APP Service event subscriber interface names */
+#define AWS_MQTT_APP_SER_DATA_RCVR          "type='signal',interface='iisc.evstation.aws_mqtt_app'"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SMART CHARGER APP Service event broadcast object and interface */
+#define SMART_CHARGER_APP_SER_DATA_OBJECT        "/iisc/evstation/smart_charger_app"
+#define SMART_CHARGER_APP_SER_DATA_INTERFACE     "iisc.evstation.smart_charger_app"
+#define SMART_CHARGER_APP_SER_DATA_SIG_NAME      "smart_charger_app"
+#define SMART_CHARGER_APP_SER_SIGNAL_ID          0x1004
+
+/* SMART CHARGER APP Service event subscriber interface names */
+#define SMART_CHARGER_APP_SER_DATA_RCVR          "type='signal',interface='iisc.evstation.smart_charger_app'"
+
+/*---------------------------------------------------------------------------------------------------------*/
+#endif
+
diff --git a/meta-libraries/recipes-libraries/dbus-wrapper/files/inc/dbus_wrapper.h b/meta-libraries/recipes-libraries/dbus-wrapper/files/inc/dbus_wrapper.h
new file mode 100644
index 0000000..9c8b142
--- /dev/null
+++ b/meta-libraries/recipes-libraries/dbus-wrapper/files/inc/dbus_wrapper.h
@@ -0,0 +1,71 @@
+#ifndef __IISC_DBUS_H__
+#define __IISC_DBUS_H__
+
+enum erros
+{
+/*    SUCCESS=0, */
+    DBUS_GET_CONN_ERROR=1,
+    DBUS_CREATE_SIG_NULL,
+    DBUS_APPEND_ERROR,
+    DBUS_WRITE_ERROR,
+    DBUS_SIGNAL_MATCH_ERROR,
+};
+
+struct dbus_var_t
+{
+  DBusError err;
+  DBusConnection* conn;
+  dbus_uint32_t serial;
+  DBusMessage* msg;
+  DBusMessageIter args;
+
+  char *obj;
+  char *interface;
+  char *sig_name;
+  char *rcvr_sig;
+};
+
+struct json_obj_t
+{
+  struct json_object *obj;
+  struct json_object *sig;
+  struct json_object *dlc;
+  struct json_object *cmd;
+  struct json_object *can_id;
+  struct json_object *payload;
+};
+
+struct signal_data_t
+{
+  uint32_t  signal_id;
+  uint32_t  can_id;
+  uint8_t   dlc;
+  uint32_t  cmd;
+  char     *payload;
+};
+
+enum SYSTEM_ERROR_CODES
+{
+    //CAN APP
+    CAN_INVALID_JSON = 0x001,
+    CAN_INVALID_PORT_ID = 0x002,
+    CAN_INVALID_PORT_ACTION = 0x003,
+
+    //SMART APP
+    SMART_APP_INVALID_JSON = 0x004,
+
+};
+
+
+void hex_to_string(uint32_t value, char *str);
+int string_to_hex(char *str);
+int write_init(struct dbus_var_t *dbus);
+struct json_obj_t read_data(struct dbus_var_t *dbus);
+int read_init(struct dbus_var_t *dbus);
+int write_data(char *data, struct dbus_var_t dbus);
+struct json_obj_t read_data(struct dbus_var_t *dbus);
+int add_filter(struct dbus_var_t *dbus, char *signal);
+int compose_data(struct json_obj_t *j_data, char *db_payload, struct signal_data_t signal_data);
+int check_data(struct dbus_var_t *dbus);
+
+#endif 
diff --git a/meta-libraries/recipes-libraries/dbus-wrapper/files/src/dbus_wrapper.c b/meta-libraries/recipes-libraries/dbus-wrapper/files/src/dbus_wrapper.c
new file mode 100755
index 0000000..f7624d8
--- /dev/null
+++ b/meta-libraries/recipes-libraries/dbus-wrapper/files/src/dbus_wrapper.c
@@ -0,0 +1,331 @@
+#include <dbus/dbus.h>
+#include <json-c/json.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <pthread.h>
+#include <syslog.h>
+
+#include "../inc/dbus_wrapper.h"
+#include "../inc/dbus_interface.h"
+
+#define DBUS "DBUS"
+
+#define LOGS(l, p, x,arg...) \
+	{\
+	syslog(l,"" p " : "#x"\n", ##arg);\
+	}
+
+pthread_mutex_t dbus_mutex;
+pthread_mutex_t dbus_compose_mutex;
+
+/*********************************************************************************************/
+/*              fn: void hex_to_string(uint32_t value, char *str)
+ *
+ *              brief: convert hex to string  
+ *
+ *              param: 
+ *                   str   -  output string
+ *                   value -  input value to be convert to string
+ *
+ *              return: none
+ */
+/*********************************************************************************************/
+
+void hex_to_string(uint32_t value, char *str){
+
+   sprintf(str,"\"0x%x\"",value);
+}
+
+/*********************************************************************************************/
+/*              fn: void string_to_hex(uint32_t *value, char *str)
+ *
+ *              brief: convert string to hex value 
+ *
+ *              param: 
+ *                   str   -  input string
+ *                   value -  converted value to be return
+ *
+ *              return: none
+ */
+/*********************************************************************************************/
+int string_to_hex( char *str){
+
+   return strtol(str,NULL,16);
+}
+
+/*********************************************************************************************/
+/*              fn: int write_init(struct dbus_var_t *dbus)
+ *
+ *              brief: Initialize dbus write
+ *
+ *              param: 
+ *                   dbus_var_t - pointer to dbus initialization variable structure
+ *
+ *              return: error/success codes
+ */
+/*********************************************************************************************/
+int write_init(struct dbus_var_t *dbus)
+{
+
+   // initialise the errors
+   dbus_error_init(&(dbus->err));
+
+   // connect to the bus
+   dbus->conn = dbus_bus_get( DBUS_BUS_SESSION, &dbus->err );
+   if ( dbus_error_is_set( &dbus->err ) ) {
+       fprintf( stderr, "Connection Error (%s)\n", dbus->err.message );
+       dbus_error_free( &dbus->err );
+   }
+   if ( NULL == dbus->conn ) {
+       return DBUS_GET_CONN_ERROR;
+   }
+
+   return 0;//SUCCESS;
+}
+
+/*********************************************************************************************/
+/*              fn: int write_data(char *data, struct dbus_var_t dbus)
+ *
+ *              brief: write in dbus connection
+ *
+ *              param: 
+ *                   dbus_var_t - pointer to dbus initialized variable structure
+ *                   char *data - data to be write on dbus
+ *
+ *              return: error/success codes
+ */
+/*********************************************************************************************/
+
+int write_data(char *data, struct dbus_var_t dbus)
+{
+
+   // create a signal and check for errors
+   dbus.msg = dbus_message_new_signal(
+                             dbus.obj,   // object name of the signal
+                             dbus.interface,   // interface name of the signal
+                             dbus.sig_name ); // name of the signal
+   if ( NULL == dbus.msg ) {
+       LOGS(LOG_INFO, DBUS, "%s Message Null\n", dbus.sig_name );
+       return DBUS_CREATE_SIG_NULL;
+   }
+
+   // append arguments onto signal
+   dbus_message_iter_init_append(dbus.msg,&dbus.args );
+
+   if( !dbus_message_iter_append_basic( &dbus.args, DBUS_TYPE_STRING, &data) ) {
+       LOGS(LOG_INFO, DBUS, "Out Of Memory! %s \n",dbus.sig_name );
+       return DBUS_APPEND_ERROR;
+   }
+
+   // send the message and flush the connection
+   if ( !dbus_connection_send( dbus.conn, dbus.msg, &dbus.serial ) ) {
+       LOGS(LOG_INFO, DBUS, "Out Of Memory! %s \n",dbus.sig_name );
+       return DBUS_WRITE_ERROR;
+   }
+   dbus_connection_flush( dbus.conn );
+  
+   // free the message
+   dbus_message_unref( dbus.msg );
+   return 0;
+}
+
+/*********************************************************************************************/
+/*              fn: int compose_data(struct json_obj_t *j_data, char *db_payload struct,
+ *                                                                   signal_data_t signal_data)
+ *
+ *              brief: prepare data to be write on dbus
+ *
+ *              param: 
+ *                   json_obj_t - paointer to json object to be write on dbus
+ *                   db_payload - data to be write on dbus
+ *                   signal_data - data from the caller service
+ *
+ *              return: error/success codes
+ */
+/*********************************************************************************************/
+
+ int compose_data(struct json_obj_t *j_data, char *db_payload, struct signal_data_t signal_data)
+{
+
+   j_data->obj = json_object_new_object();
+   j_data->dlc = json_object_new_object();
+   j_data->cmd = json_object_new_object();
+   j_data->sig = json_object_new_object();
+   j_data->can_id = json_object_new_object();
+   j_data->payload = json_object_new_object();
+   
+   char temp[64];
+   signal_data.dlc = strlen(signal_data.payload);
+ 
+   /* update length of payload */ 
+   hex_to_string(signal_data.dlc,temp);
+   j_data->dlc = json_tokener_parse(temp);
+   json_object_object_add(j_data->obj, "dlc",j_data->dlc);
+
+   /* update command*/ 
+   hex_to_string(signal_data.cmd,temp);
+   j_data->cmd = json_tokener_parse(temp);
+   json_object_object_add(j_data->obj, "cmd",j_data->cmd);
+
+   /* update SIGNAL type of broadcast service */ 
+   hex_to_string(signal_data.signal_id,temp);
+   j_data->sig = json_tokener_parse(temp);
+   json_object_object_add(j_data->obj, "sig_id",j_data->sig);
+
+   if(signal_data.signal_id == CAN_SER_SIGNAL_ID)
+   {
+       struct json_object* json_format_can_data;
+       json_format_can_data = json_tokener_parse(signal_data.payload);
+       json_object *jstring_can_data = json_format_can_data;
+       json_object_object_add(j_data->obj,"payload",jstring_can_data);
+   }
+   else if(signal_data.signal_id == LCD_SER_SIGNAL_ID) {
+       struct json_object* json_format_lcd_data;
+       json_format_lcd_data = json_tokener_parse(signal_data.payload);
+       json_object *jstring_lcd_data = json_format_lcd_data;
+       json_object_object_add(j_data->obj,"payload",jstring_lcd_data);
+   }
+   else if(signal_data.signal_id == AWS_MQTT_APP_SER_SIGNAL_ID) {
+       struct json_object* json_format_aws_data;
+       json_format_aws_data = json_tokener_parse(signal_data.payload);
+       json_object *jstring_aws_data = json_format_aws_data;
+       json_object_object_add(j_data->obj,"payload",jstring_aws_data);
+   }
+   else if(signal_data.signal_id == SMART_CHARGER_APP_SER_SIGNAL_ID) {
+       struct json_object* json_format_smart_data;
+       json_format_smart_data = json_tokener_parse(signal_data.payload);
+       json_object *jstring_smart_data = json_format_smart_data;
+       json_object_object_add(j_data->obj,"payload",jstring_smart_data);
+   }
+   else{
+       char *payload_data;
+       payload_data = malloc(strlen(signal_data.payload));
+       sprintf(payload_data,"\"%s\"",signal_data.payload);
+       j_data->payload = json_tokener_parse(payload_data);
+       free(payload_data);
+       payload_data = NULL;
+       json_object_object_add(j_data->obj,"payload",j_data->payload);
+   }
+   sprintf(db_payload, "%s", json_object_to_json_string(j_data->obj));
+   //LOGS(LOG_INFO, DBUS, "Sending Data: %s\n", json_object_to_json_string(j_data->obj));
+   //LOGS(LOG_INFO, DBUS, "Sending db_payload: %s\n", db_payload);
+   return 0;
+}
+
+/*********************************************************************************************/
+/*              fn: int read_init(struct dbus_var_t *dbus)
+ *
+ *              brief: dbus read initialize
+ *
+ *              param: 
+ *                   dbus_var_t - paointer to dbus variables
+ *
+ *              return: error/success codes
+ */
+/*********************************************************************************************/
+
+int read_init(struct dbus_var_t *dbus)
+{
+   // initialise the errors
+   dbus_error_init(&(dbus->err));
+
+   // connect to the bus
+   dbus->conn = dbus_bus_get( DBUS_BUS_SESSION, &dbus->err );
+   if ( dbus_error_is_set( &dbus->err ) ) {
+       fprintf( stderr, "Connection Error (%s)\n", dbus->err.message );
+       dbus_error_free( &dbus->err );
+   }
+   if ( NULL == dbus->conn ) {
+     return DBUS_GET_CONN_ERROR;
+   }
+   return 0;
+}
+
+/*********************************************************************************************/
+/*              fn: int add_filter(struct dbus_var_t *dbus, char *rcv_sig)
+ *
+ *              brief: dbus add signal filter
+ *
+ *              param: 
+ *                   dbus_var_t - paointer to dbus variables
+ *                   rcv_sig    - receiver signal to be add in wish list
+ *
+ *              return: error/success codes
+ */
+/*********************************************************************************************/
+
+int add_filter(struct dbus_var_t *dbus, char *rcv_sig)
+{
+  
+   dbus_bus_add_match( dbus->conn, rcv_sig, &dbus->err );
+   dbus_connection_flush(dbus->conn );
+
+   if ( dbus_error_is_set( &dbus->err ) ) {
+       fprintf( stderr, "Match Error (%s)\n", dbus->err.message );
+       return DBUS_SIGNAL_MATCH_ERROR;
+    }
+    return 0;
+}
+
+/*********************************************************************************************/
+/*              fn: int check_data(struct dbus_var_t *dbus)
+ *
+ *              brief: Check if any data is available in dbus
+ *
+ *              param: 
+ *                   dbus_var_t - paointer to dbus variables
+ *
+ *              return: data available or not 
+ */
+/*********************************************************************************************/
+
+int check_data(struct dbus_var_t *dbus)
+{
+
+    dbus_connection_read_write( dbus->conn, 0 );
+    dbus->msg = dbus_connection_pop_message( dbus->conn );
+
+    if ( NULL == dbus->msg ) {
+       usleep(500);
+       return -1;
+    }
+    else
+       return 0;
+
+}
+
+/*********************************************************************************************/
+/*              fn: int read_data(struct dbus_var_t *dbus)
+ *
+ *              brief: read data from dbus - non blocking call
+ *
+ *              param: 
+ *                   dbus_var_t - paointer to dbus variables
+ *
+ *              return: json data object
+ */
+/*********************************************************************************************/
+struct json_obj_t read_data(struct dbus_var_t *dbus)
+{
+
+   struct json_obj_t jdata;
+   char* sigvalue;
+
+     if( dbus_message_is_signal( dbus->msg, CAN_SER_DATA_INTERFACE, CAN_SER_DATA_SIG_NAME ) ||
+         dbus_message_is_signal( dbus->msg, LCD_SER_DATA_INTERFACE, LCD_SER_DATA_SIG_NAME ) ||
+         dbus_message_is_signal( dbus->msg, AWS_MQTT_APP_SER_DATA_INTERFACE, AWS_MQTT_APP_SER_DATA_SIG_NAME ) ||
+         dbus_message_is_signal( dbus->msg, SMART_CHARGER_APP_SER_DATA_INTERFACE, SMART_CHARGER_APP_SER_DATA_SIG_NAME )
+       ) {
+          // read the parameters
+       if ( !dbus_message_iter_init( dbus->msg, &dbus->args ) )
+           fprintf( stderr, "Message has no arguments!\n" );
+       else if ( DBUS_TYPE_STRING != dbus_message_iter_get_arg_type( &dbus->args ) )
+           fprintf( stderr, "Argument is not string!\n" );
+       else {
+           dbus_message_iter_get_basic( &dbus->args, &sigvalue );
+           jdata.obj = json_tokener_parse(sigvalue);
+           return jdata;
+       }
+    }
+}
diff --git a/meta-services/conf/layer.conf b/meta-services/conf/layer.conf
index 15ddac6..764dc23 100644
--- a/meta-services/conf/layer.conf
+++ b/meta-services/conf/layer.conf
@@ -13,4 +13,4 @@ LAYERDEPENDS_meta-services = "core"
 LAYERSERIES_COMPAT_meta-services = "sumo"
 
 # Custom created/developed application binaries of the image can be appended here
-# IMAGE_INSTALL_append += "myhello_app"
+IMAGE_INSTALL_append = " aws-iot-device-sdk-c can-app smart-app config-scripts"
diff --git a/meta-services/recipes-services/aws-iot-device-sdk-c/aws-iot-device-sdk-c_2.1.1.bb b/meta-services/recipes-services/aws-iot-device-sdk-c/aws-iot-device-sdk-c_2.1.1.bb
new file mode 100644
index 0000000..c84fcdd
--- /dev/null
+++ b/meta-services/recipes-services/aws-iot-device-sdk-c/aws-iot-device-sdk-c_2.1.1.bb
@@ -0,0 +1,71 @@
+SUMMARY = "aws-iot-device-sdk-c recipe in yocto"
+HOMEPAGE = "https://github.com/aws/aws-iot-device-sdk-embedded-C"
+SECTION = "base"
+LICENSE = "Apache-2.0"
+LIC_FILES_CHKSUM = "file://LICENSE.txt;md5=acc7a1bf87c055789657b148939e4b40"
+
+DEPENDS = "mbedtls"
+SRC_URI  = "https://github.com/aws/aws-iot-device-sdk-embedded-C/archive/refs/tags/v2.1.1.zip \
+            file://aws_iot_config.h \
+            file://subscribe_publish_sample.c \
+            file://certs/ \
+"
+#for 2.1.1
+#SRCREV="70071112bd5e1c5b9f150894fafe199637b4f63a"
+#SRCREV="8206cb292ed96eb6ba11afa418cb39d60caa114b"
+
+SRC_URI[md5sum] = "96077e39f51cd9ca544495bbda555d8b"
+#SRC_URI[sha256sum] = "35bd3d18a9d4d6a76e93370693576d559e6892708b996b44b0fd9e4cada904fe"
+
+# for cpputest
+SRC_URI += "https://github.com/cpputest/cpputest/archive/v3.6.tar.gz;md5sum=08ea8185fb0bb52d952c1a71ac9be831"
+SRC_URI[v3.6.tar.gz.md5sum] = "08ea8185fb0bb52d952c1a71ac9be831"
+SRC_URI[v3.6.tar.gz.sha256sum] = "1d5b745322f36569536bad2dd41fe0e74b208da6475d6a1bfb0c2cb1adeefbbb"
+
+#SRC_URI += "https://github.com/ARMmbed/mbedtls/archive/mbedtls-2.1.1.tar.gz;md5sum=6f5d3e7154ce4e04bcb9b299f614775f"
+#SRC_URI[mbedtls-2.1.1.tar.gz.md5sum] = "6f5d3e7154ce4e04bcb9b299f614775f"
+#SRC_URI[mbedtls-2.1.1.tar.gz.sha256sum] = "ae458a4987f36819bdf1d39519212f4063780fe448d4155878fccf4e782a715f"
+
+
+SRC_URI += "https://github.com/ARMmbed/mbedtls/archive/mbedtls-2.14.0.tar.gz;md5sum=1fb29c16adf56dbd98b583d053f6edbf"
+SRC_URI[mbedtls-2.1.1.tar.gz.md5sum] = "1fb29c16adf56dbd98b583d053f6edbf"
+SRC_URI[mbedtls-2.1.1.tar.gz.sha256sum] = "3e733731eca47ffdc85330cde47774e075f5d1326e413555713dec8bf9c31eb3"
+
+S="${WORKDIR}/aws-iot-device-sdk-embedded-C-2.1.1"
+B = "${WORKDIR}/build"
+EXTRA_OEMAKE = "'CC=${CC}' 'RANLIB=${RANLIB}' 'ar=${AR}' 'AR=${AR}' 'CFLAGS=${CFLAGS} -I${S}/include -DWITHOUT_XATTR' "
+
+do_compile(){
+
+    cp -rf ${S}/../cpputest-3.6/* ${S}/external_libs/CppUTest/
+    #cp -rf ${S}/../mbedtls-mbedtls-2.1.1/* ${S}/external_libs/mbedTLS/
+    cp -rf ${S}/../mbedtls-mbedtls-2.14.0/* ${S}/external_libs/mbedTLS/
+    cp ${S}/../aws_iot_config.h ${S}/samples/linux/subscribe_publish_sample/
+    #cp ${s}/../subscribe_publish_sample.c ${S}/samples/linux/subscribe_publish_sample/
+
+    cd ${S}/samples/linux/subscribe_publish_sample/ 
+    oe_runmake
+}
+do_install(){
+
+    # Samples
+    install -d ${D}${datadir}/awsiotsdk/samples/embedded-c/pub_sub
+    install -d ${D}${datadir}/awsiotsdk/samples/embedded-c/config
+    install -d ${D}${datadir}/awsiotsdk/certs
+    
+    install ${S}/samples/linux/subscribe_publish_sample/subscribe_publish_sample ${D}${datadir}/awsiotsdk/samples/embedded-c/pub_sub
+    install ${S}/../certs/* ${D}${datadir}/awsiotsdk/certs
+    install ${S}/../aws_iot_config.h ${D}${datadir}/awsiotsdk/samples/embedded-c/config
+}
+
+INSANE_SKIP_${PN} += "ldflags"
+
+FILES_${PN}-samples = "\
+    ${datadir}/awsiotsdk/samples/embedded-c/* \
+"
+
+FILES_${PN} = "\
+    ${datadir}/awsiotsdk/certs/* \
+    ${datadir}/awsiotsdk/samples/embedded-c/config/aws_iot_config.h \
+    ${datadir}/awsiotsdk/samples/embedded-c/pub_sub/subscribe_publish_sample \
+"
diff --git a/meta-services/recipes-services/aws-iot-device-sdk-c/files/aws_iot_config.h b/meta-services/recipes-services/aws-iot-device-sdk-c/files/aws_iot_config.h
new file mode 100644
index 0000000..65e48af
--- /dev/null
+++ b/meta-services/recipes-services/aws-iot-device-sdk-c/files/aws_iot_config.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+/**
+ * @file aws_iot_config.h
+ * @brief AWS IoT specific configuration file
+ */
+
+#ifndef SRC_SHADOW_IOT_SHADOW_CONFIG_H_
+#define SRC_SHADOW_IOT_SHADOW_CONFIG_H_
+
+// Get from console
+// =================================================
+//#define AWS_IOT_MQTT_HOST              "a3323ojfyuiyrv-ats.iot.ap-south-1.amazonaws.com" ///< Customer specific MQTT HOST. The same will be used for Thing Shadow
+#define AWS_IOT_MQTT_HOST              "a29rjcslolshy0-ats.iot.us-east-1.amazonaws.com" //IISC - Test
+#define AWS_IOT_MQTT_PORT              8883 ///< default port for MQTT/S
+#define AWS_IOT_MQTT_CLIENT_ID         "phytec-test-1" ///< MQTT client ID should be unique for every device
+#define AWS_IOT_MY_THING_NAME             "AWS-IoT-C-SDK" ///< Thing Name of the Shadow this device is associated with
+//#define AWS_IOT_ROOT_CA_FILENAME       "AmazonRootCA1.pem" ///< Root CA file name
+#define AWS_IOT_ROOT_CA_FILENAME       "/home/sai/projects/smart_charger_IISC/aws_iisC_certs/root-CA.crt" //IISC -Test
+//#define AWS_IOT_CERTIFICATE_FILENAME   "e473d1a14a8e42a61040e4de7f89763f09669af0510f20915608e256c65375d8-certificate.pem.crt" ///< device signed certificate file name
+#define AWS_IOT_CERTIFICATE_FILENAME   "/home/sai/projects/smart_charger_IISC/aws_iisC_certs/switch.cert.pem" // IISC - Test
+//#define AWS_IOT_PRIVATE_KEY_FILENAME   "e473d1a14a8e42a61040e4de7f89763f09669af0510f20915608e256c65375d8-private.pem.key" ///< Device private key filename
+#define AWS_IOT_PRIVATE_KEY_FILENAME   "/home/sai/projects/smart_charger_IISC/aws_iisC_certs/switch.private.key" //IISC - Test
+// =================================================
+
+// MQTT PubSub
+#define AWS_IOT_MQTT_TX_BUF_LEN 512 ///< Any time a message is sent out through the MQTT layer. The message is copied into this buffer anytime a publish is done. This will also be used in the case of Thing Shadow
+#define AWS_IOT_MQTT_RX_BUF_LEN 512 ///< Any message that comes into the device should be less than this buffer size. If a received message is bigger than this buffer size the message will be dropped.
+#define AWS_IOT_MQTT_NUM_SUBSCRIBE_HANDLERS 5 ///< Maximum number of topic filters the MQTT client can handle at any given time. This should be increased appropriately when using Thing Shadow
+
+// Thing Shadow specific configs
+#define SHADOW_MAX_SIZE_OF_RX_BUFFER AWS_IOT_MQTT_RX_BUF_LEN+1 ///< Maximum size of the SHADOW buffer to store the received Shadow message
+#define MAX_SIZE_OF_UNIQUE_CLIENT_ID_BYTES 80  ///< Maximum size of the Unique Client Id. For More info on the Client Id refer \ref response "Acknowledgments"
+#define MAX_SIZE_CLIENT_ID_WITH_SEQUENCE MAX_SIZE_OF_UNIQUE_CLIENT_ID_BYTES + 10 ///< This is size of the extra sequence number that will be appended to the Unique client Id
+#define MAX_SIZE_CLIENT_TOKEN_CLIENT_SEQUENCE MAX_SIZE_CLIENT_ID_WITH_SEQUENCE + 20 ///< This is size of the the total clientToken key and value pair in the JSON
+#define MAX_ACKS_TO_COMEIN_AT_ANY_GIVEN_TIME 10 ///< At Any given time we will wait for this many responses. This will correlate to the rate at which the shadow actions are requested
+#define MAX_THINGNAME_HANDLED_AT_ANY_GIVEN_TIME 10 ///< We could perform shadow action on any thing Name and this is maximum Thing Names we can act on at any given time
+#define MAX_JSON_TOKEN_EXPECTED 120 ///< These are the max tokens that is expected to be in the Shadow JSON document. Include the metadata that gets published
+#define MAX_SHADOW_TOPIC_LENGTH_WITHOUT_THINGNAME 60 ///< All shadow actions have to be published or subscribed to a topic which is of the format $aws/things/{thingName}/shadow/update/accepted. This refers to the size of the topic without the Thing Name
+#define MAX_SIZE_OF_THING_NAME 20 ///< The Thing Name should not be bigger than this value. Modify this if the Thing Name needs to be bigger
+#define MAX_SHADOW_TOPIC_LENGTH_BYTES MAX_SHADOW_TOPIC_LENGTH_WITHOUT_THINGNAME + MAX_SIZE_OF_THING_NAME ///< This size includes the length of topic with Thing Name
+
+// Auto Reconnect specific config
+#define AWS_IOT_MQTT_MIN_RECONNECT_WAIT_INTERVAL 1000 ///< Minimum time before the First reconnect attempt is made as part of the exponential back-off algorithm
+#define AWS_IOT_MQTT_MAX_RECONNECT_WAIT_INTERVAL 128000 ///< Maximum time interval after which exponential back-off will stop attempting to reconnect.
+
+#endif /* SRC_SHADOW_IOT_SHADOW_CONFIG_H_ */
diff --git a/meta-services/recipes-services/aws-iot-device-sdk-c/files/aws_iot_config.h_ganesh b/meta-services/recipes-services/aws-iot-device-sdk-c/files/aws_iot_config.h_ganesh
new file mode 100644
index 0000000..523ad1a
--- /dev/null
+++ b/meta-services/recipes-services/aws-iot-device-sdk-c/files/aws_iot_config.h_ganesh
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+/**
+ * @file aws_iot_config.h
+ * @brief AWS IoT specific configuration file
+ */
+
+#ifndef SRC_SHADOW_IOT_SHADOW_CONFIG_H_
+#define SRC_SHADOW_IOT_SHADOW_CONFIG_H_
+
+// Get from console
+// =================================================
+#define AWS_IOT_MQTT_HOST              "a3323ojfyuiyrv-ats.iot.ap-south-1.amazonaws.com" ///< Customer specific MQTT HOST. The same will be used for Thing Shadow
+#define AWS_IOT_MQTT_PORT              8883 ///< default port for MQTT/S
+#define AWS_IOT_MQTT_CLIENT_ID         "phytec-test-1" ///< MQTT client ID should be unique for every device
+#define AWS_IOT_MY_THING_NAME             "AWS-IoT-C-SDK" ///< Thing Name of the Shadow this device is associated with
+#define AWS_IOT_ROOT_CA_FILENAME       "AmazonRootCA1.pem" ///< Root CA file name
+#define AWS_IOT_CERTIFICATE_FILENAME   "e473d1a14a8e42a61040e4de7f89763f09669af0510f20915608e256c65375d8-certificate.pem.crt" ///< device signed certificate file name
+#define AWS_IOT_PRIVATE_KEY_FILENAME   "e473d1a14a8e42a61040e4de7f89763f09669af0510f20915608e256c65375d8-private.pem.key" ///< Device private key filename
+// =================================================
+
+// MQTT PubSub
+#define AWS_IOT_MQTT_TX_BUF_LEN 512 ///< Any time a message is sent out through the MQTT layer. The message is copied into this buffer anytime a publish is done. This will also be used in the case of Thing Shadow
+#define AWS_IOT_MQTT_RX_BUF_LEN 512 ///< Any message that comes into the device should be less than this buffer size. If a received message is bigger than this buffer size the message will be dropped.
+#define AWS_IOT_MQTT_NUM_SUBSCRIBE_HANDLERS 5 ///< Maximum number of topic filters the MQTT client can handle at any given time. This should be increased appropriately when using Thing Shadow
+
+// Thing Shadow specific configs
+#define SHADOW_MAX_SIZE_OF_RX_BUFFER AWS_IOT_MQTT_RX_BUF_LEN+1 ///< Maximum size of the SHADOW buffer to store the received Shadow message
+#define MAX_SIZE_OF_UNIQUE_CLIENT_ID_BYTES 80  ///< Maximum size of the Unique Client Id. For More info on the Client Id refer \ref response "Acknowledgments"
+#define MAX_SIZE_CLIENT_ID_WITH_SEQUENCE MAX_SIZE_OF_UNIQUE_CLIENT_ID_BYTES + 10 ///< This is size of the extra sequence number that will be appended to the Unique client Id
+#define MAX_SIZE_CLIENT_TOKEN_CLIENT_SEQUENCE MAX_SIZE_CLIENT_ID_WITH_SEQUENCE + 20 ///< This is size of the the total clientToken key and value pair in the JSON
+#define MAX_ACKS_TO_COMEIN_AT_ANY_GIVEN_TIME 10 ///< At Any given time we will wait for this many responses. This will correlate to the rate at which the shadow actions are requested
+#define MAX_THINGNAME_HANDLED_AT_ANY_GIVEN_TIME 10 ///< We could perform shadow action on any thing Name and this is maximum Thing Names we can act on at any given time
+#define MAX_JSON_TOKEN_EXPECTED 120 ///< These are the max tokens that is expected to be in the Shadow JSON document. Include the metadata that gets published
+#define MAX_SHADOW_TOPIC_LENGTH_WITHOUT_THINGNAME 60 ///< All shadow actions have to be published or subscribed to a topic which is of the format $aws/things/{thingName}/shadow/update/accepted. This refers to the size of the topic without the Thing Name
+#define MAX_SIZE_OF_THING_NAME 20 ///< The Thing Name should not be bigger than this value. Modify this if the Thing Name needs to be bigger
+#define MAX_SHADOW_TOPIC_LENGTH_BYTES MAX_SHADOW_TOPIC_LENGTH_WITHOUT_THINGNAME + MAX_SIZE_OF_THING_NAME ///< This size includes the length of topic with Thing Name
+
+// Auto Reconnect specific config
+#define AWS_IOT_MQTT_MIN_RECONNECT_WAIT_INTERVAL 1000 ///< Minimum time before the First reconnect attempt is made as part of the exponential back-off algorithm
+#define AWS_IOT_MQTT_MAX_RECONNECT_WAIT_INTERVAL 128000 ///< Maximum time interval after which exponential back-off will stop attempting to reconnect.
+
+#endif /* SRC_SHADOW_IOT_SHADOW_CONFIG_H_ */
diff --git a/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/AmazonRootCA1.pem b/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/AmazonRootCA1.pem
new file mode 100644
index 0000000..61ae256
--- /dev/null
+++ b/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/AmazonRootCA1.pem
@@ -0,0 +1,20 @@
+-----BEGIN CERTIFICATE-----
+MIIDQTCCAimgAwIBAgITBmyfz5m/jAo54vB4ikPmljZbyjANBgkqhkiG9w0BAQsF
+ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6
+b24gUm9vdCBDQSAxMB4XDTE1MDUyNjAwMDAwMFoXDTM4MDExNzAwMDAwMFowOTEL
+MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv
+b3QgQ0EgMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALJ4gHHKeNXj
+ca9HgFB0fW7Y14h29Jlo91ghYPl0hAEvrAIthtOgQ3pOsqTQNroBvo3bSMgHFzZM
+9O6II8c+6zf1tRn4SWiw3te5djgdYZ6k/oI2peVKVuRF4fn9tBb6dNqcmzU5L/qw
+IFAGbHrQgLKm+a/sRxmPUDgH3KKHOVj4utWp+UhnMJbulHheb4mjUcAwhmahRWa6
+VOujw5H5SNz/0egwLX0tdHA114gk957EWW67c4cX8jJGKLhD+rcdqsq08p8kDi1L
+93FcXmn/6pUCyziKrlA4b9v7LWIbxcceVOF34GfID5yHI9Y/QCB/IIDEgEw+OyQm
+jgSubJrIqg0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC
+AYYwHQYDVR0OBBYEFIQYzIU07LwMlJQuCFmcx7IQTgoIMA0GCSqGSIb3DQEBCwUA
+A4IBAQCY8jdaQZChGsV2USggNiMOruYou6r4lK5IpDB/G/wkjUu0yKGX9rbxenDI
+U5PMCCjjmCXPI6T53iHTfIUJrU6adTrCC2qJeHZERxhlbI1Bjjt/msv0tadQ1wUs
+N+gDS63pYaACbvXy8MWy7Vu33PqUXHeeE6V/Uq2V8viTO96LXFvKWlJbYK8U90vv
+o/ufQJVtMVT8QtPHRh8jrdkPSHCa2XV4cdFyQzR1bldZwgJcJmApzyMZFo6IQ6XU
+5MsI+yMRQ+hDKXJioaldXgjUkK642M4UwtBV8ob2xJNDd2ZhwLnoQdeXeGADbkpy
+rqXRfboQnoZsG4q5WTP468SQvvG5
+-----END CERTIFICATE-----
\ No newline at end of file
diff --git a/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/AmazonRootCA3.pem b/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/AmazonRootCA3.pem
new file mode 100644
index 0000000..3796bb2
--- /dev/null
+++ b/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/AmazonRootCA3.pem
@@ -0,0 +1,12 @@
+-----BEGIN CERTIFICATE-----
+MIIBtjCCAVugAwIBAgITBmyf1XSXNmY/Owua2eiedgPySjAKBggqhkjOPQQDAjA5
+MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g
+Um9vdCBDQSAzMB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTELMAkG
+A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJvb3Qg
+Q0EgMzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABCmXp8ZBf8ANm+gBG1bG8lKl
+ui2yEujSLtf6ycXYqm0fc4E7O5hrOXwzpcVOho6AF2hiRVd9RFgdszflZwjrZt6j
+QjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQWBBSr
+ttvXBp43rDCGB5Fwx5zEGbF4wDAKBggqhkjOPQQDAgNJADBGAiEA4IWSoxe3jfkr
+BqWTrBqYaGFy+uGh0PsceGCmQ5nFuMQCIQCcAu/xlJyzlvnrxir4tiz+OpAUFteM
+YyRIHN8wfdVoOw==
+-----END CERTIFICATE-----
\ No newline at end of file
diff --git a/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/README.txt b/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/README.txt
new file mode 100644
index 0000000..a8b3f3f
--- /dev/null
+++ b/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/README.txt
@@ -0,0 +1,4 @@
+# Copy certificates for running the samples and tests provided with the SDK into this directory
+# Certificates can be created and downloaded from the AWS IoT Console
+# The IoT Client takes the full path of the certificates as an input parameter while initializing
+# This is the default folder for the certificates only for samples and tests. A different path can be specified if required.
diff --git a/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/e473d1a14a8e42a61040e4de7f89763f09669af0510f20915608e256c65375d8-certificate.pem.crt b/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/e473d1a14a8e42a61040e4de7f89763f09669af0510f20915608e256c65375d8-certificate.pem.crt
new file mode 100644
index 0000000..7ea6a68
--- /dev/null
+++ b/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/e473d1a14a8e42a61040e4de7f89763f09669af0510f20915608e256c65375d8-certificate.pem.crt
@@ -0,0 +1,20 @@
+-----BEGIN CERTIFICATE-----
+MIIDWjCCAkKgAwIBAgIVAOwULbi368OfjhRe9OwItl9QXF2BMA0GCSqGSIb3DQEB
+CwUAME0xSzBJBgNVBAsMQkFtYXpvbiBXZWIgU2VydmljZXMgTz1BbWF6b24uY29t
+IEluYy4gTD1TZWF0dGxlIFNUPVdhc2hpbmd0b24gQz1VUzAeFw0yMjA3MTQwNTMw
+MzZaFw00OTEyMzEyMzU5NTlaMB4xHDAaBgNVBAMME0FXUyBJb1QgQ2VydGlmaWNh
+dGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQClpBVBdJmH5fzRshyl
+8VmHGEw36Pv7TShXPwJqlm2l0CFDsZe/sohjDfpatLVcBZcFOQLA7KjR18R1HK2q
+BDz27xUxb8dTp3tNahhfjq5nPFiZEKdmaBoQ9eiDMJuBdOpsyppn3ZTEFiCtJdKq
+CgNNKRIYjtG0AvJMvHlHD4BY93T0FMBQZdENdW+IZuBvWykYyNtmWOcCCm7bO/fQ
+DVZEtPzoeq7/GEKJLfmll0gwXbaBaRcD9x5g/eTp9OVHrCWJRD2CfQzO/F/mGwbi
+whEfC0D5cXg2elf7PXpmoe9vuV/LvdIZC58lSfN8Kksxmyk/c4Rv+R+IvIy281V7
+AJSLAgMBAAGjYDBeMB8GA1UdIwQYMBaAFIrfD8h7CIJEQ3KSkN0n9H2yRWJtMB0G
+A1UdDgQWBBTtBc57ObysDiAuzT/2ZTz0ubhsVDAMBgNVHRMBAf8EAjAAMA4GA1Ud
+DwEB/wQEAwIHgDANBgkqhkiG9w0BAQsFAAOCAQEAZHp0dZfHTQ1ljUdBGkZIaSFc
+jHlX4hWkcaJu/X/46G8VEpVGBbVCs1A4yUyeSi3EJpzPCFk5aTxaOFAtnycQ2n1N
+MwxY+ugB7Ny6KMM/dbUNReKxcuOm00sQ3X989BXTne6nvfUFh4/eRxL46AycWJWV
+VrkQNpu4e1KmiTgjzzBSkdC6Ywk+aFB8d/Wuh0gEc9oTPVsCrmFiozGMNKgG2Dub
+Wprms3LFxtZ41LTLBXzxaag32zpWQI7ya1nRlRJY5/BaUcygYYDaT7hWO2qFEVoX
+nAM/v4Q8s9IciB9DU9VAvrcu4S3cgPpdlfHfWCfvCUvttxO6xg5mJ4OlhDcn/g==
+-----END CERTIFICATE-----
diff --git a/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/e473d1a14a8e42a61040e4de7f89763f09669af0510f20915608e256c65375d8-private.pem.key b/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/e473d1a14a8e42a61040e4de7f89763f09669af0510f20915608e256c65375d8-private.pem.key
new file mode 100644
index 0000000..531f8ad
--- /dev/null
+++ b/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/e473d1a14a8e42a61040e4de7f89763f09669af0510f20915608e256c65375d8-private.pem.key
@@ -0,0 +1,27 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIEowIBAAKCAQEApaQVQXSZh+X80bIcpfFZhxhMN+j7+00oVz8CapZtpdAhQ7GX
+v7KIYw36WrS1XAWXBTkCwOyo0dfEdRytqgQ89u8VMW/HU6d7TWoYX46uZzxYmRCn
+ZmgaEPXogzCbgXTqbMqaZ92UxBYgrSXSqgoDTSkSGI7RtALyTLx5Rw+AWPd09BTA
+UGXRDXVviGbgb1spGMjbZljnAgpu2zv30A1WRLT86Hqu/xhCiS35pZdIMF22gWkX
+A/ceYP3k6fTlR6wliUQ9gn0Mzvxf5hsG4sIRHwtA+XF4NnpX+z16ZqHvb7lfy73S
+GQufJUnzfCpLMZspP3OEb/kfiLyMtvNVewCUiwIDAQABAoIBAAZ7no1aR+wGt1dp
+ti9Ue+GKtOj3SG10fqCziZ+sVYxI0hR5LexFy4q88FB+hB6e5WNB8PamDJFx9XFz
+9uQRmGU9xEGUE2QVyQClp2COEAtgVENhYHvklSiWx0vjKiLt9YLehx6LkJgAGbVN
+JqqbC7gIZHnrlQ+Lkfoo4kJCvA4/SQeasj8ajCh7y1RrviOubwJg6kphFaZJeAfc
+WjSUwaYJ2Ld1jdojerRXGAVgMdS8S3jrm07ICj6TN2uVbssIHngiW75n1vBEcl/x
+XnGK0Dj727cZiNUAaArddhdUXyQxE52ZXBaSHtkA+EQyU/I7GuPdYQ4hIG3vToMv
+MkIayvECgYEA02zUyjAQfFAzLUKYOQF9rmaLWDpnowAXzlTsRL2r7wzb4Jgf/+kB
+qiLvxSgTpWg9rJkaAvOQt7koWFYSXwXFJ0mzJG6o8gXkHfk2ggQo1fll/p8o2WUG
++sOOcel8RbGLaiBNqSL/SRw/Xn+2fvi2bJsv0ZmI8jDpunDnuvj4NEMCgYEAyJAo
+693IrfZAlLCw9Lxaw/jPXFFuhKTq6QzPcYGqvKv4xfO1Rp783HwFR7SvVHEVI6K8
+pD5gHFbYpMAc+PyleJWEIq6q81oStENZc7ZAbZGgZhZKn5AnggS7nOt8PzHU8+fS
+mVk7zTCuonF24KBi4N+4rZjXHsPwUaz5Mftj/hkCgYBNVAbYFJBTB3pQWYUXhIYV
+XYglsubo5UXPv5vS4JScEFXzZXB+xxhGxBRyReA5pVC5ah3ram5J5DzvYjvB6Xhc
+kEYnUxoTuzfeBqJ7F05gRKGbaVclfB/7Y78bxswfKXrWTA5biGNauCwtQgTbl9gR
+DQmGXeOKwX0bJeR7rEgLxQKBgAEhFqnlUMjx9wEfUY+/M7+gugIqDzY9+3iectiP
+w1dWnIr4yU+Be6j+JcV2lfoivNy7gNZn54ChWIzs6/zW51Obe+f6FcpS+oH7Uxic
+sRYs2LtaasclN6O6xReoF8X/UNSivIPShcys9n7Bpsqy/HuJpu+LScLJlaPQFoMa
+iECZAoGBAIh5XHq0uG9iVnXaaVOEZ6sXGuEmUbHttqVABxf5WcVWe3sqSHCxWZMf
+ZVFqVNmfKxwAqTZOw+UvuWZKkg6xVyo9pMJNBVGggSsNq2oDYjw9pwq8tvm4wjGZ
+uRuQEb84FU4gXAA7e88YRcotqoLoHwnOyoqMpiqDpvEMglJ1iHh7
+-----END RSA PRIVATE KEY-----
diff --git a/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/e473d1a14a8e42a61040e4de7f89763f09669af0510f20915608e256c65375d8-public.pem.key b/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/e473d1a14a8e42a61040e4de7f89763f09669af0510f20915608e256c65375d8-public.pem.key
new file mode 100644
index 0000000..48c97af
--- /dev/null
+++ b/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/e473d1a14a8e42a61040e4de7f89763f09669af0510f20915608e256c65375d8-public.pem.key
@@ -0,0 +1,9 @@
+-----BEGIN PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApaQVQXSZh+X80bIcpfFZ
+hxhMN+j7+00oVz8CapZtpdAhQ7GXv7KIYw36WrS1XAWXBTkCwOyo0dfEdRytqgQ8
+9u8VMW/HU6d7TWoYX46uZzxYmRCnZmgaEPXogzCbgXTqbMqaZ92UxBYgrSXSqgoD
+TSkSGI7RtALyTLx5Rw+AWPd09BTAUGXRDXVviGbgb1spGMjbZljnAgpu2zv30A1W
+RLT86Hqu/xhCiS35pZdIMF22gWkXA/ceYP3k6fTlR6wliUQ9gn0Mzvxf5hsG4sIR
+HwtA+XF4NnpX+z16ZqHvb7lfy73SGQufJUnzfCpLMZspP3OEb/kfiLyMtvNVewCU
+iwIDAQAB
+-----END PUBLIC KEY-----
diff --git a/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/root-CA.crt b/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/root-CA.crt
new file mode 100644
index 0000000..a6f3e92
--- /dev/null
+++ b/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/root-CA.crt
@@ -0,0 +1,20 @@
+-----BEGIN CERTIFICATE-----
+MIIDQTCCAimgAwIBAgITBmyfz5m/jAo54vB4ikPmljZbyjANBgkqhkiG9w0BAQsF
+ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6
+b24gUm9vdCBDQSAxMB4XDTE1MDUyNjAwMDAwMFoXDTM4MDExNzAwMDAwMFowOTEL
+MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv
+b3QgQ0EgMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALJ4gHHKeNXj
+ca9HgFB0fW7Y14h29Jlo91ghYPl0hAEvrAIthtOgQ3pOsqTQNroBvo3bSMgHFzZM
+9O6II8c+6zf1tRn4SWiw3te5djgdYZ6k/oI2peVKVuRF4fn9tBb6dNqcmzU5L/qw
+IFAGbHrQgLKm+a/sRxmPUDgH3KKHOVj4utWp+UhnMJbulHheb4mjUcAwhmahRWa6
+VOujw5H5SNz/0egwLX0tdHA114gk957EWW67c4cX8jJGKLhD+rcdqsq08p8kDi1L
+93FcXmn/6pUCyziKrlA4b9v7LWIbxcceVOF34GfID5yHI9Y/QCB/IIDEgEw+OyQm
+jgSubJrIqg0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC
+AYYwHQYDVR0OBBYEFIQYzIU07LwMlJQuCFmcx7IQTgoIMA0GCSqGSIb3DQEBCwUA
+A4IBAQCY8jdaQZChGsV2USggNiMOruYou6r4lK5IpDB/G/wkjUu0yKGX9rbxenDI
+U5PMCCjjmCXPI6T53iHTfIUJrU6adTrCC2qJeHZERxhlbI1Bjjt/msv0tadQ1wUs
+N+gDS63pYaACbvXy8MWy7Vu33PqUXHeeE6V/Uq2V8viTO96LXFvKWlJbYK8U90vv
+o/ufQJVtMVT8QtPHRh8jrdkPSHCa2XV4cdFyQzR1bldZwgJcJmApzyMZFo6IQ6XU
+5MsI+yMRQ+hDKXJioaldXgjUkK642M4UwtBV8ob2xJNDd2ZhwLnoQdeXeGADbkpy
+rqXRfboQnoZsG4q5WTP468SQvvG5
+-----END CERTIFICATE-----
diff --git a/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/switch.cert.pem b/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/switch.cert.pem
new file mode 100644
index 0000000..5e04203
--- /dev/null
+++ b/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/switch.cert.pem
@@ -0,0 +1,20 @@
+-----BEGIN CERTIFICATE-----
+MIIDWjCCAkKgAwIBAgIVAIKlaT0t7pMZvptMydx0Hvq4niRTMA0GCSqGSIb3DQEB
+CwUAME0xSzBJBgNVBAsMQkFtYXpvbiBXZWIgU2VydmljZXMgTz1BbWF6b24uY29t
+IEluYy4gTD1TZWF0dGxlIFNUPVdhc2hpbmd0b24gQz1VUzAeFw0yMjAzMjQwNTUx
+MzZaFw00OTEyMzEyMzU5NTlaMB4xHDAaBgNVBAMME0FXUyBJb1QgQ2VydGlmaWNh
+dGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCx9ySbJteHpnXCiGJE
+zummMm3LQ2sSm91SUKJ0MuTKdaOmAfcjlDwPa5OGdEoUISxOYD4nc2eiQvPXjLZ7
+wDxrSuKftZgmufUNHO70ph9fBX8QG8T8+3kJpfKKp2ewtTL4iSQf3Nxrp78TZy4/
+moIDe891bmUj7mgf43T6tvchMUmN+/05T5KGJy+VwdGgu2LHEutSghMrsNNZEQoP
+3e15D9kvI5Xa03/cAF1rmmAaQKS2KhBd+wndIC1799fIpN/Y6HhQ57YxrKPnHRwi
+paKFGsmCZxijkI0vwHqQWsUzD5r8OcBYICJzkB5gJfHVxOWhfSeiWz6fshu0vqQ0
+F/UfAgMBAAGjYDBeMB8GA1UdIwQYMBaAFD+FyNnqFOj33zy8tj+o5gmfLtbIMB0G
+A1UdDgQWBBRk6CpILQQ1Wg5mXYC5dc5eDEDzCTAMBgNVHRMBAf8EAjAAMA4GA1Ud
+DwEB/wQEAwIHgDANBgkqhkiG9w0BAQsFAAOCAQEAdC7DfmIZyzvfD4myXftfMVEX
+H9J8WvoV6BHegC4OEuQLcRATZNDQWqyGhDbbUNE2ArRUmfNSRmv6/71p2dkGxtv1
+TlPNF7gP5XvfzxXdO3bj2GwvJKS/Lo5uxJtN8fR1fji5hHOxr/uq6J247FVyoNrH
+8OisSKZ7qz2Sr19bCw7iLtrjr1vpwOxGmzuNfGIa3U3csRm5nFFtN/vLbaCk4vUn
+nhoukYW1c7gpuAJ1ZX455rH0RYqde4F6IB040kjX6+dQpT5L/AwRlmI3nlTssVLp
+lKcVd4yMa1n0O8+S0kowy9zxe4/ZIGZbcuOZi6W16bfg/qxwSdYjXIFANHK8+Q==
+-----END CERTIFICATE-----
diff --git a/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/switch.private.key b/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/switch.private.key
new file mode 100644
index 0000000..070150d
--- /dev/null
+++ b/meta-services/recipes-services/aws-iot-device-sdk-c/files/certs/switch.private.key
@@ -0,0 +1,27 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIEpAIBAAKCAQEAsfckmybXh6Z1wohiRM7ppjJty0NrEpvdUlCidDLkynWjpgH3
+I5Q8D2uThnRKFCEsTmA+J3NnokLz14y2e8A8a0rin7WYJrn1DRzu9KYfXwV/EBvE
+/Pt5CaXyiqdnsLUy+IkkH9zca6e/E2cuP5qCA3vPdW5lI+5oH+N0+rb3ITFJjfv9
+OU+ShicvlcHRoLtixxLrUoITK7DTWREKD93teQ/ZLyOV2tN/3ABda5pgGkCktioQ
+XfsJ3SAte/fXyKTf2Oh4UOe2Mayj5x0cIqWihRrJgmcYo5CNL8B6kFrFMw+a/DnA
+WCAic5AeYCXx1cTloX0nols+n7IbtL6kNBf1HwIDAQABAoIBAGCLQ2eL5caoLiAv
+XqgXW7eWieuIEnEQ7zr1lXvWFDolIXcwf8LkasSuxmRdd8Z9zIxkN7OtLp5fFets
+YZ62xdAq2tBrcjQoE2Fevd8os8IXuDuj5PSc86ehR/eiI2VAl3su4tMKPOWGJek/
+w14r0rZTF1OMZP/eGMyb110fnud47uR+4UXRNURTcnaGZALClGdlcLlDlWwRx7S9
+CHzKb5gVwmecXiV2tlekfMZMx+ww0B4oQEZzP3+F0gch5hOL0IUTi8NKtHEeVOYR
+iN3/Vn/3eRnrz3MRNcjPp4WPndzq30kffHzT6gx3bzLTzfNWnGsNa8iVaMQfAYKK
+5qIDR3kCgYEA2BdR+VV/gP03YHBmcTN1ze/CN5mZF5ruEBbA0EFIvlZvvOFlPVwl
+JzIhcqAKtYVjXA2sKtTTV/zJJGXpjxHWfjKmS6Vu3ArdamMJRza1BA9Yu5DzZUe4
+y94HrCC2axzMEcLvV2TT6f3DkPHyQNpL8FmV+i5LM9WQCEb4QY8ExTsCgYEA0tVC
+SxzFyRne7sN7Olebv7Lf4irzHbZ7m9x8TG3D4G/iaqZcqHNbC4HovFTtvU9srDZ2
+NA8/HH0ksy1XwbGomY/vuPdC6GU/LZ4nlU0d2zOMqYHsfJP+sH3QkNHZTwQTxC6B
+hLEUMbe85qSb5/Fduj8KVOesO7aZiP6yYYs0QW0CgYAlYKNFRYywexxBCjAuFICk
+BnzJsT/R3XKgRc9ENoampbzeJv6kBnRGu10dvqEblN8C5TqKjhWgepEwQpCLtsIr
+QgeRviPW2+pApLDOKKBW+3CVwRTYx/cnDFi3ZVEoZerGh7lunHorV0GkqLUGkrvf
+7x8KD0fix2YKiHwYmuxwUQKBgQCqEtRmiTBX2GHI07JdTvzZ+C64YJM7vdAa3BL9
+CHLBYyAPjmIilOO19bbL7erWEvMEPO6/cikkDyOC0qn/GxR5w+3KlNPJaps7bmBa
+BRp3kC8BMkiV+kCzGNsdZ9rX7d8QG7/pTXuP27srh1ApG8DTFDV+ZmC+zr8uDt/Q
+5h1iRQKBgQDD/4x800/Ign1apGf7zbOJdKyFeLRjsGBDDWzlyJohFogrZRFMNdHD
+ARgesZmKZvBs0bSC7Uq4Svxfruxs8690gwW92llkp4ZY6J1ACshpBKfrKu+SBAng
+l0ANr8/TfepxWkHS/ivuNx/pkR9pZosp2L/QFuAAm0PUIYU9FpQdbw==
+-----END RSA PRIVATE KEY-----
diff --git a/meta-services/recipes-services/aws-iot-device-sdk-c/files/subscribe_publish_sample.c b/meta-services/recipes-services/aws-iot-device-sdk-c/files/subscribe_publish_sample.c
new file mode 100644
index 0000000..6c1f2aa
--- /dev/null
+++ b/meta-services/recipes-services/aws-iot-device-sdk-c/files/subscribe_publish_sample.c
@@ -0,0 +1,262 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+/**
+ * @file subscribe_publish_sample.c
+ * @brief simple MQTT publish and subscribe on the same topic
+ *
+ * This example takes the parameters from the aws_iot_config.h file and establishes a connection to the AWS IoT MQTT Platform.
+ * It subscribes and publishes to the same topic - "sdkTest/sub"
+ *
+ * If all the certs are correct, you should see the messages received by the application in a loop.
+ *
+ * The application takes in the certificate path, host name , port and the number of times the publish should happen.
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <limits.h>
+#include <string.h>
+
+#include "aws_iot_config.h"
+#include "aws_iot_log.h"
+#include "aws_iot_version.h"
+#include "aws_iot_mqtt_client_interface.h"
+
+/**
+ * @brief Default cert location
+ */
+char certDirectory[PATH_MAX + 1] = "../../../certs";
+
+/**
+ * @brief Default MQTT HOST URL is pulled from the aws_iot_config.h
+ */
+char HostAddress[255] = AWS_IOT_MQTT_HOST;
+
+/**
+ * @brief Default MQTT port is pulled from the aws_iot_config.h
+ */
+uint32_t port = AWS_IOT_MQTT_PORT;
+
+/**
+ * @brief This parameter will avoid infinite loop of publish and exit the program after certain number of publishes
+ */
+uint32_t publishCount = 0;
+
+void iot_subscribe_callback_handler(AWS_IoT_Client *pClient, char *topicName, uint16_t topicNameLen,
+									IoT_Publish_Message_Params *params, void *pData) {
+	IOT_UNUSED(pData);
+	IOT_UNUSED(pClient);
+	IOT_INFO("Subscribe callback");
+	IOT_INFO("%.*s\t%.*s", topicNameLen, topicName, (int) params->payloadLen, params->payload);
+}
+
+void disconnectCallbackHandler(AWS_IoT_Client *pClient, void *data) {
+	IOT_WARN("MQTT Disconnect");
+	IoT_Error_t rc = FAILURE;
+
+	if(NULL == pClient) {
+		return;
+	}
+
+	IOT_UNUSED(data);
+
+	if(aws_iot_is_autoreconnect_enabled(pClient)) {
+		IOT_INFO("Auto Reconnect is enabled, Reconnecting attempt will start now");
+	} else {
+		IOT_WARN("Auto Reconnect not enabled. Starting manual reconnect...");
+		rc = aws_iot_mqtt_attempt_reconnect(pClient);
+		if(NETWORK_RECONNECTED == rc) {
+			IOT_WARN("Manual Reconnect Successful");
+		} else {
+			IOT_WARN("Manual Reconnect Failed - %d", rc);
+		}
+	}
+}
+
+void parseInputArgsForConnectParams(int argc, char **argv) {
+	int opt;
+
+	while(-1 != (opt = getopt(argc, argv, "h:p:c:x:"))) {
+		switch(opt) {
+			case 'h':
+				strcpy(HostAddress, optarg);
+				IOT_DEBUG("Host %s", optarg);
+				break;
+			case 'p':
+				port = atoi(optarg);
+				IOT_DEBUG("arg %s", optarg);
+				break;
+			case 'c':
+				strcpy(certDirectory, optarg);
+				IOT_DEBUG("cert root directory %s", optarg);
+				break;
+			case 'x':
+				publishCount = atoi(optarg);
+				IOT_DEBUG("publish %s times\n", optarg);
+				break;
+			case '?':
+				if(optopt == 'c') {
+					IOT_ERROR("Option -%c requires an argument.", optopt);
+				} else if(isprint(optopt)) {
+					IOT_WARN("Unknown option `-%c'.", optopt);
+				} else {
+					IOT_WARN("Unknown option character `\\x%x'.", optopt);
+				}
+				break;
+			default:
+				IOT_ERROR("Error in command line argument parsing");
+				break;
+		}
+	}
+
+}
+
+int main(int argc, char **argv) {
+	bool infinitePublishFlag = true;
+
+	char rootCA[PATH_MAX + 1];
+	char clientCRT[PATH_MAX + 1];
+	char clientKey[PATH_MAX + 1];
+	char CurrentWD[PATH_MAX + 1];
+	char cPayload[100];
+
+	int32_t i = 0;
+
+	IoT_Error_t rc = FAILURE;
+
+	AWS_IoT_Client client;
+	IoT_Client_Init_Params mqttInitParams = iotClientInitParamsDefault;
+	IoT_Client_Connect_Params connectParams = iotClientConnectParamsDefault;
+
+	IoT_Publish_Message_Params paramsQOS0;
+	IoT_Publish_Message_Params paramsQOS1;
+
+	parseInputArgsForConnectParams(argc, argv);
+
+	IOT_INFO("\nAWS IoT SDK Version %d.%d.%d-%s\n", VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH, VERSION_TAG);
+
+	getcwd(CurrentWD, sizeof(CurrentWD));
+	snprintf(rootCA, PATH_MAX + 1, "%s/%s/%s", CurrentWD, certDirectory, AWS_IOT_ROOT_CA_FILENAME);
+	snprintf(clientCRT, PATH_MAX + 1, "%s/%s/%s", CurrentWD, certDirectory, AWS_IOT_CERTIFICATE_FILENAME);
+	snprintf(clientKey, PATH_MAX + 1, "%s/%s/%s", CurrentWD, certDirectory, AWS_IOT_PRIVATE_KEY_FILENAME);
+
+	IOT_DEBUG("rootCA %s", rootCA);
+	IOT_DEBUG("clientCRT %s", clientCRT);
+	IOT_DEBUG("clientKey %s", clientKey);
+	mqttInitParams.enableAutoReconnect = false; // We enable this later below
+	mqttInitParams.pHostURL = HostAddress;
+	mqttInitParams.port = port;
+	mqttInitParams.pRootCALocation = rootCA;
+	mqttInitParams.pDeviceCertLocation = clientCRT;
+	mqttInitParams.pDevicePrivateKeyLocation = clientKey;
+	mqttInitParams.mqttCommandTimeout_ms = 20000;
+	mqttInitParams.tlsHandshakeTimeout_ms = 5000;
+	mqttInitParams.isSSLHostnameVerify = true;
+	mqttInitParams.disconnectHandler = disconnectCallbackHandler;
+	mqttInitParams.disconnectHandlerData = NULL;
+
+	rc = aws_iot_mqtt_init(&client, &mqttInitParams);
+	if(SUCCESS != rc) {
+		IOT_ERROR("aws_iot_mqtt_init returned error : %d ", rc);
+		return rc;
+	}
+
+	connectParams.keepAliveIntervalInSec = 10;
+	connectParams.isCleanSession = true;
+	connectParams.MQTTVersion = MQTT_3_1_1;
+	connectParams.pClientID = AWS_IOT_MQTT_CLIENT_ID;
+	connectParams.clientIDLen = (uint16_t) strlen(AWS_IOT_MQTT_CLIENT_ID);
+	connectParams.isWillMsgPresent = false;
+
+	IOT_INFO("Connecting...");
+	rc = aws_iot_mqtt_connect(&client, &connectParams);
+	if(SUCCESS != rc) {
+		IOT_ERROR("Error(%d) connecting to %s:%d", rc, mqttInitParams.pHostURL, mqttInitParams.port);
+		return rc;
+	}
+	/*
+	 * Enable Auto Reconnect functionality. Minimum and Maximum time of Exponential backoff are set in aws_iot_config.h
+	 *  #AWS_IOT_MQTT_MIN_RECONNECT_WAIT_INTERVAL
+	 *  #AWS_IOT_MQTT_MAX_RECONNECT_WAIT_INTERVAL
+	 */
+	rc = aws_iot_mqtt_autoreconnect_set_status(&client, true);
+	if(SUCCESS != rc) {
+		IOT_ERROR("Unable to set Auto Reconnect to true - %d", rc);
+		return rc;
+	}
+
+	IOT_INFO("Subscribing...");
+	rc = aws_iot_mqtt_subscribe(&client, "switch001", 11, QOS0, iot_subscribe_callback_handler, NULL);
+	if(SUCCESS != rc) {
+		IOT_ERROR("Error subscribing : %d ", rc);
+		return rc;
+	}
+
+	sprintf(cPayload, "%s : %d ", "hello from SDK", i);
+
+	paramsQOS0.qos = QOS0;
+	paramsQOS0.payload = (void *) cPayload;
+	paramsQOS0.isRetained = 0;
+
+	paramsQOS1.qos = QOS1;
+	paramsQOS1.payload = (void *) cPayload;
+	paramsQOS1.isRetained = 0;
+
+	if(publishCount != 0) {
+		infinitePublishFlag = false;
+	}
+
+	while((NETWORK_ATTEMPTING_RECONNECT == rc || NETWORK_RECONNECTED == rc || SUCCESS == rc)
+		  && (publishCount > 0 || infinitePublishFlag)) {
+
+		//Max time the yield function will wait for read messages
+		rc = aws_iot_mqtt_yield(&client, 100);
+		if(NETWORK_ATTEMPTING_RECONNECT == rc) {
+			// If the client is attempting to reconnect we will skip the rest of the loop.
+			continue;
+		}
+
+		IOT_INFO("-->sleep");
+		sleep(1);
+		sprintf(cPayload, "%s : %d ", "hello from SDK QOS0", i++);
+		paramsQOS0.payloadLen = strlen(cPayload);
+		rc = aws_iot_mqtt_publish(&client, "sdkTest/sub", 11, &paramsQOS0);
+		if(publishCount > 0) {
+			publishCount--;
+		}
+
+		sprintf(cPayload, "%s : %d ", "hello from SDK QOS1", i++);
+		paramsQOS1.payloadLen = strlen(cPayload);
+		rc = aws_iot_mqtt_publish(&client, "sdkTest/sub", 11, &paramsQOS1);
+		if (rc == MQTT_REQUEST_TIMEOUT_ERROR) {
+			IOT_WARN("QOS1 publish ack not received.\n");
+			rc = SUCCESS;
+		}
+		if(publishCount > 0) {
+			publishCount--;
+		}
+	}
+
+	if(SUCCESS != rc) {
+		IOT_ERROR("An error occurred in the loop.\n");
+	} else {
+		IOT_INFO("Publish done\n");
+	}
+
+	return rc;
+}
diff --git a/meta-services/recipes-services/can-app/can-app_0.1.bb b/meta-services/recipes-services/can-app/can-app_0.1.bb
new file mode 100644
index 0000000..36a8358
--- /dev/null
+++ b/meta-services/recipes-services/can-app/can-app_0.1.bb
@@ -0,0 +1,29 @@
+SUMMARY = "CAN Application"
+SECTION = "App"
+LICENSE = "MIT"
+LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302"
+
+DEPENDS += " \
+    json-c \
+    libsocketcan \
+    dbus-wrapper \
+"
+
+SRC_URI = "file://src/can_app.c \
+            file://inc/can_app.h \
+            file://inc/log.h \
+            file://src/can.c \
+            file://inc/can.h \
+            file://CMakeLists.txt \
+"
+
+S = "${WORKDIR}"
+
+inherit cmake
+
+EXTRA_OECMAKE = ""
+
+do_install() {
+    install -d ${D}${bindir}
+    install -m 0755 can_app ${D}${bindir}
+}
diff --git a/meta-services/recipes-services/can-app/files/CMakeLists.txt b/meta-services/recipes-services/can-app/files/CMakeLists.txt
new file mode 100755
index 0000000..6aafceb
--- /dev/null
+++ b/meta-services/recipes-services/can-app/files/CMakeLists.txt
@@ -0,0 +1,38 @@
+cmake_minimum_required(VERSION 3.5)
+project(can-app)
+
+include_directories(
+        ${CMAKE_CURRENT_SOURCE_DIR}/inc}
+        )
+
+link_directories(
+        ${THISDIR}/../../../dbus-wrapper/0.1-r0/build/
+        )
+
+SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-unknown-pragmas -g -D_GNU_SOURCE \
+                   -D_USINGLIBC -lrt -Wall -lpthread -g -ljson-c \
+                   -I${THISDIR}/../../dbus-wrapper/0.1-r0/inc" 
+   )
+
+set(DBUS_WRAPPER "-ldbus-wrapper" )
+set(JSON_LIBRARY "-ljson-c" )
+
+find_package(PkgConfig REQUIRED)
+pkg_check_modules(DBUS-1  REQUIRED IMPORTED_TARGET dbus-1)
+
+find_package(PkgConfig REQUIRED)
+pkg_check_modules(LIBSOCKETCAN REQUIRED IMPORTED_TARGET libsocketcan)
+
+add_executable (can_app
+           ${CMAKE_CURRENT_SOURCE_DIR}/src/can_app.c
+           ${CMAKE_CURRENT_SOURCE_DIR}/src/can.c
+       )
+
+include_directories(${JSON_INCLUDE_DIR})
+
+target_link_libraries(can_app PUBLIC
+                      ${DBUS_WRAPPER}
+                      ${JSON_LIBRARY}
+                      PkgConfig::LIBSOCKETCAN
+                      PkgConfig::DBUS-1
+)
diff --git a/meta-services/recipes-services/can-app/files/inc/can.h b/meta-services/recipes-services/can-app/files/inc/can.h
new file mode 100644
index 0000000..727edd3
--- /dev/null
+++ b/meta-services/recipes-services/can-app/files/inc/can.h
@@ -0,0 +1,39 @@
+#ifndef CAN_H
+#define CAN_H
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <string.h>
+#include <net/if.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <linux/can.h>
+#include <linux/can/raw.h>
+#include <sys/select.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include "log.h"
+
+enum can_error_states{
+	CAN_SUCCESS = 0,
+	CAN_TIMEOUT = -1,
+	CAN_CLOSE_TIMEOUT = -2,
+	CAN_OPEN_SOC_ERROR = -3,
+	CAN_OPEN_SOC_BIND_ERROR = -4,
+	CAN_SOC_SET_TIMEOUT_ERROR = -5,
+	CAN_CLOSE_ERROR = -6,
+	CAN_CLOSE_FD_ALREADY_CLOSED = -7,
+	CAN_WRITE_ERROR = -8,
+	CAN_READ_ERROR = -9,
+	CAN_UDS_WRITE_ERROR = -10,
+};
+
+int open_canbus_socket(const char *ifname);
+int write_canbus_frame(char fd, struct can_frame frame);
+int read_canbus_frame(char fd, struct can_frame *frame);
+int close_canbus_socket(char fd);
+
+#endif
diff --git a/meta-services/recipes-services/can-app/files/inc/can_app.h b/meta-services/recipes-services/can-app/files/inc/can_app.h
new file mode 100644
index 0000000..8b93d83
--- /dev/null
+++ b/meta-services/recipes-services/can-app/files/inc/can_app.h
@@ -0,0 +1,120 @@
+#ifndef CAN_APP_H
+#define CAN_APP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <time.h>
+#include <signal.h>
+#include <pthread.h>
+#include <dbus/dbus.h>
+#include <dbus_interface.h>
+#include <dbus_wrapper.h>
+#include <json-c/json.h>
+#include <json-c/json_object.h>
+#include <ctype.h>
+#include <errno.h>
+
+#include "log.h"
+#include "can.h"
+
+#define DATA_SIZE    500
+
+//#define SIG_DATA    "{\"request\": {\"port_id\": 123, \"action\": \"set\", \"voltage\": 48.45}}"
+//#define CAN_JSON_Req_string     "{\"request\": {\"port_id\": 1, \"action\": \"set\", \"voltage\": 48.45}}"
+//#define CAN_JSON_resp_string    "{\"reponse\": {\"port_id\": 1, \"resp_type\": \"response\", \"is_err\": fasle, \"err_code\": 0, \"voltage\": 13.19, \"current\": 8.18}}"
+
+#define CAN_ID      0x7E0
+#define CAN_DLC     8
+#define CAN_IFNAME  "can0"
+
+#define PORT_ID     "port_id"
+#define PORT_ON     0x01
+#define PORT_OFF    0x00
+
+#define ACTION      "action"
+#define SET         "set"
+#define RESET       "reset"
+
+#define VOLTAGE     "voltage"
+
+/*
+Minimal valid JSON objects are as below:
+The empty object '{}'
+The empty array '[]'
+The string that is empty '""'
+A number e.g. '123.4'
+The boolean value true 'true'
+The boolean value false 'false'
+The null value 'null'
+*/
+
+enum CAN_frame_type
+{
+    CAN_frame_type_request = 0x10,
+    CAN_frame_type_resp_pos = 0x60,
+    CAN_frame_type_resp_neg = 0x6F,
+    CAN_frame_type_status = 0x11
+};
+
+enum CAN_frame_indices
+{
+    frame_type = 0,
+    frame_port = 1,
+    volt_i = 2,
+    volt_d = 3,
+    curr_i = 4,
+    curr_d = 5
+};
+
+struct can_json_req
+{
+    int port_id;
+    char *action;
+    float voltage;
+}__attribute__((packed));
+
+struct can_json_req can_req_st;
+
+int fd_can;
+struct can_frame tx_frame;
+struct can_frame rx_frame;
+
+static volatile unsigned char read_can_bus = 1;
+static volatile unsigned char dbus_listen = 1;
+static bool is_req_sent = false;
+static bool is_req_valid = false;
+
+struct json_obj_t jdata;
+struct json_obj_t json_data;
+struct signal_data_t signal_data;
+
+pthread_mutex_t data_lock;
+
+void prepare_can_frame(int can_id, uint8_t can_dlc, uint8_t data[CAN_MAX_DLEN], struct can_frame *frame);
+void show_can_frame(struct can_frame frame);
+void print_st(struct can_json_req *st);
+int valid_por(int p_id);
+void send_CAN_frame(struct can_json_req *st);
+void add_key_value_pair_to_st(char *k, void *v);
+void json_parse(json_object *jobj);
+void handle_msg_from_SMART_CHARGER_APP_module();
+void handle_JSON_CAN_request(char *payload, int len);
+void *CAN_read_thread();
+void *dbus_listener();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/meta-services/recipes-services/can-app/files/inc/log.h b/meta-services/recipes-services/can-app/files/inc/log.h
new file mode 100644
index 0000000..97a3b14
--- /dev/null
+++ b/meta-services/recipes-services/can-app/files/inc/log.h
@@ -0,0 +1,67 @@
+#ifndef LOG_H
+#define LOG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+
+#define LOG_EMERG	0
+#define LOG_ALERT	1
+#define LOG_CRIT	2
+#define LOG_ERR		3
+#define LOG_WARN	4
+#define LOG_NOTICE	5
+#define LOG_INFO	6
+#define LOG_DEBUG	7
+
+#define LOG_LEVEL	7
+
+#define STD_OUT stdout
+#define STD_ERR stderr
+
+#define log_msg(prio, stream, msg, ...) \
+    do {\
+        char *str;\
+        if ((prio == LOG_EMERG) && (LOG_LEVEL >= LOG_EMERG)) {\
+            str = "EMERG";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_ALERT) && (LOG_LEVEL >= LOG_ALERT)) {\
+            str = "ALERT";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_CRIT) && (LOG_LEVEL >= LOG_CRIT)) {\
+            str = "CRIT";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_ERR) && (LOG_LEVEL >= LOG_ERR)) {\
+            str = "ERR";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_WARN) && (LOG_LEVEL >= LOG_WARN)) {\
+            str = "WARN";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_NOTICE) && (LOG_LEVEL >= LOG_NOTICE)) {\
+            str = "NOTICE";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_INFO) && (LOG_LEVEL >= LOG_INFO)) {\
+            str = "INFO";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_DEBUG) && (LOG_LEVEL >= LOG_DEBUG)) {\
+            str = "DEBUG";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+    } while(0)
+
+//log_msg(LOG_ERR, STD_ERR, "\nError in opening %s", filename);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/meta-services/recipes-services/can-app/files/scripts/can_up.sh b/meta-services/recipes-services/can-app/files/scripts/can_up.sh
new file mode 100644
index 0000000..274b205
--- /dev/null
+++ b/meta-services/recipes-services/can-app/files/scripts/can_up.sh
@@ -0,0 +1,7 @@
+#!/bin/bash
+
+ifconfig can0
+sudo ip link set can0 down
+sudo ip link set can0 type can bitrate 500000
+sudo ip link set can0 up
+ifconfig can0
diff --git a/meta-services/recipes-services/can-app/files/src/can.c b/meta-services/recipes-services/can-app/files/src/can.c
new file mode 100644
index 0000000..37f6ea5
--- /dev/null
+++ b/meta-services/recipes-services/can-app/files/src/can.c
@@ -0,0 +1,117 @@
+#include "../inc/can.h"
+
+int open_canbus_socket(const char *ifname)
+{
+
+	uint8_t fd;
+	int ret;
+	struct timeval tv;
+	struct sockaddr_can addr;
+	struct ifreq ifr;
+	
+	if((fd = socket(PF_CAN, SOCK_RAW, CAN_RAW)) < 0)
+	{
+		log_msg(LOG_ERR, STD_ERR, "Fail to create CAN Socket");
+		ret = CAN_OPEN_SOC_ERROR;
+		return ret;
+	}
+	else
+	{
+		strcpy(ifr.ifr_name, ifname);
+		ioctl(fd, SIOCGIFINDEX, &ifr);
+		addr.can_family  = AF_CAN;
+		addr.can_ifindex = ifr.ifr_ifindex;
+		
+		log_msg(LOG_DEBUG, STD_OUT, "%s at index %d", ifname, ifr.ifr_ifindex);
+		
+		if(bind(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
+		{ 
+			log_msg(LOG_ERR, STD_ERR, "CAN socket Bind error");
+			ret = CAN_OPEN_SOC_BIND_ERROR;
+			return ret;
+		}
+		else
+		{
+			tv.tv_sec = 0;
+			//can-bus read time-out issue, decrease the can-bus set time-out
+			tv.tv_usec = 2000; 
+			//CAN_TIMEOUT_SET_FAIL = -22;
+			if (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0)
+			{
+			     log_msg(LOG_ERR, STD_ERR, "set socket options error");
+			     ret = CAN_SOC_SET_TIMEOUT_ERROR;
+			     return ret;
+			}
+		}
+	}
+	ret = fd;
+	log_msg(LOG_INFO, STD_OUT, "CAN socket initialization is success!");
+	return fd;
+}
+
+int close_canbus_socket(char fd)
+{
+	int ret;
+
+	if (fd > 0)
+	{
+	  if (close(fd) < 0)
+	  {
+	      log_msg(LOG_ERR, STD_ERR, "Fail to close socket fd = %d", fd);
+	      ret = CAN_CLOSE_ERROR;
+	  }
+	  else 
+	  {
+	      log_msg(LOG_INFO, STD_OUT, "Successfully closed CAN socket fd = %d", fd);
+	      ret = CAN_SUCCESS;
+	  }
+	}
+	else
+	{
+		log_msg(LOG_ERR, STD_OUT, "Invalid CAN socket fd %d", fd);
+		ret = CAN_CLOSE_FD_ALREADY_CLOSED;
+	}
+
+	return ret;
+}
+
+int write_canbus_frame(char fd, struct can_frame frame)
+{
+	int ret;
+	int nbytes = 0;
+	
+	//write the buffer
+	nbytes = write(fd, &frame, sizeof(struct can_frame));
+	if (nbytes < 1)
+	{
+		ret = CAN_WRITE_ERROR;
+		log_msg(LOG_ERR, STD_ERR, "Error in writing CAN-Frame, nbytes: %d", nbytes);
+	}
+	else 
+	{
+		log_msg(LOG_DEBUG, STD_OUT, "Written %d bytes on CAN-BUS", nbytes);
+		ret = CAN_SUCCESS;
+	}
+	
+	return ret;
+}
+
+int read_canbus_frame(char fd, struct can_frame *frame)
+{
+	int ret = 0;
+	int nbytes = 0;
+	
+	nbytes = read(fd, frame, sizeof(struct can_frame));
+	if(nbytes < 2)
+	{
+		log_msg(LOG_DEBUG, STD_OUT, "%s failed to read CAN frame", __func__);
+		ret = CAN_READ_ERROR;
+	}
+	else
+	{
+		log_msg(LOG_INFO, STD_OUT, "%d bytes read from the CAN-BUS", nbytes);
+		ret =  nbytes;
+	}
+	
+	return ret;
+}
diff --git a/meta-services/recipes-services/can-app/files/src/can_app.c b/meta-services/recipes-services/can-app/files/src/can_app.c
new file mode 100644
index 0000000..54d3e22
--- /dev/null
+++ b/meta-services/recipes-services/can-app/files/src/can_app.c
@@ -0,0 +1,468 @@
+#include "../inc/can_app.h"
+
+/* ------------------------------------------------------------- CAN Functions --------------------------------------------------------------------------------- */
+
+void prepare_can_frame(int can_id, uint8_t can_dlc, uint8_t data[CAN_MAX_DLEN], struct can_frame *frame)
+{
+    frame->can_id = can_id;
+    frame->can_dlc = can_dlc;
+    memset((void *)frame->data, 0, CAN_MAX_DLEN);
+    memcpy((void *)frame->data, (const void *)data, CAN_MAX_DLEN);
+}
+
+void show_can_frame(struct can_frame frame)
+{
+    log_msg(LOG_INFO, STD_OUT, "CAN Frame is:");
+    printf("%s\t%X\t%X\t", CAN_IFNAME, frame.can_dlc, frame.can_id);
+    for(int i = 0; i < CAN_MAX_DLEN; i++)
+        printf("%X ", frame.data[i]);
+    printf("\n");
+}
+
+void send_CAN_frame(struct can_json_req *st)
+{
+    uint8_t can_frame[CAN_MAX_DLEN] = {0};
+    uint8_t can_frame_len = 0;
+
+    if(valid_port(st->port_id))
+    {
+        can_frame[0] = CAN_frame_type_request;
+        can_frame_len += 1;
+        
+        can_frame[1] = st->port_id;
+        can_frame_len += 1;
+
+        //log_msg(LOG_DEBUG, STD_OUT, "cmp = %d", strcmp(st->action, SET));
+        //log_msg(LOG_DEBUG, STD_OUT, "set_len = %ld", strlen(SET));
+        //log_msg(LOG_DEBUG, STD_OUT, "action_len = %ld", strlen(st->action));
+        
+        if(strcmp(st->action, SET) == 0)
+        {
+            can_frame[1] = (PORT_ON << 4) | (can_frame[1]);
+            
+            can_frame[2] = (int )st->voltage;
+            can_frame_len += 1;
+            
+            can_frame[3] = (int )((st->voltage - ((int )st->voltage))*100);
+            can_frame_len += 1;
+        }
+        else if(strcmp(st->action, RESET) == 0)
+        {
+            can_frame[1] = (PORT_OFF << 4) | (can_frame[1]);
+        }
+        else
+        {
+            log_msg(LOG_ERR, STD_ERR, "Invalid operation on the port!");
+            // send Negative reply to Smart App
+            signal_data.payload = (char *)calloc(DATA_SIZE, sizeof(char));
+            sprintf(signal_data.payload, "{\"reponse\": {\"port_id\": %d, \"resp_type\": \"%s\", \"is_err\": %s, \"err_code\": %d, \"voltage\": %.2f, \"current\": %.2f}}",
+                                                                               0, "response", "true", CAN_INVALID_PORT_ACTION, 0, 0);
+            log_msg(LOG_INFO, STD_OUT, "%s\n", signal_data.payload);
+            CAN_dbus_emitter(RESPONSE_SIGNAL);
+            is_req_valid = false;
+        }
+    }
+    else
+    {
+        log_msg(LOG_ERR, STD_ERR, "Invalid Port Id of the charger!");
+        // TODO: Send Negative reply to Smart App
+        is_req_valid = false;
+    }
+    if(is_req_valid)
+    {
+        prepare_can_frame(CAN_ID, can_frame_len, can_frame, &tx_frame);
+        show_can_frame(tx_frame);
+        write_canbus_frame(fd_can, tx_frame);
+        is_req_sent = true;
+        is_req_valid = false;   // Reset back to false to avoid sending duplicate req frames
+        can_req_st.action = NULL;
+        free(can_req_st.action);
+    }
+}
+
+void handle_JSON_CAN_request(char *payload, int len)
+{
+    json_object *jobj = json_tokener_parse(payload);
+
+    if(jobj != NULL)
+    {
+        log_msg(LOG_DEBUG, STD_OUT, "A valid JSON string is passed");
+        is_req_valid = true;
+        json_parse(jobj);
+        print_st(&can_req_st);
+        send_CAN_frame(&can_req_st);
+    }
+    else
+    {
+        log_msg(LOG_ERR, STD_ERR, "Invalid JSON string");
+
+        // Sending Invalid CAN request JSON format error
+        signal_data.payload = (char *)calloc(DATA_SIZE, sizeof(char));
+        sprintf(signal_data.payload, "{\"reponse\": {\"port_id\": %d, \"resp_type\": \"%s\", \"is_err\": %s, \"err_code\": %d, \"voltage\": %.2f, \"current\": %.2f}}",
+                                                                               0, "response", "true", CAN_INVALID_JSON, 0, 0);
+        log_msg(LOG_INFO, STD_OUT, "%s\n", signal_data.payload);
+        CAN_dbus_emitter(RESPONSE_SIGNAL);
+
+        is_req_valid = false;
+    }
+}
+
+/* ------------------------------------------------------------- JSON Functions --------------------------------------------------------------------------------- */
+
+void json_parse(json_object *jobj)
+{
+    enum json_type type;
+    
+    json_object_object_foreach(jobj, key, val)
+    {
+        type = json_object_get_type(val);
+        log_msg(LOG_DEBUG, STD_OUT, "key = %s", key);
+
+        switch(type)
+        {
+            case json_type_null:
+                log_msg(LOG_DEBUG, STD_OUT, "json_type_null");
+                int null_value = -1;
+                add_key_value_pair_to_st(key, (void *)&null_value);
+                break;
+            case json_type_boolean:
+                log_msg(LOG_DEBUG, STD_OUT, "json_type_booleann");
+                int b = json_object_get_boolean(val);
+                log_msg(LOG_DEBUG, STD_OUT, "value: %d", b);
+                add_key_value_pair_to_st(key, (void *)&b);
+                break;
+            case json_type_double:
+                log_msg(LOG_DEBUG, STD_OUT, "json_type_doublen");
+                float f = json_object_get_double(val);
+                log_msg(LOG_DEBUG, STD_OUT, "value: %lf", f);
+                add_key_value_pair_to_st(key, (void *)&f);
+                break;
+            case json_type_int:
+                log_msg(LOG_DEBUG, STD_OUT, "json_type_int");
+                int i = json_object_get_int(val);
+                log_msg(LOG_DEBUG, STD_OUT, "value: %d", i);
+                add_key_value_pair_to_st(key, (void *)&i);
+                break;
+            case json_type_string:
+                log_msg(LOG_DEBUG, STD_OUT, "json_type_string");
+                char str[DATA_SIZE] = {0};
+                memcpy((void *)str, (const void *)json_object_get_string(val), json_object_get_string_len(val));
+                str[json_object_get_string_len(val)] = '\0';
+                log_msg(LOG_DEBUG, STD_OUT, "value: %s", str);
+                add_key_value_pair_to_st(key, (void *)str);
+                break;
+            case json_type_object:
+                log_msg(LOG_DEBUG, STD_OUT, "json_type_object");
+                json_object *value_obj = val;
+                json_object_object_get_ex(jobj, key, &value_obj);
+                json_parse(value_obj);
+                break;
+            case json_type_array:
+                log_msg(LOG_DEBUG, STD_OUT, "type: json_type_array");
+                //json_parse_array(jobj, key);
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+/* ------------------------------------------------------------- D-Bus Emitter --------------------------------------------------------------------------------- */
+
+void CAN_dbus_emitter(int signal_cmd)
+{
+    struct dbus_var_t dbus_info;
+    char db_payload[DATA_SIZE] = {0};
+
+    dbus_info.obj = CAN_SER_DATA_OBJECT;
+    dbus_info.interface = CAN_SER_DATA_INTERFACE;
+    dbus_info.sig_name = CAN_SER_DATA_SIG_NAME;
+
+    signal_data.signal_id = CAN_SER_SIGNAL_ID;
+    signal_data.can_id = CAN_ID;
+    signal_data.cmd = signal_cmd;
+
+    write_init(&dbus_info);
+
+    pthread_mutex_lock(&data_lock);
+
+    compose_data(&json_data, db_payload, signal_data);
+    log_msg(LOG_INFO, STD_OUT, "db_payload Check: %s", db_payload);
+    write_data(db_payload, dbus_info);
+
+    pthread_mutex_unlock(&data_lock);
+
+    signal_data.payload = NULL;
+    free(signal_data.payload);
+}
+
+/* ------------------------------------------------------------- D-Bus Listener --------------------------------------------------------------------------------- */
+
+void *dbus_listener()
+{
+    struct dbus_var_t dbus_info;
+
+    uint32_t signal_id = 0;
+    char signal_id_str[10] = {0};
+
+    //init dbus and add filters
+    read_init(&dbus_info);
+    add_filter(&dbus_info, SMART_CHARGER_APP_SER_DATA_RCVR);
+
+    while(dbus_listen)
+    {
+        if(check_data(&dbus_info) == 0)
+        {
+            jdata = read_data(&dbus_info);
+
+            json_object_object_get_ex(jdata.obj, "sig_id", &jdata.sig);
+            json_object_object_get_ex(jdata.obj, "dlc", &jdata.dlc);
+            json_object_object_get_ex(jdata.obj, "can_id", &jdata.can_id);
+            json_object_object_get_ex(jdata.obj, "cmd", &jdata.cmd);
+            json_object_object_get_ex(jdata.obj, "payload", &jdata.payload);
+
+            // get signal_id
+            if(jdata.sig != NULL)
+            {
+                sprintf(signal_id_str, "%s", json_object_get_string(jdata.sig));
+                signal_id = (int)strtol(signal_id_str, NULL, 16);
+                log_msg(LOG_DEBUG, STD_OUT, "signal id : %04x", signal_id);
+            }
+            switch(signal_id)
+            {
+                case SMART_CHARGER_APP_SER_SIGNAL_ID:
+                    log_msg(LOG_DEBUG, STD_OUT, "Msg from SMART CHARGER APP Module");
+                    handle_msg_from_SMART_CHARGER_APP_module();
+                    break;
+                default:
+                    log_msg(LOG_DEBUG, STD_OUT, "In the default switch case");
+                    break;
+            }
+        }
+    }
+    //pthread_exit(NULL);
+    return NULL;
+}
+
+void handle_msg_from_SMART_CHARGER_APP_module()
+{
+    char get_json_dbus_payload[DATA_SIZE] = {0};
+    uint32_t sig_cmd = 0;
+
+    // get sig_cmd
+    if(jdata.cmd == NULL)
+    {
+        log_msg(LOG_WARN, STD_OUT, "No signal command");
+        return;
+    }
+
+    if(jdata.payload == NULL)
+    {
+        log_msg(LOG_WARN, STD_OUT, "No signal payload");
+        return;
+    }
+
+    sprintf(get_json_dbus_payload, "%s", json_object_get_string(jdata.cmd));
+    sig_cmd = (int)strtol(get_json_dbus_payload, NULL, 16);
+    log_msg(LOG_DEBUG, STD_OUT, "signal cmd : %04x", sig_cmd);
+
+    if(sig_cmd != REQUEST_SIGNAL)
+    {
+        log_msg(LOG_DEBUG, STD_OUT, "Invalid signal command from SMART CHARGER APP module");
+    }
+
+    sprintf(get_json_dbus_payload, "%s", json_object_get_string(jdata.payload));
+    log_msg(LOG_INFO, STD_OUT, "D-Bus signal payload : %s", get_json_dbus_payload);
+    log_msg(LOG_INFO, STD_OUT, "D-Bus signal payload len : %ld", strlen(get_json_dbus_payload));
+
+    handle_JSON_CAN_request(get_json_dbus_payload, strlen(get_json_dbus_payload));
+}
+
+/* ------------------------------------------------------------- CAN port Listener --------------------------------------------------------------------------------- */
+
+void *CAN_read_thread()
+{
+    while(read_can_bus)
+    {
+        if(read_canbus_frame(fd_can, &rx_frame) > 0)
+        {
+            // TODO: If the frame ID is 7E1 then only process it. otherwise ignore
+            show_can_frame(rx_frame);
+            convert_CAN_to_JSON();
+            //break;
+        }
+        //sleep(1);
+        usleep(250);
+    }
+    //pthread_exit(NULL);
+    return NULL;
+}
+
+/* ------------------------------------------------------------- Helper functions --------------------------------------------------------------------------------- */
+
+void convert_CAN_to_JSON()
+{
+    char resp_type[20] = {0};
+    int port_id = 0;
+    int port_state = 0;
+    int err_code = 0;
+    float voltage = 0.0;
+    float current = 0.0;
+
+    signal_data.payload = (char *)calloc(DATA_SIZE, sizeof(char));
+
+    port_id = rx_frame.data[frame_port] & 0x0F;
+    port_state = (rx_frame.data[frame_port] >> 4) & 0x0F;
+
+    log_msg(LOG_DEBUG, STD_OUT, "port_id = %d", port_id);
+    log_msg(LOG_DEBUG, STD_OUT, "port_state = %d", port_state);
+
+    switch(rx_frame.data[frame_type])
+    {
+        case CAN_frame_type_request:
+            log_msg(LOG_WARN, STD_OUT, "Request Frame received");
+            break;
+
+        case CAN_frame_type_resp_pos:
+            log_msg(LOG_DEBUG, STD_OUT, "Response frame received");
+            strcpy(resp_type, "response");
+            
+            voltage = ((((float)rx_frame.data[2])*100) + (rx_frame.data[3]%100))/100;
+            current = ((((float)rx_frame.data[4])*100) + (rx_frame.data[5]%100))/100;
+            
+            /*if(port_state)
+            {
+                voltage = ((((float)rx_frame.data[2])*100) + (rx_frame.data[3]%100))/100;
+                current = ((((float)rx_frame.data[4])*100) + (rx_frame.data[5]%100))/100;
+            }
+            else
+            {
+                err_code = rx_frame.data[2];
+            }*/
+            break;
+
+        case CAN_frame_type_resp_neg:
+            log_msg(LOG_DEBUG, STD_OUT, "Negative Response frame received");
+            strcpy(resp_type, "response");
+
+            err_code = rx_frame.data[2];
+            break;
+
+        case CAN_frame_type_status:
+            log_msg(LOG_DEBUG, STD_OUT, "Status frame received");
+            strcpy(resp_type, "status");
+
+            voltage = ((((float)rx_frame.data[2])*100) + (rx_frame.data[3]%100))/100;
+            current = ((((float)rx_frame.data[4])*100) + (rx_frame.data[5]%100))/100;
+            
+            /*if(port_state)
+            {
+                voltage = ((((float)rx_frame.data[2])*100) + (rx_frame.data[3]%100))/100;
+                current = ((((float)rx_frame.data[4])*100) + (rx_frame.data[5]%100))/100;
+            }
+            else
+            {
+                err_code = rx_frame.data[2];
+            }*/
+            break;
+
+        default:
+            log_msg(LOG_INFO, STD_OUT, "Invalid frame is received");
+            // Free the signal_data.payload variable memory and return from the function with sending any signal on D-Bus
+            signal_data.payload = NULL;
+            free(signal_data.payload);
+            return;
+            //break;
+    }
+
+    sprintf(signal_data.payload, "{\"reponse\": {\"port_id\": %d, \"resp_type\": \"%s\", \"is_err\": %s, \"err_code\": %d, \"voltage\": %.2f, \"current\": %.2f}}",
+                                                                               port_id, resp_type, (err_code ? "true" : "false"), err_code, voltage, current);
+
+    log_msg(LOG_INFO, STD_OUT, "%s\n", signal_data.payload);
+    CAN_dbus_emitter(RESPONSE_SIGNAL);
+}
+
+void print_st(struct can_json_req *st)
+{
+    log_msg(LOG_INFO, STD_OUT, "st->port_id = %d", st->port_id);
+    log_msg(LOG_INFO, STD_OUT, "st->action = %s", st->action);
+    log_msg(LOG_INFO, STD_OUT, "st->voltage = %f", st->voltage);
+}
+
+int valid_port(int p_id)
+{
+    return 1;
+}
+
+void add_key_value_pair_to_st(char *k, void *v)
+{
+    if(strcmp(k, PORT_ID) == 0)
+    {
+        can_req_st.port_id = *((int *) v);
+    }
+    else if(strcmp(k, ACTION) == 0)
+    {
+        int action_len = strlen((char *)v);
+
+        can_req_st.action = (char *)malloc(action_len);
+
+        memcpy((void *)can_req_st.action, (const void *)v, action_len);
+        can_req_st.action[action_len] = '\0';
+    }
+    else if(strcmp(k, VOLTAGE) == 0)
+    {
+        can_req_st.voltage = *((float *) v);
+    }
+    else
+    {
+        log_msg(LOG_ERR, STD_ERR, "Invalid key!");
+        // TODO: Send Invalid CAN Request JSON key pairs error
+        signal_data.payload = (char *)calloc(DATA_SIZE, sizeof(char));
+        sprintf(signal_data.payload, "{\"reponse\": {\"port_id\": %d, \"resp_type\": \"%s\", \"is_err\": %s, \"err_code\": %d, \"voltage\": %.2f, \"current\": %.2f}}",
+                                                                               0, "response", "true", CAN_INVALID_JSON, 0, 0);
+        log_msg(LOG_INFO, STD_OUT, "%s\n", signal_data.payload);
+        CAN_dbus_emitter(RESPONSE_SIGNAL);
+
+        is_req_valid = false;
+
+    }
+}
+
+/* ------------------------------------------------------------- MAIN function --------------------------------------------------------------------------------- */
+
+int main(int argc, char** argv)
+{
+    int ret = 0;
+
+    pthread_t db_listener;
+    pthread_t CAN_listener;
+    
+    // CAN bus Init
+    if((fd_can = open_canbus_socket(CAN_IFNAME)) < 0)
+    {
+        log_msg(LOG_ERR, STD_ERR, "CAN bus init failed!");
+        exit(EXIT_FAILURE);
+    }
+
+    // Thread for D-Bus listener
+    ret = pthread_create(&db_listener, NULL, &dbus_listener, NULL);
+    if(ret != 0)
+    {
+        log_msg(LOG_ERR, STD_ERR, "Error: dbus_listener thread creation Failed!, Error_code:[%d]\n", ret);
+        exit(EXIT_FAILURE);
+    }
+
+    // Thread for CAN read
+    ret = pthread_create(&CAN_listener, NULL, &CAN_read_thread, NULL);
+    if(ret != 0)
+    {
+        log_msg(LOG_ERR, STD_ERR, "Error: CAN read thread creation Failed!, Error_code:[%d]\n", ret);
+        exit(EXIT_FAILURE);
+    }
+
+    pthread_join(db_listener, NULL);
+    pthread_join(CAN_listener, NULL);
+
+    return 0;
+}
+
diff --git a/meta-services/recipes-services/can-app/files/src/can_app.c_bckup b/meta-services/recipes-services/can-app/files/src/can_app.c_bckup
new file mode 100644
index 0000000..f3b444d
--- /dev/null
+++ b/meta-services/recipes-services/can-app/files/src/can_app.c_bckup
@@ -0,0 +1,432 @@
+#include "../inc/can_app.h"
+
+void prepare_can_frame(int can_id, uint8_t can_dlc, uint8_t data[CAN_MAX_DLEN], struct can_frame *frame)
+{
+    frame->can_id = can_id;
+    frame->can_dlc = can_dlc;
+    memset((void *)frame->data, 0, CAN_MAX_DLEN);
+    memcpy((void *)frame->data, (const void *)data, CAN_MAX_DLEN);
+}
+
+void CAN_dbus_emitter()
+{
+    struct dbus_var_t dbus_info;
+    char db_payload[DATA_SIZE] = {0};
+
+    dbus_info.obj = CAN_SER_DATA_OBJECT;
+    dbus_info.interface = CAN_SER_DATA_INTERFACE;
+    dbus_info.sig_name = CAN_SER_DATA_SIG_NAME;
+
+    signal_data.signal_id = CAN_SER_SIGNAL_ID;
+    signal_data.can_id = CAN_ID;
+    signal_data.cmd = 0;
+
+    write_init(&dbus_info);
+
+    pthread_mutex_lock(&data_lock);
+
+    compose_data(&json_data, db_payload, signal_data);
+    log_msg(LOG_INFO, STD_OUT, "db_payload Check: %s", db_payload);
+    write_data(db_payload, dbus_info);
+
+    pthread_mutex_unlock(&data_lock);
+
+    signal_data.payload = NULL;
+    free(signal_data.payload);
+}
+
+void convert_CAN_to_JSON()
+{
+    char resp_type[20] = {0};
+    int port_id = 0;
+    int port_state = 0;
+    int err_code = 0;
+    float voltage = 0.0;
+    float current = 0.0;
+
+    signal_data.payload = (char *)calloc(DATA_SIZE, sizeof(char));
+
+    port_id = rx_frame.data[frame_port] & 0x0F;
+    port_state = (rx_frame.data[frame_port] >> 4) & 0x0F;
+
+    log_msg(LOG_DEBUG, STD_OUT, "port_id = %d", port_id);
+    log_msg(LOG_DEBUG, STD_OUT, "port_state = %d", port_state);
+
+    switch(rx_frame.data[frame_type])
+    {
+        case CAN_frame_type_request:
+            log_msg(LOG_WARN, STD_OUT, "Request Frame received");
+            break;
+
+        case CAN_frame_type_resp_pos:
+            log_msg(LOG_DEBUG, STD_OUT, "Response frame received");
+            strcpy(resp_type, "response");
+            
+            if(port_state)
+            {
+                voltage = ((((float)rx_frame.data[2])*100) + (rx_frame.data[3]%100))/100;
+                current = ((((float)rx_frame.data[4])*100) + (rx_frame.data[5]%100))/100;
+            }
+            else
+            {
+                err_code = rx_frame.data[2];
+            }
+            break;
+
+        case CAN_frame_type_resp_neg:
+            log_msg(LOG_DEBUG, STD_OUT, "Negative Response frame received");
+            strcpy(resp_type, "response");
+
+            err_code = rx_frame.data[2];
+            break;
+
+        case CAN_frame_type_status:
+            log_msg(LOG_DEBUG, STD_OUT, "Status frame received");
+            strcpy(resp_type, "status");
+
+            if(port_state)
+            {
+                voltage = ((((float)rx_frame.data[2])*100) + (rx_frame.data[3]%100))/100;
+                current = ((((float)rx_frame.data[4])*100) + (rx_frame.data[5]%100))/100;
+            }
+            else
+            {
+                err_code = rx_frame.data[2];
+            }
+            break;
+
+        default:
+            log_msg(LOG_INFO, STD_OUT, "Invalid frame is received");
+            break;
+    }
+
+    sprintf(signal_data.payload, "{\"reponse\": {\"port_id\": %d, \"resp_type\": \"%s\", \"is_err\": %s, \"err_code\": %d, \"voltage\": %.2f, \"current\": %.2f}}",
+                                                                               port_id, resp_type, (err_code ? "true" : "false"), err_code, voltage, current);
+
+    log_msg(LOG_INFO, STD_OUT, "%s\n", signal_data.payload);
+    CAN_dbus_emitter();
+}
+
+void show_can_frame(struct can_frame frame)
+{
+    log_msg(LOG_INFO, STD_OUT, "CAN Frame is:");
+    printf("%s\t%X\t%X\t", CAN_IFNAME, frame.can_dlc, frame.can_id);
+    for(int i = 0; i < CAN_MAX_DLEN; i++)
+        printf("%X ", frame.data[i]);
+    printf("\n");
+}
+
+void print_st(struct can_json_req *st)
+{
+    log_msg(LOG_INFO, STD_OUT, "st->port_id = %d", st->port_id);
+    log_msg(LOG_INFO, STD_OUT, "st->action = %s", st->action);
+    log_msg(LOG_INFO, STD_OUT, "st->voltage = %f", st->voltage);
+}
+
+int valid_port(int p_id)
+{
+    return 1;
+}
+
+void send_CAN_frame(struct can_json_req *st)
+{
+    uint8_t can_frame[CAN_MAX_DLEN] = {0};
+    uint8_t can_frame_len = 0;
+
+    if(valid_port(st->port_id))
+    {
+        can_frame[0] = CAN_frame_type_request;
+        can_frame_len += 1;
+        
+        can_frame[1] = st->port_id;
+        can_frame_len += 1;
+
+        //log_msg(LOG_DEBUG, STD_OUT, "cmp = %d", strcmp(st->action, SET));
+        //log_msg(LOG_DEBUG, STD_OUT, "set_len = %ld", strlen(SET));
+        //log_msg(LOG_DEBUG, STD_OUT, "action_len = %ld", strlen(st->action));
+        
+        if(strcmp(st->action, SET) == 0)
+        {
+            can_frame[1] = (PORT_ON << 4) | (can_frame[1]);
+            
+            can_frame[2] = (int )st->voltage;
+            can_frame_len += 1;
+            
+            can_frame[3] = (int )((st->voltage - ((int )st->voltage))*100);
+            can_frame_len += 1;
+        }
+        else if(strcmp(st->action, RESET) == 0)
+        {
+            can_frame[1] = (PORT_OFF << 4) | (can_frame[1]);
+        }
+        else
+        {
+            log_msg(LOG_ERR, STD_ERR, "Invalid operation on the port!");
+            // send Negative reply to Smart App
+            signal_data.payload = (char *)calloc(DATA_SIZE, sizeof(char));
+            sprintf(signal_data.payload, "{\"reponse\": {\"port_id\": %d, \"resp_type\": \"%s\", \"is_err\": %s, \"err_code\": %d, \"voltage\": %.2f, \"current\": %.2f}}",
+                                                                               0, "response", "true", CAN_INVALID_PORT_ACTION, 0, 0);
+            log_msg(LOG_INFO, STD_OUT, "%s\n", signal_data.payload);
+            CAN_dbus_emitter();
+            is_req_valid = false;
+        }
+    }
+    else
+    {
+        log_msg(LOG_ERR, STD_ERR, "Invalid Port Id of the charger!");
+        // TODO: Send Negative reply to Smart App
+        is_req_valid = false;
+    }
+    if(is_req_valid)
+    {
+        prepare_can_frame(CAN_ID, can_frame_len, can_frame, &tx_frame);
+        show_can_frame(tx_frame);
+        write_canbus_frame(fd_can, tx_frame);
+        is_req_sent = true;
+        is_req_valid = false;   // Reset back to false to avoid sending duplicate req frames
+        can_req_st.action = NULL;
+        free(can_req_st.action);
+    }
+}
+
+void add_key_value_pair_to_st(char *k, void *v)
+{
+    if(strcmp(k, PORT_ID) == 0)
+    {
+        can_req_st.port_id = *((int *) v);
+    }
+    else if(strcmp(k, ACTION) == 0)
+    {
+        int action_len = strlen((char *)v);
+
+        can_req_st.action = (char *)malloc(action_len);
+
+        memcpy((void *)can_req_st.action, (const void *)v, action_len);
+        can_req_st.action[action_len] = '\0';
+    }
+    else if(strcmp(k, VOLTAGE) == 0)
+    {
+        can_req_st.voltage = *((float *) v);
+    }
+    else
+    {
+        log_msg(LOG_ERR, STD_ERR, "Invalid key!");
+        // TODO: Send Invalid CAN Request JSON key pairs error
+        signal_data.payload = (char *)calloc(DATA_SIZE, sizeof(char));
+        sprintf(signal_data.payload, "{\"reponse\": {\"port_id\": %d, \"resp_type\": \"%s\", \"is_err\": %s, \"err_code\": %d, \"voltage\": %.2f, \"current\": %.2f}}",
+                                                                               0, "response", "true", CAN_INVALID_JSON, 0, 0);
+        log_msg(LOG_INFO, STD_OUT, "%s\n", signal_data.payload);
+        CAN_dbus_emitter();
+
+        is_req_valid = false;
+
+    }
+}
+
+void json_parse(json_object *jobj)
+{
+    enum json_type type;
+    
+    json_object_object_foreach(jobj, key, val)
+    {
+        type = json_object_get_type(val);
+        log_msg(LOG_DEBUG, STD_OUT, "key = %s", key);
+
+        switch(type)
+        {
+            case json_type_null:
+                log_msg(LOG_DEBUG, STD_OUT, "json_type_null");
+                int null_value = -1;
+                add_key_value_pair_to_st(key, (void *)&null_value);
+                break;
+            case json_type_boolean:
+                log_msg(LOG_DEBUG, STD_OUT, "json_type_booleann");
+                int b = json_object_get_boolean(val);
+                log_msg(LOG_DEBUG, STD_OUT, "value: %d", b);
+                add_key_value_pair_to_st(key, (void *)&b);
+                break;
+            case json_type_double:
+                log_msg(LOG_DEBUG, STD_OUT, "json_type_doublen");
+                float f = json_object_get_double(val);
+                log_msg(LOG_DEBUG, STD_OUT, "value: %lf", f);
+                add_key_value_pair_to_st(key, (void *)&f);
+                break;
+            case json_type_int:
+                log_msg(LOG_DEBUG, STD_OUT, "json_type_int");
+                int i = json_object_get_int(val);
+                log_msg(LOG_DEBUG, STD_OUT, "value: %d", i);
+                add_key_value_pair_to_st(key, (void *)&i);
+                break;
+            case json_type_string:
+                log_msg(LOG_DEBUG, STD_OUT, "json_type_string");
+                char str[DATA_SIZE] = {0};
+                memcpy((void *)str, (const void *)json_object_get_string(val), json_object_get_string_len(val));
+                str[json_object_get_string_len(val)] = '\0';
+                log_msg(LOG_DEBUG, STD_OUT, "value: %s", str);
+                add_key_value_pair_to_st(key, (void *)str);
+                break;
+            case json_type_object:
+                log_msg(LOG_DEBUG, STD_OUT, "json_type_object");
+                json_object *value_obj = val;
+                json_object_object_get_ex(jobj, key, &value_obj);
+                json_parse(value_obj);
+                break;
+            case json_type_array:
+                log_msg(LOG_DEBUG, STD_OUT, "type: json_type_array");
+                //json_parse_array(jobj, key);
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+void handle_JSON_CAN_request(char *payload, int len)
+{
+    json_object *jobj = json_tokener_parse(payload);
+
+    if(jobj != NULL)
+    {
+        log_msg(LOG_DEBUG, STD_OUT, "A valid JSON string is passed");
+        is_req_valid = true;
+        json_parse(jobj);
+        print_st(&can_req_st);
+        send_CAN_frame(&can_req_st);
+    }
+    else
+    {
+        log_msg(LOG_ERR, STD_ERR, "Invalid JSON string");
+
+        // Sending Invalid CAN request JSON format error
+        signal_data.payload = (char *)calloc(DATA_SIZE, sizeof(char));
+        sprintf(signal_data.payload, "{\"reponse\": {\"port_id\": %d, \"resp_type\": \"%s\", \"is_err\": %s, \"err_code\": %d, \"voltage\": %.2f, \"current\": %.2f}}",
+                                                                               0, "response", "true", CAN_INVALID_JSON, 0, 0);
+        log_msg(LOG_INFO, STD_OUT, "%s\n", signal_data.payload);
+        CAN_dbus_emitter();
+
+        is_req_valid = false;
+    }
+}
+
+int main(int argc, char** argv)
+{
+    int ret = 0;
+
+    pthread_t db_listener;
+    pthread_t CAN_listener;
+    
+    // CAN bus Init
+    if((fd_can = open_canbus_socket(CAN_IFNAME)) < 0)
+    {
+        log_msg(LOG_ERR, STD_ERR, "CAN bus init failed!");
+        exit(EXIT_FAILURE);
+    }
+
+    // Thread for D-Bus listener
+    ret = pthread_create(&db_listener, NULL, &dbus_listener, NULL);
+    if(ret != 0)
+    {
+        log_msg(LOG_ERR, STD_ERR, "Error: dbus_listener thread creation Failed!, Error_code:[%d]\n", ret);
+        exit(EXIT_FAILURE);
+    }
+
+    // Thread for CAN read
+    ret = pthread_create(&CAN_listener, NULL, &CAN_read_thread, NULL);
+    if(ret != 0)
+    {
+        log_msg(LOG_ERR, STD_ERR, "Error: CAN read thread creation Failed!, Error_code:[%d]\n", ret);
+        exit(EXIT_FAILURE);
+    }
+
+    pthread_join(db_listener, NULL);
+    pthread_join(CAN_listener, NULL);
+
+    return 0;
+}
+
+void *CAN_read_thread()
+{
+    while(read_can_bus)
+    {
+        if(read_canbus_frame(fd_can, &rx_frame) > 0)
+        {
+            show_can_frame(rx_frame);
+            convert_CAN_to_JSON();
+            //break;
+        }
+        sleep(1);
+    }
+    //pthread_exit(NULL);
+    return NULL;
+}
+
+void *dbus_listener()
+{
+    struct dbus_var_t dbus_info;
+
+    char get_json_dbus_payload[DATA_SIZE] = {0};
+    uint32_t signal_payload_len = 0;
+
+    //init dbus and add filters
+    read_init(&dbus_info);
+    add_filter(&dbus_info, SMART_CHARGER_APP_SER_DATA_RCVR);
+    
+    while(dbus_listen)
+    {
+        if(check_data(&dbus_info) == 0)
+        {
+            jdata = read_data(&dbus_info);
+
+            json_object_object_get_ex(jdata.obj, "sig_id", &jdata.sig);
+            json_object_object_get_ex(jdata.obj, "dlc", &jdata.dlc);
+            json_object_object_get_ex(jdata.obj, "can_id", &jdata.can_id);
+            json_object_object_get_ex(jdata.obj, "cmd", &jdata.cmd);
+            json_object_object_get_ex(jdata.obj, "payload", &jdata.payload);
+            
+            // get signal_id
+            if(jdata.sig != NULL)
+            {
+                sprintf(get_json_dbus_payload, "%s", json_object_get_string(jdata.sig));
+                uint32_t signal_id = (int)strtol(get_json_dbus_payload, NULL, 16);
+                log_msg(LOG_DEBUG, STD_OUT, "signal id : %04x", signal_id);
+            }
+            
+            // get signal payload len
+            if(jdata.dlc != NULL)
+            {
+                sprintf(get_json_dbus_payload, "%s", json_object_get_string(jdata.dlc));
+                signal_payload_len = (int)strtol(get_json_dbus_payload, NULL, 16);
+                log_msg(LOG_DEBUG, STD_OUT, "signal payload len : %04x", signal_payload_len);
+            }
+
+            // get can_id
+            if(jdata.can_id != NULL)
+            {
+                sprintf(get_json_dbus_payload, "%s", json_object_get_string(jdata.can_id));
+                uint32_t CAN_id = (int)strtol(get_json_dbus_payload, NULL, 16);
+                log_msg(LOG_DEBUG, STD_OUT, "CAN id : %04x", CAN_id);
+            }
+
+            // get sig_cmd
+            if(jdata.cmd != NULL)
+            {
+                sprintf(get_json_dbus_payload, "%s", json_object_get_string(jdata.cmd));
+                uint32_t sig_cmd = (int)strtol(get_json_dbus_payload, NULL, 16);
+                log_msg(LOG_DEBUG, STD_OUT, "signal cmd : %04x", sig_cmd);
+            }
+
+            // get sig_payload
+            if(jdata.payload != NULL)
+            {
+                sprintf(get_json_dbus_payload, "%s", json_object_get_string(jdata.payload));
+                //memcpy((void *)get_json_dbus_payload, (const void *)json_object_get_string(jdata.payload), signal_payload_len);
+                log_msg(LOG_INFO, STD_OUT, "signal payload : %s", get_json_dbus_payload);
+                log_msg(LOG_INFO, STD_OUT, "signal payload len : %ld", strlen(get_json_dbus_payload));
+            }
+            handle_JSON_CAN_request(get_json_dbus_payload, signal_payload_len);
+        }
+    }
+    //pthread_exit(NULL);
+    return NULL;
+}
+
diff --git a/meta-services/recipes-services/config-scripts/config-scripts_0.1.bb b/meta-services/recipes-services/config-scripts/config-scripts_0.1.bb
new file mode 100644
index 0000000..e0f2d0e
--- /dev/null
+++ b/meta-services/recipes-services/config-scripts/config-scripts_0.1.bb
@@ -0,0 +1,29 @@
+SUMMARY = "All configuration related scripts and services"
+DESCRIPTION = "scripts and Services on system boot"
+LICENSE = "CLOSED"
+
+SRC_URI =  " \
+    file://scripts/dbus_export.sh \
+    file://services/dbus_export.service \
+    file://scripts/can_config.sh \
+    file://services/can_config.service \
+"
+
+do_install () {
+    install -d ${D}${bindir}
+    install -m 0777 ${WORKDIR}/scripts/dbus_export.sh ${D}${bindir}
+    install -m 0777 ${WORKDIR}/scripts/can_config.sh ${D}${bindir}
+
+    install -d ${D}${systemd_unitdir}/system/
+    install -m 0644 ${WORKDIR}/services/dbus_export.service ${D}${systemd_unitdir}/system
+    install -m 0644 ${WORKDIR}/services/can_config.service ${D}${systemd_unitdir}/system
+}
+
+NATIVE_SYSTEMD_SUPPORT = "1"
+SYSTEMD_PACKAGES = "${PN}"
+SYSTEMD_SERVICE_${PN} = "dbus_export.service can_config.service"
+
+inherit allarch systemd
+
+FILES_${PN} += "${bindir}"
+FILES_${PN} += "${systemd_unitdir}/system/"
diff --git a/meta-services/recipes-services/config-scripts/files/scripts/can_config.sh b/meta-services/recipes-services/config-scripts/files/scripts/can_config.sh
new file mode 100644
index 0000000..acf3618
--- /dev/null
+++ b/meta-services/recipes-services/config-scripts/files/scripts/can_config.sh
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+ifconfig can0
+ip link set can0 down
+ip link set can0 type can bitrate 500000
+ip link set can0 up
+ifconfig can0
diff --git a/meta-services/recipes-services/config-scripts/files/scripts/dbus_export.sh b/meta-services/recipes-services/config-scripts/files/scripts/dbus_export.sh
new file mode 100644
index 0000000..24e72e9
--- /dev/null
+++ b/meta-services/recipes-services/config-scripts/files/scripts/dbus_export.sh
@@ -0,0 +1,2 @@
+#!/bin/sh
+export $(dbus-launch)
diff --git a/meta-services/recipes-services/config-scripts/files/services/can_config.service b/meta-services/recipes-services/config-scripts/files/services/can_config.service
new file mode 100644
index 0000000..bd91942
--- /dev/null
+++ b/meta-services/recipes-services/config-scripts/files/services/can_config.service
@@ -0,0 +1,14 @@
+[Unit]
+Description=start CAN config-Service on system boot
+#Wants=network.target
+#Before=network.target
+
+[Service]
+Type=simple
+#RemainAfterExit=yes
+
+ExecStart=/bin/sh  /usr/bin/can_config.sh
+
+[Install]
+WantedBy=multi-user.target
+
diff --git a/meta-services/recipes-services/config-scripts/files/services/dbus_export.service b/meta-services/recipes-services/config-scripts/files/services/dbus_export.service
new file mode 100644
index 0000000..42d1880
--- /dev/null
+++ b/meta-services/recipes-services/config-scripts/files/services/dbus_export.service
@@ -0,0 +1,9 @@
+[Unit]
+Description=D-Bus export service
+
+[Service]
+Type=simple
+ExecStart=/usr/bin/dbus_export.sh
+
+[Install]
+WantedBy=multi-user.target
diff --git a/meta-services/recipes-services/evcharger-app/evcharger-app_0.1.bb b/meta-services/recipes-services/evcharger-app/evcharger-app_0.1.bb
new file mode 100644
index 0000000..3917552
--- /dev/null
+++ b/meta-services/recipes-services/evcharger-app/evcharger-app_0.1.bb
@@ -0,0 +1,36 @@
+SUMMARY = "Smart EV charger Application"
+SECTION = "services"
+
+LICENSE = "MIT"
+LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302"
+
+DEPENDS += " \
+    json-c \
+    openssl \
+    paho-mqtt-c \
+"
+
+SRC_URI = " \
+    file://src/smart_charger_app.c \
+    file://src/can.c \
+    file://inc/can.h \
+    file://inc/log.h \
+"
+
+S = "${WORKDIR}"
+
+TARGET_CC_ARCH += "${LDFLAGS}"
+
+#inherit cmake
+#EXTRA_OECMAKE = ""
+
+do_compile() {
+    ${CC} src/smart_charger_app.c src/can.c -o smart_charger_app ${CFLAGS} -lpaho-mqtt3a -lpthread
+}
+
+#INSANE_SKIP_${PN}-dev = "ldflags"
+
+do_install() {
+    install -d ${D}${bindir}
+    install -m 0755 smart_charger_app ${D}${bindir}
+}
diff --git a/meta-services/recipes-services/evcharger-app/files/CMakeLists.txt b/meta-services/recipes-services/evcharger-app/files/CMakeLists.txt
new file mode 100644
index 0000000..bb43a85
--- /dev/null
+++ b/meta-services/recipes-services/evcharger-app/files/CMakeLists.txt
@@ -0,0 +1,24 @@
+cmake_minimum_required(VERSION 3.5)
+project(evcharger-app)
+
+include_directories(
+        ${CMAKE_CURRENT_SOURCE_DIR}/inc}
+        )
+
+SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-unknown-pragmas -g -D_GNU_SOURCE \
+                   -D_USINGLIBC -lrt -Wall -lpthread -g -lpaho-mqtt3a" 
+   )
+
+set(JSON_LIBRARY "-ljson-c" )
+set(PAHO-MQTT-C_LIBRARY "-lpaho-mqtt3a" )
+
+add_executable (smart_charger_app 
+           ${CMAKE_CURRENT_SOURCE_DIR}/src/smart_charger_app.c
+           ${CMAKE_CURRENT_SOURCE_DIR}/src/can.c 
+           ${CMAKE_CURRENT_SOURCE_DIR}/inc/can.h 
+           ${CMAKE_CURRENT_SOURCE_DIR}/inc/log.h 
+       )
+
+target_link_libraries(evcharger-app PUBLIC
+                      ${PAHO-MQTT-C_LIBRARY}
+)                      
diff --git a/meta-services/recipes-services/evcharger-app/files/inc/can.h b/meta-services/recipes-services/evcharger-app/files/inc/can.h
new file mode 100755
index 0000000..727edd3
--- /dev/null
+++ b/meta-services/recipes-services/evcharger-app/files/inc/can.h
@@ -0,0 +1,39 @@
+#ifndef CAN_H
+#define CAN_H
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <string.h>
+#include <net/if.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <linux/can.h>
+#include <linux/can/raw.h>
+#include <sys/select.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include "log.h"
+
+enum can_error_states{
+	CAN_SUCCESS = 0,
+	CAN_TIMEOUT = -1,
+	CAN_CLOSE_TIMEOUT = -2,
+	CAN_OPEN_SOC_ERROR = -3,
+	CAN_OPEN_SOC_BIND_ERROR = -4,
+	CAN_SOC_SET_TIMEOUT_ERROR = -5,
+	CAN_CLOSE_ERROR = -6,
+	CAN_CLOSE_FD_ALREADY_CLOSED = -7,
+	CAN_WRITE_ERROR = -8,
+	CAN_READ_ERROR = -9,
+	CAN_UDS_WRITE_ERROR = -10,
+};
+
+int open_canbus_socket(const char *ifname);
+int write_canbus_frame(char fd, struct can_frame frame);
+int read_canbus_frame(char fd, struct can_frame *frame);
+int close_canbus_socket(char fd);
+
+#endif
diff --git a/meta-services/recipes-services/evcharger-app/files/inc/log.h b/meta-services/recipes-services/evcharger-app/files/inc/log.h
new file mode 100644
index 0000000..dacfc2a
--- /dev/null
+++ b/meta-services/recipes-services/evcharger-app/files/inc/log.h
@@ -0,0 +1,67 @@
+#ifndef LOG_H
+#define LOG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+
+#define LOG_EMERG	0
+#define LOG_ALERT	1
+#define LOG_CRIT	2
+#define LOG_ERR		3
+#define LOG_WARN	4
+#define LOG_NOTICE	5
+#define LOG_INFO	6
+#define LOG_DEBUG	7
+
+#define LOG_LEVEL	6
+
+#define STD_OUT stdout
+#define STD_ERR stderr
+
+#define log_msg(prio, stream, msg, ...) \
+    do {\
+        char *str;\
+        if ((prio == LOG_EMERG) && (LOG_LEVEL >= LOG_EMERG)) {\
+            str = "EMERG";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_ALERT) && (LOG_LEVEL >= LOG_ALERT)) {\
+            str = "ALERT";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_CRIT) && (LOG_LEVEL >= LOG_CRIT)) {\
+            str = "CRIT";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_ERR) && (LOG_LEVEL >= LOG_ERR)) {\
+            str = "ERR";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_WARN) && (LOG_LEVEL >= LOG_WARN)) {\
+            str = "WARN";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_NOTICE) && (LOG_LEVEL >= LOG_NOTICE)) {\
+            str = "NOTICE";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_INFO) && (LOG_LEVEL >= LOG_INFO)) {\
+            str = "INFO";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_DEBUG) && (LOG_LEVEL >= LOG_DEBUG)) {\
+            str = "DEBUG";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+    } while(0)
+
+//log_msg(LOG_ERR, STD_ERR, "\nError in opening %s", filename);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/meta-services/recipes-services/evcharger-app/files/src/can.c b/meta-services/recipes-services/evcharger-app/files/src/can.c
new file mode 100755
index 0000000..37f6ea5
--- /dev/null
+++ b/meta-services/recipes-services/evcharger-app/files/src/can.c
@@ -0,0 +1,117 @@
+#include "../inc/can.h"
+
+int open_canbus_socket(const char *ifname)
+{
+
+	uint8_t fd;
+	int ret;
+	struct timeval tv;
+	struct sockaddr_can addr;
+	struct ifreq ifr;
+	
+	if((fd = socket(PF_CAN, SOCK_RAW, CAN_RAW)) < 0)
+	{
+		log_msg(LOG_ERR, STD_ERR, "Fail to create CAN Socket");
+		ret = CAN_OPEN_SOC_ERROR;
+		return ret;
+	}
+	else
+	{
+		strcpy(ifr.ifr_name, ifname);
+		ioctl(fd, SIOCGIFINDEX, &ifr);
+		addr.can_family  = AF_CAN;
+		addr.can_ifindex = ifr.ifr_ifindex;
+		
+		log_msg(LOG_DEBUG, STD_OUT, "%s at index %d", ifname, ifr.ifr_ifindex);
+		
+		if(bind(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
+		{ 
+			log_msg(LOG_ERR, STD_ERR, "CAN socket Bind error");
+			ret = CAN_OPEN_SOC_BIND_ERROR;
+			return ret;
+		}
+		else
+		{
+			tv.tv_sec = 0;
+			//can-bus read time-out issue, decrease the can-bus set time-out
+			tv.tv_usec = 2000; 
+			//CAN_TIMEOUT_SET_FAIL = -22;
+			if (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0)
+			{
+			     log_msg(LOG_ERR, STD_ERR, "set socket options error");
+			     ret = CAN_SOC_SET_TIMEOUT_ERROR;
+			     return ret;
+			}
+		}
+	}
+	ret = fd;
+	log_msg(LOG_INFO, STD_OUT, "CAN socket initialization is success!");
+	return fd;
+}
+
+int close_canbus_socket(char fd)
+{
+	int ret;
+
+	if (fd > 0)
+	{
+	  if (close(fd) < 0)
+	  {
+	      log_msg(LOG_ERR, STD_ERR, "Fail to close socket fd = %d", fd);
+	      ret = CAN_CLOSE_ERROR;
+	  }
+	  else 
+	  {
+	      log_msg(LOG_INFO, STD_OUT, "Successfully closed CAN socket fd = %d", fd);
+	      ret = CAN_SUCCESS;
+	  }
+	}
+	else
+	{
+		log_msg(LOG_ERR, STD_OUT, "Invalid CAN socket fd %d", fd);
+		ret = CAN_CLOSE_FD_ALREADY_CLOSED;
+	}
+
+	return ret;
+}
+
+int write_canbus_frame(char fd, struct can_frame frame)
+{
+	int ret;
+	int nbytes = 0;
+	
+	//write the buffer
+	nbytes = write(fd, &frame, sizeof(struct can_frame));
+	if (nbytes < 1)
+	{
+		ret = CAN_WRITE_ERROR;
+		log_msg(LOG_ERR, STD_ERR, "Error in writing CAN-Frame, nbytes: %d", nbytes);
+	}
+	else 
+	{
+		log_msg(LOG_DEBUG, STD_OUT, "Written %d bytes on CAN-BUS", nbytes);
+		ret = CAN_SUCCESS;
+	}
+	
+	return ret;
+}
+
+int read_canbus_frame(char fd, struct can_frame *frame)
+{
+	int ret = 0;
+	int nbytes = 0;
+	
+	nbytes = read(fd, frame, sizeof(struct can_frame));
+	if(nbytes < 2)
+	{
+		log_msg(LOG_DEBUG, STD_OUT, "%s failed to read CAN frame", __func__);
+		ret = CAN_READ_ERROR;
+	}
+	else
+	{
+		log_msg(LOG_INFO, STD_OUT, "%d bytes read from the CAN-BUS", nbytes);
+		ret =  nbytes;
+	}
+	
+	return ret;
+}
diff --git a/meta-services/recipes-services/evcharger-app/files/src/smart_charger_app.c b/meta-services/recipes-services/evcharger-app/files/src/smart_charger_app.c
new file mode 100644
index 0000000..b53b48b
--- /dev/null
+++ b/meta-services/recipes-services/evcharger-app/files/src/smart_charger_app.c
@@ -0,0 +1,426 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include "MQTTAsync.h"
+
+#include <pthread.h>
+#include "../inc/can.h"
+
+#if !defined(_WIN32)
+#include <unistd.h>
+#else
+#include <windows.h>
+#endif
+
+#if defined(_WRS_KERNEL)
+#include <OsWrapper.h>
+#endif
+
+#define ADDRESS     	"tcp://mqtt.eclipseprojects.io:1883"
+//#define ADDRESS     	"tcp://broker.mqttdashboard.com:1883"
+#define CLIENTID    	"ev_charger"
+#define PUB_TOPIC       "device_to_cloud_resp"
+#define SUB_TOPIC       "cloud_to_device_cmd"
+#define PAYLOAD     	"Hello World!"
+#define QOS         	1
+#define TIMEOUT     	10000L
+
+#define CAN_ID          0x7E0
+#define CAN_DLC         8
+#define CAN_IFNAME      "can0"
+
+#define PORT_PA         "PA"
+#define PORT_PB         "PB"
+#define PORT_PC         "PC"
+
+#define ON              "ON"
+#define OFF             "OFF"
+
+struct can_frame tx_frame;
+struct can_frame rx_frame;
+
+uint8_t can_data[8] = {0x48, 0x45, 0x4C, 0x4C, 0x4F, 0x00, 0x00, 0x00};
+uint8_t can_data_PA_ON[8] = {0x10, 0x11, 0x31, 0x24, 0x00, 0x00, 0x00, 0x00};
+uint8_t can_data_PA_OFF[8] = {0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+uint8_t can_data_PB_ON[8] = {0x10, 0x12, 0x3E, 0x38, 0x00, 0x00, 0x00, 0x00};
+uint8_t can_data_PB_OFF[8] = {0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+uint8_t can_data_PC_ON[8] = {0x10, 0x13, 0x49, 0x2D, 0x00, 0x00, 0x00, 0x00};
+uint8_t can_data_PC_OFF[8] = {0x10, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+int disc_finished = 0;
+int subscribed = 0;
+int finished = 0;
+int fd_can;
+
+MQTTAsync mqtt_client;
+
+//Function  prototypes
+void onDisconnectFailure(void* context, MQTTAsync_failureData* response);
+void onDisconnect(void* context, MQTTAsync_successData* response);
+void onSendFailure(void* context, MQTTAsync_failureData* response);
+void onSend(void* context, MQTTAsync_successData* response);
+void connlost(void *context, char *cause);
+void onConnectFailure(void* context, MQTTAsync_failureData* response);
+void onSubscribe(void* context, MQTTAsync_successData* response);
+void onSubscribeFailure(void* context, MQTTAsync_failureData* response);
+void onConnect(void* context, MQTTAsync_successData* response);
+int messageArrived(void* context, char* topicName, int topicLen, MQTTAsync_message* m);
+int establish_mqtt_connection();
+void destroy_mqtt_connection();
+void* can_read(void* args);
+void prepare_can_frame(int can_id, uint8_t can_dlc, uint8_t data[CAN_MAX_DLEN], struct can_frame *frame);
+void show_can_frame(struct can_frame frame);
+
+/*MQTTAsync_disconnectOptions disconn_opts = MQTTAsync_disconnectOptions_initializer;
+MQTTAsync_responseOptions resp_opts = MQTTAsync_responseOptions_initializer;*/
+
+void onDisconnectFailure(void* context, MQTTAsync_failureData* response)
+{
+	log_msg(LOG_ERR, STD_ERR, "MQTT Disconnect failed");
+	finished = 1;
+}
+
+void onDisconnect(void* context, MQTTAsync_successData* response)
+{
+	log_msg(LOG_INFO, STD_OUT, "MQTT Successful disconnection\n");
+	finished = 1;
+}
+
+void onSendFailure(void* context, MQTTAsync_failureData* response)
+{
+	log_msg(LOG_ERR, STD_ERR, "Message send failed token %d error code %d", response->token, response->code);
+}
+
+void onSend(void* context, MQTTAsync_successData* response)
+{
+	log_msg(LOG_INFO, STD_OUT, "Message with token value %d delivery confirmed", response->token);
+}
+
+void connlost(void *context, char *cause)
+{
+	MQTTAsync client = (MQTTAsync)context;
+	MQTTAsync_connectOptions conn_opts = MQTTAsync_connectOptions_initializer;
+	int rc;
+
+	log_msg(LOG_ERR, STD_ERR, "MQTT Connection lost");
+	log_msg(LOG_ERR, STD_ERR, "Cause: %s", cause);
+
+	log_msg(LOG_INFO, STD_OUT, "Reconnecting\n");
+
+	conn_opts.keepAliveInterval = 20;
+	conn_opts.cleansession = 1;
+       
+       	conn_opts.onSuccess = onConnect;
+        conn_opts.onFailure = onConnectFailure;
+        conn_opts.context = client;
+
+	if ((rc = MQTTAsync_connect(client, &conn_opts)) != MQTTASYNC_SUCCESS)
+	{
+		log_msg(LOG_ERR, STD_ERR, "Failed to re-connect, return code %d", rc);
+ 		finished = 1;
+	}
+	log_msg(LOG_INFO, STD_OUT, "Reconnected successfully!");
+}
+
+void onConnectFailure(void* context, MQTTAsync_failureData* response)
+{
+	log_msg(LOG_ERR, STD_ERR, "Connect failed, rc %d", response ? response->code : 0);
+	finished = 1;
+}
+
+void onSubscribe(void* context, MQTTAsync_successData* response)
+{
+        log_msg(LOG_INFO, STD_OUT, "Subscribe succeeded");
+        subscribed = 1;
+}
+
+void onSubscribeFailure(void* context, MQTTAsync_failureData* response)
+{
+        log_msg(LOG_ERR, STD_ERR, "Subscribe failed, rc %d", response->code);
+        finished = 1;
+}
+
+void onConnect(void* context, MQTTAsync_successData* response)
+{
+	int rc;
+	MQTTAsync client = (MQTTAsync)context;
+	MQTTAsync_responseOptions opts = MQTTAsync_responseOptions_initializer;
+
+	log_msg(LOG_INFO, STD_OUT, "MQTT connection successful!");
+	
+	log_msg(LOG_INFO, STD_OUT, "Subscribing to topic %s\nfor client %s using QoS%d", SUB_TOPIC, CLIENTID, QOS);
+
+        opts.onSuccess = onSubscribe;
+        opts.onFailure = onSubscribeFailure;
+        opts.context = client;
+        
+	if ((rc = MQTTAsync_subscribe(client, SUB_TOPIC, QOS, &opts)) != MQTTASYNC_SUCCESS)
+        {
+                log_msg(LOG_ERR, STD_ERR, "Failed to start subscribe, return code %d", rc);
+                finished = 1;
+        }
+
+}
+
+char** str_split(char* a_str, const char a_delim)
+{
+	char** result    = 0;
+	size_t count     = 0;
+	char* tmp        = a_str;
+	char* last_comma = 0;
+	char delim[2];
+	delim[0] = a_delim;
+	delim[1] = 0;
+	
+	/* Count how many elements will be extracted. */
+	while (*tmp)
+	{
+	    if (a_delim == *tmp)
+	    {
+	        count++;
+	        last_comma = tmp;
+	    }
+	    tmp++;
+	}
+	
+	/* Add space for trailing token. */
+	count += last_comma < (a_str + strlen(a_str) - 1);
+	
+	/* Add space for terminating null string so caller
+	   knows where the list of returned strings ends. */
+	count++;
+	printf("count = %ld\n", count);
+	result = malloc(sizeof(char*) * count);
+	
+	if (result)
+	{
+	    size_t idx  = 0;
+	    char* token = strtok(a_str, delim);
+	
+	    while (token)
+	    {
+	        assert(idx < count);
+	        *(result + idx++) = strdup(token);
+	        token = strtok(0, delim);
+	    }
+	    assert(idx == count - 1);
+	    *(result + idx) = 0;
+	}
+	
+	return result;
+}
+
+int messageArrived(void* context, char* topicName, int topicLen, MQTTAsync_message* m)
+{
+	log_msg(LOG_INFO, STD_OUT, "Message arrived from Cloud");
+	log_msg(LOG_INFO, STD_OUT, "	topic: %s", topicName);
+	log_msg(LOG_INFO, STD_OUT, "	message: %.*s", m->payloadlen, (char*)m->payload);
+
+	char** tokens;
+
+	tokens = str_split((char*)m->payload, ' ');
+	int port_details = 0;
+	if(tokens)
+	{
+	    int i;
+	    for (i = 0; *(tokens + i); i++)
+	    {
+	        printf("[%s]\n", *(tokens + i));
+		port_details += 1;
+	        //free(*(tokens + i));
+	    }
+	    //printf("\n");
+	    //free(tokens);
+	}
+
+	if(port_details >=3)
+        {
+                if((strcmp(*(tokens + 0), PORT_PA) == 0) && (strcmp(*(tokens + 1), ON) == 0))
+                {
+                        prepare_can_frame(CAN_ID, CAN_DLC, can_data_PA_ON, &tx_frame);
+                        show_can_frame(tx_frame);
+                }
+                else if((strcmp(*(tokens + 0), PORT_PA) == 0) && (strcmp(*(tokens + 1), OFF) == 0))
+                {
+                        prepare_can_frame(CAN_ID, CAN_DLC, can_data_PA_OFF, &tx_frame);
+                        show_can_frame(tx_frame);
+                }
+                else if((strcmp(*(tokens + 0), PORT_PB) == 0) && (strcmp(*(tokens + 1), ON) == 0))
+                {
+                        prepare_can_frame(CAN_ID, CAN_DLC, can_data_PB_ON, &tx_frame);
+                        show_can_frame(tx_frame);
+                }
+                else if((strcmp(*(tokens + 0), PORT_PB) == 0) && (strcmp(*(tokens + 1), OFF) == 0))
+                {
+                        prepare_can_frame(CAN_ID, CAN_DLC, can_data_PB_OFF, &tx_frame);
+                        show_can_frame(tx_frame);
+                }
+                else if((strcmp(*(tokens + 0), PORT_PC) == 0) && (strcmp(*(tokens + 1), ON) == 0))
+                {
+                        prepare_can_frame(CAN_ID, CAN_DLC, can_data_PC_ON, &tx_frame);
+                        show_can_frame(tx_frame);
+                }
+                else if((strcmp(*(tokens + 0), PORT_PC) == 0) && (strcmp(*(tokens + 1), OFF) == 0))
+                {
+                        prepare_can_frame(CAN_ID, CAN_DLC, can_data_PC_OFF, &tx_frame);
+                        show_can_frame(tx_frame);
+                }
+                else
+                {
+                        log_msg(LOG_WARN, STD_OUT, "Invalid port number! Selecting port-A by default ON");
+                        prepare_can_frame(CAN_ID, CAN_DLC, can_data_PA_ON, &tx_frame);
+                        show_can_frame(tx_frame);
+                }
+        }
+        else
+        {
+                log_msg(LOG_WARN, STD_OUT, "\nExpected command from the cloud: <PA/PB/PC> <ON/OFF>.\n");
+                close(fd_can);
+        }
+
+	// Freeing the memory
+        if(tokens)
+        {
+            int i;
+            for (i = 0; *(tokens + i); i++)
+            {
+                free(*(tokens + i));
+            }
+            free(tokens);
+        }
+
+	write_canbus_frame(fd_can, tx_frame);
+
+	MQTTAsync_freeMessage(&m);
+	MQTTAsync_free(topicName);
+	return 1;
+}
+
+int establish_mqtt_connection()
+{
+	MQTTAsync_connectOptions conn_opts = MQTTAsync_connectOptions_initializer;
+
+	int rc;
+
+	if ((rc = MQTTAsync_create(&mqtt_client, ADDRESS, CLIENTID, MQTTCLIENT_PERSISTENCE_NONE, NULL)) != MQTTASYNC_SUCCESS)
+	{
+		log_msg(LOG_ERR, STD_ERR, "Failed to create client object, return code %d\n", rc);
+		return -1;
+	}
+
+	if ((rc = MQTTAsync_setCallbacks(mqtt_client, NULL, connlost, messageArrived, NULL)) != MQTTASYNC_SUCCESS)
+	{
+		log_msg(LOG_ERR, STD_ERR, "Failed to set callback, return code %d\n", rc);
+		return -1;
+	}
+	
+	conn_opts.keepAliveInterval = 20;
+	conn_opts.cleansession = 1;
+	conn_opts.onSuccess = onConnect;
+	conn_opts.onFailure = onConnectFailure;
+	conn_opts.context = mqtt_client;
+	if ((rc = MQTTAsync_connect(mqtt_client, &conn_opts)) != MQTTASYNC_SUCCESS)
+	{
+		log_msg(LOG_ERR, STD_ERR, "Failed to start connect, return code %d\n", rc);
+		return -1;
+	}
+	log_msg(LOG_INFO, STD_OUT, "MQTT connection established successfully!");
+	return rc;
+}
+
+void destroy_mqtt_connection(MQTTAsync clnt)
+{
+	MQTTAsync_destroy(&clnt);
+}
+
+void prepare_can_frame(int can_id, uint8_t can_dlc, uint8_t data[CAN_MAX_DLEN], struct can_frame *frame)
+{
+        frame->can_id = can_id;
+        frame->can_dlc = can_dlc;
+        memset((void *)frame->data, 0, CAN_MAX_DLEN);
+        memcpy((void *)frame->data, (const void *)data, CAN_MAX_DLEN);
+}
+
+void show_can_frame(struct can_frame frame)
+{
+        log_msg(LOG_INFO, STD_OUT, "CAN Frame is:");
+        printf("%s\t%X\t%X\t", CAN_IFNAME, frame.can_dlc, frame.can_id);
+        for(int i = 0; i < CAN_MAX_DLEN; i++)
+                printf("%X ", frame.data[i]);
+        printf("\n");
+}
+
+void* can_read(void* args)
+{
+	log_msg(LOG_INFO, STD_OUT, "Thread function called");
+	while(1)
+        {
+                if(read_canbus_frame(fd_can, &rx_frame) > 0)
+                {
+                        show_can_frame(rx_frame);
+                        //Prepare MQTT msg and publish to cloud
+			MQTTAsync_responseOptions resp_opts = MQTTAsync_responseOptions_initializer;
+			MQTTAsync_message pubmsg = MQTTAsync_message_initializer;
+			int rc;
+			char msg_to_cloud[200];
+			sprintf(msg_to_cloud, "%X:%d:%X %X %X %X %X %X %X %X", rx_frame.can_id, rx_frame.can_dlc, 
+					rx_frame.data[0], rx_frame.data[1], rx_frame.data[2], rx_frame.data[3], rx_frame.data[4], rx_frame.data[5], rx_frame.data[6], rx_frame.data[7]);
+			resp_opts.onSuccess = onSend;
+			resp_opts.onFailure = onSendFailure;
+			resp_opts.context = mqtt_client;
+			pubmsg.payload = msg_to_cloud;
+			pubmsg.payloadlen = (int)strlen(msg_to_cloud);
+			log_msg(LOG_INFO, STD_OUT, "pubmsg.payloadlen = %d", pubmsg.payloadlen);
+			pubmsg.qos = QOS;
+			pubmsg.retained = 0;
+			if ((rc = MQTTAsync_sendMessage(mqtt_client, PUB_TOPIC, &pubmsg, &resp_opts)) != MQTTASYNC_SUCCESS)
+			{
+			        log_msg(LOG_ERR, STD_ERR, "Failed to start sendMessage, return code %d\n", rc);
+			}
+                }
+                sleep(1);
+        }
+
+}
+
+int main(int argc, char* argv[])
+{
+	int ch;
+	pthread_t id;
+
+	// MQTT connection establishment
+	if(establish_mqtt_connection() < 0)
+	{
+		log_msg(LOG_ERR, STD_OUT, "Unable to establish mqtt connection, Exiting!!!");
+		exit(EXIT_FAILURE);
+	}
+	
+	// CAN Init
+        if((fd_can = open_canbus_socket(CAN_IFNAME)) < 0)
+        {
+                log_msg(LOG_ERR, STD_ERR, "open_canbus_socket Error. Exiting!!");
+		exit(EXIT_FAILURE);
+        }
+	
+	// Thread for CAN read
+	int ret = pthread_create(&id, NULL, &can_read, NULL);
+
+	if(ret == 0)
+	{
+		log_msg(LOG_INFO, STD_OUT, "Thread created successfully.");
+	}
+	else
+	{
+		log_msg(LOG_ERR, STD_ERR, "Thread not created.");
+		exit(EXIT_FAILURE);
+	}
+
+        do
+        {
+                ch = getchar();
+        } while (ch!='Q' && ch != 'q');
+
+ 	return 0;
+}
+  
diff --git a/meta-services/recipes-services/lcd-app/files/GaugingSystem.pro b/meta-services/recipes-services/lcd-app/files/GaugingSystem.pro
new file mode 100644
index 0000000..741dd95
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/GaugingSystem.pro
@@ -0,0 +1,33 @@
+#-------------------------------------------------
+#
+# Project created by QtCreator 2016-09-24T15:37:58
+#
+#-------------------------------------------------
+
+QT       += core gui sql xml
+
+greaterThan(QT_MAJOR_VERSION, 4): QT += widgets printsupport
+
+TARGET = GaugingSystem
+TEMPLATE = app
+#CONFIG += release
+#QTPLUGIN += qsqlmysql
+
+#LIBS += -L/usr/lib/plugins -lqsqlmysql
+
+SOURCES += main.cpp\
+        mainwindow.cpp \
+    mysqltablemodel.cpp \
+    componentdialog.cpp \
+    gaugedatabasemanager.cpp \
+    sqltabledelegate.cpp \
+    qcustomplot.cpp
+
+HEADERS  += mainwindow.h \
+    mysqltablemodel.h \
+    componentdialog.h \
+    gaugedatabasemanager.h \
+    sqltabledelegate.h \
+    include.h \
+    gaugedata.h \
+    qcustomplot.h
diff --git a/meta-services/recipes-services/lcd-app/files/GaugingSystem.pro.user b/meta-services/recipes-services/lcd-app/files/GaugingSystem.pro.user
new file mode 100644
index 0000000..4f5bc10
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/GaugingSystem.pro.user
@@ -0,0 +1,336 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE QtCreatorProject>
+<!-- Written by QtCreator 4.5.2, 2022-10-19T19:16:08. -->
+<qtcreator>
+ <data>
+  <variable>EnvironmentId</variable>
+  <value type="QByteArray">{c8df2f42-11a4-4c00-a45b-d38d7dab65ed}</value>
+ </data>
+ <data>
+  <variable>ProjectExplorer.Project.ActiveTarget</variable>
+  <value type="int">0</value>
+ </data>
+ <data>
+  <variable>ProjectExplorer.Project.EditorSettings</variable>
+  <valuemap type="QVariantMap">
+   <value type="bool" key="EditorConfiguration.AutoIndent">true</value>
+   <value type="bool" key="EditorConfiguration.AutoSpacesForTabs">false</value>
+   <value type="bool" key="EditorConfiguration.CamelCaseNavigation">true</value>
+   <valuemap type="QVariantMap" key="EditorConfiguration.CodeStyle.0">
+    <value type="QString" key="language">Cpp</value>
+    <valuemap type="QVariantMap" key="value">
+     <value type="QByteArray" key="CurrentPreferences">CppGlobal</value>
+    </valuemap>
+   </valuemap>
+   <valuemap type="QVariantMap" key="EditorConfiguration.CodeStyle.1">
+    <value type="QString" key="language">QmlJS</value>
+    <valuemap type="QVariantMap" key="value">
+     <value type="QByteArray" key="CurrentPreferences">QmlJSGlobal</value>
+    </valuemap>
+   </valuemap>
+   <value type="int" key="EditorConfiguration.CodeStyle.Count">2</value>
+   <value type="QByteArray" key="EditorConfiguration.Codec">UTF-8</value>
+   <value type="bool" key="EditorConfiguration.ConstrainTooltips">false</value>
+   <value type="int" key="EditorConfiguration.IndentSize">4</value>
+   <value type="bool" key="EditorConfiguration.KeyboardTooltips">false</value>
+   <value type="int" key="EditorConfiguration.MarginColumn">80</value>
+   <value type="bool" key="EditorConfiguration.MouseHiding">true</value>
+   <value type="bool" key="EditorConfiguration.MouseNavigation">true</value>
+   <value type="int" key="EditorConfiguration.PaddingMode">1</value>
+   <value type="bool" key="EditorConfiguration.ScrollWheelZooming">true</value>
+   <value type="bool" key="EditorConfiguration.ShowMargin">false</value>
+   <value type="int" key="EditorConfiguration.SmartBackspaceBehavior">0</value>
+   <value type="bool" key="EditorConfiguration.SmartSelectionChanging">true</value>
+   <value type="bool" key="EditorConfiguration.SpacesForTabs">true</value>
+   <value type="int" key="EditorConfiguration.TabKeyBehavior">0</value>
+   <value type="int" key="EditorConfiguration.TabSize">8</value>
+   <value type="bool" key="EditorConfiguration.UseGlobal">true</value>
+   <value type="int" key="EditorConfiguration.Utf8BomBehavior">1</value>
+   <value type="bool" key="EditorConfiguration.addFinalNewLine">true</value>
+   <value type="bool" key="EditorConfiguration.cleanIndentation">true</value>
+   <value type="bool" key="EditorConfiguration.cleanWhitespace">true</value>
+   <value type="bool" key="EditorConfiguration.inEntireDocument">false</value>
+  </valuemap>
+ </data>
+ <data>
+  <variable>ProjectExplorer.Project.PluginSettings</variable>
+  <valuemap type="QVariantMap"/>
+ </data>
+ <data>
+  <variable>ProjectExplorer.Project.Target.0</variable>
+  <valuemap type="QVariantMap">
+   <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Desktop</value>
+   <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName">Desktop</value>
+   <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">{24e58ccf-eea5-4774-9dba-076f61e6c4a5}</value>
+   <value type="int" key="ProjectExplorer.Target.ActiveBuildConfiguration">0</value>
+   <value type="int" key="ProjectExplorer.Target.ActiveDeployConfiguration">0</value>
+   <value type="int" key="ProjectExplorer.Target.ActiveRunConfiguration">0</value>
+   <valuemap type="QVariantMap" key="ProjectExplorer.Target.BuildConfiguration.0">
+    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory">/home/sai/projects/qt_pocs/build-GaugingSystem-Desktop-Debug</value>
+    <valuemap type="QVariantMap" key="ProjectExplorer.BuildConfiguration.BuildStepList.0">
+     <valuemap type="QVariantMap" key="ProjectExplorer.BuildStepList.Step.0">
+      <value type="bool" key="ProjectExplorer.BuildStep.Enabled">true</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">qmake</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">QtProjectManager.QMakeBuildStep</value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.LinkQmlDebuggingLibrary">true</value>
+      <value type="QString" key="QtProjectManager.QMakeBuildStep.QMakeArguments"></value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.QMakeForced">false</value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.SeparateDebugInfo">false</value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.UseQtQuickCompiler">false</value>
+     </valuemap>
+     <valuemap type="QVariantMap" key="ProjectExplorer.BuildStepList.Step.1">
+      <value type="bool" key="ProjectExplorer.BuildStep.Enabled">true</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Make</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.MakeStep</value>
+      <valuelist type="QVariantList" key="Qt4ProjectManager.MakeStep.AutomaticallyAddedMakeArguments">
+       <value type="QString">-w</value>
+       <value type="QString">-r</value>
+      </valuelist>
+      <value type="bool" key="Qt4ProjectManager.MakeStep.Clean">false</value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeArguments"></value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeCommand"></value>
+     </valuemap>
+     <value type="int" key="ProjectExplorer.BuildStepList.StepsCount">2</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Build</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">ProjectExplorer.BuildSteps.Build</value>
+    </valuemap>
+    <valuemap type="QVariantMap" key="ProjectExplorer.BuildConfiguration.BuildStepList.1">
+     <valuemap type="QVariantMap" key="ProjectExplorer.BuildStepList.Step.0">
+      <value type="bool" key="ProjectExplorer.BuildStep.Enabled">true</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Make</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.MakeStep</value>
+      <valuelist type="QVariantList" key="Qt4ProjectManager.MakeStep.AutomaticallyAddedMakeArguments">
+       <value type="QString">-w</value>
+       <value type="QString">-r</value>
+      </valuelist>
+      <value type="bool" key="Qt4ProjectManager.MakeStep.Clean">true</value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeArguments">clean</value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeCommand"></value>
+     </valuemap>
+     <value type="int" key="ProjectExplorer.BuildStepList.StepsCount">1</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Clean</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">ProjectExplorer.BuildSteps.Clean</value>
+    </valuemap>
+    <value type="int" key="ProjectExplorer.BuildConfiguration.BuildStepListCount">2</value>
+    <value type="bool" key="ProjectExplorer.BuildConfiguration.ClearSystemEnvironment">false</value>
+    <valuelist type="QVariantList" key="ProjectExplorer.BuildConfiguration.UserEnvironmentChanges"/>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Debug</value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.Qt4BuildConfiguration</value>
+    <value type="int" key="Qt4ProjectManager.Qt4BuildConfiguration.BuildConfiguration">2</value>
+    <value type="bool" key="Qt4ProjectManager.Qt4BuildConfiguration.UseShadowBuild">true</value>
+   </valuemap>
+   <valuemap type="QVariantMap" key="ProjectExplorer.Target.BuildConfiguration.1">
+    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory">/home/sai/projects/qt_pocs/build-GaugingSystem-Desktop-Release</value>
+    <valuemap type="QVariantMap" key="ProjectExplorer.BuildConfiguration.BuildStepList.0">
+     <valuemap type="QVariantMap" key="ProjectExplorer.BuildStepList.Step.0">
+      <value type="bool" key="ProjectExplorer.BuildStep.Enabled">true</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">qmake</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">QtProjectManager.QMakeBuildStep</value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.LinkQmlDebuggingLibrary">false</value>
+      <value type="QString" key="QtProjectManager.QMakeBuildStep.QMakeArguments"></value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.QMakeForced">false</value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.SeparateDebugInfo">false</value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.UseQtQuickCompiler">false</value>
+     </valuemap>
+     <valuemap type="QVariantMap" key="ProjectExplorer.BuildStepList.Step.1">
+      <value type="bool" key="ProjectExplorer.BuildStep.Enabled">true</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Make</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.MakeStep</value>
+      <valuelist type="QVariantList" key="Qt4ProjectManager.MakeStep.AutomaticallyAddedMakeArguments">
+       <value type="QString">-w</value>
+       <value type="QString">-r</value>
+      </valuelist>
+      <value type="bool" key="Qt4ProjectManager.MakeStep.Clean">false</value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeArguments"></value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeCommand"></value>
+     </valuemap>
+     <value type="int" key="ProjectExplorer.BuildStepList.StepsCount">2</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Build</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">ProjectExplorer.BuildSteps.Build</value>
+    </valuemap>
+    <valuemap type="QVariantMap" key="ProjectExplorer.BuildConfiguration.BuildStepList.1">
+     <valuemap type="QVariantMap" key="ProjectExplorer.BuildStepList.Step.0">
+      <value type="bool" key="ProjectExplorer.BuildStep.Enabled">true</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Make</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.MakeStep</value>
+      <valuelist type="QVariantList" key="Qt4ProjectManager.MakeStep.AutomaticallyAddedMakeArguments">
+       <value type="QString">-w</value>
+       <value type="QString">-r</value>
+      </valuelist>
+      <value type="bool" key="Qt4ProjectManager.MakeStep.Clean">true</value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeArguments">clean</value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeCommand"></value>
+     </valuemap>
+     <value type="int" key="ProjectExplorer.BuildStepList.StepsCount">1</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Clean</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">ProjectExplorer.BuildSteps.Clean</value>
+    </valuemap>
+    <value type="int" key="ProjectExplorer.BuildConfiguration.BuildStepListCount">2</value>
+    <value type="bool" key="ProjectExplorer.BuildConfiguration.ClearSystemEnvironment">false</value>
+    <valuelist type="QVariantList" key="ProjectExplorer.BuildConfiguration.UserEnvironmentChanges"/>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Release</value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.Qt4BuildConfiguration</value>
+    <value type="int" key="Qt4ProjectManager.Qt4BuildConfiguration.BuildConfiguration">0</value>
+    <value type="bool" key="Qt4ProjectManager.Qt4BuildConfiguration.UseShadowBuild">true</value>
+   </valuemap>
+   <valuemap type="QVariantMap" key="ProjectExplorer.Target.BuildConfiguration.2">
+    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory">/home/sai/projects/qt_pocs/build-GaugingSystem-Desktop-Profile</value>
+    <valuemap type="QVariantMap" key="ProjectExplorer.BuildConfiguration.BuildStepList.0">
+     <valuemap type="QVariantMap" key="ProjectExplorer.BuildStepList.Step.0">
+      <value type="bool" key="ProjectExplorer.BuildStep.Enabled">true</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">qmake</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">QtProjectManager.QMakeBuildStep</value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.LinkQmlDebuggingLibrary">true</value>
+      <value type="QString" key="QtProjectManager.QMakeBuildStep.QMakeArguments"></value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.QMakeForced">false</value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.SeparateDebugInfo">true</value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.UseQtQuickCompiler">false</value>
+     </valuemap>
+     <valuemap type="QVariantMap" key="ProjectExplorer.BuildStepList.Step.1">
+      <value type="bool" key="ProjectExplorer.BuildStep.Enabled">true</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Make</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.MakeStep</value>
+      <valuelist type="QVariantList" key="Qt4ProjectManager.MakeStep.AutomaticallyAddedMakeArguments">
+       <value type="QString">-w</value>
+       <value type="QString">-r</value>
+      </valuelist>
+      <value type="bool" key="Qt4ProjectManager.MakeStep.Clean">false</value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeArguments"></value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeCommand"></value>
+     </valuemap>
+     <value type="int" key="ProjectExplorer.BuildStepList.StepsCount">2</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Build</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">ProjectExplorer.BuildSteps.Build</value>
+    </valuemap>
+    <valuemap type="QVariantMap" key="ProjectExplorer.BuildConfiguration.BuildStepList.1">
+     <valuemap type="QVariantMap" key="ProjectExplorer.BuildStepList.Step.0">
+      <value type="bool" key="ProjectExplorer.BuildStep.Enabled">true</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Make</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.MakeStep</value>
+      <valuelist type="QVariantList" key="Qt4ProjectManager.MakeStep.AutomaticallyAddedMakeArguments">
+       <value type="QString">-w</value>
+       <value type="QString">-r</value>
+      </valuelist>
+      <value type="bool" key="Qt4ProjectManager.MakeStep.Clean">true</value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeArguments">clean</value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeCommand"></value>
+     </valuemap>
+     <value type="int" key="ProjectExplorer.BuildStepList.StepsCount">1</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Clean</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">ProjectExplorer.BuildSteps.Clean</value>
+    </valuemap>
+    <value type="int" key="ProjectExplorer.BuildConfiguration.BuildStepListCount">2</value>
+    <value type="bool" key="ProjectExplorer.BuildConfiguration.ClearSystemEnvironment">false</value>
+    <valuelist type="QVariantList" key="ProjectExplorer.BuildConfiguration.UserEnvironmentChanges"/>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Profile</value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.Qt4BuildConfiguration</value>
+    <value type="int" key="Qt4ProjectManager.Qt4BuildConfiguration.BuildConfiguration">0</value>
+    <value type="bool" key="Qt4ProjectManager.Qt4BuildConfiguration.UseShadowBuild">true</value>
+   </valuemap>
+   <value type="int" key="ProjectExplorer.Target.BuildConfigurationCount">3</value>
+   <valuemap type="QVariantMap" key="ProjectExplorer.Target.DeployConfiguration.0">
+    <valuemap type="QVariantMap" key="ProjectExplorer.BuildConfiguration.BuildStepList.0">
+     <value type="int" key="ProjectExplorer.BuildStepList.StepsCount">0</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Deploy</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">ProjectExplorer.BuildSteps.Deploy</value>
+    </valuemap>
+    <value type="int" key="ProjectExplorer.BuildConfiguration.BuildStepListCount">1</value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Deploy locally</value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">ProjectExplorer.DefaultDeployConfiguration</value>
+   </valuemap>
+   <value type="int" key="ProjectExplorer.Target.DeployConfigurationCount">1</value>
+   <valuemap type="QVariantMap" key="ProjectExplorer.Target.PluginSettings"/>
+   <valuemap type="QVariantMap" key="ProjectExplorer.Target.RunConfiguration.0">
+    <value type="bool" key="Analyzer.QmlProfiler.AggregateTraces">false</value>
+    <value type="bool" key="Analyzer.QmlProfiler.FlushEnabled">false</value>
+    <value type="uint" key="Analyzer.QmlProfiler.FlushInterval">1000</value>
+    <value type="QString" key="Analyzer.QmlProfiler.LastTraceFile"></value>
+    <value type="bool" key="Analyzer.QmlProfiler.Settings.UseGlobalSettings">true</value>
+    <valuelist type="QVariantList" key="Analyzer.Valgrind.AddedSuppressionFiles"/>
+    <value type="bool" key="Analyzer.Valgrind.Callgrind.CollectBusEvents">false</value>
+    <value type="bool" key="Analyzer.Valgrind.Callgrind.CollectSystime">false</value>
+    <value type="bool" key="Analyzer.Valgrind.Callgrind.EnableBranchSim">false</value>
+    <value type="bool" key="Analyzer.Valgrind.Callgrind.EnableCacheSim">false</value>
+    <value type="bool" key="Analyzer.Valgrind.Callgrind.EnableEventToolTips">true</value>
+    <value type="double" key="Analyzer.Valgrind.Callgrind.MinimumCostRatio">0.01</value>
+    <value type="double" key="Analyzer.Valgrind.Callgrind.VisualisationMinimumCostRatio">10</value>
+    <value type="bool" key="Analyzer.Valgrind.FilterExternalIssues">true</value>
+    <value type="int" key="Analyzer.Valgrind.LeakCheckOnFinish">1</value>
+    <value type="int" key="Analyzer.Valgrind.NumCallers">25</value>
+    <valuelist type="QVariantList" key="Analyzer.Valgrind.RemovedSuppressionFiles"/>
+    <value type="int" key="Analyzer.Valgrind.SelfModifyingCodeDetection">1</value>
+    <value type="bool" key="Analyzer.Valgrind.Settings.UseGlobalSettings">true</value>
+    <value type="bool" key="Analyzer.Valgrind.ShowReachable">false</value>
+    <value type="bool" key="Analyzer.Valgrind.TrackOrigins">true</value>
+    <value type="QString" key="Analyzer.Valgrind.ValgrindExecutable">valgrind</value>
+    <valuelist type="QVariantList" key="Analyzer.Valgrind.VisibleErrorKinds">
+     <value type="int">0</value>
+     <value type="int">1</value>
+     <value type="int">2</value>
+     <value type="int">3</value>
+     <value type="int">4</value>
+     <value type="int">5</value>
+     <value type="int">6</value>
+     <value type="int">7</value>
+     <value type="int">8</value>
+     <value type="int">9</value>
+     <value type="int">10</value>
+     <value type="int">11</value>
+     <value type="int">12</value>
+     <value type="int">13</value>
+     <value type="int">14</value>
+    </valuelist>
+    <value type="int" key="PE.EnvironmentAspect.Base">2</value>
+    <valuelist type="QVariantList" key="PE.EnvironmentAspect.Changes"/>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">GaugingSystem</value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.Qt4RunConfiguration:/home/sai/projects/qt_pocs/GaugingSystem/GaugingSystem.pro</value>
+    <value type="bool" key="QmakeProjectManager.QmakeRunConfiguration.UseLibrarySearchPath">true</value>
+    <value type="QString" key="Qt4ProjectManager.Qt4RunConfiguration.CommandLineArguments"></value>
+    <value type="QString" key="Qt4ProjectManager.Qt4RunConfiguration.ProFile">GaugingSystem.pro</value>
+    <value type="bool" key="Qt4ProjectManager.Qt4RunConfiguration.UseDyldImageSuffix">false</value>
+    <value type="QString" key="Qt4ProjectManager.Qt4RunConfiguration.UserWorkingDirectory"></value>
+    <value type="QString" key="Qt4ProjectManager.Qt4RunConfiguration.UserWorkingDirectory.default">/home/sai/projects/qt_pocs/build-GaugingSystem-Desktop-Debug</value>
+    <value type="uint" key="RunConfiguration.QmlDebugServerPort">3768</value>
+    <value type="bool" key="RunConfiguration.UseCppDebugger">false</value>
+    <value type="bool" key="RunConfiguration.UseCppDebuggerAuto">true</value>
+    <value type="bool" key="RunConfiguration.UseMultiProcess">false</value>
+    <value type="bool" key="RunConfiguration.UseQmlDebugger">false</value>
+    <value type="bool" key="RunConfiguration.UseQmlDebuggerAuto">true</value>
+   </valuemap>
+   <value type="int" key="ProjectExplorer.Target.RunConfigurationCount">1</value>
+  </valuemap>
+ </data>
+ <data>
+  <variable>ProjectExplorer.Project.TargetCount</variable>
+  <value type="int">1</value>
+ </data>
+ <data>
+  <variable>ProjectExplorer.Project.Updater.FileVersion</variable>
+  <value type="int">18</value>
+ </data>
+ <data>
+  <variable>Version</variable>
+  <value type="int">18</value>
+ </data>
+</qtcreator>
diff --git a/meta-services/recipes-services/lcd-app/files/GaugingSystem.pro.user.1b9615d b/meta-services/recipes-services/lcd-app/files/GaugingSystem.pro.user.1b9615d
new file mode 100644
index 0000000..1c56a08
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/GaugingSystem.pro.user.1b9615d
@@ -0,0 +1,271 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE QtCreatorProject>
+<!-- Written by QtCreator 3.4.1, 2018-02-12T14:16:00. -->
+<qtcreator>
+ <data>
+  <variable>EnvironmentId</variable>
+  <value type="QByteArray">{1b9615de-4527-4bad-8632-3040b80e9835}</value>
+ </data>
+ <data>
+  <variable>ProjectExplorer.Project.ActiveTarget</variable>
+  <value type="int">0</value>
+ </data>
+ <data>
+  <variable>ProjectExplorer.Project.EditorSettings</variable>
+  <valuemap type="QVariantMap">
+   <value type="bool" key="EditorConfiguration.AutoIndent">true</value>
+   <value type="bool" key="EditorConfiguration.AutoSpacesForTabs">false</value>
+   <value type="bool" key="EditorConfiguration.CamelCaseNavigation">true</value>
+   <valuemap type="QVariantMap" key="EditorConfiguration.CodeStyle.0">
+    <value type="QString" key="language">Cpp</value>
+    <valuemap type="QVariantMap" key="value">
+     <value type="QByteArray" key="CurrentPreferences">CppGlobal</value>
+    </valuemap>
+   </valuemap>
+   <valuemap type="QVariantMap" key="EditorConfiguration.CodeStyle.1">
+    <value type="QString" key="language">QmlJS</value>
+    <valuemap type="QVariantMap" key="value">
+     <value type="QByteArray" key="CurrentPreferences">QmlJSGlobal</value>
+    </valuemap>
+   </valuemap>
+   <value type="int" key="EditorConfiguration.CodeStyle.Count">2</value>
+   <value type="QByteArray" key="EditorConfiguration.Codec">UTF-8</value>
+   <value type="bool" key="EditorConfiguration.ConstrainTooltips">false</value>
+   <value type="int" key="EditorConfiguration.IndentSize">4</value>
+   <value type="bool" key="EditorConfiguration.KeyboardTooltips">false</value>
+   <value type="int" key="EditorConfiguration.MarginColumn">80</value>
+   <value type="bool" key="EditorConfiguration.MouseHiding">true</value>
+   <value type="bool" key="EditorConfiguration.MouseNavigation">true</value>
+   <value type="int" key="EditorConfiguration.PaddingMode">1</value>
+   <value type="bool" key="EditorConfiguration.ScrollWheelZooming">true</value>
+   <value type="bool" key="EditorConfiguration.ShowMargin">false</value>
+   <value type="int" key="EditorConfiguration.SmartBackspaceBehavior">0</value>
+   <value type="bool" key="EditorConfiguration.SpacesForTabs">true</value>
+   <value type="int" key="EditorConfiguration.TabKeyBehavior">0</value>
+   <value type="int" key="EditorConfiguration.TabSize">8</value>
+   <value type="bool" key="EditorConfiguration.UseGlobal">true</value>
+   <value type="int" key="EditorConfiguration.Utf8BomBehavior">1</value>
+   <value type="bool" key="EditorConfiguration.addFinalNewLine">true</value>
+   <value type="bool" key="EditorConfiguration.cleanIndentation">true</value>
+   <value type="bool" key="EditorConfiguration.cleanWhitespace">true</value>
+   <value type="bool" key="EditorConfiguration.inEntireDocument">false</value>
+  </valuemap>
+ </data>
+ <data>
+  <variable>ProjectExplorer.Project.PluginSettings</variable>
+  <valuemap type="QVariantMap"/>
+ </data>
+ <data>
+  <variable>ProjectExplorer.Project.Target.0</variable>
+  <valuemap type="QVariantMap">
+   <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Qt5.6.2</value>
+   <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName">Qt5.6.2</value>
+   <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">{ce78b7ca-9f3f-4cf1-830d-61c876bd7ed1}</value>
+   <value type="int" key="ProjectExplorer.Target.ActiveBuildConfiguration">0</value>
+   <value type="int" key="ProjectExplorer.Target.ActiveDeployConfiguration">0</value>
+   <value type="int" key="ProjectExplorer.Target.ActiveRunConfiguration">0</value>
+   <valuemap type="QVariantMap" key="ProjectExplorer.Target.BuildConfiguration.0">
+    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory">/home/bha/phytec/customer_projects/TVS/GaugingSystem/Gauge5Nov/GaugingSystemwithQt5.3/GaugingSystem_mira/build-GaugingSystem-Qt5_6_2-Debug</value>
+    <valuemap type="QVariantMap" key="ProjectExplorer.BuildConfiguration.BuildStepList.0">
+     <valuemap type="QVariantMap" key="ProjectExplorer.BuildStepList.Step.0">
+      <value type="bool" key="ProjectExplorer.BuildStep.Enabled">true</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">qmake</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">QtProjectManager.QMakeBuildStep</value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.LinkQmlDebuggingLibrary">false</value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.LinkQmlDebuggingLibraryAuto">true</value>
+      <value type="QString" key="QtProjectManager.QMakeBuildStep.QMakeArguments"></value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.QMakeForced">false</value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.SeparateDebugInfo">false</value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.UseQtQuickCompiler">false</value>
+     </valuemap>
+     <valuemap type="QVariantMap" key="ProjectExplorer.BuildStepList.Step.1">
+      <value type="bool" key="ProjectExplorer.BuildStep.Enabled">true</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Make</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.MakeStep</value>
+      <valuelist type="QVariantList" key="Qt4ProjectManager.MakeStep.AutomaticallyAddedMakeArguments">
+       <value type="QString">-w</value>
+       <value type="QString">-r</value>
+      </valuelist>
+      <value type="bool" key="Qt4ProjectManager.MakeStep.Clean">false</value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeArguments"></value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeCommand"></value>
+     </valuemap>
+     <value type="int" key="ProjectExplorer.BuildStepList.StepsCount">2</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Build</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">ProjectExplorer.BuildSteps.Build</value>
+    </valuemap>
+    <valuemap type="QVariantMap" key="ProjectExplorer.BuildConfiguration.BuildStepList.1">
+     <valuemap type="QVariantMap" key="ProjectExplorer.BuildStepList.Step.0">
+      <value type="bool" key="ProjectExplorer.BuildStep.Enabled">true</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Make</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.MakeStep</value>
+      <valuelist type="QVariantList" key="Qt4ProjectManager.MakeStep.AutomaticallyAddedMakeArguments">
+       <value type="QString">-w</value>
+       <value type="QString">-r</value>
+      </valuelist>
+      <value type="bool" key="Qt4ProjectManager.MakeStep.Clean">true</value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeArguments">clean</value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeCommand"></value>
+     </valuemap>
+     <value type="int" key="ProjectExplorer.BuildStepList.StepsCount">1</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Clean</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">ProjectExplorer.BuildSteps.Clean</value>
+    </valuemap>
+    <value type="int" key="ProjectExplorer.BuildConfiguration.BuildStepListCount">2</value>
+    <value type="bool" key="ProjectExplorer.BuildConfiguration.ClearSystemEnvironment">false</value>
+    <valuelist type="QVariantList" key="ProjectExplorer.BuildConfiguration.UserEnvironmentChanges"/>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Debug</value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.Qt4BuildConfiguration</value>
+    <value type="int" key="Qt4ProjectManager.Qt4BuildConfiguration.BuildConfiguration">2</value>
+    <value type="bool" key="Qt4ProjectManager.Qt4BuildConfiguration.UseShadowBuild">true</value>
+   </valuemap>
+   <valuemap type="QVariantMap" key="ProjectExplorer.Target.BuildConfiguration.1">
+    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory">/home/bha/phytec/customer_projects/TVS/GaugingSystem/Gauge5Nov/GaugingSystemwithQt5.3/GaugingSystem_mira/build-GaugingSystem-Qt5_6_2-Release</value>
+    <valuemap type="QVariantMap" key="ProjectExplorer.BuildConfiguration.BuildStepList.0">
+     <valuemap type="QVariantMap" key="ProjectExplorer.BuildStepList.Step.0">
+      <value type="bool" key="ProjectExplorer.BuildStep.Enabled">true</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">qmake</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">QtProjectManager.QMakeBuildStep</value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.LinkQmlDebuggingLibrary">false</value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.LinkQmlDebuggingLibraryAuto">true</value>
+      <value type="QString" key="QtProjectManager.QMakeBuildStep.QMakeArguments"></value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.QMakeForced">false</value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.SeparateDebugInfo">false</value>
+      <value type="bool" key="QtProjectManager.QMakeBuildStep.UseQtQuickCompiler">false</value>
+     </valuemap>
+     <valuemap type="QVariantMap" key="ProjectExplorer.BuildStepList.Step.1">
+      <value type="bool" key="ProjectExplorer.BuildStep.Enabled">true</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Make</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.MakeStep</value>
+      <valuelist type="QVariantList" key="Qt4ProjectManager.MakeStep.AutomaticallyAddedMakeArguments">
+       <value type="QString">-w</value>
+       <value type="QString">-r</value>
+      </valuelist>
+      <value type="bool" key="Qt4ProjectManager.MakeStep.Clean">false</value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeArguments"></value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeCommand"></value>
+     </valuemap>
+     <value type="int" key="ProjectExplorer.BuildStepList.StepsCount">2</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Build</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">ProjectExplorer.BuildSteps.Build</value>
+    </valuemap>
+    <valuemap type="QVariantMap" key="ProjectExplorer.BuildConfiguration.BuildStepList.1">
+     <valuemap type="QVariantMap" key="ProjectExplorer.BuildStepList.Step.0">
+      <value type="bool" key="ProjectExplorer.BuildStep.Enabled">true</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Make</value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+      <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.MakeStep</value>
+      <valuelist type="QVariantList" key="Qt4ProjectManager.MakeStep.AutomaticallyAddedMakeArguments">
+       <value type="QString">-w</value>
+       <value type="QString">-r</value>
+      </valuelist>
+      <value type="bool" key="Qt4ProjectManager.MakeStep.Clean">true</value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeArguments">clean</value>
+      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeCommand"></value>
+     </valuemap>
+     <value type="int" key="ProjectExplorer.BuildStepList.StepsCount">1</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Clean</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">ProjectExplorer.BuildSteps.Clean</value>
+    </valuemap>
+    <value type="int" key="ProjectExplorer.BuildConfiguration.BuildStepListCount">2</value>
+    <value type="bool" key="ProjectExplorer.BuildConfiguration.ClearSystemEnvironment">false</value>
+    <valuelist type="QVariantList" key="ProjectExplorer.BuildConfiguration.UserEnvironmentChanges"/>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Release</value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.Qt4BuildConfiguration</value>
+    <value type="int" key="Qt4ProjectManager.Qt4BuildConfiguration.BuildConfiguration">0</value>
+    <value type="bool" key="Qt4ProjectManager.Qt4BuildConfiguration.UseShadowBuild">true</value>
+   </valuemap>
+   <value type="int" key="ProjectExplorer.Target.BuildConfigurationCount">2</value>
+   <valuemap type="QVariantMap" key="ProjectExplorer.Target.DeployConfiguration.0">
+    <valuemap type="QVariantMap" key="ProjectExplorer.BuildConfiguration.BuildStepList.0">
+     <value type="int" key="ProjectExplorer.BuildStepList.StepsCount">0</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Deploy</value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+     <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">ProjectExplorer.BuildSteps.Deploy</value>
+    </valuemap>
+    <value type="int" key="ProjectExplorer.BuildConfiguration.BuildStepListCount">1</value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Deploy locally</value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">ProjectExplorer.DefaultDeployConfiguration</value>
+   </valuemap>
+   <value type="int" key="ProjectExplorer.Target.DeployConfigurationCount">1</value>
+   <valuemap type="QVariantMap" key="ProjectExplorer.Target.PluginSettings"/>
+   <valuemap type="QVariantMap" key="ProjectExplorer.Target.RunConfiguration.0">
+    <valuelist type="QVariantList" key="Analyzer.Valgrind.AddedSuppressionFiles"/>
+    <value type="bool" key="Analyzer.Valgrind.Callgrind.CollectBusEvents">false</value>
+    <value type="bool" key="Analyzer.Valgrind.Callgrind.CollectSystime">false</value>
+    <value type="bool" key="Analyzer.Valgrind.Callgrind.EnableBranchSim">false</value>
+    <value type="bool" key="Analyzer.Valgrind.Callgrind.EnableCacheSim">false</value>
+    <value type="bool" key="Analyzer.Valgrind.Callgrind.EnableEventToolTips">true</value>
+    <value type="double" key="Analyzer.Valgrind.Callgrind.MinimumCostRatio">0.01</value>
+    <value type="double" key="Analyzer.Valgrind.Callgrind.VisualisationMinimumCostRatio">10</value>
+    <value type="bool" key="Analyzer.Valgrind.FilterExternalIssues">true</value>
+    <value type="int" key="Analyzer.Valgrind.LeakCheckOnFinish">1</value>
+    <value type="int" key="Analyzer.Valgrind.NumCallers">25</value>
+    <valuelist type="QVariantList" key="Analyzer.Valgrind.RemovedSuppressionFiles"/>
+    <value type="int" key="Analyzer.Valgrind.SelfModifyingCodeDetection">1</value>
+    <value type="bool" key="Analyzer.Valgrind.Settings.UseGlobalSettings">true</value>
+    <value type="bool" key="Analyzer.Valgrind.ShowReachable">false</value>
+    <value type="bool" key="Analyzer.Valgrind.TrackOrigins">true</value>
+    <value type="QString" key="Analyzer.Valgrind.ValgrindExecutable">valgrind</value>
+    <valuelist type="QVariantList" key="Analyzer.Valgrind.VisibleErrorKinds">
+     <value type="int">0</value>
+     <value type="int">1</value>
+     <value type="int">2</value>
+     <value type="int">3</value>
+     <value type="int">4</value>
+     <value type="int">5</value>
+     <value type="int">6</value>
+     <value type="int">7</value>
+     <value type="int">8</value>
+     <value type="int">9</value>
+     <value type="int">10</value>
+     <value type="int">11</value>
+     <value type="int">12</value>
+     <value type="int">13</value>
+     <value type="int">14</value>
+    </valuelist>
+    <value type="int" key="PE.EnvironmentAspect.Base">2</value>
+    <valuelist type="QVariantList" key="PE.EnvironmentAspect.Changes"/>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">GaugingSystem</value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
+    <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.Qt4RunConfiguration:/home/bha/phytec/customer_projects/TVS/GaugingSystem/Gauge5Nov/GaugingSystemwithQt5.3/GaugingSystem_mira/GaugingSystem/GaugingSystem.pro</value>
+    <value type="QString" key="Qt4ProjectManager.Qt4RunConfiguration.CommandLineArguments"></value>
+    <value type="QString" key="Qt4ProjectManager.Qt4RunConfiguration.ProFile">GaugingSystem.pro</value>
+    <value type="bool" key="Qt4ProjectManager.Qt4RunConfiguration.UseDyldImageSuffix">false</value>
+    <value type="bool" key="Qt4ProjectManager.Qt4RunConfiguration.UseTerminal">false</value>
+    <value type="QString" key="Qt4ProjectManager.Qt4RunConfiguration.UserWorkingDirectory"></value>
+    <value type="uint" key="RunConfiguration.QmlDebugServerPort">3768</value>
+    <value type="bool" key="RunConfiguration.UseCppDebugger">false</value>
+    <value type="bool" key="RunConfiguration.UseCppDebuggerAuto">true</value>
+    <value type="bool" key="RunConfiguration.UseMultiProcess">false</value>
+    <value type="bool" key="RunConfiguration.UseQmlDebugger">false</value>
+    <value type="bool" key="RunConfiguration.UseQmlDebuggerAuto">true</value>
+   </valuemap>
+   <value type="int" key="ProjectExplorer.Target.RunConfigurationCount">1</value>
+  </valuemap>
+ </data>
+ <data>
+  <variable>ProjectExplorer.Project.TargetCount</variable>
+  <value type="int">1</value>
+ </data>
+ <data>
+  <variable>ProjectExplorer.Project.Updater.FileVersion</variable>
+  <value type="int">18</value>
+ </data>
+ <data>
+  <variable>Version</variable>
+  <value type="int">18</value>
+ </data>
+</qtcreator>
diff --git a/meta-services/recipes-services/lcd-app/files/componentdialog.cpp b/meta-services/recipes-services/lcd-app/files/componentdialog.cpp
new file mode 100644
index 0000000..0741083
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/componentdialog.cpp
@@ -0,0 +1,106 @@
+#include "componentdialog.h"
+#include<QDebug>
+#include<QEvent>
+#include<QKeyEvent>
+
+/**
+ * @brief ComponentDialog::ComponentDialog This constructor initializes the UI for the pop up\n
+ * Component scanning window. It is called when ever START is pressed to scan the new component.
+ * @param parent MainWindow.
+ */
+ComponentDialog::ComponentDialog(QWidget *parent)
+    : QWidget(parent)
+{
+
+    m_ComponentText = "";
+
+    QVBoxLayout *vMainLayout = new QVBoxLayout();
+    vMainLayout->setContentsMargins(10,0,0,10);
+    vMainLayout->setSpacing(0);
+
+    QLabel *label = new QLabel("EnterComponent ID");
+    label->setStyleSheet("font: 22px;");
+    vMainLayout->addWidget(label,Qt::AlignCenter);
+
+    m_ComponentEdit = new QLineEdit();
+    m_ComponentEdit->setObjectName("leComponentId");
+
+    connect(m_ComponentEdit,SIGNAL(returnPressed()),this,SLOT(sendString()));
+    m_ComponentEdit->setMaximumWidth(240);
+    vMainLayout->addWidget(m_ComponentEdit,Qt::AlignCenter);
+    vMainLayout->addStretch();
+
+    this->setLayout(vMainLayout);
+    setWindowTitle("Enter Component ID");
+    setWindowFlags(Qt::Dialog);
+    setAttribute(Qt::WA_DeleteOnClose);
+    setFixedSize(260,100);
+
+}
+
+/**
+ * @brief ComponentDialog::setText Sets the text in Enter Component Id line edit. Not being used now\n
+ * as the text in the line edit directly read from RFID Scanner.
+ * @param text
+ */
+void ComponentDialog::setText(QString text)
+{
+    m_ComponentText = text;
+}
+
+/**
+ * @brief ComponentDialog::getText Not being used. Testing purpose.
+ * @return
+ */
+QString ComponentDialog::getText()
+{
+    return m_ComponentText;
+}
+
+/**
+ * @brief ComponentDialog::clearText Not being Used. Testing purpose.
+ */
+void ComponentDialog::clearText()
+{
+    m_ComponentEdit->clear();
+}
+
+/**
+ * @brief ComponentDialog::focusComponentId Not being Used. Testing purpose.
+ */
+void ComponentDialog::focusComponentId()
+{
+    m_ComponentEdit->setFocus();
+}
+
+/**
+ * @brief ComponentDialog::isComponentIdHasFocus Not being Used. Testing purpose.
+ * @return
+ */
+bool ComponentDialog::isComponentIdHasFocus()
+{
+   return m_ComponentEdit->hasFocus();
+}
+
+/**
+ * @brief ComponentDialog::sendString This is called Once the component tag is scanned from the \n
+ * RFID Scanner or return is pressed in the line edit. It emits the signal and calls the MainWindow slot\n
+ * scannedString(QString). The slot loads the component parameter.
+ */
+void ComponentDialog::sendString()
+{
+   emit scannedString(m_ComponentEdit->text());
+
+    this->close();
+}
+
+/**
+ * @brief ComponentDialog::closeDialog This function is called to close the "Enter Component Id"\n
+ * window. This is called from the bool MainWindow::eventFilter(QObject *object, QEvent *event), whenever\n
+ * the ABORT is pressed.
+ */
+void ComponentDialog::closeDialog()
+{
+    this->close();
+}
+
diff --git a/meta-services/recipes-services/lcd-app/files/componentdialog.h b/meta-services/recipes-services/lcd-app/files/componentdialog.h
new file mode 100644
index 0000000..6ff1a22
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/componentdialog.h
@@ -0,0 +1,42 @@
+#ifndef COMPONENTDIALOG_H
+#define COMPONENTDIALOG_H
+
+#include <QWidget>
+#include <QBoxLayout>
+#include <QLineEdit>
+#include <QLabel>
+
+/**
+ * @brief The ComponentDialog class, It is the class which is used to pop up "Enter Component Id"\n
+ * window.
+ */
+
+class ComponentDialog : public QWidget
+{
+    Q_OBJECT
+public:
+    explicit ComponentDialog(QWidget *parent = 0);
+
+signals:
+
+    void scannedString(QString);
+
+public slots:
+
+    void setText(QString text);
+    QString getText();
+    void sendString();
+    void closeDialog();
+    void clearText();
+    void focusComponentId();
+    bool isComponentIdHasFocus();
+
+
+private:
+    QLineEdit *m_ComponentEdit;
+    QString m_ComponentText;
+
+
+};
+
+#endif // COMPONENTDIALOG_H
diff --git a/meta-services/recipes-services/lcd-app/files/gauge_system_master.xml b/meta-services/recipes-services/lcd-app/files/gauge_system_master.xml
new file mode 100644
index 0000000..d975859
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/gauge_system_master.xml
@@ -0,0 +1,76 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<master>
+	<station>
+		<workcenter_code>2MCC108</workcenter_code>
+		<part_no>N7030120</part_no>
+		<part_desc>Crankcase</part_desc>
+		<opn_no>0010</opn_no>
+		<unique_channel_id>1</unique_channel_id>
+		<no_of_parameters>3</no_of_parameters>
+	</station>
+	<hardware>
+		<hardware_id>1</hardware_id>
+		<hardware_desc>6 channel unit</hardware_desc>
+		<build>airtronic</build>
+		<valid_length>12</valid_length>
+		<crop_index>3</crop_index>
+		<crop_length>6</crop_length>
+		<add_value>0</add_value>
+		<baud_rate>2400</baud_rate>
+		<stop_bits>8</stop_bits>
+		<parity>none</parity>
+		<flow_control>none</flow_control>
+	</hardware>
+	<hardware>
+		<hardware_id>2</hardware_id>
+		<hardware_desc>Single channel unit</hardware_desc>
+		<build>airtronic</build>
+		<valid_length>12</valid_length>
+		<crop_index>3</crop_index>
+		<crop_length>6</crop_length>
+		<add_value>0</add_value>
+		<baud_rate>2400</baud_rate>
+		<stop_bits>8</stop_bits>
+		<parity>none</parity>
+		<flow_control>none</flow_control>
+	</hardware>	
+	<parameter>
+		<parameter_id>455</parameter_id>
+		<parameter_desc>Oil hole drilling</parameter_desc>
+		<USL>52.016</USL>
+		<LSL>52.000</LSL>
+		<target_value>52.008</target_value>
+		<UOM>mm</UOM>
+		<gauge_no>G6301630</gauge_no>
+		<old_parameter_id>1</old_parameter_id> <!-- sequence id -->
+		<image_path>tvs1.jpg</image_path>
+		<hardware_id>1</hardware_id>
+		<port>COM1</port>
+	</parameter>
+	<parameter>
+		<parameter_id>456</parameter_id>
+		<parameter_desc>CBDF milling</parameter_desc>
+		<USL>10.015</USL>
+		<LSL>10.000</LSL>
+		<target_value>10.007</target_value>
+		<UOM>mm</UOM>
+		<gauge_no>G6301631</gauge_no>
+		<old_parameter_id>2</old_parameter_id> <!-- sequence id -->
+		<image_path>tvs2.jpg</image_path>
+		<hardware_id>2</hardware_id>
+		<port>COM2</port>
+	</parameter>
+	<parameter>
+		<parameter_id>457</parameter_id>
+		<parameter_desc>Boring</parameter_desc>
+		<USL>48.900</USL>
+		<LSL>48.890</LSL>
+		<target_value>48.895</target_value>
+		<UOM>mm</UOM>
+		<gauge_no>G6311112</gauge_no>
+		<old_parameter_id>3</old_parameter_id> <!-- sequence id -->
+		<image_path>tvs3.jpg</image_path>
+		<hardware_id>1</hardware_id>
+		<port>COM1</port>
+	</parameter>
+</master>
\ No newline at end of file
diff --git a/meta-services/recipes-services/lcd-app/files/gauge_system_master_1.xml b/meta-services/recipes-services/lcd-app/files/gauge_system_master_1.xml
new file mode 100644
index 0000000..5831173
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/gauge_system_master_1.xml
@@ -0,0 +1,126 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<master>
+	<station>
+		<workcenter_code>2MCC108</workcenter_code>
+		<part_no>N7030120</part_no>
+		<part_desc>Crankcase</part_desc>
+		<opn_no>0010</opn_no>
+		<unique_channel_id>1</unique_channel_id>
+		<no_of_parameters>3</no_of_parameters>
+		<componentId_length>12</componentId_length>
+	</station>
+	<hardware>
+		<hardware_id>1</hardware_id>
+		<hardware_desc>6 channel unit</hardware_desc>
+		<build>airtronic</build>
+		<valid_length>12</valid_length>
+		<crop_index>3</crop_index>
+		<crop_length>6</crop_length>
+		<add_value>0</add_value>
+		<baud_rate>2400</baud_rate>
+		<stop_bits>8</stop_bits>
+		<parity>none</parity>
+		<flow_control>none</flow_control>
+	</hardware>
+	<hardware>
+		<hardware_id>2</hardware_id>
+		<hardware_desc>Single channel unit</hardware_desc>
+		<build>airtronic</build>
+		<valid_length>12</valid_length>
+		<crop_index>3</crop_index>
+		<crop_length>6</crop_length>
+		<add_value>0</add_value>
+		<baud_rate>2400</baud_rate>
+		<stop_bits>8</stop_bits>
+		<parity>none</parity>
+		<flow_control>none</flow_control>
+	</hardware>
+	<hardware>
+		<hardware_id>3</hardware_id>
+		<hardware_desc>Single channel unit</hardware_desc>
+		<build>airtronic</build>
+		<valid_length>12</valid_length>
+		<crop_index>3</crop_index>
+		<crop_length>6</crop_length>
+		<add_value>0</add_value>
+		<baud_rate>2400</baud_rate>
+		<stop_bits>8</stop_bits>
+		<parity>none</parity>
+		<flow_control>none</flow_control>
+	</hardware>
+	<hardware>
+		<hardware_id>4</hardware_id>
+		<hardware_desc>Single channel unit</hardware_desc>
+		<build>airtronic</build>
+		<valid_length>12</valid_length>
+		<crop_index>3</crop_index>
+		<crop_length>6</crop_length>
+		<add_value>0</add_value>
+		<baud_rate>2400</baud_rate>
+		<stop_bits>8</stop_bits>
+		<parity>none</parity>
+		<flow_control>none</flow_control>
+	</hardware>	
+	<parameter>
+		<parameter_id>455</parameter_id>
+		<parameter_desc>Oil hole drilling</parameter_desc>
+		<USL>52.016</USL>
+		<LSL>52.000</LSL>
+		<target_value>52.008</target_value>
+		<UOM>mm</UOM>
+		<gauge_no>G6301630</gauge_no>
+		<old_parameter_id>1</old_parameter_id> <!-- sequence id -->
+		<image_path>tvs1.jpg</image_path>
+		<hardware_id>1</hardware_id>
+		<port>COM1</port>
+	</parameter>
+	<parameter>
+		<parameter_id>456</parameter_id>
+		<parameter_desc>CBDF milling</parameter_desc>
+		<USL>10.015</USL>
+		<LSL>10.000</LSL>
+		<target_value>10.007</target_value>
+		<UOM>mm</UOM>
+		<gauge_no>G6301631</gauge_no>
+		<old_parameter_id>2</old_parameter_id> <!-- sequence id -->
+		<image_path>tvs2.jpg</image_path>
+		<hardware_id>2</hardware_id>
+		<port>COM2</port>
+	</parameter>
+	<parameter>
+		<parameter_id>457</parameter_id>
+		<parameter_desc>Boring</parameter_desc>
+		<USL>48.900</USL>
+		<LSL>48.890</LSL>
+		<target_value>48.895</target_value>
+		<UOM>mm</UOM>
+		<gauge_no>G6311112</gauge_no>
+		<old_parameter_id>3</old_parameter_id> <!-- sequence id -->
+		<image_path>tvs3.jpg</image_path>
+		<hardware_id>1</hardware_id>
+		<port>COM3</port>
+	</parameter>
+	<parameter>
+		<parameter_id>458</parameter_id>
+		<parameter_desc>Intake</parameter_desc>
+		<USL>48.900</USL>
+		<LSL>48.890</LSL>
+		<target_value>48.895</target_value>
+		<UOM>mm</UOM>
+		<gauge_no>G6311113</gauge_no>
+		<old_parameter_id>4</old_parameter_id> <!-- sequence id -->
+		<image_path>tvs_spare.png</image_path>
+		<hardware_id>3</hardware_id>
+		<port>COM4</port>
+	</parameter>
+	<settings>
+		<host_name>localhost</host_name>
+		<port_number>3306</port_number>
+		<user_name>TVS</user_name>
+		<password>saad</password>
+		<database_name>gaugespc</database_name>
+	</settings>
+	<general>
+		<uartread_delay>1000</uartread_delay>
+	</general>
+</master>
diff --git a/meta-services/recipes-services/lcd-app/files/gaugedata.h b/meta-services/recipes-services/lcd-app/files/gaugedata.h
new file mode 100644
index 0000000..367ee0e
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/gaugedata.h
@@ -0,0 +1,19 @@
+#ifndef GAUGEDATA_H
+#define GAUGEDATA_H
+#include <QString>
+
+/**
+ * @brief The GaugeTableData class This class contains the fields which are required to show\n
+ * on the table view.
+ */
+class GaugeTableData
+{
+public:
+   QString m_GaugeName;
+   float m_USL;
+   float m_MaxVal;
+   float m_MinVal;
+   float m_LSL;
+};
+
+#endif // GAUGEDATA_H
diff --git a/meta-services/recipes-services/lcd-app/files/gaugedatabasemanager.cpp b/meta-services/recipes-services/lcd-app/files/gaugedatabasemanager.cpp
new file mode 100644
index 0000000..307822b
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/gaugedatabasemanager.cpp
@@ -0,0 +1,237 @@
+#include "gaugedatabasemanager.h"
+#include <QDebug>
+#include <QSqlError>
+#include <QtSql>
+#include<QMessageBox>
+
+Q_DECLARE_METATYPE(GaugeTableData)
+Q_DECLARE_METATYPE(QList<GaugeTableData> )
+
+GaugeDatabaseManager::GaugeDatabaseManager(QObject *parent)
+    : QObject(parent)
+{
+    qRegisterMetaType<GaugeTableData>();
+    qRegisterMetaType< QList<GaugeTableData> >();
+}
+
+/**
+ * @brief GaugeDatabaseManager::initDatabase Not being used for now.
+ */
+
+void GaugeDatabaseManager::initDatabase()
+{
+    m_SqlDataBase = QSqlDatabase::addDatabase("QMYSQL");
+//    m_SqlDataBase.setHostName("192.168.1.68");
+    m_SqlDataBase.setHostName("localhost");
+    m_SqlDataBase.setPort(3306);
+    m_SqlDataBase.setUserName("TVS");
+    m_SqlDataBase.setPassword("saad");
+    m_SqlDataBase.setDatabaseName("gaugespc");
+
+    if(m_SqlDataBase.open())
+        qDebug() << "Remote MySql opened Successfully";
+    else
+        qDebug() << "Remote Mysql failed to open" << m_SqlDataBase.lastError().text()
+                 << m_SqlDataBase.lastError().number();
+
+    createDatabase();
+}
+
+/**
+ * @brief GaugeDatabaseManager::openDatabase This is called in the MainWindow Constructor and \n
+ * when next pressed(when the database connection broked), to connect to the Mysql server database.\n
+ * It also calls the function to create table in the database if table does not exist.
+ * @param mysqlSettings It is the serverSettings pointer which contains Database information, given by the xml file.
+ * @return
+ */
+
+bool GaugeDatabaseManager::openDatabase(serverSettings *mysqlSettings)
+{
+    bool flag = false;
+
+    m_SqlDataBase = QSqlDatabase::addDatabase("QMYSQL");
+//    m_SqlDataBase.setHostName("192.168.1.68");
+    m_SqlDataBase.setHostName(mysqlSettings->hostName);
+    m_SqlDataBase.setPort(mysqlSettings->portNumber);
+    m_SqlDataBase.setUserName(mysqlSettings->userName);
+    m_SqlDataBase.setPassword(mysqlSettings->password);
+    m_SqlDataBase.setDatabaseName(mysqlSettings->databaseName);
+
+    if(m_SqlDataBase.open())
+    {
+        qDebug() << "Remote MySql opened Successfully";
+        flag = true;
+    }
+    else
+    {
+        qDebug() << "Remote Mysql failed to open" << m_SqlDataBase.lastError().text()
+                 << m_SqlDataBase.lastError().number();
+
+        emit showWarning(QString("Fails to connect the Database"), 3000);
+
+        flag = false;
+    }
+
+    qDebug() << "here" << QSqlDatabase::drivers();
+
+    createDatabase();
+
+    return flag;
+}
+
+/**
+ * @brief GaugeDatabaseManager::createDatabase This function prepares and executes the mysql query\n
+ * to create table in mysql database.
+ * @return TRUE If table is created or already exist.
+ *         False If query fails to execute or fails to create the table.
+ */
+bool GaugeDatabaseManager::createDatabase()
+{
+    QSqlQuery query;
+
+    bool check =  query.exec(QString("CREATE TABLE IF NOT EXISTS gaugespc ("
+                                     "row_id int(11) NOT NULL PRIMARY KEY AUTO_INCREMENT,"
+                                     "workcenter_code varchar(20) DEFAULT NULL,"
+                                     "part_no varchar(25) DEFAULT NULL,"
+                                     "component_id varchar(30) DEFAULT NULL,"
+                                     "station_id varchar(45) DEFAULT NULL,"
+                                     "unique_channel_number varchar(45) DEFAULT NULL,"
+                                     "primary_number int(11) DEFAULT NULL,"
+                                     "gauge_number varchar(45) DEFAULT NULL,"
+                                     "USL decimal(18,4) DEFAULT NULL,"
+                                     "LSL decimal(18,4) DEFAULT NULL,"
+                                     "measured_value decimal(18,4) DEFAULT NULL,"
+                                     "min_ova_value decimal(18,4) DEFAULT NULL,"
+                                     "measured_on timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',"
+                                     "created_on timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,"
+                                     "created_by varchar(10) DEFAULT NULL,"
+                                     "measured_by varchar(10) DEFAULT NULL"
+                                     ")"));
+
+    return check;
+}
+
+/**
+ * @brief GaugeDatabaseManager::insertValuesIntoDatabase This function inserts the new row into the database\n
+ * table. It is called in bool MainWindow::saveValuesToDataBase(). The following are the parameters\n
+ * which are inserted into the table.
+ * @param workcenter_code
+ * @param part_no
+ * @param component_id
+ * @param station_id
+ * @param unique_channel_number
+ * @param primary_number
+ * @param gauge_number
+ * @param usl
+ * @param lsl
+ * @param measured_value
+ * @param min_ova
+ * @return
+ */
+
+bool GaugeDatabaseManager::insertValuesIntoDatabase(QString workcenter_code,QString part_no,QString component_id,QString station_id,QString unique_channel_number,int primary_number,
+                                                    QString gauge_number,float usl,float lsl,float measured_value,float min_ova)
+{
+    QSqlQuery query;
+
+    bool check;
+    query.prepare(QString("INSERT INTO gaugespc "
+                          "( workcenter_code ,part_no, component_id , station_id , unique_channel_number ,primary_number , "
+                          "gauge_number , USL , LSL , measured_value , min_ova_value , measured_on , created_on , created_by, measured_by) VALUES (?, ?, ?, ?, ? ,? , ? , ? , ? , ?, ? , ? , ? , ?, ? )"));
+
+    query.addBindValue(workcenter_code);
+    query.addBindValue(part_no);
+    query.addBindValue(component_id);
+    query.addBindValue(station_id);
+    query.addBindValue(unique_channel_number);
+    query.addBindValue(primary_number);
+    query.addBindValue(gauge_number);
+    query.addBindValue(usl);
+    query.addBindValue(lsl);
+    query.addBindValue(measured_value);
+    query.addBindValue(min_ova);
+    query.addBindValue(QDateTime::currentDateTimeUtc());
+    query.addBindValue(QDateTime::currentDateTimeUtc());
+    query.addBindValue("root");
+    query.addBindValue("root");
+
+    check = query.exec();
+
+
+    if(check)
+    {
+        qDebug() << "Insertion successfull";
+
+//        readValuesFromDatabase();
+    }
+    else
+        qDebug() <<"Error in saving" << query.lastError();
+
+    qDebug() << "Inserted Rows = " << query.numRowsAffected();
+
+    if(query.numRowsAffected() != 1)//This is to check, Is row inserted in the table.
+        check = false;
+
+    return check;
+}
+
+/**
+ * @brief GaugeDatabaseManager::isDatabaseConnected This function is called to check that application\n
+ * is connected to database or not.
+ * @return TRUE When Database is connected.\n
+ *         FALSE When Database is not connected.
+ */
+
+bool GaugeDatabaseManager::isDatabaseConnected()
+{
+    bool flag = false;
+
+    if(m_SqlDataBase.open())
+        flag = true;
+    else
+        flag = false;
+
+    return flag;
+}
+
+/**
+ * @brief GaugeDatabaseManager::removeValuesFromDatabase Not in use
+ * @return
+ */
+
+bool GaugeDatabaseManager::removeValuesFromDatabase()
+{
+    return false;
+}
+
+/**
+ * @brief GaugeDatabaseManager::updateValuesToDatabase Not in use
+ * @return
+ */
+
+bool GaugeDatabaseManager::updateValuesToDatabase()
+{
+    return false;
+}
+
+/**
+ * @brief GaugeDatabaseManager::readValuesFromDatabase Not in use
+ */
+
+void GaugeDatabaseManager::readValuesFromDatabase()
+{
+    QSqlQuery query;
+    query.exec(QString("select *from gaugespc"));
+
+    while (query.next()) {
+        GaugeTableData data;
+
+        data.m_GaugeName = query.value(7).toString();
+        data.m_USL = query.value(8).toFloat();
+        data.m_LSL = query.value(9).toFloat();
+        data.m_MaxVal = query.value(10).toFloat();
+        data.m_MinVal = query.value(11).toFloat();
+//        m_GaugeTableData.push_back(data);//saad:rm (I think not being used now, remove and check the application working).
+    }
+
+}
diff --git a/meta-services/recipes-services/lcd-app/files/gaugedatabasemanager.h b/meta-services/recipes-services/lcd-app/files/gaugedatabasemanager.h
new file mode 100644
index 0000000..b21dcaf
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/gaugedatabasemanager.h
@@ -0,0 +1,45 @@
+#ifndef GAUGEDATABASEMANAGER_H
+#define GAUGEDATABASEMANAGER_H
+
+#include <QObject>
+#include <QSqlDatabase>
+#include "include.h"
+#include "gaugedata.h"
+
+/**
+ * @brief The GaugeDatabaseManager class This class manages all the mysql server database\n
+ * operations mainly like Database connection, new row insertion in the table.
+ */
+
+class GaugeDatabaseManager : public QObject
+{
+    Q_OBJECT
+public:
+    explicit GaugeDatabaseManager(QObject *parent = 0);
+
+signals:
+
+    void sendDataBaseValues(QList<GaugeTableData> tabledata);
+    void showWarning(QString text, int mSec = 2000);
+
+public slots:
+
+public :
+    void initDatabase();
+    bool openDatabase(serverSettings *mysqlSettings);
+    bool createDatabase();
+    bool insertValuesIntoDatabase(QString workcenter_code,QString part_no,QString component_id,QString station_id,QString unique_channel_number,int primary_number,
+                                  QString gauge_number,float usl,float lsl,float measured_value,float min_ova);
+    bool removeValuesFromDatabase();
+    bool updateValuesToDatabase();
+    void readValuesFromDatabase();
+
+    bool isDatabaseConnected();
+
+private:
+    QSqlDatabase m_SqlDataBase;
+    QList<GaugeTableData> m_GaugeTableData;
+
+};
+
+#endif // GAUGEDATABASEMANAGER_H
diff --git a/meta-services/recipes-services/lcd-app/files/include.h b/meta-services/recipes-services/lcd-app/files/include.h
new file mode 100644
index 0000000..8235a50
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/include.h
@@ -0,0 +1,49 @@
+#ifndef INCLUDE_H
+#define INCLUDE_H
+
+
+#include <qnamespace.h>
+
+/**
+ *This has the enum for Table view used in sqltabledelegate.cpp and the enum for the \n
+ *User gpio input keys.\n
+ * One class is defined serverSettings which has the information required to connect to the\n
+ * Database present in mysql server.
+ */
+
+namespace Tvs {
+
+    enum GaugeRoles {
+        USLRole = Qt::UserRole,
+        MaxValRole,
+        MinValRole,
+        LSLRole
+    };
+
+    enum key
+    {
+        StartCycle = Qt::Key_S,
+        NextParameter = Qt::Key_N,
+        Previous = Qt::Key_P,
+        Abort = Qt::Key_A
+    };
+}
+
+/**
+ * @brief The serverSettings class is the user defined class, which stores the mysql server and\n
+ * database related information given in the xml file.
+ */
+
+class serverSettings
+{
+public:
+    int portNumber;
+    QString hostName;
+    QString userName;
+    QString password;
+    QString databaseName;
+
+};
+
+
+#endif // INCLUDE_H
diff --git a/meta-services/recipes-services/lcd-app/files/main.cpp b/meta-services/recipes-services/lcd-app/files/main.cpp
new file mode 100644
index 0000000..9a67588
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/main.cpp
@@ -0,0 +1,23 @@
+#include "mainwindow.h"
+#include <QApplication>
+//#include "gaugedatabasemanager.h"
+
+/**
+ * @brief main 1. This is the starting point of the application.\n
+ *             2. It creates MainWindow instance, and call show() to show the UI.
+ * @param argc not in use
+ * @param argv not in use
+ * @return a.exec()
+ */
+
+int main(int argc, char *argv[])
+{
+    QApplication a(argc, argv);
+
+    MainWindow w;
+
+    w.show();
+//    w.showFullScreen();
+
+    return a.exec();
+}
diff --git a/meta-services/recipes-services/lcd-app/files/mainwindow.cpp b/meta-services/recipes-services/lcd-app/files/mainwindow.cpp
new file mode 100644
index 0000000..bf19acc
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/mainwindow.cpp
@@ -0,0 +1,1570 @@
+#include "mainwindow.h"
+#include <QDir>
+#include "componentdialog.h"
+#include <QMessageBox>
+#include "sqltabledelegate.h"
+#include<termios.h>
+#include<QTimer>
+#include<QApplication>
+#include<QTime>
+#include<unistd.h>
+
+#define WIDTH 800
+#define HEIGHT 600
+
+Q_DECLARE_METATYPE(GaugeTableData)
+Q_DECLARE_METATYPE(QList<GaugeTableData> )
+
+#ifdef __arm__
+char hrdwrComPort[COM_PORTS][20] = {
+                "/dev/ttymxc3",
+                "/dev/ttymxc0",
+                "/dev/ttyUSB2",
+                "/dev/ttyUSB3"
+                };
+#else
+char hrdwrComPort[COM_PORTS][20] = {
+                "/dev/pts/20",
+                "/dev/pts/27",
+                "/dev/pts/30",
+                "/dev/pts/33"
+                };
+#endif
+
+char relayGpio[COM_PORTS][35] = {
+                "/sys/class/gpio/gpio511/value",
+                "/sys/class/gpio/gpio510/value",
+                "/sys/class/gpio/gpio509/value",
+                "/sys/class/gpio/gpio508/value"
+                };
+
+
+/**
+ * @fn MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)
+ * @brief It is the MainWindow Constructor. Called when MainWindow instance is created.
+ * It initializes the following\n
+ * 1. Creates the Full user interface screen.\n
+ * 2. Table view and graph initialization.\n
+ * 3. Xml file reading and loading the information locally.\n
+ * 4. All four uarts and four relays initialization.\n
+ * 5. Database initialization and connection.
+ * @param parent NULL
+ */
+MainWindow::MainWindow(QWidget *parent)
+    : QMainWindow(parent)
+{
+    qRegisterMetaType<GaugeTableData>();
+    qRegisterMetaType< QList<GaugeTableData> >();
+
+    maxval = minval = 0.0;
+    uartReadDelay = 0;
+
+#ifdef __arm__
+    qDebug() << "ARM_ARCH";
+#else
+    qDebug() << "x86_ARCH";
+#endif
+
+    QFrame *mainFrame = new QFrame(this);
+    QVBoxLayout *vMainLayout = new QVBoxLayout();
+    vMainLayout->setContentsMargins(0,0,0,0);
+
+    vMainLayout->setSpacing(0);
+
+    //Title Frame
+    QFrame *titleFrame = new QFrame(this);
+    titleFrame->setStyleSheet("background-color : white");
+
+//    titleFrame->setMinimumSize(WIDTH, 150);
+    titleFrame->setMinimumSize(this->width(), ((this->height() / 3) - 10));
+
+    QVBoxLayout *vTitleLayout = new QVBoxLayout();
+    QHBoxLayout *titleFrameLayout = new QHBoxLayout();
+    QLabel *logoLbl = new QLabel(this);
+    logoLbl->setPixmap(QPixmap("tvs_logo.png"));
+    titleFrameLayout->addWidget(logoLbl,0,Qt::AlignLeft);
+
+    QLabel *nameLbl = new QLabel(this);
+    nameLbl->setStyleSheet("font: bold 35px;");//30px
+    nameLbl->setText("TVS GAUGING SOFTWARE");
+    titleFrameLayout->addWidget(nameLbl,0,Qt::AlignCenter);
+
+    QLabel *horseLbl = new QLabel(this);
+    horseLbl->setPixmap(QPixmap("tvs_horse.png"));
+    titleFrameLayout->addWidget(horseLbl,0,Qt::AlignRight);
+    vTitleLayout->addLayout(titleFrameLayout);
+
+    QHBoxLayout *componetntLayout = new QHBoxLayout();
+    componetntLayout->setContentsMargins(0,0,0,0);
+    componetntLayout->setSpacing(0);
+    QLabel *lbPaetDesc = new QLabel("Part Desc:");
+    m_lePartDesc = new QLineEdit();
+    componetntLayout->addWidget(lbPaetDesc);
+    componetntLayout->addWidget(m_lePartDesc);
+    componetntLayout->addStretch();
+
+    QLabel *lbPartNumber = new QLabel("Part Number:");
+    m_lePartNumber = new QLineEdit();
+    componetntLayout->addWidget(lbPartNumber);
+    componetntLayout->addWidget(m_lePartNumber);
+    componetntLayout->addStretch();
+
+    QPushButton *startCycleButn = new QPushButton("START CYCLE");
+    startCycleButn->setStyleSheet("background-color : light gray");
+    componetntLayout->addWidget(startCycleButn);
+    connect(startCycleButn,SIGNAL(clicked(bool)),this,SLOT(startCycleClicked()));
+
+    QPushButton *pbnextParameter = new QPushButton("Next");
+    pbnextParameter->setStyleSheet("background-color : light gray");
+    componetntLayout->addWidget(pbnextParameter);
+    connect(pbnextParameter,SIGNAL(clicked(bool)),this,SLOT(nextParameterClicked()));
+
+    QPushButton *pbPrevious = new QPushButton("Previous");
+    componetntLayout->addWidget(pbPrevious);
+    pbPrevious->setStyleSheet("background-color : light gray");
+    connect(pbPrevious,SIGNAL(clicked(bool)),this,SLOT(previousClicked()));
+
+    QPushButton *abortCycleButn = new QPushButton("ABORT CYCLE");
+    componetntLayout->addWidget(abortCycleButn);
+    abortCycleButn->setStyleSheet("background-color : light gray");
+    connect(abortCycleButn,SIGNAL(clicked(bool)),this,SLOT(abortCycleClicked()));
+
+    componetntLayout->addStretch();
+    vTitleLayout->addLayout(componetntLayout);
+
+    titleFrame->setLayout(vTitleLayout);
+    vMainLayout->addWidget(titleFrame);
+
+    //Main Settings Frame
+    QGroupBox *groupBox = new QGroupBox(tr("GAUGE READING"));
+    groupBox->setStyleSheet("QGroupBox { font-weight: bold; } ");
+
+    QHBoxLayout *settingsLayout = new QHBoxLayout();
+    settingsLayout->setContentsMargins(0,0,0,0);
+    settingsLayout->setSpacing(0);
+
+    QVBoxLayout *vSettingsMainLayout = new QVBoxLayout();
+    vSettingsMainLayout->setContentsMargins(0,0,0,0);
+    vSettingsMainLayout->setSpacing(0);
+    settingsLayout->addLayout(vSettingsMainLayout);
+
+    QFrame *settingsFrame = new QFrame(this);
+
+    QGridLayout *gridLayout = new QGridLayout();
+
+    QLabel *componentIdLabel = new QLabel("Component ID:");
+    m_ComponentId = new QLineEdit();
+    gridLayout->addWidget(componentIdLabel,0,0);
+    gridLayout->addWidget(m_ComponentId,0,1);
+
+    QLabel *lbParameterDesc = new QLabel("Parameter Desc");
+    m_leParameterDesc = new QLineEdit();
+    gridLayout->addWidget(lbParameterDesc, 1, 0);
+    gridLayout->addWidget(m_leParameterDesc, 1, 1);
+
+    QLabel *selectedGaugeLbl = new QLabel("Selected Gauge:");
+    m_SelectedGauge = new QLineEdit();
+    gridLayout->addWidget(selectedGaugeLbl,0,2);
+    gridLayout->addWidget(m_SelectedGauge,0,3);
+
+    QLabel *upperLimitLbl = new QLabel("UPPER LIMIT:");
+    m_UpperLimitEdit = new QLineEdit();
+    gridLayout->addWidget(upperLimitLbl,2,0);
+    gridLayout->addWidget(m_UpperLimitEdit,2,1);
+
+    QLabel *maxValLbl = new QLabel("MAX:");
+    m_MaxValueEdit = new QLineEdit();
+    gridLayout->addWidget(maxValLbl,1,2);
+    gridLayout->addWidget(m_MaxValueEdit,1,3);
+
+    QLabel *minVal = new QLabel("MIN:");
+    m_MinValueEdit = new QLineEdit();
+    gridLayout->addWidget(minVal,2,2);
+    gridLayout->addWidget(m_MinValueEdit,2,3);
+
+    QLabel *lowerLimit = new QLabel("LOWER LIMIT:");
+    m_LowerLimitEdit = new QLineEdit();
+    gridLayout->addWidget(lowerLimit,3,0);
+    gridLayout->addWidget(m_LowerLimitEdit,3,1);
+
+    QLabel *ovalityLbl = new QLabel("OVALITY:");
+    m_OvalityEdit = new QLineEdit();
+    gridLayout->addWidget(ovalityLbl,3,2);
+    gridLayout->addWidget(m_OvalityEdit,3,3);
+
+    m_ItemImageLabel = new QLabel();
+    m_ItemImageLabel->setStyleSheet("background-color : white");
+
+//    m_ItemImageLabel->setMinimumSize(200,450);
+    m_ItemImageLabel->setMinimumSize((this->width() / 2),
+                                     /*(this->height() - (this->height() / 3 - 10))*/this->height());
+
+    settingsFrame->setLayout(gridLayout);
+
+    vSettingsMainLayout->addWidget(settingsFrame);
+    vSettingsMainLayout->addStretch();
+    vSettingsMainLayout->addWidget(m_ItemImageLabel);
+
+    m_StackedWidget = new QStackedWidget(this);
+//    m_StackedWidget->setMinimumSize(450,400);
+    m_StackedWidget->setMinimumSize((this->width() / 2), (this->height() / 2));
+
+    settingsLayout->addWidget(m_StackedWidget);
+
+    QWidget *dummyWidget = new QWidget(this);
+
+    SqlTableDelegate *delegate = new SqlTableDelegate();
+
+    m_SqlModel = new MySqlTableModel();
+    m_TableView = new QTableView(this);
+    m_TableView->setMinimumSize((this->width() / 2 + 200), (this->height() / 2));
+    m_TableView->setItemDelegate(delegate);
+    m_TableView->setModel(m_SqlModel);
+
+    m_TableView->setColumnWidth(0, 150);
+    for (int col = 1; col < 5; col++)
+    {
+        m_TableView->setColumnWidth(col,110);
+//        m_TableView->setColumnWidth(col, ((m_TableView->width() - 70) / 5));
+    }
+
+    m_ChartView = new QWidget (this);
+
+    m_StackedWidget->addWidget(dummyWidget);
+    m_StackedWidget->addWidget(m_TableView);
+    m_StackedWidget->addWidget(m_ChartView);
+
+    m_StackedWidget->setCurrentWidget(dummyWidget);
+
+    m_ChartPlot = new QCustomPlot(m_ChartView);
+    m_ChartPlot->addGraph();//Minimum boundary line.
+    m_ChartPlot->addGraph();//Maximum boundary line.
+    m_ChartPlot->addGraph();//graph with the values from uart.
+
+    isValidation = false;
+    isMax = isMin = isOval = false;
+
+    groupBox->setLayout(settingsLayout);
+    vMainLayout->addWidget(groupBox);
+
+    mainFrame->setLayout(vMainLayout);
+    setCentralWidget(mainFrame);
+    setWindowTitle("TVS GUAGING SOFTWARE");
+
+    parseXml();
+
+//    initComPorts();
+
+    initRelays();
+
+    m_DatabaseManager = new GaugeDatabaseManager();
+    connect(m_DatabaseManager, SIGNAL(showWarning(QString, int)), this,
+            SLOT(showWarning(QString, int)));
+    m_DatabaseManager->openDatabase(&m_mysqlServerSettings);
+
+    m_ParamDataListIterator = m_ParameterDataList.begin();
+    m_ParameterIndex = 0;
+    for(int i = 0; i < m_ParameterDataList.size(); ++i)
+    {
+        QVector<double> temp;
+        QVector<double> temp1;
+        m_MaxGraphValues.push_back(temp);
+        m_MinGraphValues.push_back(temp1);
+    }
+
+    m_SqlModel->setNumberOfParameters(m_ParameterDataList.size());
+
+    this->centralWidget()->setFocus();
+
+    this->m_lePartDesc->setReadOnly(true);
+    this->m_lePartNumber->setReadOnly(true);
+    this->m_ComponentId->setReadOnly(true);
+    this->m_leParameterDesc->setReadOnly(true);
+    this->m_UpperLimitEdit->setReadOnly(true);
+    this->m_LowerLimitEdit->setReadOnly(true);
+    this->m_SelectedGauge->setReadOnly(true);
+    this->m_MinValueEdit->setReadOnly(true);
+    this->m_MaxValueEdit->setReadOnly(true);
+    this->m_OvalityEdit->setReadOnly(true);
+
+    isCompIdDialogVisible = false;
+}
+
+/**
+ * @brief MainWindow::~MainWindow It gets called when the application is closed.\n
+ * It does the following\n
+ * 1. Closes the file descriptors of uarts and relays.\n
+ * 2. Deletes the dynamically allocated memory.
+ */
+MainWindow::~MainWindow()
+{
+    for(int i = 0; i < COM_PORTS; ++i)
+    {
+        if(!(portReadFd[i] < 0))
+        {
+            qDebug() << "closing COM" << (i + 1);
+            ::close(portReadFd[i]);
+        }
+
+        if(!(relaysWriteFd[i] < 0))
+        {
+            qDebug() << "closing relay connected to COM" << (i + 1);
+        }
+    }//closing com ports and relays
+
+    delete m_ChartPlot;
+}
+
+void MainWindow::openComPort(int comPort)
+{
+    portReadFd[comPort - 1] = open(hrdwrComPort[comPort - 1], O_RDONLY | O_NDELAY | O_NOCTTY | O_NONBLOCK);
+
+    if(portReadFd[comPort - 1] < 0)
+    {
+        qDebug() << "Failed to open COM" << (comPort);
+        showWarning(QString("Failed to open COM%1").arg((comPort)));
+    }
+    else
+    {
+        struct termios comPortConfig;
+
+        tcgetattr(portReadFd[comPort - 1], &comPortConfig);//get the current attributes.
+
+        comPortConfig.c_iflag &= ~(IGNBRK | BRKINT | ICRNL | INLCR);
+        comPortConfig.c_iflag &= ~(PARMRK | INPCK | ISTRIP | IXON);//IXON/IXOFF:no software flow control
+        comPortConfig.c_oflag &= ~(OCRNL | ONLCR | ONLRET | ONOCR);
+        comPortConfig.c_oflag &= ~( OFILL | OLCUC | OPOST);
+        comPortConfig.c_lflag &= ~(ECHO | ECHONL | ICANON | IEXTEN);//non-conical mode.
+        comPortConfig.c_lflag &= ~(ISIG | ECHOK | ECHOCTL | ECHOPRT);
+        comPortConfig.c_cflag &= ~(CSIZE | PARENB);//no parity check.
+        comPortConfig.c_cflag &= ~CRTSCTS;//Turn off hardware flow control(RTS/CTS).
+        comPortConfig.c_cflag |= CS8 | CLOCAL;//CS8:8bit, no parity, 1 stop bit.
+        comPortConfig.c_cflag &= ~CBAUD;
+        comPortConfig.c_cflag |= B2400;
+        comPortConfig.c_cc[VMIN] = 1;
+        comPortConfig.c_cc[VTIME] = 0;
+        tcsetattr(portReadFd[comPort - 1], TCSANOW, &comPortConfig);
+    }
+
+}
+
+void MainWindow::closeComPort(int comPort)
+{
+
+    ::close(portReadFd[comPort - 1]);
+}
+
+/**
+ * @brief MainWindow::startCycleClicked It is called when START is pressed from the user.\n
+ * It has following functionalities\n
+ * 1. When inspection is not yet started and on Home Screen and START is pressed, the application pops\n
+ *    up the Enter Component Id window to scan the component id on the station. Once the compinent id is\n
+ *    is scanned it loads the first parameter in the xml file details on the UI.\n
+ * 2. Once the component is scanned and details are loaded on the UI and START is pressed, the application\n
+ *    inspects the current parameter MAX value and displays on the UI. And also draws the graph\n
+ *    with last recent 15 MAX values. When MAX value is not read properly it waits for the user\n
+ *    to press START again and read the MAX value.\n
+ * 3. If START is pressed once after taking the MAX value, the application now inspects the MIN value\n
+ *    and displays on the UI. And also draws the graph with recent 15 MIN values.If the MIN Value is \n
+ *    not proper it waits for the user to press START again to read the MIN value again.\n
+ * 4. If START is pressed after MIN value, the application compelets the the current parameter inspection\n
+ *    by calculating and displaying the ovality. And the process continues by loading the next parameter.
+ */
+void MainWindow::startCycleClicked()
+{
+    if(!isValidation)
+    {
+        clearValues();
+
+        if(!isCompIdDialogVisible)
+        {
+            m_dlgComponentId = new ComponentDialog(this);
+            connect(m_dlgComponentId,SIGNAL(scannedString(QString)),this,SLOT(scannedString(QString)));
+
+            m_dlgComponentId->show();
+            isCompIdDialogVisible = true;
+
+            m_dlgComponentId->installEventFilter(this);
+            for(int i = 0; i < m_dlgComponentId->children().size(); ++i)
+            {
+                if(m_dlgComponentId->children().at(i)->inherits("QLineEdit"))
+                {
+                    if(m_dlgComponentId->children().at(i)->objectName() == "leComponentId")
+                        m_dlgComponentId->children().at(i)->installEventFilter(this);
+                }
+            }
+
+            m_dlgComponentId->move((this->width() / 2) - 300, this->height() / 2);//to show the window in the center.
+
+        }
+    }
+    else if(isValidation)
+    {
+        qDebug() << "Current Hardware" << m_HardwareData.m_Hardware_Id;
+
+        static bool flag = true;
+
+        if(flag == false)
+            return;
+
+        flag = false;
+
+        if(!isMax)
+        {
+            m_MaxValueEdit->setFocus();
+            maxval = getMaxValue();
+
+            if(maxval != -1)
+            {
+                if((maxval >= m_ParameterData.m_LSL.toFloat()) && (maxval <= m_ParameterData.m_USL.toFloat()))
+                {
+                    m_MaxValueEdit->setStyleSheet("background-color: green; font: bold 12px; color : white");
+                }
+                else
+                {
+                    m_MaxValueEdit->setStyleSheet("background-color: red; font: bold 12px; color : white");
+
+                }
+
+
+                m_MaxValueEdit->setText(QString::number(maxval));
+
+                if(m_MaxGraphValues.at(m_ParameterIndex).size() < 15)
+                {
+                    qDebug() << "if max  < 15" << m_MaxGraphValues.at(m_ParameterIndex).size()
+                             << m_ParameterIndex;
+                    m_MaxGraphValues[m_ParameterIndex].push_back(maxval);
+                }
+                else
+                {
+                    qDebug() << "Max Graph values > 15" << m_MaxGraphValues.at(m_ParameterIndex).size()
+                             << m_ParameterIndex;
+                    m_MaxGraphValues[m_ParameterIndex].remove(0);
+                    m_MaxGraphValues[m_ParameterIndex].push_back(maxval);
+                }
+
+                isMax = true;
+                showGraphWithMaxValues();
+            }
+        }
+        else if(!isMin)
+        {
+            m_MinValueEdit->setFocus();
+            minval = getMinValue();
+
+            if(minval != -1)
+            {
+
+                m_MinValueEdit->setText(QString::number(minval));
+
+                if((minval >= m_ParameterData.m_LSL.toFloat()) && (minval <= m_ParameterData.m_USL.toFloat()))
+                {
+                    m_MinValueEdit->setStyleSheet("background-color: green; font: bold 12px; color : white");
+                }
+                else
+                {
+                    m_MinValueEdit->setStyleSheet("background-color: red; font: bold 12px; color : white");
+
+                }
+
+                if(m_MinGraphValues.at(m_ParameterIndex).size() < 15)
+                {
+                    qDebug() << "if min  < 15" << m_MinGraphValues.at(m_ParameterIndex).size()
+                             << m_ParameterIndex;
+                    m_MinGraphValues[m_ParameterIndex].push_back(minval);
+                }
+                else
+                {
+                    qDebug() << "Min Graph values > 15" << m_MinGraphValues.at(m_ParameterIndex).size()
+                             << m_ParameterIndex;
+                    m_MinGraphValues[m_ParameterIndex].remove(0);
+                    m_MinGraphValues[m_ParameterIndex].push_back(minval);
+                }
+
+                showGraphWithMinValues();
+
+                isMin = true;
+
+                //saad:Added to complete the cycle in two start clicks.
+                isOval = true;
+                m_OvalityEdit->setFocus();
+                float oval = maxval - minval;
+
+                QString ovalStr = QString::number(oval);
+                m_OvalityEdit->setText(ovalStr);
+                isOval = true;
+            }
+        }
+
+        else if(!isOval)
+        {
+            m_OvalityEdit->setFocus();
+            float oval = maxval - minval;
+
+            QString ovalStr = QString::number(oval);
+            m_OvalityEdit->setText(ovalStr);
+            isOval = true;
+        }
+
+        flag = true;
+    }
+
+}
+
+/**
+ * @brief MainWindow::nextParameterClicked It is called when NEXT is pressed. \n
+ * It does the following once parameter Ovality is calculated\n
+ * 1. Checks the database connection.\n
+ * 2. If database is conneted, it inserts the new row into the mysql database and loads the next\n
+ *    parameter if present in xml file and also displays the table or if there is no next parameter\n
+ *    it just shows table with the inspected values.\n
+ * 3. If database is not conneted, it tries to reconnect the database and once the database is\n
+ *    connected it does the step2. If database reconnection fails it displays the error message\n
+ *    and no next parameter is loaded.
+ */
+void MainWindow::nextParameterClicked()
+{
+    static bool flag = true;//to avoid up coming events till the "next" operation finished.
+    if(flag == false)
+        return;
+
+    flag = false;
+    qDebug("nextParameterClicked");
+    if(isOval)
+    {
+        if(m_DatabaseManager->isDatabaseConnected() == true)
+        {
+            isOval = false;
+//            flag = true;
+            saveValuesToDataBase();
+            updateTableAndLoadNextParameter();
+            if(m_ParamDataListIterator != m_ParameterDataList.end() - 1)
+            {
+                m_ParamDataListIterator++;
+                m_ParameterIndex++;
+                fillValues(m_ScannedComponentId);
+            }
+            else
+            {
+                isValidation = false;
+                qDebug("No next Parameter to load");
+            }
+            this->centralWidget()->setFocus();
+        }
+        else
+        {
+            qDebug() << "Database not connected. Check Network";
+            showWarning(QString("Database not connected. Check Network"));
+
+            if(m_DatabaseManager->openDatabase(&m_mysqlServerSettings))
+            {
+                showWarning(QString("Database connected. Save Values to Database"));
+
+                saveValuesToDataBase();
+                updateTableAndLoadNextParameter();
+                if(m_ParamDataListIterator != m_ParameterDataList.end() - 1)
+                {
+                    m_ParamDataListIterator++;
+                    m_ParameterIndex++;
+                    fillValues(m_ScannedComponentId);
+                }
+                else
+                {
+                    isValidation = false;
+                    qDebug("No next Parameter to load");
+                }
+                this->centralWidget()->setFocus();
+            }
+
+        }
+
+    }
+    else if(isValidation)
+    {
+        qDebug("On current Parameter inspection, Can not load next Parameter");
+        showWarning(QString("Complete the current parameter inspection"));
+    }
+    else
+    {
+        qDebug("Scan Next component to start the inspection");
+    }
+    flag = true;
+}
+
+/**
+ * @brief MainWindow::previousClicked It is called when the PREVIOUS is pressed.\n
+ * It does the following functionalities\n
+ * 1. When Parameter is on Ovality, it clears the Ovality and sets the focus to MIN edit.\n
+ * 2. When on MIN edit, it clears the MIN edit and sets the focus on MAX edit and displays\n
+ *    MAX graph.\n
+ * 3. When on MAX edit, clears MAX edit loads the dummy widget in place of graph.\n
+ * 4. When on parameter and no inspection started yet then it loads either the previous\n
+ *    parameter if present in the xml file or loads the Home Screen.\n
+ */
+
+void MainWindow::previousClicked()
+{
+    qDebug("previousClicked");
+    if(isValidation)
+    {
+        if(isOval)
+        {
+            m_OvalityEdit->setText("");
+            isOval = false;
+            m_MinValueEdit->setFocus();
+            showGraphWithMinValues();
+        }
+        else if(isMin)
+        {
+            m_MaxValueEdit->setFocus();
+            m_MinValueEdit->setText("");
+            m_MinValueEdit->setStyleSheet("background-color: white");
+
+            isMin = false;
+            showGraphWithMaxValues();
+        }
+        else if(isMax)
+        {
+            m_MaxValueEdit->setText("");
+            m_MaxValueEdit->setStyleSheet("background-color: white");
+            isMax = false;
+
+            this->centralWidget()->setFocus();
+
+            m_StackedWidget->setCurrentIndex(0);
+        }
+        else
+        {
+            clearValues();
+            if(m_ParamDataListIterator != m_ParameterDataList.begin())
+            {
+                m_SqlModel->removeGaugeDataRow();
+                m_ParamDataListIterator--;
+                m_ParameterIndex--;
+                fillValues(m_ScannedComponentId);
+            }
+            else
+            {
+                isValidation = false;
+                qDebug("No previous parameter to load");
+            }
+            m_StackedWidget->setCurrentIndex(0);
+            this->centralWidget()->setFocus();
+        }
+
+    }
+    else
+    {
+        qDebug("Scan Component to start the inspection");
+    }
+}
+
+/**
+ * @brief MainWindow::abortCycleClicked It gets called when ABORT is pressed.\n
+ * It stops the on going inspection, clears all the displayed information and closes all\n
+ * the pop up windows and makes the application return to the default state.
+ */
+
+void MainWindow::abortCycleClicked()
+{
+    clearValues();
+    isValidation = false;
+    m_ParamDataListIterator = m_ParameterDataList.begin();
+    m_ParameterIndex = 0;
+    m_StackedWidget->setCurrentIndex(0);
+    m_SqlModel->abortTableRows();
+    this->centralWidget()->setFocus();
+}
+
+/**
+ * @brief MainWindow::scannedString It is called when the signal emitted from ComponentDialog::sendString(),\n
+ * the signal is emitted once the component Id is scanned from rfid scanner.
+ * @param str Component Id from the Enter Component Id Window.
+ */
+
+void MainWindow::scannedString(QString str)
+{
+    m_ScannedComponentId = str;
+
+    isCompIdDialogVisible = false;
+    qDebug() << m_ScannedComponentId << str;
+
+    if(m_ScannedComponentId.length() == m_StationData.m_componentId_Length)
+    {
+        m_StackedWidget->setCurrentIndex(0);
+        m_ParamDataListIterator = m_ParameterDataList.begin();
+        m_ParameterIndex = 0;
+        fillValues(m_ScannedComponentId);
+        qDebug() << "Validation successful";
+    }
+    else
+    {
+        showWarning(QString("Component Id is invalid."));
+    }
+}
+
+/**
+ * @brief MainWindow::parseXml This called from MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)\n
+ * It parses the xml file and all the information present in the xml file stores locally at the start of the\n
+ * application.
+ *
+ */
+
+void MainWindow::parseXml()
+{
+    QString parserString;
+    QFile file("gauge_system_master_1.xml");
+    if(!file.open(QIODevice::ReadOnly) || file.atEnd())
+        return;
+    else
+        parserString = file.readAll();
+
+    QDomDocument dom;
+    if(!dom.setContent(parserString))
+        qDebug()<< "set content failed";
+
+
+    QDomElement docElem = dom.documentElement();
+
+    QDomNode n = docElem.firstChild();
+
+
+    while(!n.isNull()) {
+        QDomElement e = n.toElement(); // try to convert the node to an element.
+
+        if(e.tagName() == "station")
+        {
+
+            if(n.hasChildNodes())
+            {
+                QDomNodeList list = n.childNodes();
+
+                for(int i =0; i < list.size();i++)
+                {
+                    QDomElement element = list.at(i).toElement();
+                    if(element.tagName() == "workcenter_code")
+                    {
+                        m_StationData.m_WorkCenterCode = element.text();
+                    }
+                    if(element.tagName() == "part_no")
+                    {
+                        m_StationData.m_PartNo = element.text();
+                    }
+                    if(element.tagName() == "part_desc")
+                    {
+                        m_StationData.m_PartDesc = element.text();
+                    }
+                    if(element.tagName() == "opn_no")
+                    {
+                        m_StationData.m_Opn_No = element.text();
+                    }
+                    if(element.tagName() == "unique_channel_id")
+                    {
+                        m_StationData.m_Unique_Channel_Id = element.text().toInt();
+                    }
+                    if(element.tagName() == "no_of_parameters")
+                    {
+                        m_StationData.m_No_Of_Parameters = element.text().toInt();
+                    }
+                    if(element.tagName() == "componentId_length")
+                    {
+                        m_StationData.m_componentId_Length = element.text().toInt();
+                    }
+
+                }
+
+            }
+        }
+        else if(e.tagName() == "hardware")
+        {
+
+            if(n.hasChildNodes())
+            {
+                HardwareData data;
+                QDomNodeList list = n.childNodes();
+                for(int i =0; i < list.size();i++)
+                {
+                    QDomElement element = list.at(i).toElement();
+                    if(element.tagName() == "hardware_id")
+                    {
+                        data.m_Hardware_Id = element.text().toInt();
+                    }
+                    if(element.tagName() == "hardware_desc")
+                    {
+                        data.m_Hardware_Desc = element.text();
+                    }
+                    if(element.tagName() == "build")
+                    {
+                        data.m_Build = element.text();
+                    }
+                    if(element.tagName() == "valid_length")
+                    {
+                        data.m_Valid_Length = element.text().toInt();
+                    }
+                    if(element.tagName() == "crop_index")
+                    {
+                        data.m_Crop_Index = element.text().toInt();
+                    }
+                    if(element.tagName() == "crop_length")
+                    {
+                        data.m_Crop_Length = element.text().toInt();
+                    }
+                    if(element.tagName() == "add_value")
+                    {
+                        data.m_AddValue = element.text().toFloat();
+                    }
+                    if(element.tagName() == "baud_rate")
+                    {
+                        data.m_BaudRate = element.text().toInt();
+                    }
+                    if(element.tagName() == "stop_bits")
+                    {
+                        data.m_StopBits = element.text().toInt();
+                    }
+                    if(element.tagName() == "parity")
+                    {
+                        data.m_Parity = element.text();
+                    }
+                    if(element.tagName() == "flow_control")
+                    {
+                        data.m_FlowControl = element.text();
+                    }
+
+                }
+
+                //m_HardwareDataList.push_back(data);
+                m_HardwareDataList.insert(data.m_Hardware_Id,data);
+
+            }
+        }
+        else if(e.tagName() == "parameter")
+        {
+            if(n.hasChildNodes())
+            {
+                QDomNodeList list = n.childNodes();
+                ParameterData data;
+
+                for(int i =0; i < list.size();i++)
+                {
+                    QDomElement element = list.at(i).toElement();
+
+
+                    if(element.tagName() == "parameter_id")
+                    {
+                        data.m_ParameterId = element.text().toInt();
+                    }
+                    if(element.tagName() == "parameter_desc")
+                    {
+                        data.m_ParameterDesc = element.text();
+                    }
+                    if(element.tagName() == "USL")
+                    {
+                        data.m_USL = element.text();
+                    }
+                    if(element.tagName() == "LSL")
+                    {
+                        data.m_LSL = element.text();
+                    }
+                    if(element.tagName() == "target_value")
+                    {
+                        data.m_TargetValue = element.text().toFloat();
+                    }
+                    if(element.tagName() == "UOM")
+                    {
+                        data.m_Uom = element.text();
+                    }
+                    if(element.tagName() == "gauge_no")
+                    {
+                        data.m_GaugeNo = element.text();
+                    }
+                    if(element.tagName() == "old_parameter_id")
+                    {
+                        data.m_OldParamId = element.text().toInt();
+                    }
+                    if(element.tagName() == "image_path")
+                    {
+                        data.m_ImagePath = element.text();
+                    }
+                    if(element.tagName() == "hardware_id")
+                    {
+                        data.m_HardwareId = element.text().toInt();
+                    }
+                    if(element.tagName() == "port")
+                    {
+                        data.m_Port = element.text();
+                    }
+
+                }
+//                m_ParameterDataList.insert(data.m_GaugeNo,data);
+                m_ParameterDataList.push_back(data);
+            }
+        }
+        else if(e.tagName() == "settings")
+        {
+
+            if(n.hasChildNodes())
+            {
+                QDomNodeList list = n.childNodes();
+                for(int i =0; i < list.size();i++)
+                {
+                    QDomElement element = list.at(i).toElement();
+                    if(element.tagName() == "host_name")
+                    {
+                        m_mysqlServerSettings.hostName = element.text();
+                    }
+                    if(element.tagName() == "port_number")
+                    {
+                        m_mysqlServerSettings.portNumber = element.text().toInt();
+                    }
+                    if(element.tagName() == "user_name")
+                    {
+                        m_mysqlServerSettings.userName = element.text();
+                    }
+                    if(element.tagName() == "password")
+                    {
+                        m_mysqlServerSettings.password = element.text();
+                    }
+                    if(element.tagName() == "database_name")
+                    {
+                        m_mysqlServerSettings.databaseName = element.text();
+                    }
+
+                }
+
+            }
+        }
+        else if(e.tagName() == "general")
+        {
+            if(n.hasChildNodes())
+            {
+                QDomNodeList list = n.childNodes();
+                for(int i =0; i < list.size();i++)
+                {
+                    QDomElement element = list.at(i).toElement();
+
+                    if(element.tagName() == "uartread_delay")
+                    {
+                        uartReadDelay = element.text().toInt();
+                    }
+                }
+            }
+        }
+
+        n = n.nextSibling();
+    }
+
+    qDebug() << "Size hardware : " << m_HardwareDataList.size() << " Size param : " << m_ParameterDataList.size();
+
+}
+
+/**
+ * @brief MainWindow::initComPorts This function is called in MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)\n
+ * it opens all the 4 uarts and initializes them so that later in the applcation only read and\n
+ * write takes place. When it fails to open the uarts, the error message is shown before the\n
+ * application starts.
+ */
+
+void MainWindow::initComPorts()
+{
+    qDebug() << "Number of Hardware ports available = 4"
+             << "Hardware ports currently in use = " << m_HardwareDataList.size();
+
+    for(int i = 0; i < COM_PORTS; ++i)
+    {
+        portReadFd[i] = open(hrdwrComPort[i], O_RDONLY | O_NDELAY | O_NOCTTY | O_NONBLOCK);
+
+        if(portReadFd[i] < 0)
+        {
+            qDebug() << "Failed to open COM" << (i + 1);
+            showWarning(QString("Failed to open COM%1").arg((i + 1)));
+        }
+        else
+        {
+            struct termios comPortConfig;
+
+            tcgetattr(portReadFd[i], &comPortConfig);//get the current attributes.
+
+            comPortConfig.c_iflag &= ~(IGNBRK | BRKINT | ICRNL | INLCR);
+            comPortConfig.c_iflag &= ~(PARMRK | INPCK | ISTRIP | IXON);//IXON/IXOFF:no software flow control
+            comPortConfig.c_oflag &= ~(OCRNL | ONLCR | ONLRET | ONOCR);
+            comPortConfig.c_oflag &= ~( OFILL | OLCUC | OPOST);
+            comPortConfig.c_lflag &= ~(ECHO | ECHONL | ICANON | IEXTEN);//non-conical mode.
+            comPortConfig.c_lflag &= ~(ISIG | ECHOK | ECHOCTL | ECHOPRT);
+            comPortConfig.c_cflag &= ~(CSIZE | PARENB);//no parity check.
+            comPortConfig.c_cflag &= ~CRTSCTS;//Turn off hardware flow control(RTS/CTS).
+            comPortConfig.c_cflag |= CS8 | CLOCAL;//CS8:8bit, no parity, 1 stop bit.
+            comPortConfig.c_cflag &= ~CBAUD;
+            comPortConfig.c_cflag |= B2400;
+            comPortConfig.c_cc[VMIN] = 1;
+            comPortConfig.c_cc[VTIME] = 0;
+            tcsetattr(portReadFd[i], TCSANOW, &comPortConfig);
+        }
+    }
+
+}
+
+/**
+ * @brief MainWindow::initRelays It is called in MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)\n
+ * It does the following\n
+ * 1. Exports the gpios connected to relays to use them in user space.\n
+ * 2. Sets the direction of the gpios.\n
+ * 3. Open the the gpios to manipulate the gpio values in the application.
+ */
+
+void MainWindow::initRelays()
+{
+    int fd = open("/sys/class/gpio/export", O_WRONLY);
+    write(fd,"511", 4);
+    ::close(fd);
+
+    fd = open("/sys/class/gpio/export", O_WRONLY);
+    write(fd,"510", 4);
+    ::close(fd);
+
+    fd = open("/sys/class/gpio/export", O_WRONLY);
+    write(fd,"509", 4);
+    ::close(fd);
+
+    fd = open("/sys/class/gpio/export", O_WRONLY);
+    write(fd,"508", 4);
+    ::close(fd);
+
+    fd = open("/sys/class/gpio/gpio511/direction", O_WRONLY);
+    write(fd,"out",4);
+    ::close(fd);
+
+    fd = open("/sys/class/gpio/gpio510/direction", O_WRONLY);
+    write(fd,"out",4);
+    ::close(fd);
+
+    fd = open("/sys/class/gpio/gpio509/direction", O_WRONLY);
+    write(fd,"out",4);
+    ::close(fd);
+
+    fd = open("/sys/class/gpio/gpio508/direction", O_WRONLY);
+    write(fd,"out",4);
+    ::close(fd);
+
+    for(int i = 0; i < COM_PORTS; ++i)
+    {
+        relaysWriteFd[i] = open(relayGpio[i], O_WRONLY);
+
+        if(relaysWriteFd[i] < 0)
+        {
+            qDebug() << "Failed to open Relay" << (i + 1);
+            showWarning(QString("Failed to init Relay%1").arg((i + 1)));
+        }
+    }
+}
+
+/**
+ * @brief MainWindow::fillValues It is called to fill the values from the xml file which are\n
+ * stored locally on the UI whenever new parameter is loaded.\n
+ * Following are the 3 places where the new parameter is loaded and this function is called.\n
+ * 1. Once the component Id is scanned, this function is called in void MainWindow::scannedString(QString str)\n
+ * 2. when NEXT pressed and loading next parameter, in void MainWindow::nextParameterClicked()\n
+ * 3. When PREVIOUS pressed and loading the previous parameter, in void MainWindow::previousClicked().
+ * @param gaugeValue It is the scanned Component Id.
+ */
+
+void MainWindow::fillValues(QString gaugeValue)
+{
+    //ParameterData data = m_ParameterDataList.value(gaugeValue);
+    ParameterData data = *m_ParamDataListIterator;
+
+    m_ParameterData = data;
+    m_HardwareData = m_HardwareDataList.value(m_ParameterData.m_HardwareId);
+    qDebug() << data.m_USL << " " << data.m_LSL << " " << data.m_ParameterDesc << " " <<data.m_ImagePath;
+    m_UpperLimitEdit->setText(data.m_USL);
+    m_LowerLimitEdit->setText(data.m_LSL);
+    m_USLValue = data.m_USL.toFloat();
+    m_LSLValue = data.m_LSL.toFloat();
+    m_lePartDesc->setText(m_StationData.m_PartDesc);
+    m_lePartNumber->setText(m_StationData.m_PartNo);
+
+    m_leParameterDesc->setText(m_ParameterData.m_ParameterDesc);
+
+    ////setting image///
+    int height = m_ItemImageLabel->height();
+    int width = m_ItemImageLabel->width();
+    m_ItemImageLabel->setPixmap(QPixmap(data.m_ImagePath).scaled((width),
+                                                                 (height),
+                                                                 Qt::KeepAspectRatio,
+                                                                 Qt::SmoothTransformation));
+
+    m_ComponentId->setText(gaugeValue);
+    m_SelectedGauge->setText(data.m_GaugeNo);
+    isValidation = true;
+}
+
+/**
+ * @brief MainWindow::getMaxValue It is called in void MainWindow::startCycleClicked() to get\n
+ * the parameter MAX value.\n
+ * It does the following functionalities\n
+ * 1. Makes the relay ON to trigger the Gauging unit to send the packet.\n
+ * 2. Waits for some time before reading the Uart. delay time is inputted though xml file\n
+ * 3. Reads the packet from the uart and checks the packet length with the length given in xml file.\n
+ * 4. If the length matches it crops the value based on details in xml file and returns the value.\n
+ * 5. If length doesnot matches displays the error message.
+ * 6. Makes the relay OFF.
+ * @return float MAX value when packet size is equal to the size given in xml file.\n
+ *         -1 when packet size is not equal or there is no data to read from Gauging unit.
+ */
+
+float MainWindow::getMaxValue()
+{
+    //G6301630
+//    QString str = "C01+052.015\r\n";//Packet from the Gauge unit
+    int serialComPort = m_ParameterData.m_Port.mid(m_ParameterData.m_Port.size() - 1, 1).toInt();
+    float value;
+
+    openComPort(serialComPort);
+
+    write(relaysWriteFd[serialComPort - 1], "1", 2);//saad:relay
+
+    QTime currentTime = QTime::currentTime();
+    while(currentTime.elapsed() <= uartReadDelay);//delay before reading from uart, after switching relay ON
+
+    char buffer[m_HardwareData.m_Valid_Length + 2];
+    ssize_t size = read(portReadFd[serialComPort - 1], buffer,
+            (m_HardwareData.m_Valid_Length + 2));//read along with ('\r' and '\n') and replace it with '\0'.
+    buffer[m_HardwareData.m_Valid_Length] = '\0';
+
+    QString str(buffer);
+    if(size == (m_HardwareData.m_Valid_Length + 2))
+    {
+        qDebug() << "Max read value = " << str << size << buffer;
+        QStringRef subStr(&str,m_HardwareData.m_Crop_Index + 1, m_HardwareData.m_Crop_Length + 1); //for testing to be commented out later
+        QString cropValue = subStr.toString();
+        value = cropValue.toFloat() + m_HardwareData.m_AddValue;
+    }
+    else if(size == -1)
+    {
+        value = -1;
+        qDebug() << "No Data to read from hardware";
+        showWarning(QString("No Data to read from hardware"));
+    }
+    else
+    {
+        qDebug() << "Invalid Max Value Data format";
+        qDebug() << "read value = " << str << size;
+        showWarning(QString("Invalid max value data format"));
+        value = -1;
+    }
+
+    write(relaysWriteFd[serialComPort - 1], "0", 2);//saad:relay
+    closeComPort(serialComPort);
+    return value;
+}
+
+/**
+ * @brief MainWindow::getMaxValue It is called in void MainWindow::startCycleClicked() to get\n
+ * the parameter MIN value.\n
+ * It does the following functionalities\n
+ * 1. Makes the relay ON to trigger the Gauging unit to send the packet.\n
+ * 2. Waits for some time before reading the Uart. delay time is inputted though xml file\n
+ * 3. Reads the packet from the uart and checks the packet length with the length given in xml file.\n
+ * 4. If the length matches it crops the value based on details in xml file and returns the value.\n
+ * 5. If length doesnot matches displays the error message.
+ * 6. Makes the relay OFF.
+ * @return float MIN value when packet size is equal to the size given in xml file.\n
+ *         -1 when packet size is not equal or there is no data to read from Gauging unit.
+ */
+
+float MainWindow::getMinValue()
+{
+//    QString str = "C01+048.001\r\n";//Packet from the Gauge unit
+    float value;
+    int serialComPort = m_ParameterData.m_Port.mid(m_ParameterData.m_Port.size() - 1, 1).toInt();
+    char buffer[m_HardwareData.m_Valid_Length + 2];
+
+    openComPort(serialComPort);
+    write(relaysWriteFd[serialComPort - 1], "1", 2);//saad:relay
+
+    QTime currentTime = QTime::currentTime();
+    while(currentTime.elapsed() <= uartReadDelay);//delay before reading from uart, after switching relay ON
+
+    ssize_t size = read(portReadFd[serialComPort - 1], buffer,
+            (m_HardwareData.m_Valid_Length + 2));//read along with ('\r' and '\n') and replace it with '\0'.
+    buffer[m_HardwareData.m_Valid_Length] = '\0';
+
+    QString str(buffer);
+    if(size == (m_HardwareData.m_Valid_Length + 2))
+    {
+        qDebug() << "Min read value = " << str << size << buffer;
+        QStringRef subStr(&str,m_HardwareData.m_Crop_Index + 1,m_HardwareData.m_Crop_Length + 1); //for testing to be commented out later
+        QString cropValue = subStr.toString();
+        value = cropValue.toFloat() + m_HardwareData.m_AddValue;
+    }
+    else if(size == -1)
+    {
+        value = -1;
+        qDebug() << "No Data to read from hardware";
+        showWarning(QString("No Data to read from hardware"));
+    }
+    else
+    {
+        qDebug() << "Invalid Min Value Data format";
+        qDebug() << "read value = " << str << size;
+        showWarning(QString("Invalid min value data format"));
+        value = -1;
+    }
+
+    write(relaysWriteFd[serialComPort - 1], "0", 2);//saad:relay
+    closeComPort(serialComPort);
+    return value;
+}
+
+/**
+ * @brief MainWindow::clearValues This function clears all the line edits of the UI.\n
+ * And brings the application to Home Screen. This is called when new parameter is loaded\n
+ * or when user wants to ABORT.
+ */
+
+void MainWindow::clearValues()
+{
+    m_MinValueEdit->setStyleSheet("background-color: white");
+    m_MaxValueEdit->setStyleSheet("background-color: white");
+    maxval = 0.0;
+    minval = 0.0;
+    isMax = isMin = isOval = false;
+    m_OvalityEdit->clear();
+    m_MaxValueEdit->clear();
+    m_MinValueEdit->clear();
+    m_lePartDesc->clear();
+    m_lePartNumber->clear();
+    m_ComponentId->clear();
+    m_leParameterDesc->clear();
+    m_SelectedGauge->clear();
+    m_UpperLimitEdit->clear();
+    m_LowerLimitEdit->clear();
+    m_ItemImageLabel->setPixmap(QPixmap(""));
+}
+
+/**
+ * @brief MainWindow::saveValuesToDataBase It is called in void MainWindow::nextParameterClicked()\n
+ * to save the values in mysql database of the current parameter before loading the next parameter.\n
+ * @return True When row is inserted successfully in mysql server table.\n
+ *         false When row insertion fails.
+ */
+
+bool MainWindow::saveValuesToDataBase()
+{
+    bool ret  =  m_DatabaseManager->insertValuesIntoDatabase(m_StationData.m_WorkCenterCode,m_StationData.m_PartNo,m_ComponentId->text(), m_StationData.m_Opn_No,
+                                                             QString::number(m_StationData.m_Unique_Channel_Id),m_ParameterData.m_OldParamId,m_ParameterData.m_GaugeNo
+                                                             ,m_ParameterData.m_USL.toFloat(),m_ParameterData.m_LSL.toFloat(),m_MaxValueEdit->text().toFloat()
+                                                             ,m_MinValueEdit->text().toFloat());
+
+     return ret;
+}
+
+/**
+ * @brief MainWindow::updateTableAndLoadNextParameter It is called in void MainWindow::nextParameterClicked()\n
+ * After the parameter inspection is done and NEXT is pressed it updates the current inspected values on\n
+ * table view and displays the table.
+ * Following are the functionalities it does\n
+ * 1. Updates the m_SqlModel by calling void MySqlTableModel::updateGaugeData(GaugeTableData gaugeData), this function inserts the new rows and
+ *    deletes the old rows.\n
+ * 2. Shows the TableView widget.\n
+ * 3. Then Calls m_TableView->update(m_SqlModel->index(0,0)) which calls void SqlTableDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const\n
+ *    This function changes the colours of the columns to red and green.
+ */
+
+void MainWindow::updateTableAndLoadNextParameter()
+{
+    GaugeTableData data;
+
+    data.m_GaugeName = m_ParameterData.m_GaugeNo;
+    data.m_LSL = m_ParameterData.m_LSL.toFloat();
+    data.m_USL = m_ParameterData.m_USL.toFloat();
+    data.m_MaxVal = m_MaxValueEdit->text().toFloat();
+    data.m_MinVal = m_MinValueEdit->text().toFloat();
+
+    m_SqlModel->updateGaugeData(data);
+    m_StackedWidget->setCurrentWidget(m_TableView);
+    m_TableView->update(m_SqlModel->index(0,0));
+
+    clearValues();
+}
+
+/**
+ * @brief MainWindow::showGraphWithMaxValues This is called in void MainWindow::startCycleClicked()\n
+ * and in void MainWindow::previousClicked().\n
+ * When the focus is on MAX edit it does the following things\n
+ * 1. Sets the X axis and Y axis range.\n
+ * 2. Draws the minimum and maximum line with different colours.\n
+ * 3. Sets graph data with x and y values and plots the graph, both are Qvector arrays with 15 values.\n
+ * 4. Sets the graph view on display and adjusts the view geometry.
+ */
+void MainWindow::showGraphWithMaxValues()
+{
+    m_ChartPlot->xAxis->setRange(0, 16);
+    m_ChartPlot->xAxis->setAutoTicks(false);
+    QVector<double> xAxisSteps;
+    for(int i = 0; i < 17; i++)
+        xAxisSteps.push_back(i);
+    m_ChartPlot->xAxis->setTickVector(xAxisSteps);
+
+    m_ChartPlot->yAxis->setRange((m_ParameterData.m_LSL.toFloat() - 0.005),
+            (m_ParameterData.m_USL.toFloat() + 0.005));
+
+    QPen pen;
+
+    QVector<double> xMin, yMin;//Minimum line
+    xMin.push_back(1.0);
+    xMin.push_back(15.0);
+    yMin.push_back(m_ParameterData.m_LSL.toFloat());
+    yMin.push_back(m_ParameterData.m_LSL.toFloat());//Minimun line
+
+    QVector<double> xMax, yMax;//Maximum line
+    xMax.push_back(1.0);
+    xMax.push_back(15.0);
+    yMax.push_back(m_ParameterData.m_USL.toFloat());
+    yMax.push_back(m_ParameterData.m_USL.toFloat());//Maximum line
+
+    QVector<double> xGraphValues;//graph values
+    for(int i = 0; i < m_MaxGraphValues[m_ParameterIndex].size(); ++i)
+    {
+        xGraphValues.push_back(i + 1);
+    }
+
+    pen.setColor(Qt::magenta);
+    m_ChartPlot->graph(0)->setPen(pen);
+    m_ChartPlot->graph(0)->setData(xMin, yMin);
+
+    pen.setColor(Qt::red);
+    m_ChartPlot->graph(1)->setPen(pen);
+    m_ChartPlot->graph(1)->setData(xMax, yMax);
+
+    pen.setColor(Qt::blue);
+    m_ChartPlot->graph(2)->setPen(pen);
+    m_ChartPlot->graph(2)->setData(xGraphValues, m_MaxGraphValues[m_ParameterIndex]);
+
+    m_ChartPlot->replot();
+
+    m_StackedWidget->setCurrentWidget(m_ChartView);
+    m_ChartPlot->setGeometry(m_ChartView->x() + 10, m_ChartView->y() + 10,
+                             m_ChartView->width() - 10, m_ChartView->height() -10);
+}
+
+/**
+ * @brief MainWindow::showGraphWithMinValues This is called in void MainWindow::startCycleClicked()\n
+ * and in void MainWindow::previousClicked().\n
+ * When the focus is on MIN edit it does the following things\n
+ * 1. Sets the X axis and Y axis range.\n
+ * 2. Draws the minimum and maximum line with different colours.\n
+ * 3. Sets graph data with x and y values and plots the graph, both are Qvector arrays with 15 values.\n
+ * 4. Sets the graph view on display and adjusts the view geometry.
+ */
+
+void MainWindow::showGraphWithMinValues()
+{
+    m_ChartPlot->xAxis->setRange(0, 16);
+    m_ChartPlot->xAxis->setAutoTicks(false);
+    QVector<double> xAxisSteps;
+    for(int i = 0; i < 17; i++)
+        xAxisSteps.push_back(i);
+    m_ChartPlot->xAxis->setTickVector(xAxisSteps);
+
+    m_ChartPlot->yAxis->setRange((m_ParameterData.m_LSL.toFloat() - 0.005),
+            (m_ParameterData.m_USL.toFloat() + 0.005));
+
+    QPen pen;
+
+    QVector<double> xMin, yMin;//Minimum line
+    xMin.push_back(1.0);
+    xMin.push_back(15.0);
+    yMin.push_back(m_ParameterData.m_LSL.toFloat());
+    yMin.push_back(m_ParameterData.m_LSL.toFloat());//Minimun line
+
+    QVector<double> xMax, yMax;//Maximum line
+    xMax.push_back(1.0);
+    xMax.push_back(15.0);
+    yMax.push_back(m_ParameterData.m_USL.toFloat());
+    yMax.push_back(m_ParameterData.m_USL.toFloat());//Maximum line
+
+    QVector<double> xGraphValues;
+    for(int i = 0; i < m_MinGraphValues[m_ParameterIndex].size(); ++i)
+    {
+        xGraphValues.push_back(i + 1);
+    }
+
+    pen.setColor(Qt::magenta);
+    m_ChartPlot->graph(0)->setPen(pen);
+    m_ChartPlot->graph(0)->setData(xMin, yMin);
+
+    pen.setColor(Qt::red);
+    m_ChartPlot->graph(1)->setPen(pen);
+    m_ChartPlot->graph(1)->setData(xMax, yMax);
+
+    pen.setColor(Qt::blue);
+    m_ChartPlot->graph(2)->setPen(pen);
+    m_ChartPlot->graph(2)->setData(xGraphValues, m_MinGraphValues[m_ParameterIndex]);
+
+    m_ChartPlot->replot();
+
+    m_StackedWidget->setCurrentWidget(m_ChartView);
+    m_ChartPlot->setGeometry(m_ChartView->x() + 10, m_ChartView->y() + 10,
+                             m_ChartView->width() - 10, m_ChartView->height() - 10);
+
+}
+
+/**
+ * @brief MainWindow::updateDataDataBase Not being used in the application.
+ * @param tabledata
+ */
+
+void MainWindow::updateDataDataBase(QList<GaugeTableData> tabledata)
+{
+    m_GaugeTableData.clear();
+    m_GaugeTableData = tabledata;
+}
+
+/**
+ * @brief MainWindow::showWarning This function pops up the window and shows the error message\n
+ * It is being called in many function to display the error. It shows the message for mentioned\n
+ * number of milli seconds and gets hidden after that.
+ * @param text Error String
+ * @param mSec Message pop up(display) time in milli seconds, by default delay is 2 seconds.
+ */
+
+void MainWindow::showWarning(QString text, int mSec)
+{
+    QMessageBox msgBox(this);
+    msgBox.setStandardButtons(0);
+    msgBox.setWindowFlags(Qt::Dialog);
+    msgBox.setIcon(QMessageBox::Warning);
+    msgBox.setStyleSheet("background-color : grey; color : red");
+    msgBox.setWindowTitle(QString("Error!"));
+    msgBox.setText(text);
+    QTimer::singleShot(mSec, &msgBox, SLOT(accept()));
+    msgBox.exec();
+}
+
+/**
+ * @brief MainWindow::keyPressEvent This function catches the 4 gpio push button press events.\n
+ * Based on the button pressed it calls the respective function.
+ * @param keyEvent Specifies key pressed.
+ */
+
+void MainWindow::keyPressEvent(QKeyEvent *keyEvent)
+{
+    qDebug() << "In KeyPressEvent" << "key = " << keyEvent->key() << keyEvent->text();
+
+#ifdef __arm__
+    if(keyEvent->key() == Qt::Key_F1)
+    {
+        this->startCycleClicked();
+    }
+    else if (keyEvent->key() == Qt::Key_F2)
+    {
+        this->nextParameterClicked();
+    }
+    else if(keyEvent->key() == Qt::Key_F3)
+    {
+        this->previousClicked();
+    }
+    else if(keyEvent->key() == Qt::Key_F4)
+    {
+        this->abortCycleClicked();
+    }
+#else
+    if(keyEvent->key() == Tvs::StartCycle)
+    {
+        this->startCycleClicked();
+    }
+    else if (keyEvent->key() == Tvs::NextParameter)
+    {
+        this->nextParameterClicked();
+    }
+    else if(keyEvent->key() == Tvs::Previous)
+    {
+        this->previousClicked();
+    }
+    else if(keyEvent->key() == Tvs::Abort)
+    {
+        this->abortCycleClicked();
+    }
+#endif
+}
+
+/**
+ * @brief MainWindow::eventFilter This function is called to filter key presses when the\n
+ * Enter Component Id window is visible to avoid the key entry in the window line edit. \n
+ * When returned TRUE event is filtered, when returned FALSE event is not filtered and it reaches to the object.
+ * @param object Current object which is focussed.
+ * @param event QEvent on the focussed object.
+ * @return TRUE when 4 gpio push buttons pressed when the focus is on Enter Component Id window\n
+ *              line edit.\n
+ *         FALSE When focus is not on Enter Component Id window\n
+ *               line edit.\n
+ */
+
+bool MainWindow::eventFilter(QObject *object, QEvent *event)
+{
+
+    if (event->type() == QEvent::KeyPress)
+    {
+        if(object->objectName() == "leComponentId")
+        {
+            QKeyEvent *keyEvent = static_cast<QKeyEvent *>(event);
+#ifdef __arm__
+
+            if (keyEvent->key() == Qt::Key_F1)
+            {
+                qDebug("In MainWindow::eventFilter-KEY_S pressed");
+                return true;
+            }
+            else if (keyEvent->key() == Qt::Key_F2)
+            {
+                qDebug("In MainWindow::eventFilter-KEY_N pressed");
+                return true;
+            }
+            else if (keyEvent->key() == Qt::Key_F3)
+            {
+                qDebug("In MainWindow::eventFilter-KEY_P pressed");
+                return true;
+            }
+            else if (keyEvent->key() == Qt::Key_F4)
+            {
+                qDebug("In MainWindow::eventFilter-KEY_A pressed");
+                isValidation = false;
+                m_dlgComponentId->closeDialog();
+                isCompIdDialogVisible = false;
+                this->centralWidget()->setFocus();
+                return true;
+            }
+
+#else
+            if (keyEvent->key() == Qt::Key_S)
+            {
+                qDebug("In MainWindow::eventFilter-KEY_S pressed");
+                return true;
+            }
+            else if (keyEvent->key() == Qt::Key_N)
+            {
+                qDebug("In MainWindow::eventFilter-KEY_N pressed");
+                return true;
+            }
+            else if (keyEvent->key() == Qt::Key_P)
+            {
+                qDebug("In MainWindow::eventFilter-KEY_P pressed");
+                return true;
+            }
+            else if (keyEvent->key() == Qt::Key_A)
+            {
+                qDebug("In MainWindow::eventFilter-KEY_A pressed");
+                isValidation = false;
+                m_dlgComponentId->closeDialog();
+                isCompIdDialogVisible = false;
+                this->centralWidget()->setFocus();
+                return true;
+            }
+#endif
+        }
+
+    }
+
+    return false;
+}
+
diff --git a/meta-services/recipes-services/lcd-app/files/mainwindow.h b/meta-services/recipes-services/lcd-app/files/mainwindow.h
new file mode 100644
index 0000000..bd46e85
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/mainwindow.h
@@ -0,0 +1,189 @@
+#ifndef MAINWINDOW_H
+#define MAINWINDOW_H
+
+#include <QMainWindow>
+#include <QBoxLayout>
+#include <QGridLayout>
+#include <QFrame>
+#include <QWidget>
+#include <QStackedWidget>
+#include <QLineEdit>
+#include <QPushButton>
+#include <QLabel>
+#include <QDebug>
+#include <QGroupBox>
+#include <QInputDialog>
+#include <QTableView>
+#include <QSqlTableModel>
+#include <QDomElement>
+#include <QList>
+#include <QMap>
+#include<QHash>
+#include<QVector>
+#include "qcustomplot.h"
+//#include <QtCharts>
+//#include <QChartView>
+//#include <QChart>
+
+#include "mysqltablemodel.h"
+#include "gaugedatabasemanager.h"
+#include<componentdialog.h>
+
+#include <unistd.h>
+#include <fcntl.h>
+#include<include.h>
+
+#define COM_PORTS 4
+
+/**
+ * @brief The StationData class is the user defined class, which stores station details given\n
+ * in the xml file.
+ */
+class StationData
+{
+public:
+    QString m_WorkCenterCode;//Stores the station unique id.
+    QString m_PartNo;//Stores the part number which comes on the station.
+    QString m_PartDesc;//Stores the part name(description) which comes on the station.
+    QString m_Opn_No;//
+    int   m_Unique_Channel_Id;//
+    int   m_No_Of_Parameters;//Number of parameters to be inspected on the station.
+    int   m_componentId_Length;//Length of the each component id.
+};
+
+/**
+ * @brief The HardwareData class is the user defined class, which stores the Hardware details given\n
+ * in xml file.
+ */
+
+class HardwareData{
+
+public:
+    int m_Hardware_Id;//Stores the Id of the Gauging System
+    QString m_Hardware_Desc;//Stores Gauging System description
+    QString m_Build;//Build name
+    int m_Valid_Length;//Specifies the data packet length sent by the Gauging System
+    int m_Crop_Index;//Specifies the index at which the data should be extracted from the packet.
+    int m_Crop_Length;//Specifies the number of digits from the m_Crop_Index to be extracted from the packet.
+    float m_AddValue;//value that should be added to the data extracted from the packet sent by the Gauging unit.
+    int m_BaudRate;//Specifies the Baud rate at which the Gauging unit communicates.
+    int m_StopBits;//Gauging unit stop bits.
+    QString m_Parity;//parity details of the Gauging unit.
+    QString m_FlowControl;//Flow control information of the Gauging unit.
+};
+
+/**
+ * @brief The ParameterData class is the user defined class, stores the Parameter details given\n
+ * in xml file.
+ */
+
+class ParameterData{
+public:
+    int m_ParameterId;//Each parameter unique id.
+    QString m_ParameterDesc;//Each parameter description
+    QString m_USL;//
+    QString m_LSL;//
+    float m_TargetValue;//
+    QString m_Uom;//
+    QString m_GaugeNo;//
+    int m_OldParamId;//
+    QString m_ImagePath;//Contains the parameter image path.
+    int m_HardwareId;//Stores hardware Id
+    QString m_Port;//Tells the board COM port number to which the hardware is connected.
+
+};
+
+/**
+ * @brief The MainWindow class is the UI interaction class. More details and the functionalities
+ * are described on  each method of the class.
+ */
+
+class MainWindow : public QMainWindow
+{
+    Q_OBJECT
+
+public:
+    MainWindow(QWidget *parent = 0);
+    ~MainWindow();
+
+    bool eventFilter(QObject *object, QEvent *event);
+
+private slots:
+    void openComPort(int comPort);
+    void closeComPort(int comPort);
+
+    void startCycleClicked();
+    void nextParameterClicked();
+    void previousClicked();
+    void abortCycleClicked();
+    void scannedString(QString str);
+
+  private:
+
+    void parseXml();
+    void initComPorts();
+    void initRelays();
+    void fillValues(QString gaugeValue);
+    float getMaxValue();
+    float getMinValue();
+    bool saveValuesToDataBase();
+    void updateTableAndLoadNextParameter();
+    void showGraphWithMinValues();
+    void showGraphWithMaxValues();
+    void clearValues();
+
+public slots:
+    void updateDataDataBase(QList<GaugeTableData> tabledata);
+    void showWarning(QString text, int mSec = 2000);
+
+protected:
+    void keyPressEvent(QKeyEvent *keyEvent);
+
+
+private:
+    QStackedWidget *m_StackedWidget;
+    QLineEdit *m_lePartDesc;
+    QLineEdit *m_lePartNumber;
+    QLineEdit *m_ComponentId;
+    QLineEdit *m_leParameterDesc;
+    QLineEdit *m_SelectedGauge;
+    QLineEdit *m_MinValueEdit;
+    QLineEdit *m_MaxValueEdit;
+    QLineEdit *m_LowerLimitEdit;
+    QLineEdit *m_UpperLimitEdit;
+    QLineEdit *m_OvalityEdit;
+    QLabel *m_ItemImageLabel;
+    QTableView *m_TableView;
+    MySqlTableModel *m_SqlModel;
+    QString m_ScannedComponentId;
+    StationData m_StationData;
+    QVector<ParameterData> m_ParameterDataList;
+    QHash<int,HardwareData> m_HardwareDataList;
+    QVector<ParameterData>::Iterator m_ParamDataListIterator;
+    int m_ParameterIndex;
+    QVector< QVector<double> > m_MaxGraphValues;
+    QVector< QVector<double> > m_MinGraphValues;
+    bool isValidation;
+    float m_USLValue;
+    float m_LSLValue;
+    bool isMin,isMax,isOval;
+
+    QWidget *m_ChartView;
+    QCustomPlot *m_ChartPlot;
+    ParameterData m_ParameterData;
+    HardwareData m_HardwareData;
+    float maxval,minval;
+    GaugeDatabaseManager *m_DatabaseManager;
+    QList<GaugeTableData> m_GaugeTableData;
+    serverSettings m_mysqlServerSettings;
+
+    ComponentDialog *m_dlgComponentId;
+    bool isCompIdDialogVisible;
+
+    int portReadFd[COM_PORTS];
+    int relaysWriteFd[COM_PORTS];//Number of Relays == Number of Serial ports
+
+    int uartReadDelay;
+};
+
+#endif // MAINWINDOW_H
diff --git a/meta-services/recipes-services/lcd-app/files/mysqltablemodel.cpp b/meta-services/recipes-services/lcd-app/files/mysqltablemodel.cpp
new file mode 100644
index 0000000..455cd7c
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/mysqltablemodel.cpp
@@ -0,0 +1,151 @@
+#include "mysqltablemodel.h"
+#include <QDebug>
+Q_DECLARE_METATYPE(GaugeTableData)
+Q_DECLARE_METATYPE(QList<GaugeTableData> )
+
+/**
+ * @brief MySqlTableModel::MySqlTableModel This is the MySqlTableModel Constructor whereever this\n
+ * class instance is created it gets called and in header it creates 5 columns for the Tableview.\n
+ * qRegisterMetaType is called to register our data type in QVariant.
+ */
+MySqlTableModel::MySqlTableModel()
+{
+    qRegisterMetaType<GaugeTableData>();
+    qRegisterMetaType< QList<GaugeTableData> >();
+
+    m_noOfParameters = 0;
+    m_GaugeTableData.clear();
+    m_HeaderList << "Gauge" << "USL" << "Actual 1" << "Actual 2 " << "LSL";
+
+}
+
+/**
+ * @brief MySqlTableModel::rowCount While subclassing QAbstractItemModel this should be defined.
+ * Not in use now.
+ * @param parent
+ * @return Number of rows in table.
+ */
+
+int MySqlTableModel::rowCount(const QModelIndex &parent) const
+{
+    return m_GaugeTableData.size();
+}
+
+/**
+ * @brief MySqlTableModel::columnCount While subclassing QAbstractItemModel this should be defined.\n
+ * Not in use now.
+ * @param parent
+ * @return Number of columns in table.
+ */
+
+int MySqlTableModel::columnCount(const QModelIndex &parent) const
+{
+    return m_HeaderList.size();
+}
+
+/**
+ * @brief MySqlTableModel::data This function is called by void SqlTableDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const\n
+ * to get the values by specifying the role.
+ * @param idx QModelIndex(Table index)
+ * @param role Specifies the columns in the table.
+ * @return return QVariant based on the role.
+ */
+
+QVariant MySqlTableModel::data(const QModelIndex &idx, int role) const
+{
+    GaugeTableData tableData = m_GaugeTableData.at(idx.row());
+
+    if(role == Qt::DisplayRole)
+    {
+        return tableData.m_GaugeName;
+    }
+    else if(role == Tvs::USLRole)
+    {
+        return tableData.m_USL;
+    }
+    else if(role == Tvs::MaxValRole)
+    {
+        return tableData.m_MaxVal;
+    }
+    else if(role == Tvs::MinValRole)
+    {
+        return tableData.m_MinVal;
+    }
+    else if(role == Tvs::LSLRole)
+    {
+        return tableData.m_LSL;
+    }
+
+    return QVariant();
+}
+
+/**
+ * @brief MySqlTableModel::headerData Not in use.
+ * @param section
+ * @param orientation
+ * @param role
+ * @return
+ */
+
+QVariant MySqlTableModel::headerData(int section, Qt::Orientation orientation, int role) const
+{
+    if (role != Qt::DisplayRole)
+        return QVariant();
+
+    if (orientation == Qt::Horizontal)
+        return m_HeaderList.at(section);
+    else
+        return QString("%1").arg(section+1);
+}
+
+/**
+ * @brief MySqlTableModel::updateGaugeData Called in void MainWindow::updateTableAndLoadNextParameter()\n
+ * when NEXT is pressed to update the rows in the table.
+ * @param gaugeData
+ */
+
+void MySqlTableModel::updateGaugeData(GaugeTableData gaugeData)
+{
+    if(m_GaugeTableData.size() >= m_noOfParameters)//saad:Tableview can store and display maximum of 9 rows
+    {        
+        m_GaugeTableData.clear();
+
+        this->beginRemoveRows(QModelIndex(), 0, (m_noOfParameters - 1));
+        this->endRemoveRows();
+    }
+
+    this->beginInsertRows(QModelIndex(),m_GaugeTableData.size(),m_GaugeTableData.size()) ;
+    m_GaugeTableData.push_back(gaugeData);
+    this->endInsertRows();
+}
+
+/**
+ * @brief MySqlTableModel::setNumberOfParameters It is a setter called in MainWindow Constructor.
+ * @param parameters
+ */
+void MySqlTableModel::setNumberOfParameters(int parameters)
+{
+    this->m_noOfParameters = parameters;
+}
+
+void MySqlTableModel::removeGaugeDataRow()
+{
+    if(!m_GaugeTableData.isEmpty())
+    {
+
+
+        this->beginRemoveRows(QModelIndex(), (m_GaugeTableData.size() - 1), (m_GaugeTableData.size() - 1));
+        this->endRemoveRows();
+        m_GaugeTableData.pop_back();
+    }
+}
+
+void MySqlTableModel::abortTableRows()
+{
+    if(!m_GaugeTableData.isEmpty())
+    {
+        this->beginRemoveRows(QModelIndex(), 0, (m_GaugeTableData.size() - 1));
+        this->endRemoveRows();
+        m_GaugeTableData.clear();
+    }
+}
diff --git a/meta-services/recipes-services/lcd-app/files/mysqltablemodel.h b/meta-services/recipes-services/lcd-app/files/mysqltablemodel.h
new file mode 100644
index 0000000..10b8c27
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/mysqltablemodel.h
@@ -0,0 +1,43 @@
+#ifndef MYSQLTABLEMODEL_H
+#define MYSQLTABLEMODEL_H
+
+#include <QObject>
+#include <QSqlTableModel>
+#include <QAbstractTableModel>
+#include <QStringList>
+#include <QList>
+#include "include.h"
+#include "gaugedata.h"
+
+/**
+ * @brief The MySqlTableModel class This class is the user defined class which inherits QabstractTableModel. \n
+ * This model is used to represent the database table items in a table view.\n
+ *
+ */
+
+class MySqlTableModel : public QAbstractTableModel
+{
+    Q_OBJECT
+public:
+    MySqlTableModel();
+    int rowCount(const QModelIndex &parent) const;
+    int columnCount(const QModelIndex &parent) const;
+    QVariant data(const QModelIndex &idx, int role) const;
+    QVariant headerData(int section, Qt::Orientation orientation, int role) const;
+
+private:
+
+    QStringList m_HeaderList;
+    QList<GaugeTableData> m_GaugeTableData;
+    int m_noOfParameters;
+
+public :
+
+    void updateGaugeData(GaugeTableData gaugeData);
+    void setNumberOfParameters(int parameters);
+    void removeGaugeDataRow();
+    void abortTableRows();
+
+};
+
+#endif // MYSQLTABLEMODEL_H
diff --git a/meta-services/recipes-services/lcd-app/files/qcustomplot.cpp b/meta-services/recipes-services/lcd-app/files/qcustomplot.cpp
new file mode 100644
index 0000000..3086082
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/qcustomplot.cpp
@@ -0,0 +1,23553 @@
+/***************************************************************************
+**                                                                        **
+**  QCustomPlot, an easy to use, modern plotting widget for Qt            **
+**  Copyright (C) 2011-2015 Emanuel Eichhammer                            **
+**                                                                        **
+**  This program is free software: you can redistribute it and/or modify  **
+**  it under the terms of the GNU General Public License as published by  **
+**  the Free Software Foundation, either version 3 of the License, or     **
+**  (at your option) any later version.                                   **
+**                                                                        **
+**  This program is distributed in the hope that it will be useful,       **
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of        **
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         **
+**  GNU General Public License for more details.                          **
+**                                                                        **
+**  You should have received a copy of the GNU General Public License     **
+**  along with this program.  If not, see http://www.gnu.org/licenses/.   **
+**                                                                        **
+****************************************************************************
+**           Author: Emanuel Eichhammer                                   **
+**  Website/Contact: http://www.qcustomplot.com/                          **
+**             Date: 22.12.15                                             **
+**          Version: 1.3.2                                                **
+****************************************************************************/
+
+#include "qcustomplot.h"
+
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPPainter
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPPainter
+  \brief QPainter subclass used internally
+  
+  This QPainter subclass is used to provide some extended functionality e.g. for tweaking position
+  consistency between antialiased and non-antialiased painting. Further it provides workarounds
+  for QPainter quirks.
+  
+  \warning This class intentionally hides non-virtual functions of QPainter, e.g. setPen, save and
+  restore. So while it is possible to pass a QCPPainter instance to a function that expects a
+  QPainter pointer, some of the workarounds and tweaks will be unavailable to the function (because
+  it will call the base class implementations of the functions actually hidden by QCPPainter).
+*/
+
+/*!
+  Creates a new QCPPainter instance and sets default values
+*/
+QCPPainter::QCPPainter() :
+  QPainter(),
+  mModes(pmDefault),
+  mIsAntialiasing(false)
+{
+  // don't setRenderHint(QPainter::NonCosmeticDefautPen) here, because painter isn't active yet and
+  // a call to begin() will follow
+}
+
+/*!
+  Creates a new QCPPainter instance on the specified paint \a device and sets default values. Just
+  like the analogous QPainter constructor, begins painting on \a device immediately.
+  
+  Like \ref begin, this method sets QPainter::NonCosmeticDefaultPen in Qt versions before Qt5.
+*/
+QCPPainter::QCPPainter(QPaintDevice *device) :
+  QPainter(device),
+  mModes(pmDefault),
+  mIsAntialiasing(false)
+{
+#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0) // before Qt5, default pens used to be cosmetic if NonCosmeticDefaultPen flag isn't set. So we set it to get consistency across Qt versions.
+  if (isActive())
+    setRenderHint(QPainter::NonCosmeticDefaultPen);
+#endif
+}
+
+QCPPainter::~QCPPainter()
+{
+}
+
+/*!
+  Sets the pen of the painter and applies certain fixes to it, depending on the mode of this
+  QCPPainter.
+  
+  \note this function hides the non-virtual base class implementation.
+*/
+void QCPPainter::setPen(const QPen &pen)
+{
+  QPainter::setPen(pen);
+  if (mModes.testFlag(pmNonCosmetic))
+    makeNonCosmetic();
+}
+
+/*! \overload
+  
+  Sets the pen (by color) of the painter and applies certain fixes to it, depending on the mode of
+  this QCPPainter.
+  
+  \note this function hides the non-virtual base class implementation.
+*/
+void QCPPainter::setPen(const QColor &color)
+{
+  QPainter::setPen(color);
+  if (mModes.testFlag(pmNonCosmetic))
+    makeNonCosmetic();
+}
+
+/*! \overload
+  
+  Sets the pen (by style) of the painter and applies certain fixes to it, depending on the mode of
+  this QCPPainter.
+  
+  \note this function hides the non-virtual base class implementation.
+*/
+void QCPPainter::setPen(Qt::PenStyle penStyle)
+{
+  QPainter::setPen(penStyle);
+  if (mModes.testFlag(pmNonCosmetic))
+    makeNonCosmetic();
+}
+
+/*! \overload
+  
+  Works around a Qt bug introduced with Qt 4.8 which makes drawing QLineF unpredictable when
+  antialiasing is disabled. Thus when antialiasing is disabled, it rounds the \a line to
+  integer coordinates and then passes it to the original drawLine.
+  
+  \note this function hides the non-virtual base class implementation.
+*/
+void QCPPainter::drawLine(const QLineF &line)
+{
+  if (mIsAntialiasing || mModes.testFlag(pmVectorized))
+    QPainter::drawLine(line);
+  else
+    QPainter::drawLine(line.toLine());
+}
+
+/*!
+  Sets whether painting uses antialiasing or not. Use this method instead of using setRenderHint
+  with QPainter::Antialiasing directly, as it allows QCPPainter to regain pixel exactness between
+  antialiased and non-antialiased painting (Since Qt < 5.0 uses slightly different coordinate systems for
+  AA/Non-AA painting).
+*/
+void QCPPainter::setAntialiasing(bool enabled)
+{
+  setRenderHint(QPainter::Antialiasing, enabled);
+  if (mIsAntialiasing != enabled)
+  {
+    mIsAntialiasing = enabled;
+    if (!mModes.testFlag(pmVectorized)) // antialiasing half-pixel shift only needed for rasterized outputs
+    {
+      if (mIsAntialiasing)
+        translate(0.5, 0.5);
+      else
+        translate(-0.5, -0.5);
+    }
+  }
+}
+
+/*!
+  Sets the mode of the painter. This controls whether the painter shall adjust its
+  fixes/workarounds optimized for certain output devices.
+*/
+void QCPPainter::setModes(QCPPainter::PainterModes modes)
+{
+  mModes = modes;
+}
+
+/*!
+  Sets the QPainter::NonCosmeticDefaultPen in Qt versions before Qt5 after beginning painting on \a
+  device. This is necessary to get cosmetic pen consistency across Qt versions, because since Qt5,
+  all pens are non-cosmetic by default, and in Qt4 this render hint must be set to get that
+  behaviour.
+  
+  The Constructor \ref QCPPainter(QPaintDevice *device) which directly starts painting also sets
+  the render hint as appropriate.
+  
+  \note this function hides the non-virtual base class implementation.
+*/
+bool QCPPainter::begin(QPaintDevice *device)
+{
+  bool result = QPainter::begin(device);
+#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0) // before Qt5, default pens used to be cosmetic if NonCosmeticDefaultPen flag isn't set. So we set it to get consistency across Qt versions.
+  if (result)
+    setRenderHint(QPainter::NonCosmeticDefaultPen);
+#endif
+  return result;
+}
+
+/*! \overload
+  
+  Sets the mode of the painter. This controls whether the painter shall adjust its
+  fixes/workarounds optimized for certain output devices.
+*/
+void QCPPainter::setMode(QCPPainter::PainterMode mode, bool enabled)
+{
+  if (!enabled && mModes.testFlag(mode))
+    mModes &= ~mode;
+  else if (enabled && !mModes.testFlag(mode))
+    mModes |= mode;
+}
+
+/*!
+  Saves the painter (see QPainter::save). Since QCPPainter adds some new internal state to
+  QPainter, the save/restore functions are reimplemented to also save/restore those members.
+  
+  \note this function hides the non-virtual base class implementation.
+  
+  \see restore
+*/
+void QCPPainter::save()
+{
+  mAntialiasingStack.push(mIsAntialiasing);
+  QPainter::save();
+}
+
+/*!
+  Restores the painter (see QPainter::restore). Since QCPPainter adds some new internal state to
+  QPainter, the save/restore functions are reimplemented to also save/restore those members.
+  
+  \note this function hides the non-virtual base class implementation.
+  
+  \see save
+*/
+void QCPPainter::restore()
+{
+  if (!mAntialiasingStack.isEmpty())
+    mIsAntialiasing = mAntialiasingStack.pop();
+  else
+    qDebug() << Q_FUNC_INFO << "Unbalanced save/restore";
+  QPainter::restore();
+}
+
+/*!
+  Changes the pen width to 1 if it currently is 0. This function is called in the \ref setPen
+  overrides when the \ref pmNonCosmetic mode is set.
+*/
+void QCPPainter::makeNonCosmetic()
+{
+  if (qFuzzyIsNull(pen().widthF()))
+  {
+    QPen p = pen();
+    p.setWidth(1);
+    QPainter::setPen(p);
+  }
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPScatterStyle
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPScatterStyle
+  \brief Represents the visual appearance of scatter points
+  
+  This class holds information about shape, color and size of scatter points. In plottables like
+  QCPGraph it is used to store how scatter points shall be drawn. For example, \ref
+  QCPGraph::setScatterStyle takes a QCPScatterStyle instance.
+  
+  A scatter style consists of a shape (\ref setShape), a line color (\ref setPen) and possibly a
+  fill (\ref setBrush), if the shape provides a fillable area. Further, the size of the shape can
+  be controlled with \ref setSize.
+
+  \section QCPScatterStyle-defining Specifying a scatter style
+  
+  You can set all these configurations either by calling the respective functions on an instance:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpscatterstyle-creation-1
+  
+  Or you can use one of the various constructors that take different parameter combinations, making
+  it easy to specify a scatter style in a single call, like so:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpscatterstyle-creation-2
+  
+  \section QCPScatterStyle-undefinedpen Leaving the color/pen up to the plottable
+  
+  There are two constructors which leave the pen undefined: \ref QCPScatterStyle() and \ref
+  QCPScatterStyle(ScatterShape shape, double size). If those constructors are used, a call to \ref
+  isPenDefined will return false. It leads to scatter points that inherit the pen from the
+  plottable that uses the scatter style. Thus, if such a scatter style is passed to QCPGraph, the line
+  color of the graph (\ref QCPGraph::setPen) will be used by the scatter points. This makes
+  it very convenient to set up typical scatter settings:
+  
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpscatterstyle-shortcreation
+
+  Notice that it wasn't even necessary to explicitly call a QCPScatterStyle constructor. This works
+  because QCPScatterStyle provides a constructor that can transform a \ref ScatterShape directly
+  into a QCPScatterStyle instance (that's the \ref QCPScatterStyle(ScatterShape shape, double size)
+  constructor with a default for \a size). In those cases, C++ allows directly supplying a \ref
+  ScatterShape, where actually a QCPScatterStyle is expected.
+  
+  \section QCPScatterStyle-custompath-and-pixmap Custom shapes and pixmaps
+  
+  QCPScatterStyle supports drawing custom shapes and arbitrary pixmaps as scatter points.
+
+  For custom shapes, you can provide a QPainterPath with the desired shape to the \ref
+  setCustomPath function or call the constructor that takes a painter path. The scatter shape will
+  automatically be set to \ref ssCustom.
+  
+  For pixmaps, you call \ref setPixmap with the desired QPixmap. Alternatively you can use the
+  constructor that takes a QPixmap. The scatter shape will automatically be set to \ref ssPixmap.
+  Note that \ref setSize does not influence the appearance of the pixmap.
+*/
+
+/* start documentation of inline functions */
+
+/*! \fn bool QCPScatterStyle::isNone() const
+  
+  Returns whether the scatter shape is \ref ssNone.
+  
+  \see setShape
+*/
+
+/*! \fn bool QCPScatterStyle::isPenDefined() const
+  
+  Returns whether a pen has been defined for this scatter style.
+  
+  The pen is undefined if a constructor is called that does not carry \a pen as parameter. Those are
+  \ref QCPScatterStyle() and \ref QCPScatterStyle(ScatterShape shape, double size). If the pen is
+  left undefined, the scatter color will be inherited from the plottable that uses this scatter
+  style.
+  
+  \see setPen
+*/
+
+/* end documentation of inline functions */
+
+/*!
+  Creates a new QCPScatterStyle instance with size set to 6. No shape, pen or brush is defined.
+  
+  Since the pen is undefined (\ref isPenDefined returns false), the scatter color will be inherited
+  from the plottable that uses this scatter style.
+*/
+QCPScatterStyle::QCPScatterStyle() :
+  mSize(6),
+  mShape(ssNone),
+  mPen(Qt::NoPen),
+  mBrush(Qt::NoBrush),
+  mPenDefined(false)
+{
+}
+
+/*!
+  Creates a new QCPScatterStyle instance with shape set to \a shape and size to \a size. No pen or
+  brush is defined.
+  
+  Since the pen is undefined (\ref isPenDefined returns false), the scatter color will be inherited
+  from the plottable that uses this scatter style.
+*/
+QCPScatterStyle::QCPScatterStyle(ScatterShape shape, double size) :
+  mSize(size),
+  mShape(shape),
+  mPen(Qt::NoPen),
+  mBrush(Qt::NoBrush),
+  mPenDefined(false)
+{
+}
+
+/*!
+  Creates a new QCPScatterStyle instance with shape set to \a shape, the pen color set to \a color,
+  and size to \a size. No brush is defined, i.e. the scatter point will not be filled.
+*/
+QCPScatterStyle::QCPScatterStyle(ScatterShape shape, const QColor &color, double size) :
+  mSize(size),
+  mShape(shape),
+  mPen(QPen(color)),
+  mBrush(Qt::NoBrush),
+  mPenDefined(true)
+{
+}
+
+/*!
+  Creates a new QCPScatterStyle instance with shape set to \a shape, the pen color set to \a color,
+  the brush color to \a fill (with a solid pattern), and size to \a size.
+*/
+QCPScatterStyle::QCPScatterStyle(ScatterShape shape, const QColor &color, const QColor &fill, double size) :
+  mSize(size),
+  mShape(shape),
+  mPen(QPen(color)),
+  mBrush(QBrush(fill)),
+  mPenDefined(true)
+{
+}
+
+/*!
+  Creates a new QCPScatterStyle instance with shape set to \a shape, the pen set to \a pen, the
+  brush to \a brush, and size to \a size.
+  
+  \warning In some cases it might be tempting to directly use a pen style like <tt>Qt::NoPen</tt> as \a pen
+  and a color like <tt>Qt::blue</tt> as \a brush. Notice however, that the corresponding call\n
+  <tt>QCPScatterStyle(QCPScatterShape::ssCircle, Qt::NoPen, Qt::blue, 5)</tt>\n
+  doesn't necessarily lead C++ to use this constructor in some cases, but might mistake
+  <tt>Qt::NoPen</tt> for a QColor and use the
+  \ref QCPScatterStyle(ScatterShape shape, const QColor &color, const QColor &fill, double size)
+  constructor instead (which will lead to an unexpected look of the scatter points). To prevent
+  this, be more explicit with the parameter types. For example, use <tt>QBrush(Qt::blue)</tt>
+  instead of just <tt>Qt::blue</tt>, to clearly point out to the compiler that this constructor is
+  wanted.
+*/
+QCPScatterStyle::QCPScatterStyle(ScatterShape shape, const QPen &pen, const QBrush &brush, double size) :
+  mSize(size),
+  mShape(shape),
+  mPen(pen),
+  mBrush(brush),
+  mPenDefined(pen.style() != Qt::NoPen)
+{
+}
+
+/*!
+  Creates a new QCPScatterStyle instance which will show the specified \a pixmap. The scatter shape
+  is set to \ref ssPixmap.
+*/
+QCPScatterStyle::QCPScatterStyle(const QPixmap &pixmap) :
+  mSize(5),
+  mShape(ssPixmap),
+  mPen(Qt::NoPen),
+  mBrush(Qt::NoBrush),
+  mPixmap(pixmap),
+  mPenDefined(false)
+{
+}
+
+/*!
+  Creates a new QCPScatterStyle instance with a custom shape that is defined via \a customPath. The
+  scatter shape is set to \ref ssCustom.
+  
+  The custom shape line will be drawn with \a pen and filled with \a brush. The size has a slightly
+  different meaning than for built-in scatter points: The custom path will be drawn scaled by a
+  factor of \a size/6.0. Since the default \a size is 6, the custom path will appear at a its
+  natural size by default. To double the size of the path for example, set \a size to 12.
+*/
+QCPScatterStyle::QCPScatterStyle(const QPainterPath &customPath, const QPen &pen, const QBrush &brush, double size) :
+  mSize(size),
+  mShape(ssCustom),
+  mPen(pen),
+  mBrush(brush),
+  mCustomPath(customPath),
+  mPenDefined(pen.style() != Qt::NoPen)
+{
+}
+
+/*!
+  Sets the size (pixel diameter) of the drawn scatter points to \a size.
+  
+  \see setShape
+*/
+void QCPScatterStyle::setSize(double size)
+{
+  mSize = size;
+}
+
+/*!
+  Sets the shape to \a shape.
+  
+  Note that the calls \ref setPixmap and \ref setCustomPath automatically set the shape to \ref
+  ssPixmap and \ref ssCustom, respectively.
+  
+  \see setSize
+*/
+void QCPScatterStyle::setShape(QCPScatterStyle::ScatterShape shape)
+{
+  mShape = shape;
+}
+
+/*!
+  Sets the pen that will be used to draw scatter points to \a pen.
+  
+  If the pen was previously undefined (see \ref isPenDefined), the pen is considered defined after
+  a call to this function, even if \a pen is <tt>Qt::NoPen</tt>.
+  
+  \see setBrush
+*/
+void QCPScatterStyle::setPen(const QPen &pen)
+{
+  mPenDefined = true;
+  mPen = pen;
+}
+
+/*!
+  Sets the brush that will be used to fill scatter points to \a brush. Note that not all scatter
+  shapes have fillable areas. For example, \ref ssPlus does not while \ref ssCircle does.
+  
+  \see setPen
+*/
+void QCPScatterStyle::setBrush(const QBrush &brush)
+{
+  mBrush = brush;
+}
+
+/*!
+  Sets the pixmap that will be drawn as scatter point to \a pixmap.
+  
+  Note that \ref setSize does not influence the appearance of the pixmap.
+  
+  The scatter shape is automatically set to \ref ssPixmap.
+*/
+void QCPScatterStyle::setPixmap(const QPixmap &pixmap)
+{
+  setShape(ssPixmap);
+  mPixmap = pixmap;
+}
+
+/*!
+  Sets the custom shape that will be drawn as scatter point to \a customPath.
+  
+  The scatter shape is automatically set to \ref ssCustom.
+*/
+void QCPScatterStyle::setCustomPath(const QPainterPath &customPath)
+{
+  setShape(ssCustom);
+  mCustomPath = customPath;
+}
+
+/*!
+  Applies the pen and the brush of this scatter style to \a painter. If this scatter style has an
+  undefined pen (\ref isPenDefined), sets the pen of \a painter to \a defaultPen instead.
+  
+  This function is used by plottables (or any class that wants to draw scatters) just before a
+  number of scatters with this style shall be drawn with the \a painter.
+  
+  \see drawShape
+*/
+void QCPScatterStyle::applyTo(QCPPainter *painter, const QPen &defaultPen) const
+{
+  painter->setPen(mPenDefined ? mPen : defaultPen);
+  painter->setBrush(mBrush);
+}
+
+/*!
+  Draws the scatter shape with \a painter at position \a pos.
+  
+  This function does not modify the pen or the brush on the painter, as \ref applyTo is meant to be
+  called before scatter points are drawn with \ref drawShape.
+  
+  \see applyTo
+*/
+void QCPScatterStyle::drawShape(QCPPainter *painter, QPointF pos) const
+{
+  drawShape(painter, pos.x(), pos.y());
+}
+
+/*! \overload
+  Draws the scatter shape with \a painter at position \a x and \a y.
+*/
+void QCPScatterStyle::drawShape(QCPPainter *painter, double x, double y) const
+{
+  double w = mSize/2.0;
+  switch (mShape)
+  {
+    case ssNone: break;
+    case ssDot:
+    {
+      painter->drawLine(QPointF(x, y), QPointF(x+0.0001, y));
+      break;
+    }
+    case ssCross:
+    {
+      painter->drawLine(QLineF(x-w, y-w, x+w, y+w));
+      painter->drawLine(QLineF(x-w, y+w, x+w, y-w));
+      break;
+    }
+    case ssPlus:
+    {
+      painter->drawLine(QLineF(x-w,   y, x+w,   y));
+      painter->drawLine(QLineF(  x, y+w,   x, y-w));
+      break;
+    }
+    case ssCircle:
+    {
+      painter->drawEllipse(QPointF(x , y), w, w);
+      break;
+    }
+    case ssDisc:
+    {
+      QBrush b = painter->brush();
+      painter->setBrush(painter->pen().color());
+      painter->drawEllipse(QPointF(x , y), w, w);
+      painter->setBrush(b);
+      break;
+    }
+    case ssSquare:
+    {
+      painter->drawRect(QRectF(x-w, y-w, mSize, mSize));
+      break;
+    }
+    case ssDiamond:
+    {
+      painter->drawLine(QLineF(x-w,   y,   x, y-w));
+      painter->drawLine(QLineF(  x, y-w, x+w,   y));
+      painter->drawLine(QLineF(x+w,   y,   x, y+w));
+      painter->drawLine(QLineF(  x, y+w, x-w,   y));
+      break;
+    }
+    case ssStar:
+    {
+      painter->drawLine(QLineF(x-w,   y, x+w,   y));
+      painter->drawLine(QLineF(  x, y+w,   x, y-w));
+      painter->drawLine(QLineF(x-w*0.707, y-w*0.707, x+w*0.707, y+w*0.707));
+      painter->drawLine(QLineF(x-w*0.707, y+w*0.707, x+w*0.707, y-w*0.707));
+      break;
+    }
+    case ssTriangle:
+    {
+       painter->drawLine(QLineF(x-w, y+0.755*w, x+w, y+0.755*w));
+       painter->drawLine(QLineF(x+w, y+0.755*w,   x, y-0.977*w));
+       painter->drawLine(QLineF(  x, y-0.977*w, x-w, y+0.755*w));
+      break;
+    }
+    case ssTriangleInverted:
+    {
+       painter->drawLine(QLineF(x-w, y-0.755*w, x+w, y-0.755*w));
+       painter->drawLine(QLineF(x+w, y-0.755*w,   x, y+0.977*w));
+       painter->drawLine(QLineF(  x, y+0.977*w, x-w, y-0.755*w));
+      break;
+    }
+    case ssCrossSquare:
+    {
+       painter->drawLine(QLineF(x-w, y-w, x+w*0.95, y+w*0.95));
+       painter->drawLine(QLineF(x-w, y+w*0.95, x+w*0.95, y-w));
+       painter->drawRect(QRectF(x-w, y-w, mSize, mSize));
+      break;
+    }
+    case ssPlusSquare:
+    {
+       painter->drawLine(QLineF(x-w,   y, x+w*0.95,   y));
+       painter->drawLine(QLineF(  x, y+w,        x, y-w));
+       painter->drawRect(QRectF(x-w, y-w, mSize, mSize));
+      break;
+    }
+    case ssCrossCircle:
+    {
+       painter->drawLine(QLineF(x-w*0.707, y-w*0.707, x+w*0.670, y+w*0.670));
+       painter->drawLine(QLineF(x-w*0.707, y+w*0.670, x+w*0.670, y-w*0.707));
+       painter->drawEllipse(QPointF(x, y), w, w);
+      break;
+    }
+    case ssPlusCircle:
+    {
+       painter->drawLine(QLineF(x-w,   y, x+w,   y));
+       painter->drawLine(QLineF(  x, y+w,   x, y-w));
+       painter->drawEllipse(QPointF(x, y), w, w);
+      break;
+    }
+    case ssPeace:
+    {
+       painter->drawLine(QLineF(x, y-w,         x,       y+w));
+       painter->drawLine(QLineF(x,   y, x-w*0.707, y+w*0.707));
+       painter->drawLine(QLineF(x,   y, x+w*0.707, y+w*0.707));
+       painter->drawEllipse(QPointF(x, y), w, w);
+      break;
+    }
+    case ssPixmap:
+    {
+      painter->drawPixmap(x-mPixmap.width()*0.5, y-mPixmap.height()*0.5, mPixmap);
+      break;
+    }
+    case ssCustom:
+    {
+      QTransform oldTransform = painter->transform();
+      painter->translate(x, y);
+      painter->scale(mSize/6.0, mSize/6.0);
+      painter->drawPath(mCustomPath);
+      painter->setTransform(oldTransform);
+      break;
+    }
+  }
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPLayer
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPLayer
+  \brief A layer that may contain objects, to control the rendering order
+  
+  The Layering system of QCustomPlot is the mechanism to control the rendering order of the
+  elements inside the plot.
+  
+  It is based on the two classes QCPLayer and QCPLayerable. QCustomPlot holds an ordered list of
+  one or more instances of QCPLayer (see QCustomPlot::addLayer, QCustomPlot::layer,
+  QCustomPlot::moveLayer, etc.). When replotting, QCustomPlot goes through the list of layers
+  bottom to top and successively draws the layerables of the layers.
+  
+  A QCPLayer contains an ordered list of QCPLayerable instances. QCPLayerable is an abstract base
+  class from which almost all visible objects derive, like axes, grids, graphs, items, etc.
+  
+  Initially, QCustomPlot has five layers: "background", "grid", "main", "axes" and "legend" (in
+  that order). The top two layers "axes" and "legend" contain the default axes and legend, so they
+  will be drawn on top. In the middle, there is the "main" layer. It is initially empty and set as
+  the current layer (see QCustomPlot::setCurrentLayer). This means, all new plottables, items etc.
+  are created on this layer by default. Then comes the "grid" layer which contains the QCPGrid
+  instances (which belong tightly to QCPAxis, see \ref QCPAxis::grid). The Axis rect background
+  shall be drawn behind everything else, thus the default QCPAxisRect instance is placed on the
+  "background" layer. Of course, the layer affiliation of the individual objects can be changed as
+  required (\ref QCPLayerable::setLayer).
+  
+  Controlling the ordering of objects is easy: Create a new layer in the position you want it to
+  be, e.g. above "main", with QCustomPlot::addLayer. Then set the current layer with
+  QCustomPlot::setCurrentLayer to that new layer and finally create the objects normally. They will
+  be placed on the new layer automatically, due to the current layer setting. Alternatively you
+  could have also ignored the current layer setting and just moved the objects with
+  QCPLayerable::setLayer to the desired layer after creating them.
+  
+  It is also possible to move whole layers. For example, If you want the grid to be shown in front
+  of all plottables/items on the "main" layer, just move it above "main" with
+  QCustomPlot::moveLayer.
+  
+  The rendering order within one layer is simply by order of creation or insertion. The item
+  created last (or added last to the layer), is drawn on top of all other objects on that layer.
+  
+  When a layer is deleted, the objects on it are not deleted with it, but fall on the layer below
+  the deleted layer, see QCustomPlot::removeLayer.
+*/
+
+/* start documentation of inline functions */
+
+/*! \fn QList<QCPLayerable*> QCPLayer::children() const
+  
+  Returns a list of all layerables on this layer. The order corresponds to the rendering order:
+  layerables with higher indices are drawn above layerables with lower indices.
+*/
+
+/*! \fn int QCPLayer::index() const
+  
+  Returns the index this layer has in the QCustomPlot. The index is the integer number by which this layer can be
+  accessed via \ref QCustomPlot::layer.
+  
+  Layers with higher indices will be drawn above layers with lower indices.
+*/
+
+/* end documentation of inline functions */
+
+/*!
+  Creates a new QCPLayer instance.
+  
+  Normally you shouldn't directly instantiate layers, use \ref QCustomPlot::addLayer instead.
+  
+  \warning It is not checked that \a layerName is actually a unique layer name in \a parentPlot.
+  This check is only performed by \ref QCustomPlot::addLayer.
+*/
+QCPLayer::QCPLayer(QCustomPlot *parentPlot, const QString &layerName) :
+  QObject(parentPlot),
+  mParentPlot(parentPlot),
+  mName(layerName),
+  mIndex(-1), // will be set to a proper value by the QCustomPlot layer creation function
+  mVisible(true)
+{
+  // Note: no need to make sure layerName is unique, because layer
+  // management is done with QCustomPlot functions.
+}
+
+QCPLayer::~QCPLayer()
+{
+  // If child layerables are still on this layer, detach them, so they don't try to reach back to this
+  // then invalid layer once they get deleted/moved themselves. This only happens when layers are deleted
+  // directly, like in the QCustomPlot destructor. (The regular layer removal procedure for the user is to
+  // call QCustomPlot::removeLayer, which moves all layerables off this layer before deleting it.)
+  
+  while (!mChildren.isEmpty())
+    mChildren.last()->setLayer(0); // removes itself from mChildren via removeChild()
+  
+  if (mParentPlot->currentLayer() == this)
+    qDebug() << Q_FUNC_INFO << "The parent plot's mCurrentLayer will be a dangling pointer. Should have been set to a valid layer or 0 beforehand.";
+}
+
+/*!
+  Sets whether this layer is visible or not. If \a visible is set to false, all layerables on this
+  layer will be invisible.
+
+  This function doesn't change the visibility property of the layerables (\ref
+  QCPLayerable::setVisible), but the \ref QCPLayerable::realVisibility of each layerable takes the
+  visibility of the parent layer into account.
+*/
+void QCPLayer::setVisible(bool visible)
+{
+  mVisible = visible;
+}
+
+/*! \internal
+  
+  Adds the \a layerable to the list of this layer. If \a prepend is set to true, the layerable will
+  be prepended to the list, i.e. be drawn beneath the other layerables already in the list.
+  
+  This function does not change the \a mLayer member of \a layerable to this layer. (Use
+  QCPLayerable::setLayer to change the layer of an object, not this function.)
+  
+  \see removeChild
+*/
+void QCPLayer::addChild(QCPLayerable *layerable, bool prepend)
+{
+  if (!mChildren.contains(layerable))
+  {
+    if (prepend)
+      mChildren.prepend(layerable);
+    else
+      mChildren.append(layerable);
+  } else
+    qDebug() << Q_FUNC_INFO << "layerable is already child of this layer" << reinterpret_cast<quintptr>(layerable);
+}
+
+/*! \internal
+  
+  Removes the \a layerable from the list of this layer.
+  
+  This function does not change the \a mLayer member of \a layerable. (Use QCPLayerable::setLayer
+  to change the layer of an object, not this function.)
+  
+  \see addChild
+*/
+void QCPLayer::removeChild(QCPLayerable *layerable)
+{
+  if (!mChildren.removeOne(layerable))
+    qDebug() << Q_FUNC_INFO << "layerable is not child of this layer" << reinterpret_cast<quintptr>(layerable);
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPLayerable
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPLayerable
+  \brief Base class for all drawable objects
+  
+  This is the abstract base class most visible objects derive from, e.g. plottables, axes, grid
+  etc.
+
+  Every layerable is on a layer (QCPLayer) which allows controlling the rendering order by stacking
+  the layers accordingly.
+  
+  For details about the layering mechanism, see the QCPLayer documentation.
+*/
+
+/* start documentation of inline functions */
+
+/*! \fn QCPLayerable *QCPLayerable::parentLayerable() const
+ 
+  Returns the parent layerable of this layerable. The parent layerable is used to provide
+  visibility hierarchies in conjunction with the method \ref realVisibility. This way, layerables
+  only get drawn if their parent layerables are visible, too.
+  
+  Note that a parent layerable is not necessarily also the QObject parent for memory management.
+  Further, a layerable doesn't always have a parent layerable, so this function may return 0.
+  
+  A parent layerable is set implicitly with when placed inside layout elements and doesn't need to be
+  set manually by the user.
+*/
+
+/* end documentation of inline functions */
+/* start documentation of pure virtual functions */
+
+/*! \fn virtual void QCPLayerable::applyDefaultAntialiasingHint(QCPPainter *painter) const = 0
+  \internal
+  
+  This function applies the default antialiasing setting to the specified \a painter, using the
+  function \ref applyAntialiasingHint. It is the antialiasing state the painter is put in, when
+  \ref draw is called on the layerable. If the layerable has multiple entities whose antialiasing
+  setting may be specified individually, this function should set the antialiasing state of the
+  most prominent entity. In this case however, the \ref draw function usually calls the specialized
+  versions of this function before drawing each entity, effectively overriding the setting of the
+  default antialiasing hint.
+  
+  <b>First example:</b> QCPGraph has multiple entities that have an antialiasing setting: The graph
+  line, fills, scatters and error bars. Those can be configured via QCPGraph::setAntialiased,
+  QCPGraph::setAntialiasedFill, QCPGraph::setAntialiasedScatters etc. Consequently, there isn't
+  only the QCPGraph::applyDefaultAntialiasingHint function (which corresponds to the graph line's
+  antialiasing), but specialized ones like QCPGraph::applyFillAntialiasingHint and
+  QCPGraph::applyScattersAntialiasingHint. So before drawing one of those entities, QCPGraph::draw
+  calls the respective specialized applyAntialiasingHint function.
+  
+  <b>Second example:</b> QCPItemLine consists only of a line so there is only one antialiasing
+  setting which can be controlled with QCPItemLine::setAntialiased. (This function is inherited by
+  all layerables. The specialized functions, as seen on QCPGraph, must be added explicitly to the
+  respective layerable subclass.) Consequently it only has the normal
+  QCPItemLine::applyDefaultAntialiasingHint. The \ref QCPItemLine::draw function doesn't need to
+  care about setting any antialiasing states, because the default antialiasing hint is already set
+  on the painter when the \ref draw function is called, and that's the state it wants to draw the
+  line with.
+*/
+
+/*! \fn virtual void QCPLayerable::draw(QCPPainter *painter) const = 0
+  \internal
+  
+  This function draws the layerable with the specified \a painter. It is only called by
+  QCustomPlot, if the layerable is visible (\ref setVisible).
+  
+  Before this function is called, the painter's antialiasing state is set via \ref
+  applyDefaultAntialiasingHint, see the documentation there. Further, the clipping rectangle was
+  set to \ref clipRect.
+*/
+
+/* end documentation of pure virtual functions */
+/* start documentation of signals */
+
+/*! \fn void QCPLayerable::layerChanged(QCPLayer *newLayer);
+  
+  This signal is emitted when the layer of this layerable changes, i.e. this layerable is moved to
+  a different layer.
+  
+  \see setLayer
+*/
+
+/* end documentation of signals */
+
+/*!
+  Creates a new QCPLayerable instance.
+  
+  Since QCPLayerable is an abstract base class, it can't be instantiated directly. Use one of the
+  derived classes.
+  
+  If \a plot is provided, it automatically places itself on the layer named \a targetLayer. If \a
+  targetLayer is an empty string, it places itself on the current layer of the plot (see \ref
+  QCustomPlot::setCurrentLayer).
+  
+  It is possible to provide 0 as \a plot. In that case, you should assign a parent plot at a later
+  time with \ref initializeParentPlot.
+  
+  The layerable's parent layerable is set to \a parentLayerable, if provided. Direct layerable
+  parents are mainly used to control visibility in a hierarchy of layerables. This means a
+  layerable is only drawn, if all its ancestor layerables are also visible. Note that \a
+  parentLayerable does not become the QObject-parent (for memory management) of this layerable, \a
+  plot does. It is not uncommon to set the QObject-parent to something else in the constructors of
+  QCPLayerable subclasses, to guarantee a working destruction hierarchy.
+*/
+QCPLayerable::QCPLayerable(QCustomPlot *plot, QString targetLayer, QCPLayerable *parentLayerable) :
+  QObject(plot),
+  mVisible(true),
+  mParentPlot(plot),
+  mParentLayerable(parentLayerable),
+  mLayer(0),
+  mAntialiased(true)
+{
+  if (mParentPlot)
+  {
+    if (targetLayer.isEmpty())
+      setLayer(mParentPlot->currentLayer());
+    else if (!setLayer(targetLayer))
+      qDebug() << Q_FUNC_INFO << "setting QCPlayerable initial layer to" << targetLayer << "failed.";
+  }
+}
+
+QCPLayerable::~QCPLayerable()
+{
+  if (mLayer)
+  {
+    mLayer->removeChild(this);
+    mLayer = 0;
+  }
+}
+
+/*!
+  Sets the visibility of this layerable object. If an object is not visible, it will not be drawn
+  on the QCustomPlot surface, and user interaction with it (e.g. click and selection) is not
+  possible.
+*/
+void QCPLayerable::setVisible(bool on)
+{
+  mVisible = on;
+}
+
+/*!
+  Sets the \a layer of this layerable object. The object will be placed on top of the other objects
+  already on \a layer.
+  
+  If \a layer is 0, this layerable will not be on any layer and thus not appear in the plot (or
+  interact/receive events).
+  
+  Returns true if the layer of this layerable was successfully changed to \a layer.
+*/
+bool QCPLayerable::setLayer(QCPLayer *layer)
+{
+  return moveToLayer(layer, false);
+}
+
+/*! \overload
+  Sets the layer of this layerable object by name
+  
+  Returns true on success, i.e. if \a layerName is a valid layer name.
+*/
+bool QCPLayerable::setLayer(const QString &layerName)
+{
+  if (!mParentPlot)
+  {
+    qDebug() << Q_FUNC_INFO << "no parent QCustomPlot set";
+    return false;
+  }
+  if (QCPLayer *layer = mParentPlot->layer(layerName))
+  {
+    return setLayer(layer);
+  } else
+  {
+    qDebug() << Q_FUNC_INFO << "there is no layer with name" << layerName;
+    return false;
+  }
+}
+
+/*!
+  Sets whether this object will be drawn antialiased or not.
+  
+  Note that antialiasing settings may be overridden by QCustomPlot::setAntialiasedElements and
+  QCustomPlot::setNotAntialiasedElements.
+*/
+void QCPLayerable::setAntialiased(bool enabled)
+{
+  mAntialiased = enabled;
+}
+
+/*!
+  Returns whether this layerable is visible, taking the visibility of the layerable parent and the
+  visibility of the layer this layerable is on into account. This is the method that is consulted
+  to decide whether a layerable shall be drawn or not.
+  
+  If this layerable has a direct layerable parent (usually set via hierarchies implemented in
+  subclasses, like in the case of QCPLayoutElement), this function returns true only if this
+  layerable has its visibility set to true and the parent layerable's \ref realVisibility returns
+  true.
+  
+  If this layerable doesn't have a direct layerable parent, returns the state of this layerable's
+  visibility.
+*/
+bool QCPLayerable::realVisibility() const
+{
+  return mVisible && (!mLayer || mLayer->visible()) && (!mParentLayerable || mParentLayerable.data()->realVisibility());
+}
+
+/*!
+  This function is used to decide whether a click hits a layerable object or not.
+
+  \a pos is a point in pixel coordinates on the QCustomPlot surface. This function returns the
+  shortest pixel distance of this point to the object. If the object is either invisible or the
+  distance couldn't be determined, -1.0 is returned. Further, if \a onlySelectable is true and the
+  object is not selectable, -1.0 is returned, too.
+
+  If the object is represented not by single lines but by an area like a \ref QCPItemText or the
+  bars of a \ref QCPBars plottable, a click inside the area should also be considered a hit. In
+  these cases this function thus returns a constant value greater zero but still below the parent
+  plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).
+  
+  Providing a constant value for area objects allows selecting line objects even when they are
+  obscured by such area objects, by clicking close to the lines (i.e. closer than
+  0.99*selectionTolerance).
+  
+  The actual setting of the selection state is not done by this function. This is handled by the
+  parent QCustomPlot when the mouseReleaseEvent occurs, and the finally selected object is notified
+  via the selectEvent/deselectEvent methods.
+  
+  \a details is an optional output parameter. Every layerable subclass may place any information
+  in \a details. This information will be passed to \ref selectEvent when the parent QCustomPlot
+  decides on the basis of this selectTest call, that the object was successfully selected. The
+  subsequent call to \ref selectEvent will carry the \a details. This is useful for multi-part
+  objects (like QCPAxis). This way, a possibly complex calculation to decide which part was clicked
+  is only done once in \ref selectTest. The result (i.e. the actually clicked part) can then be
+  placed in \a details. So in the subsequent \ref selectEvent, the decision which part was
+  selected doesn't have to be done a second time for a single selection operation.
+  
+  You may pass 0 as \a details to indicate that you are not interested in those selection details.
+  
+  \see selectEvent, deselectEvent, QCustomPlot::setInteractions
+*/
+double QCPLayerable::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(pos)
+  Q_UNUSED(onlySelectable)
+  Q_UNUSED(details)
+  return -1.0;
+}
+
+/*! \internal
+  
+  Sets the parent plot of this layerable. Use this function once to set the parent plot if you have
+  passed 0 in the constructor. It can not be used to move a layerable from one QCustomPlot to
+  another one.
+  
+  Note that, unlike when passing a non-null parent plot in the constructor, this function does not
+  make \a parentPlot the QObject-parent of this layerable. If you want this, call
+  QObject::setParent(\a parentPlot) in addition to this function.
+  
+  Further, you will probably want to set a layer (\ref setLayer) after calling this function, to
+  make the layerable appear on the QCustomPlot.
+  
+  The parent plot change will be propagated to subclasses via a call to \ref parentPlotInitialized
+  so they can react accordingly (e.g. also initialize the parent plot of child layerables, like
+  QCPLayout does).
+*/
+void QCPLayerable::initializeParentPlot(QCustomPlot *parentPlot)
+{
+  if (mParentPlot)
+  {
+    qDebug() << Q_FUNC_INFO << "called with mParentPlot already initialized";
+    return;
+  }
+  
+  if (!parentPlot)
+    qDebug() << Q_FUNC_INFO << "called with parentPlot zero";
+  
+  mParentPlot = parentPlot;
+  parentPlotInitialized(mParentPlot);
+}
+
+/*! \internal
+  
+  Sets the parent layerable of this layerable to \a parentLayerable. Note that \a parentLayerable does not
+  become the QObject-parent (for memory management) of this layerable.
+  
+  The parent layerable has influence on the return value of the \ref realVisibility method. Only
+  layerables with a fully visible parent tree will return true for \ref realVisibility, and thus be
+  drawn.
+  
+  \see realVisibility
+*/
+void QCPLayerable::setParentLayerable(QCPLayerable *parentLayerable)
+{
+  mParentLayerable = parentLayerable;
+}
+
+/*! \internal
+  
+  Moves this layerable object to \a layer. If \a prepend is true, this object will be prepended to
+  the new layer's list, i.e. it will be drawn below the objects already on the layer. If it is
+  false, the object will be appended.
+  
+  Returns true on success, i.e. if \a layer is a valid layer.
+*/
+bool QCPLayerable::moveToLayer(QCPLayer *layer, bool prepend)
+{
+  if (layer && !mParentPlot)
+  {
+    qDebug() << Q_FUNC_INFO << "no parent QCustomPlot set";
+    return false;
+  }
+  if (layer && layer->parentPlot() != mParentPlot)
+  {
+    qDebug() << Q_FUNC_INFO << "layer" << layer->name() << "is not in same QCustomPlot as this layerable";
+    return false;
+  }
+  
+  QCPLayer *oldLayer = mLayer;
+  if (mLayer)
+    mLayer->removeChild(this);
+  mLayer = layer;
+  if (mLayer)
+    mLayer->addChild(this, prepend);
+  if (mLayer != oldLayer)
+    emit layerChanged(mLayer);
+  return true;
+}
+
+/*! \internal
+
+  Sets the QCPainter::setAntialiasing state on the provided \a painter, depending on the \a
+  localAntialiased value as well as the overrides \ref QCustomPlot::setAntialiasedElements and \ref
+  QCustomPlot::setNotAntialiasedElements. Which override enum this function takes into account is
+  controlled via \a overrideElement.
+*/
+void QCPLayerable::applyAntialiasingHint(QCPPainter *painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const
+{
+  if (mParentPlot && mParentPlot->notAntialiasedElements().testFlag(overrideElement))
+    painter->setAntialiasing(false);
+  else if (mParentPlot && mParentPlot->antialiasedElements().testFlag(overrideElement))
+    painter->setAntialiasing(true);
+  else
+    painter->setAntialiasing(localAntialiased);
+}
+
+/*! \internal
+
+  This function is called by \ref initializeParentPlot, to allow subclasses to react on the setting
+  of a parent plot. This is the case when 0 was passed as parent plot in the constructor, and the
+  parent plot is set at a later time.
+  
+  For example, QCPLayoutElement/QCPLayout hierarchies may be created independently of any
+  QCustomPlot at first. When they are then added to a layout inside the QCustomPlot, the top level
+  element of the hierarchy gets its parent plot initialized with \ref initializeParentPlot. To
+  propagate the parent plot to all the children of the hierarchy, the top level element then uses
+  this function to pass the parent plot on to its child elements.
+  
+  The default implementation does nothing.
+  
+  \see initializeParentPlot
+*/
+void QCPLayerable::parentPlotInitialized(QCustomPlot *parentPlot)
+{
+   Q_UNUSED(parentPlot)
+}
+
+/*! \internal
+
+  Returns the selection category this layerable shall belong to. The selection category is used in
+  conjunction with \ref QCustomPlot::setInteractions to control which objects are selectable and
+  which aren't.
+  
+  Subclasses that don't fit any of the normal \ref QCP::Interaction values can use \ref
+  QCP::iSelectOther. This is what the default implementation returns.
+  
+  \see QCustomPlot::setInteractions
+*/
+QCP::Interaction QCPLayerable::selectionCategory() const
+{
+  return QCP::iSelectOther;
+}
+
+/*! \internal
+  
+  Returns the clipping rectangle of this layerable object. By default, this is the viewport of the
+  parent QCustomPlot. Specific subclasses may reimplement this function to provide different
+  clipping rects.
+  
+  The returned clipping rect is set on the painter before the draw function of the respective
+  object is called.
+*/
+QRect QCPLayerable::clipRect() const
+{
+  if (mParentPlot)
+    return mParentPlot->viewport();
+  else
+    return QRect();
+}
+
+/*! \internal
+  
+  This event is called when the layerable shall be selected, as a consequence of a click by the
+  user. Subclasses should react to it by setting their selection state appropriately. The default
+  implementation does nothing.
+  
+  \a event is the mouse event that caused the selection. \a additive indicates, whether the user
+  was holding the multi-select-modifier while performing the selection (see \ref
+  QCustomPlot::setMultiSelectModifier). if \a additive is true, the selection state must be toggled
+  (i.e. become selected when unselected and unselected when selected).
+  
+  Every selectEvent is preceded by a call to \ref selectTest, which has returned positively (i.e.
+  returned a value greater than 0 and less than the selection tolerance of the parent QCustomPlot).
+  The \a details data you output from \ref selectTest is fed back via \a details here. You may
+  use it to transport any kind of information from the selectTest to the possibly subsequent
+  selectEvent. Usually \a details is used to transfer which part was clicked, if it is a layerable
+  that has multiple individually selectable parts (like QCPAxis). This way selectEvent doesn't need
+  to do the calculation again to find out which part was actually clicked.
+  
+  \a selectionStateChanged is an output parameter. If the pointer is non-null, this function must
+  set the value either to true or false, depending on whether the selection state of this layerable
+  was actually changed. For layerables that only are selectable as a whole and not in parts, this
+  is simple: if \a additive is true, \a selectionStateChanged must also be set to true, because the
+  selection toggles. If \a additive is false, \a selectionStateChanged is only set to true, if the
+  layerable was previously unselected and now is switched to the selected state.
+  
+  \see selectTest, deselectEvent
+*/
+void QCPLayerable::selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)
+{
+  Q_UNUSED(event)
+  Q_UNUSED(additive)
+  Q_UNUSED(details)
+  Q_UNUSED(selectionStateChanged)
+}
+
+/*! \internal
+  
+  This event is called when the layerable shall be deselected, either as consequence of a user
+  interaction or a call to \ref QCustomPlot::deselectAll. Subclasses should react to it by
+  unsetting their selection appropriately.
+  
+  just as in \ref selectEvent, the output parameter \a selectionStateChanged (if non-null), must
+  return true or false when the selection state of this layerable has changed or not changed,
+  respectively.
+  
+  \see selectTest, selectEvent
+*/
+void QCPLayerable::deselectEvent(bool *selectionStateChanged)
+{
+  Q_UNUSED(selectionStateChanged)
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPRange
+////////////////////////////////////////////////////////////////////////////////////////////////////
+/*! \class QCPRange
+  \brief Represents the range an axis is encompassing.
+  
+  contains a \a lower and \a upper double value and provides convenience input, output and
+  modification functions.
+  
+  \see QCPAxis::setRange
+*/
+
+/*!
+  Minimum range size (\a upper - \a lower) the range changing functions will accept. Smaller
+  intervals would cause errors due to the 11-bit exponent of double precision numbers,
+  corresponding to a minimum magnitude of roughly 1e-308.
+  \see validRange, maxRange
+*/
+const double QCPRange::minRange = 1e-280;
+
+/*!
+  Maximum values (negative and positive) the range will accept in range-changing functions.
+  Larger absolute values would cause errors due to the 11-bit exponent of double precision numbers,
+  corresponding to a maximum magnitude of roughly 1e308.
+  Since the number of planck-volumes in the entire visible universe is only ~1e183, this should
+  be enough.
+  \see validRange, minRange
+*/
+const double QCPRange::maxRange = 1e250;
+
+/*!
+  Constructs a range with \a lower and \a upper set to zero.
+*/
+QCPRange::QCPRange() :
+  lower(0),
+  upper(0)
+{
+}
+
+/*! \overload
+  Constructs a range with the specified \a lower and \a upper values.
+*/
+QCPRange::QCPRange(double lower, double upper) :
+  lower(lower),
+  upper(upper)
+{
+  normalize();
+}
+
+/*!
+  Returns the size of the range, i.e. \a upper-\a lower
+*/
+double QCPRange::size() const
+{
+  return upper-lower;
+}
+
+/*!
+  Returns the center of the range, i.e. (\a upper+\a lower)*0.5
+*/
+double QCPRange::center() const
+{
+  return (upper+lower)*0.5;
+}
+
+/*!
+  Makes sure \a lower is numerically smaller than \a upper. If this is not the case, the values
+  are swapped.
+*/
+void QCPRange::normalize()
+{
+  if (lower > upper)
+    qSwap(lower, upper);
+}
+
+/*!
+  Expands this range such that \a otherRange is contained in the new range. It is assumed that both
+  this range and \a otherRange are normalized (see \ref normalize).
+  
+  If \a otherRange is already inside the current range, this function does nothing.
+  
+  \see expanded
+*/
+void QCPRange::expand(const QCPRange &otherRange)
+{
+  if (lower > otherRange.lower)
+    lower = otherRange.lower;
+  if (upper < otherRange.upper)
+    upper = otherRange.upper;
+}
+
+
+/*!
+  Returns an expanded range that contains this and \a otherRange. It is assumed that both this
+  range and \a otherRange are normalized (see \ref normalize).
+  
+  \see expand
+*/
+QCPRange QCPRange::expanded(const QCPRange &otherRange) const
+{
+  QCPRange result = *this;
+  result.expand(otherRange);
+  return result;
+}
+
+/*!
+  Returns a sanitized version of the range. Sanitized means for logarithmic scales, that
+  the range won't span the positive and negative sign domain, i.e. contain zero. Further
+  \a lower will always be numerically smaller (or equal) to \a upper.
+  
+  If the original range does span positive and negative sign domains or contains zero,
+  the returned range will try to approximate the original range as good as possible.
+  If the positive interval of the original range is wider than the negative interval, the
+  returned range will only contain the positive interval, with lower bound set to \a rangeFac or
+  \a rangeFac *\a upper, whichever is closer to zero. Same procedure is used if the negative interval
+  is wider than the positive interval, this time by changing the \a upper bound.
+*/
+QCPRange QCPRange::sanitizedForLogScale() const
+{
+  double rangeFac = 1e-3;
+  QCPRange sanitizedRange(lower, upper);
+  sanitizedRange.normalize();
+  // can't have range spanning negative and positive values in log plot, so change range to fix it
+  //if (qFuzzyCompare(sanitizedRange.lower+1, 1) && !qFuzzyCompare(sanitizedRange.upper+1, 1))
+  if (sanitizedRange.lower == 0.0 && sanitizedRange.upper != 0.0)
+  {
+    // case lower is 0
+    if (rangeFac < sanitizedRange.upper*rangeFac)
+      sanitizedRange.lower = rangeFac;
+    else
+      sanitizedRange.lower = sanitizedRange.upper*rangeFac;
+  } //else if (!qFuzzyCompare(lower+1, 1) && qFuzzyCompare(upper+1, 1))
+  else if (sanitizedRange.lower != 0.0 && sanitizedRange.upper == 0.0)
+  {
+    // case upper is 0
+    if (-rangeFac > sanitizedRange.lower*rangeFac)
+      sanitizedRange.upper = -rangeFac;
+    else
+      sanitizedRange.upper = sanitizedRange.lower*rangeFac;
+  } else if (sanitizedRange.lower < 0 && sanitizedRange.upper > 0)
+  {
+    // find out whether negative or positive interval is wider to decide which sign domain will be chosen
+    if (-sanitizedRange.lower > sanitizedRange.upper)
+    {
+      // negative is wider, do same as in case upper is 0
+      if (-rangeFac > sanitizedRange.lower*rangeFac)
+        sanitizedRange.upper = -rangeFac;
+      else
+        sanitizedRange.upper = sanitizedRange.lower*rangeFac;
+    } else
+    {
+      // positive is wider, do same as in case lower is 0
+      if (rangeFac < sanitizedRange.upper*rangeFac)
+        sanitizedRange.lower = rangeFac;
+      else
+        sanitizedRange.lower = sanitizedRange.upper*rangeFac;
+    }
+  }
+  // due to normalization, case lower>0 && upper<0 should never occur, because that implies upper<lower
+  return sanitizedRange;
+}
+
+/*!
+  Returns a sanitized version of the range. Sanitized means for linear scales, that
+  \a lower will always be numerically smaller (or equal) to \a upper.
+*/
+QCPRange QCPRange::sanitizedForLinScale() const
+{
+  QCPRange sanitizedRange(lower, upper);
+  sanitizedRange.normalize();
+  return sanitizedRange;
+}
+
+/*!
+  Returns true when \a value lies within or exactly on the borders of the range.
+*/
+bool QCPRange::contains(double value) const
+{
+  return value >= lower && value <= upper;
+}
+
+/*!
+  Checks, whether the specified range is within valid bounds, which are defined
+  as QCPRange::maxRange and QCPRange::minRange.
+  A valid range means:
+  \li range bounds within -maxRange and maxRange
+  \li range size above minRange
+  \li range size below maxRange
+*/
+bool QCPRange::validRange(double lower, double upper)
+{
+  return (lower > -maxRange &&
+          upper < maxRange &&
+          qAbs(lower-upper) > minRange &&
+          qAbs(lower-upper) < maxRange &&
+          !(lower > 0 && qIsInf(upper/lower)) &&
+          !(upper < 0 && qIsInf(lower/upper)));
+}
+
+/*!
+  \overload
+  Checks, whether the specified range is within valid bounds, which are defined
+  as QCPRange::maxRange and QCPRange::minRange.
+  A valid range means:
+  \li range bounds within -maxRange and maxRange
+  \li range size above minRange
+  \li range size below maxRange
+*/
+bool QCPRange::validRange(const QCPRange &range)
+{
+  return (range.lower > -maxRange &&
+          range.upper < maxRange &&
+          qAbs(range.lower-range.upper) > minRange &&
+          qAbs(range.lower-range.upper) < maxRange &&
+          !(range.lower > 0 && qIsInf(range.upper/range.lower)) &&
+          !(range.upper < 0 && qIsInf(range.lower/range.upper)));
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPMarginGroup
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPMarginGroup
+  \brief A margin group allows synchronization of margin sides if working with multiple layout elements.
+  
+  QCPMarginGroup allows you to tie a margin side of two or more layout elements together, such that
+  they will all have the same size, based on the largest required margin in the group.
+  
+  \n
+  \image html QCPMarginGroup.png "Demonstration of QCPMarginGroup"
+  \n
+  
+  In certain situations it is desirable that margins at specific sides are synchronized across
+  layout elements. For example, if one QCPAxisRect is below another one in a grid layout, it will
+  provide a cleaner look to the user if the left and right margins of the two axis rects are of the
+  same size. The left axis of the top axis rect will then be at the same horizontal position as the
+  left axis of the lower axis rect, making them appear aligned. The same applies for the right
+  axes. This is what QCPMarginGroup makes possible.
+  
+  To add/remove a specific side of a layout element to/from a margin group, use the \ref
+  QCPLayoutElement::setMarginGroup method. To completely break apart the margin group, either call
+  \ref clear, or just delete the margin group.
+  
+  \section QCPMarginGroup-example Example
+  
+  First create a margin group:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpmargingroup-creation-1
+  Then set this group on the layout element sides:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpmargingroup-creation-2
+  Here, we've used the first two axis rects of the plot and synchronized their left margins with
+  each other and their right margins with each other.
+*/
+
+/* start documentation of inline functions */
+
+/*! \fn QList<QCPLayoutElement*> QCPMarginGroup::elements(QCP::MarginSide side) const
+  
+  Returns a list of all layout elements that have their margin \a side associated with this margin
+  group.
+*/
+
+/* end documentation of inline functions */
+
+/*!
+  Creates a new QCPMarginGroup instance in \a parentPlot.
+*/
+QCPMarginGroup::QCPMarginGroup(QCustomPlot *parentPlot) :
+  QObject(parentPlot),
+  mParentPlot(parentPlot)
+{
+  mChildren.insert(QCP::msLeft, QList<QCPLayoutElement*>());
+  mChildren.insert(QCP::msRight, QList<QCPLayoutElement*>());
+  mChildren.insert(QCP::msTop, QList<QCPLayoutElement*>());
+  mChildren.insert(QCP::msBottom, QList<QCPLayoutElement*>());
+}
+
+QCPMarginGroup::~QCPMarginGroup()
+{
+  clear();
+}
+
+/*!
+  Returns whether this margin group is empty. If this function returns true, no layout elements use
+  this margin group to synchronize margin sides.
+*/
+bool QCPMarginGroup::isEmpty() const
+{
+  QHashIterator<QCP::MarginSide, QList<QCPLayoutElement*> > it(mChildren);
+  while (it.hasNext())
+  {
+    it.next();
+    if (!it.value().isEmpty())
+      return false;
+  }
+  return true;
+}
+
+/*!
+  Clears this margin group. The synchronization of the margin sides that use this margin group is
+  lifted and they will use their individual margin sizes again.
+*/
+void QCPMarginGroup::clear()
+{
+  // make all children remove themselves from this margin group:
+  QHashIterator<QCP::MarginSide, QList<QCPLayoutElement*> > it(mChildren);
+  while (it.hasNext())
+  {
+    it.next();
+    const QList<QCPLayoutElement*> elements = it.value();
+    for (int i=elements.size()-1; i>=0; --i)
+      elements.at(i)->setMarginGroup(it.key(), 0); // removes itself from mChildren via removeChild
+  }
+}
+
+/*! \internal
+  
+  Returns the synchronized common margin for \a side. This is the margin value that will be used by
+  the layout element on the respective side, if it is part of this margin group.
+  
+  The common margin is calculated by requesting the automatic margin (\ref
+  QCPLayoutElement::calculateAutoMargin) of each element associated with \a side in this margin
+  group, and choosing the largest returned value. (QCPLayoutElement::minimumMargins is taken into
+  account, too.)
+*/
+int QCPMarginGroup::commonMargin(QCP::MarginSide side) const
+{
+  // query all automatic margins of the layout elements in this margin group side and find maximum:
+  int result = 0;
+  const QList<QCPLayoutElement*> elements = mChildren.value(side);
+  for (int i=0; i<elements.size(); ++i)
+  {
+    if (!elements.at(i)->autoMargins().testFlag(side))
+      continue;
+    int m = qMax(elements.at(i)->calculateAutoMargin(side), QCP::getMarginValue(elements.at(i)->minimumMargins(), side));
+    if (m > result)
+      result = m;
+  }
+  return result;
+}
+
+/*! \internal
+  
+  Adds \a element to the internal list of child elements, for the margin \a side.
+  
+  This function does not modify the margin group property of \a element.
+*/
+void QCPMarginGroup::addChild(QCP::MarginSide side, QCPLayoutElement *element)
+{
+  if (!mChildren[side].contains(element))
+    mChildren[side].append(element);
+  else
+    qDebug() << Q_FUNC_INFO << "element is already child of this margin group side" << reinterpret_cast<quintptr>(element);
+}
+
+/*! \internal
+  
+  Removes \a element from the internal list of child elements, for the margin \a side.
+  
+  This function does not modify the margin group property of \a element.
+*/
+void QCPMarginGroup::removeChild(QCP::MarginSide side, QCPLayoutElement *element)
+{
+  if (!mChildren[side].removeOne(element))
+    qDebug() << Q_FUNC_INFO << "element is not child of this margin group side" << reinterpret_cast<quintptr>(element);
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPLayoutElement
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPLayoutElement
+  \brief The abstract base class for all objects that form \ref thelayoutsystem "the layout system".
+  
+  This is an abstract base class. As such, it can't be instantiated directly, rather use one of its subclasses.
+  
+  A Layout element is a rectangular object which can be placed in layouts. It has an outer rect
+  (QCPLayoutElement::outerRect) and an inner rect (\ref QCPLayoutElement::rect). The difference
+  between outer and inner rect is called its margin. The margin can either be set to automatic or
+  manual (\ref setAutoMargins) on a per-side basis. If a side is set to manual, that margin can be
+  set explicitly with \ref setMargins and will stay fixed at that value. If it's set to automatic,
+  the layout element subclass will control the value itself (via \ref calculateAutoMargin).
+  
+  Layout elements can be placed in layouts (base class QCPLayout) like QCPLayoutGrid. The top level
+  layout is reachable via \ref QCustomPlot::plotLayout, and is a \ref QCPLayoutGrid. Since \ref
+  QCPLayout itself derives from \ref QCPLayoutElement, layouts can be nested.
+  
+  Thus in QCustomPlot one can divide layout elements into two categories: The ones that are
+  invisible by themselves, because they don't draw anything. Their only purpose is to manage the
+  position and size of other layout elements. This category of layout elements usually use
+  QCPLayout as base class. Then there is the category of layout elements which actually draw
+  something. For example, QCPAxisRect, QCPLegend and QCPPlotTitle are of this category. This does
+  not necessarily mean that the latter category can't have child layout elements. QCPLegend for
+  instance, actually derives from QCPLayoutGrid and the individual legend items are child layout
+  elements in the grid layout.
+*/
+
+/* start documentation of inline functions */
+
+/*! \fn QCPLayout *QCPLayoutElement::layout() const
+  
+  Returns the parent layout of this layout element.
+*/
+
+/*! \fn QRect QCPLayoutElement::rect() const
+  
+  Returns the inner rect of this layout element. The inner rect is the outer rect (\ref
+  setOuterRect) shrinked by the margins (\ref setMargins, \ref setAutoMargins).
+  
+  In some cases, the area between outer and inner rect is left blank. In other cases the margin
+  area is used to display peripheral graphics while the main content is in the inner rect. This is
+  where automatic margin calculation becomes interesting because it allows the layout element to
+  adapt the margins to the peripheral graphics it wants to draw. For example, \ref QCPAxisRect
+  draws the axis labels and tick labels in the margin area, thus needs to adjust the margins (if
+  \ref setAutoMargins is enabled) according to the space required by the labels of the axes.
+*/
+
+/*! \fn virtual void QCPLayoutElement::mousePressEvent(QMouseEvent *event)
+  
+  This event is called, if the mouse was pressed while being inside the outer rect of this layout
+  element.
+*/
+
+/*! \fn virtual void QCPLayoutElement::mouseMoveEvent(QMouseEvent *event)
+  
+  This event is called, if the mouse is moved inside the outer rect of this layout element.
+*/
+
+/*! \fn virtual void QCPLayoutElement::mouseReleaseEvent(QMouseEvent *event)
+  
+  This event is called, if the mouse was previously pressed inside the outer rect of this layout
+  element and is now released.
+*/
+
+/*! \fn virtual void QCPLayoutElement::mouseDoubleClickEvent(QMouseEvent *event)
+  
+  This event is called, if the mouse is double-clicked inside the outer rect of this layout
+  element.
+*/
+
+/*! \fn virtual void QCPLayoutElement::wheelEvent(QWheelEvent *event)
+  
+  This event is called, if the mouse wheel is scrolled while the cursor is inside the rect of this
+  layout element.
+*/
+
+/* end documentation of inline functions */
+
+/*!
+  Creates an instance of QCPLayoutElement and sets default values.
+*/
+QCPLayoutElement::QCPLayoutElement(QCustomPlot *parentPlot) :
+  QCPLayerable(parentPlot), // parenthood is changed as soon as layout element gets inserted into a layout (except for top level layout)
+  mParentLayout(0),
+  mMinimumSize(),
+  mMaximumSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX),
+  mRect(0, 0, 0, 0),
+  mOuterRect(0, 0, 0, 0),
+  mMargins(0, 0, 0, 0),
+  mMinimumMargins(0, 0, 0, 0),
+  mAutoMargins(QCP::msAll)
+{
+}
+
+QCPLayoutElement::~QCPLayoutElement()
+{
+  setMarginGroup(QCP::msAll, 0); // unregister at margin groups, if there are any
+  // unregister at layout:
+  if (qobject_cast<QCPLayout*>(mParentLayout)) // the qobject_cast is just a safeguard in case the layout forgets to call clear() in its dtor and this dtor is called by QObject dtor
+    mParentLayout->take(this);
+}
+
+/*!
+  Sets the outer rect of this layout element. If the layout element is inside a layout, the layout
+  sets the position and size of this layout element using this function.
+  
+  Calling this function externally has no effect, since the layout will overwrite any changes to
+  the outer rect upon the next replot.
+  
+  The layout element will adapt its inner \ref rect by applying the margins inward to the outer rect.
+  
+  \see rect
+*/
+void QCPLayoutElement::setOuterRect(const QRect &rect)
+{
+  if (mOuterRect != rect)
+  {
+    mOuterRect = rect;
+    mRect = mOuterRect.adjusted(mMargins.left(), mMargins.top(), -mMargins.right(), -mMargins.bottom());
+  }
+}
+
+/*!
+  Sets the margins of this layout element. If \ref setAutoMargins is disabled for some or all
+  sides, this function is used to manually set the margin on those sides. Sides that are still set
+  to be handled automatically are ignored and may have any value in \a margins.
+  
+  The margin is the distance between the outer rect (controlled by the parent layout via \ref
+  setOuterRect) and the inner \ref rect (which usually contains the main content of this layout
+  element).
+  
+  \see setAutoMargins
+*/
+void QCPLayoutElement::setMargins(const QMargins &margins)
+{
+  if (mMargins != margins)
+  {
+    mMargins = margins;
+    mRect = mOuterRect.adjusted(mMargins.left(), mMargins.top(), -mMargins.right(), -mMargins.bottom());
+  }
+}
+
+/*!
+  If \ref setAutoMargins is enabled on some or all margins, this function is used to provide
+  minimum values for those margins.
+  
+  The minimum values are not enforced on margin sides that were set to be under manual control via
+  \ref setAutoMargins.
+  
+  \see setAutoMargins
+*/
+void QCPLayoutElement::setMinimumMargins(const QMargins &margins)
+{
+  if (mMinimumMargins != margins)
+  {
+    mMinimumMargins = margins;
+  }
+}
+
+/*!
+  Sets on which sides the margin shall be calculated automatically. If a side is calculated
+  automatically, a minimum margin value may be provided with \ref setMinimumMargins. If a side is
+  set to be controlled manually, the value may be specified with \ref setMargins.
+  
+  Margin sides that are under automatic control may participate in a \ref QCPMarginGroup (see \ref
+  setMarginGroup), to synchronize (align) it with other layout elements in the plot.
+  
+  \see setMinimumMargins, setMargins
+*/
+void QCPLayoutElement::setAutoMargins(QCP::MarginSides sides)
+{
+  mAutoMargins = sides;
+}
+
+/*!
+  Sets the minimum size for the inner \ref rect of this layout element. A parent layout tries to
+  respect the \a size here by changing row/column sizes in the layout accordingly.
+  
+  If the parent layout size is not sufficient to satisfy all minimum size constraints of its child
+  layout elements, the layout may set a size that is actually smaller than \a size. QCustomPlot
+  propagates the layout's size constraints to the outside by setting its own minimum QWidget size
+  accordingly, so violations of \a size should be exceptions.
+*/
+void QCPLayoutElement::setMinimumSize(const QSize &size)
+{
+  if (mMinimumSize != size)
+  {
+    mMinimumSize = size;
+    if (mParentLayout)
+      mParentLayout->sizeConstraintsChanged();
+  }
+}
+
+/*! \overload
+  
+  Sets the minimum size for the inner \ref rect of this layout element.
+*/
+void QCPLayoutElement::setMinimumSize(int width, int height)
+{
+  setMinimumSize(QSize(width, height));
+}
+
+/*!
+  Sets the maximum size for the inner \ref rect of this layout element. A parent layout tries to
+  respect the \a size here by changing row/column sizes in the layout accordingly.
+*/
+void QCPLayoutElement::setMaximumSize(const QSize &size)
+{
+  if (mMaximumSize != size)
+  {
+    mMaximumSize = size;
+    if (mParentLayout)
+      mParentLayout->sizeConstraintsChanged();
+  }
+}
+
+/*! \overload
+  
+  Sets the maximum size for the inner \ref rect of this layout element.
+*/
+void QCPLayoutElement::setMaximumSize(int width, int height)
+{
+  setMaximumSize(QSize(width, height));
+}
+
+/*!
+  Sets the margin \a group of the specified margin \a sides.
+  
+  Margin groups allow synchronizing specified margins across layout elements, see the documentation
+  of \ref QCPMarginGroup.
+  
+  To unset the margin group of \a sides, set \a group to 0.
+  
+  Note that margin groups only work for margin sides that are set to automatic (\ref
+  setAutoMargins).
+*/
+void QCPLayoutElement::setMarginGroup(QCP::MarginSides sides, QCPMarginGroup *group)
+{
+  QVector<QCP::MarginSide> sideVector;
+  if (sides.testFlag(QCP::msLeft)) sideVector.append(QCP::msLeft);
+  if (sides.testFlag(QCP::msRight)) sideVector.append(QCP::msRight);
+  if (sides.testFlag(QCP::msTop)) sideVector.append(QCP::msTop);
+  if (sides.testFlag(QCP::msBottom)) sideVector.append(QCP::msBottom);
+  
+  for (int i=0; i<sideVector.size(); ++i)
+  {
+    QCP::MarginSide side = sideVector.at(i);
+    if (marginGroup(side) != group)
+    {
+      QCPMarginGroup *oldGroup = marginGroup(side);
+      if (oldGroup) // unregister at old group
+        oldGroup->removeChild(side, this);
+      
+      if (!group) // if setting to 0, remove hash entry. Else set hash entry to new group and register there
+      {
+        mMarginGroups.remove(side);
+      } else // setting to a new group
+      {
+        mMarginGroups[side] = group;
+        group->addChild(side, this);
+      }
+    }
+  }
+}
+
+/*!
+  Updates the layout element and sub-elements. This function is automatically called before every
+  replot by the parent layout element. It is called multiple times, once for every \ref
+  UpdatePhase. The phases are run through in the order of the enum values. For details about what
+  happens at the different phases, see the documentation of \ref UpdatePhase.
+  
+  Layout elements that have child elements should call the \ref update method of their child
+  elements, and pass the current \a phase unchanged.
+  
+  The default implementation executes the automatic margin mechanism in the \ref upMargins phase.
+  Subclasses should make sure to call the base class implementation.
+*/
+void QCPLayoutElement::update(UpdatePhase phase)
+{
+  if (phase == upMargins)
+  {
+    if (mAutoMargins != QCP::msNone)
+    {
+      // set the margins of this layout element according to automatic margin calculation, either directly or via a margin group:
+      QMargins newMargins = mMargins;
+      QList<QCP::MarginSide> allMarginSides = QList<QCP::MarginSide>() << QCP::msLeft << QCP::msRight << QCP::msTop << QCP::msBottom;
+      foreach (QCP::MarginSide side, allMarginSides)
+      {
+        if (mAutoMargins.testFlag(side)) // this side's margin shall be calculated automatically
+        {
+          if (mMarginGroups.contains(side))
+            QCP::setMarginValue(newMargins, side, mMarginGroups[side]->commonMargin(side)); // this side is part of a margin group, so get the margin value from that group
+          else
+            QCP::setMarginValue(newMargins, side, calculateAutoMargin(side)); // this side is not part of a group, so calculate the value directly
+          // apply minimum margin restrictions:
+          if (QCP::getMarginValue(newMargins, side) < QCP::getMarginValue(mMinimumMargins, side))
+            QCP::setMarginValue(newMargins, side, QCP::getMarginValue(mMinimumMargins, side));
+        }
+      }
+      setMargins(newMargins);
+    }
+  }
+}
+
+/*!
+  Returns the minimum size this layout element (the inner \ref rect) may be compressed to.
+  
+  if a minimum size (\ref setMinimumSize) was not set manually, parent layouts consult this
+  function to determine the minimum allowed size of this layout element. (A manual minimum size is
+  considered set if it is non-zero.)
+*/
+QSize QCPLayoutElement::minimumSizeHint() const
+{
+  return mMinimumSize;
+}
+
+/*!
+  Returns the maximum size this layout element (the inner \ref rect) may be expanded to.
+  
+  if a maximum size (\ref setMaximumSize) was not set manually, parent layouts consult this
+  function to determine the maximum allowed size of this layout element. (A manual maximum size is
+  considered set if it is smaller than Qt's QWIDGETSIZE_MAX.)
+*/
+QSize QCPLayoutElement::maximumSizeHint() const
+{
+  return mMaximumSize;
+}
+
+/*!
+  Returns a list of all child elements in this layout element. If \a recursive is true, all
+  sub-child elements are included in the list, too.
+  
+  \warning There may be entries with value 0 in the returned list. (For example, QCPLayoutGrid may have
+  empty cells which yield 0 at the respective index.)
+*/
+QList<QCPLayoutElement*> QCPLayoutElement::elements(bool recursive) const
+{
+  Q_UNUSED(recursive)
+  return QList<QCPLayoutElement*>();
+}
+
+/*!
+  Layout elements are sensitive to events inside their outer rect. If \a pos is within the outer
+  rect, this method returns a value corresponding to 0.99 times the parent plot's selection
+  tolerance. However, layout elements are not selectable by default. So if \a onlySelectable is
+  true, -1.0 is returned.
+  
+  See \ref QCPLayerable::selectTest for a general explanation of this virtual method.
+  
+  QCPLayoutElement subclasses may reimplement this method to provide more specific selection test
+  behaviour.
+*/
+double QCPLayoutElement::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  
+  if (onlySelectable)
+    return -1;
+  
+  if (QRectF(mOuterRect).contains(pos))
+  {
+    if (mParentPlot)
+      return mParentPlot->selectionTolerance()*0.99;
+    else
+    {
+      qDebug() << Q_FUNC_INFO << "parent plot not defined";
+      return -1;
+    }
+  } else
+    return -1;
+}
+
+/*! \internal
+  
+  propagates the parent plot initialization to all child elements, by calling \ref
+  QCPLayerable::initializeParentPlot on them.
+*/
+void QCPLayoutElement::parentPlotInitialized(QCustomPlot *parentPlot)
+{
+  foreach (QCPLayoutElement* el, elements(false))
+  {
+    if (!el->parentPlot())
+      el->initializeParentPlot(parentPlot);
+  }
+}
+
+/*! \internal
+  
+  Returns the margin size for this \a side. It is used if automatic margins is enabled for this \a
+  side (see \ref setAutoMargins). If a minimum margin was set with \ref setMinimumMargins, the
+  returned value will not be smaller than the specified minimum margin.
+  
+  The default implementation just returns the respective manual margin (\ref setMargins) or the
+  minimum margin, whichever is larger.
+*/
+int QCPLayoutElement::calculateAutoMargin(QCP::MarginSide side)
+{
+  return qMax(QCP::getMarginValue(mMargins, side), QCP::getMarginValue(mMinimumMargins, side));
+}
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPLayout
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPLayout
+  \brief The abstract base class for layouts
+  
+  This is an abstract base class for layout elements whose main purpose is to define the position
+  and size of other child layout elements. In most cases, layouts don't draw anything themselves
+  (but there are exceptions to this, e.g. QCPLegend).
+  
+  QCPLayout derives from QCPLayoutElement, and thus can itself be nested in other layouts.
+  
+  QCPLayout introduces a common interface for accessing and manipulating the child elements. Those
+  functions are most notably \ref elementCount, \ref elementAt, \ref takeAt, \ref take, \ref
+  simplify, \ref removeAt, \ref remove and \ref clear. Individual subclasses may add more functions
+  to this interface which are more specialized to the form of the layout. For example, \ref
+  QCPLayoutGrid adds functions that take row and column indices to access cells of the layout grid
+  more conveniently.
+  
+  Since this is an abstract base class, you can't instantiate it directly. Rather use one of its
+  subclasses like QCPLayoutGrid or QCPLayoutInset.
+  
+  For a general introduction to the layout system, see the dedicated documentation page \ref
+  thelayoutsystem "The Layout System".
+*/
+
+/* start documentation of pure virtual functions */
+
+/*! \fn virtual int QCPLayout::elementCount() const = 0
+  
+  Returns the number of elements/cells in the layout.
+  
+  \see elements, elementAt
+*/
+
+/*! \fn virtual QCPLayoutElement* QCPLayout::elementAt(int index) const = 0
+  
+  Returns the element in the cell with the given \a index. If \a index is invalid, returns 0.
+  
+  Note that even if \a index is valid, the respective cell may be empty in some layouts (e.g.
+  QCPLayoutGrid), so this function may return 0 in those cases. You may use this function to check
+  whether a cell is empty or not.
+  
+  \see elements, elementCount, takeAt
+*/
+
+/*! \fn virtual QCPLayoutElement* QCPLayout::takeAt(int index) = 0
+  
+  Removes the element with the given \a index from the layout and returns it.
+  
+  If the \a index is invalid or the cell with that index is empty, returns 0.
+  
+  Note that some layouts don't remove the respective cell right away but leave an empty cell after
+  successful removal of the layout element. To collapse empty cells, use \ref simplify.
+  
+  \see elementAt, take
+*/
+
+/*! \fn virtual bool QCPLayout::take(QCPLayoutElement* element) = 0
+  
+  Removes the specified \a element from the layout and returns true on success.
+  
+  If the \a element isn't in this layout, returns false.
+  
+  Note that some layouts don't remove the respective cell right away but leave an empty cell after
+  successful removal of the layout element. To collapse empty cells, use \ref simplify.
+  
+  \see takeAt
+*/
+
+/* end documentation of pure virtual functions */
+
+/*!
+  Creates an instance of QCPLayout and sets default values. Note that since QCPLayout
+  is an abstract base class, it can't be instantiated directly.
+*/
+QCPLayout::QCPLayout()
+{
+}
+
+/*!
+  First calls the QCPLayoutElement::update base class implementation to update the margins on this
+  layout.
+  
+  Then calls \ref updateLayout which subclasses reimplement to reposition and resize their cells.
+  
+  Finally, \ref update is called on all child elements.
+*/
+void QCPLayout::update(UpdatePhase phase)
+{
+  QCPLayoutElement::update(phase);
+  
+  // set child element rects according to layout:
+  if (phase == upLayout)
+    updateLayout();
+  
+  // propagate update call to child elements:
+  const int elCount = elementCount();
+  for (int i=0; i<elCount; ++i)
+  {
+    if (QCPLayoutElement *el = elementAt(i))
+      el->update(phase);
+  }
+}
+
+/* inherits documentation from base class */
+QList<QCPLayoutElement*> QCPLayout::elements(bool recursive) const
+{
+  const int c = elementCount();
+  QList<QCPLayoutElement*> result;
+#if QT_VERSION >= QT_VERSION_CHECK(4, 7, 0)
+  result.reserve(c);
+#endif
+  for (int i=0; i<c; ++i)
+    result.append(elementAt(i));
+  if (recursive)
+  {
+    for (int i=0; i<c; ++i)
+    {
+      if (result.at(i))
+        result << result.at(i)->elements(recursive);
+    }
+  }
+  return result;
+}
+
+/*!
+  Simplifies the layout by collapsing empty cells. The exact behavior depends on subclasses, the
+  default implementation does nothing.
+  
+  Not all layouts need simplification. For example, QCPLayoutInset doesn't use explicit
+  simplification while QCPLayoutGrid does.
+*/
+void QCPLayout::simplify()
+{
+}
+
+/*!
+  Removes and deletes the element at the provided \a index. Returns true on success. If \a index is
+  invalid or points to an empty cell, returns false.
+  
+  This function internally uses \ref takeAt to remove the element from the layout and then deletes
+  the returned element. Note that some layouts don't remove the respective cell right away but leave an
+  empty cell after successful removal of the layout element. To collapse empty cells, use \ref
+  simplify.
+  
+  \see remove, takeAt
+*/
+bool QCPLayout::removeAt(int index)
+{
+  if (QCPLayoutElement *el = takeAt(index))
+  {
+    delete el;
+    return true;
+  } else
+    return false;
+}
+
+/*!
+  Removes and deletes the provided \a element. Returns true on success. If \a element is not in the
+  layout, returns false.
+  
+  This function internally uses \ref takeAt to remove the element from the layout and then deletes
+  the element. Note that some layouts don't remove the respective cell right away but leave an
+  empty cell after successful removal of the layout element. To collapse empty cells, use \ref
+  simplify.
+  
+  \see removeAt, take
+*/
+bool QCPLayout::remove(QCPLayoutElement *element)
+{
+  if (take(element))
+  {
+    delete element;
+    return true;
+  } else
+    return false;
+}
+
+/*!
+  Removes and deletes all layout elements in this layout. Finally calls \ref simplify to make sure
+  all empty cells are collapsed.
+  
+  \see remove, removeAt
+*/
+void QCPLayout::clear()
+{
+  for (int i=elementCount()-1; i>=0; --i)
+  {
+    if (elementAt(i))
+      removeAt(i);
+  }
+  simplify();
+}
+
+/*!
+  Subclasses call this method to report changed (minimum/maximum) size constraints.
+  
+  If the parent of this layout is again a QCPLayout, forwards the call to the parent's \ref
+  sizeConstraintsChanged. If the parent is a QWidget (i.e. is the \ref QCustomPlot::plotLayout of
+  QCustomPlot), calls QWidget::updateGeometry, so if the QCustomPlot widget is inside a Qt QLayout,
+  it may update itself and resize cells accordingly.
+*/
+void QCPLayout::sizeConstraintsChanged() const
+{
+  if (QWidget *w = qobject_cast<QWidget*>(parent()))
+    w->updateGeometry();
+  else if (QCPLayout *l = qobject_cast<QCPLayout*>(parent()))
+    l->sizeConstraintsChanged();
+}
+
+/*! \internal
+  
+  Subclasses reimplement this method to update the position and sizes of the child elements/cells
+  via calling their \ref QCPLayoutElement::setOuterRect. The default implementation does nothing.
+  
+  The geometry used as a reference is the inner \ref rect of this layout. Child elements should stay
+  within that rect.
+  
+  \ref getSectionSizes may help with the reimplementation of this function.
+  
+  \see update
+*/
+void QCPLayout::updateLayout()
+{
+}
+
+
+/*! \internal
+  
+  Associates \a el with this layout. This is done by setting the \ref QCPLayoutElement::layout, the
+  \ref QCPLayerable::parentLayerable and the QObject parent to this layout.
+  
+  Further, if \a el didn't previously have a parent plot, calls \ref
+  QCPLayerable::initializeParentPlot on \a el to set the paret plot.
+  
+  This method is used by subclass specific methods that add elements to the layout. Note that this
+  method only changes properties in \a el. The removal from the old layout and the insertion into
+  the new layout must be done additionally.
+*/
+void QCPLayout::adoptElement(QCPLayoutElement *el)
+{
+  if (el)
+  {
+    el->mParentLayout = this;
+    el->setParentLayerable(this);
+    el->setParent(this);
+    if (!el->parentPlot())
+      el->initializeParentPlot(mParentPlot);
+  } else
+    qDebug() << Q_FUNC_INFO << "Null element passed";
+}
+
+/*! \internal
+  
+  Disassociates \a el from this layout. This is done by setting the \ref QCPLayoutElement::layout
+  and the \ref QCPLayerable::parentLayerable to zero. The QObject parent is set to the parent
+  QCustomPlot.
+  
+  This method is used by subclass specific methods that remove elements from the layout (e.g. \ref
+  take or \ref takeAt). Note that this method only changes properties in \a el. The removal from
+  the old layout must be done additionally.
+*/
+void QCPLayout::releaseElement(QCPLayoutElement *el)
+{
+  if (el)
+  {
+    el->mParentLayout = 0;
+    el->setParentLayerable(0);
+    el->setParent(mParentPlot);
+    // Note: Don't initializeParentPlot(0) here, because layout element will stay in same parent plot
+  } else
+    qDebug() << Q_FUNC_INFO << "Null element passed";
+}
+
+/*! \internal
+  
+  This is a helper function for the implementation of \ref updateLayout in subclasses.
+  
+  It calculates the sizes of one-dimensional sections with provided constraints on maximum section
+  sizes, minimum section sizes, relative stretch factors and the final total size of all sections.
+  
+  The QVector entries refer to the sections. Thus all QVectors must have the same size.
+  
+  \a maxSizes gives the maximum allowed size of each section. If there shall be no maximum size
+  imposed, set all vector values to Qt's QWIDGETSIZE_MAX.
+  
+  \a minSizes gives the minimum allowed size of each section. If there shall be no minimum size
+  imposed, set all vector values to zero. If the \a minSizes entries add up to a value greater than
+  \a totalSize, sections will be scaled smaller than the proposed minimum sizes. (In other words,
+  not exceeding the allowed total size is taken to be more important than not going below minimum
+  section sizes.)
+  
+  \a stretchFactors give the relative proportions of the sections to each other. If all sections
+  shall be scaled equally, set all values equal. If the first section shall be double the size of
+  each individual other section, set the first number of \a stretchFactors to double the value of
+  the other individual values (e.g. {2, 1, 1, 1}).
+  
+  \a totalSize is the value that the final section sizes will add up to. Due to rounding, the
+  actual sum may differ slightly. If you want the section sizes to sum up to exactly that value,
+  you could distribute the remaining difference on the sections.
+  
+  The return value is a QVector containing the section sizes.
+*/
+QVector<int> QCPLayout::getSectionSizes(QVector<int> maxSizes, QVector<int> minSizes, QVector<double> stretchFactors, int totalSize) const
+{
+  if (maxSizes.size() != minSizes.size() || minSizes.size() != stretchFactors.size())
+  {
+    qDebug() << Q_FUNC_INFO << "Passed vector sizes aren't equal:" << maxSizes << minSizes << stretchFactors;
+    return QVector<int>();
+  }
+  if (stretchFactors.isEmpty())
+    return QVector<int>();
+  int sectionCount = stretchFactors.size();
+  QVector<double> sectionSizes(sectionCount);
+  // if provided total size is forced smaller than total minimum size, ignore minimum sizes (squeeze sections):
+  int minSizeSum = 0;
+  for (int i=0; i<sectionCount; ++i)
+    minSizeSum += minSizes.at(i);
+  if (totalSize < minSizeSum)
+  {
+    // new stretch factors are minimum sizes and minimum sizes are set to zero:
+    for (int i=0; i<sectionCount; ++i)
+    {
+      stretchFactors[i] = minSizes.at(i);
+      minSizes[i] = 0;
+    }
+  }
+  
+  QList<int> minimumLockedSections;
+  QList<int> unfinishedSections;
+  for (int i=0; i<sectionCount; ++i)
+    unfinishedSections.append(i);
+  double freeSize = totalSize;
+  
+  int outerIterations = 0;
+  while (!unfinishedSections.isEmpty() && outerIterations < sectionCount*2) // the iteration check ist just a failsafe in case something really strange happens
+  {
+    ++outerIterations;
+    int innerIterations = 0;
+    while (!unfinishedSections.isEmpty() && innerIterations < sectionCount*2) // the iteration check ist just a failsafe in case something really strange happens
+    {
+      ++innerIterations;
+      // find section that hits its maximum next:
+      int nextId = -1;
+      double nextMax = 1e12;
+      for (int i=0; i<unfinishedSections.size(); ++i)
+      {
+        int secId = unfinishedSections.at(i);
+        double hitsMaxAt = (maxSizes.at(secId)-sectionSizes.at(secId))/stretchFactors.at(secId);
+        if (hitsMaxAt < nextMax)
+        {
+          nextMax = hitsMaxAt;
+          nextId = secId;
+        }
+      }
+      // check if that maximum is actually within the bounds of the total size (i.e. can we stretch all remaining sections so far that the found section
+      // actually hits its maximum, without exceeding the total size when we add up all sections)
+      double stretchFactorSum = 0;
+      for (int i=0; i<unfinishedSections.size(); ++i)
+        stretchFactorSum += stretchFactors.at(unfinishedSections.at(i));
+      double nextMaxLimit = freeSize/stretchFactorSum;
+      if (nextMax < nextMaxLimit) // next maximum is actually hit, move forward to that point and fix the size of that section
+      {
+        for (int i=0; i<unfinishedSections.size(); ++i)
+        {
+          sectionSizes[unfinishedSections.at(i)] += nextMax*stretchFactors.at(unfinishedSections.at(i)); // increment all sections
+          freeSize -= nextMax*stretchFactors.at(unfinishedSections.at(i));
+        }
+        unfinishedSections.removeOne(nextId); // exclude the section that is now at maximum from further changes
+      } else // next maximum isn't hit, just distribute rest of free space on remaining sections
+      {
+        for (int i=0; i<unfinishedSections.size(); ++i)
+          sectionSizes[unfinishedSections.at(i)] += nextMaxLimit*stretchFactors.at(unfinishedSections.at(i)); // increment all sections
+        unfinishedSections.clear();
+      }
+    }
+    if (innerIterations == sectionCount*2)
+      qDebug() << Q_FUNC_INFO << "Exceeded maximum expected inner iteration count, layouting aborted. Input was:" << maxSizes << minSizes << stretchFactors << totalSize;
+    
+    // now check whether the resulting section sizes violate minimum restrictions:
+    bool foundMinimumViolation = false;
+    for (int i=0; i<sectionSizes.size(); ++i)
+    {
+      if (minimumLockedSections.contains(i))
+        continue;
+      if (sectionSizes.at(i) < minSizes.at(i)) // section violates minimum
+      {
+        sectionSizes[i] = minSizes.at(i); // set it to minimum
+        foundMinimumViolation = true; // make sure we repeat the whole optimization process
+        minimumLockedSections.append(i);
+      }
+    }
+    if (foundMinimumViolation)
+    {
+      freeSize = totalSize;
+      for (int i=0; i<sectionCount; ++i)
+      {
+        if (!minimumLockedSections.contains(i)) // only put sections that haven't hit their minimum back into the pool
+          unfinishedSections.append(i);
+        else
+          freeSize -= sectionSizes.at(i); // remove size of minimum locked sections from available space in next round
+      }
+      // reset all section sizes to zero that are in unfinished sections (all others have been set to their minimum):
+      for (int i=0; i<unfinishedSections.size(); ++i)
+        sectionSizes[unfinishedSections.at(i)] = 0;
+    }
+  }
+  if (outerIterations == sectionCount*2)
+    qDebug() << Q_FUNC_INFO << "Exceeded maximum expected outer iteration count, layouting aborted. Input was:" << maxSizes << minSizes << stretchFactors << totalSize;
+  
+  QVector<int> result(sectionCount);
+  for (int i=0; i<sectionCount; ++i)
+    result[i] = qRound(sectionSizes.at(i));
+  return result;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPLayoutGrid
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPLayoutGrid
+  \brief A layout that arranges child elements in a grid
+  
+  Elements are laid out in a grid with configurable stretch factors (\ref setColumnStretchFactor,
+  \ref setRowStretchFactor) and spacing (\ref setColumnSpacing, \ref setRowSpacing).
+  
+  Elements can be added to cells via \ref addElement. The grid is expanded if the specified row or
+  column doesn't exist yet. Whether a cell contains a valid layout element can be checked with \ref
+  hasElement, that element can be retrieved with \ref element. If rows and columns that only have
+  empty cells shall be removed, call \ref simplify. Removal of elements is either done by just
+  adding the element to a different layout or by using the QCPLayout interface \ref take or \ref
+  remove.
+  
+  Row and column insertion can be performed with \ref insertRow and \ref insertColumn.
+*/
+
+/*!
+  Creates an instance of QCPLayoutGrid and sets default values.
+*/
+QCPLayoutGrid::QCPLayoutGrid() :
+  mColumnSpacing(5),
+  mRowSpacing(5)
+{
+}
+
+QCPLayoutGrid::~QCPLayoutGrid()
+{
+  // clear all child layout elements. This is important because only the specific layouts know how
+  // to handle removing elements (clear calls virtual removeAt method to do that).
+  clear();
+}
+
+/*!
+  Returns the element in the cell in \a row and \a column.
+  
+  Returns 0 if either the row/column is invalid or if the cell is empty. In those cases, a qDebug
+  message is printed. To check whether a cell exists and isn't empty, use \ref hasElement.
+  
+  \see addElement, hasElement
+*/
+QCPLayoutElement *QCPLayoutGrid::element(int row, int column) const
+{
+  if (row >= 0 && row < mElements.size())
+  {
+    if (column >= 0 && column < mElements.first().size())
+    {
+      if (QCPLayoutElement *result = mElements.at(row).at(column))
+        return result;
+      else
+        qDebug() << Q_FUNC_INFO << "Requested cell is empty. Row:" << row << "Column:" << column;
+    } else
+      qDebug() << Q_FUNC_INFO << "Invalid column. Row:" << row << "Column:" << column;
+  } else
+    qDebug() << Q_FUNC_INFO << "Invalid row. Row:" << row << "Column:" << column;
+  return 0;
+}
+
+/*!
+  Returns the number of rows in the layout.
+  
+  \see columnCount
+*/
+int QCPLayoutGrid::rowCount() const
+{
+  return mElements.size();
+}
+
+/*!
+  Returns the number of columns in the layout.
+  
+  \see rowCount
+*/
+int QCPLayoutGrid::columnCount() const
+{
+  if (mElements.size() > 0)
+    return mElements.first().size();
+  else
+    return 0;
+}
+
+/*!
+  Adds the \a element to cell with \a row and \a column. If \a element is already in a layout, it
+  is first removed from there. If \a row or \a column don't exist yet, the layout is expanded
+  accordingly.
+  
+  Returns true if the element was added successfully, i.e. if the cell at \a row and \a column
+  didn't already have an element.
+  
+  \see element, hasElement, take, remove
+*/
+bool QCPLayoutGrid::addElement(int row, int column, QCPLayoutElement *element)
+{
+  if (element)
+  {
+    if (!hasElement(row, column))
+    {
+      if (element->layout()) // remove from old layout first
+        element->layout()->take(element);
+      expandTo(row+1, column+1);
+      mElements[row][column] = element;
+      adoptElement(element);
+      return true;
+    } else
+      qDebug() << Q_FUNC_INFO << "There is already an element in the specified row/column:" << row << column;
+  } else
+    qDebug() << Q_FUNC_INFO << "Can't add null element to row/column:" << row << column;
+  return false;
+}
+
+/*!
+  Returns whether the cell at \a row and \a column exists and contains a valid element, i.e. isn't
+  empty.
+  
+  \see element
+*/
+bool QCPLayoutGrid::hasElement(int row, int column)
+{
+  if (row >= 0 && row < rowCount() && column >= 0 && column < columnCount())
+    return mElements.at(row).at(column);
+  else
+    return false;
+}
+
+/*!
+  Sets the stretch \a factor of \a column.
+  
+  Stretch factors control the relative sizes of rows and columns. Cells will not be resized beyond
+  their minimum and maximum widths/heights (\ref QCPLayoutElement::setMinimumSize, \ref
+  QCPLayoutElement::setMaximumSize), regardless of the stretch factor.
+  
+  The default stretch factor of newly created rows/columns is 1.
+  
+  \see setColumnStretchFactors, setRowStretchFactor
+*/
+void QCPLayoutGrid::setColumnStretchFactor(int column, double factor)
+{
+  if (column >= 0 && column < columnCount())
+  {
+    if (factor > 0)
+      mColumnStretchFactors[column] = factor;
+    else
+      qDebug() << Q_FUNC_INFO << "Invalid stretch factor, must be positive:" << factor;
+  } else
+    qDebug() << Q_FUNC_INFO << "Invalid column:" << column;
+}
+
+/*!
+  Sets the stretch \a factors of all columns. \a factors must have the size \ref columnCount.
+  
+  Stretch factors control the relative sizes of rows and columns. Cells will not be resized beyond
+  their minimum and maximum widths/heights (\ref QCPLayoutElement::setMinimumSize, \ref
+  QCPLayoutElement::setMaximumSize), regardless of the stretch factor.
+  
+  The default stretch factor of newly created rows/columns is 1.
+  
+  \see setColumnStretchFactor, setRowStretchFactors
+*/
+void QCPLayoutGrid::setColumnStretchFactors(const QList<double> &factors)
+{
+  if (factors.size() == mColumnStretchFactors.size())
+  {
+    mColumnStretchFactors = factors;
+    for (int i=0; i<mColumnStretchFactors.size(); ++i)
+    {
+      if (mColumnStretchFactors.at(i) <= 0)
+      {
+        qDebug() << Q_FUNC_INFO << "Invalid stretch factor, must be positive:" << mColumnStretchFactors.at(i);
+        mColumnStretchFactors[i] = 1;
+      }
+    }
+  } else
+    qDebug() << Q_FUNC_INFO << "Column count not equal to passed stretch factor count:" << factors;
+}
+
+/*!
+  Sets the stretch \a factor of \a row.
+  
+  Stretch factors control the relative sizes of rows and columns. Cells will not be resized beyond
+  their minimum and maximum widths/heights (\ref QCPLayoutElement::setMinimumSize, \ref
+  QCPLayoutElement::setMaximumSize), regardless of the stretch factor.
+  
+  The default stretch factor of newly created rows/columns is 1.
+  
+  \see setColumnStretchFactors, setRowStretchFactor
+*/
+void QCPLayoutGrid::setRowStretchFactor(int row, double factor)
+{
+  if (row >= 0 && row < rowCount())
+  {
+    if (factor > 0)
+      mRowStretchFactors[row] = factor;
+    else
+      qDebug() << Q_FUNC_INFO << "Invalid stretch factor, must be positive:" << factor;
+  } else
+    qDebug() << Q_FUNC_INFO << "Invalid row:" << row;
+}
+
+/*!
+  Sets the stretch \a factors of all rows. \a factors must have the size \ref rowCount.
+  
+  Stretch factors control the relative sizes of rows and columns. Cells will not be resized beyond
+  their minimum and maximum widths/heights (\ref QCPLayoutElement::setMinimumSize, \ref
+  QCPLayoutElement::setMaximumSize), regardless of the stretch factor.
+  
+  The default stretch factor of newly created rows/columns is 1.
+  
+  \see setRowStretchFactor, setColumnStretchFactors
+*/
+void QCPLayoutGrid::setRowStretchFactors(const QList<double> &factors)
+{
+  if (factors.size() == mRowStretchFactors.size())
+  {
+    mRowStretchFactors = factors;
+    for (int i=0; i<mRowStretchFactors.size(); ++i)
+    {
+      if (mRowStretchFactors.at(i) <= 0)
+      {
+        qDebug() << Q_FUNC_INFO << "Invalid stretch factor, must be positive:" << mRowStretchFactors.at(i);
+        mRowStretchFactors[i] = 1;
+      }
+    }
+  } else
+    qDebug() << Q_FUNC_INFO << "Row count not equal to passed stretch factor count:" << factors;
+}
+
+/*!
+  Sets the gap that is left blank between columns to \a pixels.
+  
+  \see setRowSpacing
+*/
+void QCPLayoutGrid::setColumnSpacing(int pixels)
+{
+  mColumnSpacing = pixels;
+}
+
+/*!
+  Sets the gap that is left blank between rows to \a pixels.
+  
+  \see setColumnSpacing
+*/
+void QCPLayoutGrid::setRowSpacing(int pixels)
+{
+  mRowSpacing = pixels;
+}
+
+/*!
+  Expands the layout to have \a newRowCount rows and \a newColumnCount columns. So the last valid
+  row index will be \a newRowCount-1, the last valid column index will be \a newColumnCount-1.
+  
+  If the current column/row count is already larger or equal to \a newColumnCount/\a newRowCount,
+  this function does nothing in that dimension.
+  
+  Newly created cells are empty, new rows and columns have the stretch factor 1.
+  
+  Note that upon a call to \ref addElement, the layout is expanded automatically to contain the
+  specified row and column, using this function.
+  
+  \see simplify
+*/
+void QCPLayoutGrid::expandTo(int newRowCount, int newColumnCount)
+{
+  // add rows as necessary:
+  while (rowCount() < newRowCount)
+  {
+    mElements.append(QList<QCPLayoutElement*>());
+    mRowStretchFactors.append(1);
+  }
+  // go through rows and expand columns as necessary:
+  int newColCount = qMax(columnCount(), newColumnCount);
+  for (int i=0; i<rowCount(); ++i)
+  {
+    while (mElements.at(i).size() < newColCount)
+      mElements[i].append(0);
+  }
+  while (mColumnStretchFactors.size() < newColCount)
+    mColumnStretchFactors.append(1);
+}
+
+/*!
+  Inserts a new row with empty cells at the row index \a newIndex. Valid values for \a newIndex
+  range from 0 (inserts a row at the top) to \a rowCount (appends a row at the bottom).
+  
+  \see insertColumn
+*/
+void QCPLayoutGrid::insertRow(int newIndex)
+{
+  if (mElements.isEmpty() || mElements.first().isEmpty()) // if grid is completely empty, add first cell
+  {
+    expandTo(1, 1);
+    return;
+  }
+  
+  if (newIndex < 0)
+    newIndex = 0;
+  if (newIndex > rowCount())
+    newIndex = rowCount();
+  
+  mRowStretchFactors.insert(newIndex, 1);
+  QList<QCPLayoutElement*> newRow;
+  for (int col=0; col<columnCount(); ++col)
+    newRow.append((QCPLayoutElement*)0);
+  mElements.insert(newIndex, newRow);
+}
+
+/*!
+  Inserts a new column with empty cells at the column index \a newIndex. Valid values for \a
+  newIndex range from 0 (inserts a row at the left) to \a rowCount (appends a row at the right).
+  
+  \see insertRow
+*/
+void QCPLayoutGrid::insertColumn(int newIndex)
+{
+  if (mElements.isEmpty() || mElements.first().isEmpty()) // if grid is completely empty, add first cell
+  {
+    expandTo(1, 1);
+    return;
+  }
+  
+  if (newIndex < 0)
+    newIndex = 0;
+  if (newIndex > columnCount())
+    newIndex = columnCount();
+  
+  mColumnStretchFactors.insert(newIndex, 1);
+  for (int row=0; row<rowCount(); ++row)
+    mElements[row].insert(newIndex, (QCPLayoutElement*)0);
+}
+
+/* inherits documentation from base class */
+void QCPLayoutGrid::updateLayout()
+{
+  QVector<int> minColWidths, minRowHeights, maxColWidths, maxRowHeights;
+  getMinimumRowColSizes(&minColWidths, &minRowHeights);
+  getMaximumRowColSizes(&maxColWidths, &maxRowHeights);
+  
+  int totalRowSpacing = (rowCount()-1) * mRowSpacing;
+  int totalColSpacing = (columnCount()-1) * mColumnSpacing;
+  QVector<int> colWidths = getSectionSizes(maxColWidths, minColWidths, mColumnStretchFactors.toVector(), mRect.width()-totalColSpacing);
+  QVector<int> rowHeights = getSectionSizes(maxRowHeights, minRowHeights, mRowStretchFactors.toVector(), mRect.height()-totalRowSpacing);
+  
+  // go through cells and set rects accordingly:
+  int yOffset = mRect.top();
+  for (int row=0; row<rowCount(); ++row)
+  {
+    if (row > 0)
+      yOffset += rowHeights.at(row-1)+mRowSpacing;
+    int xOffset = mRect.left();
+    for (int col=0; col<columnCount(); ++col)
+    {
+      if (col > 0)
+        xOffset += colWidths.at(col-1)+mColumnSpacing;
+      if (mElements.at(row).at(col))
+        mElements.at(row).at(col)->setOuterRect(QRect(xOffset, yOffset, colWidths.at(col), rowHeights.at(row)));
+    }
+  }
+}
+
+/* inherits documentation from base class */
+int QCPLayoutGrid::elementCount() const
+{
+  return rowCount()*columnCount();
+}
+
+/* inherits documentation from base class */
+QCPLayoutElement *QCPLayoutGrid::elementAt(int index) const
+{
+  if (index >= 0 && index < elementCount())
+    return mElements.at(index / columnCount()).at(index % columnCount());
+  else
+    return 0;
+}
+
+/* inherits documentation from base class */
+QCPLayoutElement *QCPLayoutGrid::takeAt(int index)
+{
+  if (QCPLayoutElement *el = elementAt(index))
+  {
+    releaseElement(el);
+    mElements[index / columnCount()][index % columnCount()] = 0;
+    return el;
+  } else
+  {
+    qDebug() << Q_FUNC_INFO << "Attempt to take invalid index:" << index;
+    return 0;
+  }
+}
+
+/* inherits documentation from base class */
+bool QCPLayoutGrid::take(QCPLayoutElement *element)
+{
+  if (element)
+  {
+    for (int i=0; i<elementCount(); ++i)
+    {
+      if (elementAt(i) == element)
+      {
+        takeAt(i);
+        return true;
+      }
+    }
+    qDebug() << Q_FUNC_INFO << "Element not in this layout, couldn't take";
+  } else
+    qDebug() << Q_FUNC_INFO << "Can't take null element";
+  return false;
+}
+
+/* inherits documentation from base class */
+QList<QCPLayoutElement*> QCPLayoutGrid::elements(bool recursive) const
+{
+  QList<QCPLayoutElement*> result;
+  int colC = columnCount();
+  int rowC = rowCount();
+#if QT_VERSION >= QT_VERSION_CHECK(4, 7, 0)
+  result.reserve(colC*rowC);
+#endif
+  for (int row=0; row<rowC; ++row)
+  {
+    for (int col=0; col<colC; ++col)
+    {
+      result.append(mElements.at(row).at(col));
+    }
+  }
+  if (recursive)
+  {
+    int c = result.size();
+    for (int i=0; i<c; ++i)
+    {
+      if (result.at(i))
+        result << result.at(i)->elements(recursive);
+    }
+  }
+  return result;
+}
+
+/*!
+  Simplifies the layout by collapsing rows and columns which only contain empty cells.
+*/
+void QCPLayoutGrid::simplify()
+{
+  // remove rows with only empty cells:
+  for (int row=rowCount()-1; row>=0; --row)
+  {
+    bool hasElements = false;
+    for (int col=0; col<columnCount(); ++col)
+    {
+      if (mElements.at(row).at(col))
+      {
+        hasElements = true;
+        break;
+      }
+    }
+    if (!hasElements)
+    {
+      mRowStretchFactors.removeAt(row);
+      mElements.removeAt(row);
+      if (mElements.isEmpty()) // removed last element, also remove stretch factor (wouldn't happen below because also columnCount changed to 0 now)
+        mColumnStretchFactors.clear();
+    }
+  }
+  
+  // remove columns with only empty cells:
+  for (int col=columnCount()-1; col>=0; --col)
+  {
+    bool hasElements = false;
+    for (int row=0; row<rowCount(); ++row)
+    {
+      if (mElements.at(row).at(col))
+      {
+        hasElements = true;
+        break;
+      }
+    }
+    if (!hasElements)
+    {
+      mColumnStretchFactors.removeAt(col);
+      for (int row=0; row<rowCount(); ++row)
+        mElements[row].removeAt(col);
+    }
+  }
+}
+
+/* inherits documentation from base class */
+QSize QCPLayoutGrid::minimumSizeHint() const
+{
+  QVector<int> minColWidths, minRowHeights;
+  getMinimumRowColSizes(&minColWidths, &minRowHeights);
+  QSize result(0, 0);
+  for (int i=0; i<minColWidths.size(); ++i)
+    result.rwidth() += minColWidths.at(i);
+  for (int i=0; i<minRowHeights.size(); ++i)
+    result.rheight() += minRowHeights.at(i);
+  result.rwidth() += qMax(0, columnCount()-1) * mColumnSpacing + mMargins.left() + mMargins.right();
+  result.rheight() += qMax(0, rowCount()-1) * mRowSpacing + mMargins.top() + mMargins.bottom();
+  return result;
+}
+
+/* inherits documentation from base class */
+QSize QCPLayoutGrid::maximumSizeHint() const
+{
+  QVector<int> maxColWidths, maxRowHeights;
+  getMaximumRowColSizes(&maxColWidths, &maxRowHeights);
+  
+  QSize result(0, 0);
+  for (int i=0; i<maxColWidths.size(); ++i)
+    result.setWidth(qMin(result.width()+maxColWidths.at(i), QWIDGETSIZE_MAX));
+  for (int i=0; i<maxRowHeights.size(); ++i)
+    result.setHeight(qMin(result.height()+maxRowHeights.at(i), QWIDGETSIZE_MAX));
+  result.rwidth() += qMax(0, columnCount()-1) * mColumnSpacing + mMargins.left() + mMargins.right();
+  result.rheight() += qMax(0, rowCount()-1) * mRowSpacing + mMargins.top() + mMargins.bottom();
+  return result;
+}
+
+/*! \internal
+  
+  Places the minimum column widths and row heights into \a minColWidths and \a minRowHeights
+  respectively.
+  
+  The minimum height of a row is the largest minimum height of any element in that row. The minimum
+  width of a column is the largest minimum width of any element in that column.
+  
+  This is a helper function for \ref updateLayout.
+  
+  \see getMaximumRowColSizes
+*/
+void QCPLayoutGrid::getMinimumRowColSizes(QVector<int> *minColWidths, QVector<int> *minRowHeights) const
+{
+  *minColWidths = QVector<int>(columnCount(), 0);
+  *minRowHeights = QVector<int>(rowCount(), 0);
+  for (int row=0; row<rowCount(); ++row)
+  {
+    for (int col=0; col<columnCount(); ++col)
+    {
+      if (mElements.at(row).at(col))
+      {
+        QSize minHint = mElements.at(row).at(col)->minimumSizeHint();
+        QSize min = mElements.at(row).at(col)->minimumSize();
+        QSize final(min.width() > 0 ? min.width() : minHint.width(), min.height() > 0 ? min.height() : minHint.height());
+        if (minColWidths->at(col) < final.width())
+          (*minColWidths)[col] = final.width();
+        if (minRowHeights->at(row) < final.height())
+          (*minRowHeights)[row] = final.height();
+      }
+    }
+  }
+}
+
+/*! \internal
+  
+  Places the maximum column widths and row heights into \a maxColWidths and \a maxRowHeights
+  respectively.
+  
+  The maximum height of a row is the smallest maximum height of any element in that row. The
+  maximum width of a column is the smallest maximum width of any element in that column.
+  
+  This is a helper function for \ref updateLayout.
+  
+  \see getMinimumRowColSizes
+*/
+void QCPLayoutGrid::getMaximumRowColSizes(QVector<int> *maxColWidths, QVector<int> *maxRowHeights) const
+{
+  *maxColWidths = QVector<int>(columnCount(), QWIDGETSIZE_MAX);
+  *maxRowHeights = QVector<int>(rowCount(), QWIDGETSIZE_MAX);
+  for (int row=0; row<rowCount(); ++row)
+  {
+    for (int col=0; col<columnCount(); ++col)
+    {
+      if (mElements.at(row).at(col))
+      {
+        QSize maxHint = mElements.at(row).at(col)->maximumSizeHint();
+        QSize max = mElements.at(row).at(col)->maximumSize();
+        QSize final(max.width() < QWIDGETSIZE_MAX ? max.width() : maxHint.width(), max.height() < QWIDGETSIZE_MAX ? max.height() : maxHint.height());
+        if (maxColWidths->at(col) > final.width())
+          (*maxColWidths)[col] = final.width();
+        if (maxRowHeights->at(row) > final.height())
+          (*maxRowHeights)[row] = final.height();
+      }
+    }
+  }
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPLayoutInset
+////////////////////////////////////////////////////////////////////////////////////////////////////
+/*! \class QCPLayoutInset
+  \brief A layout that places child elements aligned to the border or arbitrarily positioned
+  
+  Elements are placed either aligned to the border or at arbitrary position in the area of the
+  layout. Which placement applies is controlled with the \ref InsetPlacement (\ref
+  setInsetPlacement).
+
+  Elements are added via \ref addElement(QCPLayoutElement *element, Qt::Alignment alignment) or
+  addElement(QCPLayoutElement *element, const QRectF &rect). If the first method is used, the inset
+  placement will default to \ref ipBorderAligned and the element will be aligned according to the
+  \a alignment parameter. The second method defaults to \ref ipFree and allows placing elements at
+  arbitrary position and size, defined by \a rect.
+  
+  The alignment or rect can be set via \ref setInsetAlignment or \ref setInsetRect, respectively.
+  
+  This is the layout that every QCPAxisRect has as \ref QCPAxisRect::insetLayout.
+*/
+
+/* start documentation of inline functions */
+
+/*! \fn virtual void QCPLayoutInset::simplify()
+  
+  The QCPInsetLayout does not need simplification since it can never have empty cells due to its
+  linear index structure. This method does nothing.
+*/
+
+/* end documentation of inline functions */
+
+/*!
+  Creates an instance of QCPLayoutInset and sets default values.
+*/
+QCPLayoutInset::QCPLayoutInset()
+{
+}
+
+QCPLayoutInset::~QCPLayoutInset()
+{
+  // clear all child layout elements. This is important because only the specific layouts know how
+  // to handle removing elements (clear calls virtual removeAt method to do that).
+  clear();
+}
+
+/*!
+  Returns the placement type of the element with the specified \a index.
+*/
+QCPLayoutInset::InsetPlacement QCPLayoutInset::insetPlacement(int index) const
+{
+  if (elementAt(index))
+    return mInsetPlacement.at(index);
+  else
+  {
+    qDebug() << Q_FUNC_INFO << "Invalid element index:" << index;
+    return ipFree;
+  }
+}
+
+/*!
+  Returns the alignment of the element with the specified \a index. The alignment only has a
+  meaning, if the inset placement (\ref setInsetPlacement) is \ref ipBorderAligned.
+*/
+Qt::Alignment QCPLayoutInset::insetAlignment(int index) const
+{
+  if (elementAt(index))
+    return mInsetAlignment.at(index);
+  else
+  {
+    qDebug() << Q_FUNC_INFO << "Invalid element index:" << index;
+    return 0;
+  }
+}
+
+/*!
+  Returns the rect of the element with the specified \a index. The rect only has a
+  meaning, if the inset placement (\ref setInsetPlacement) is \ref ipFree.
+*/
+QRectF QCPLayoutInset::insetRect(int index) const
+{
+  if (elementAt(index))
+    return mInsetRect.at(index);
+  else
+  {
+    qDebug() << Q_FUNC_INFO << "Invalid element index:" << index;
+    return QRectF();
+  }
+}
+
+/*!
+  Sets the inset placement type of the element with the specified \a index to \a placement.
+  
+  \see InsetPlacement
+*/
+void QCPLayoutInset::setInsetPlacement(int index, QCPLayoutInset::InsetPlacement placement)
+{
+  if (elementAt(index))
+    mInsetPlacement[index] = placement;
+  else
+    qDebug() << Q_FUNC_INFO << "Invalid element index:" << index;
+}
+
+/*!
+  If the inset placement (\ref setInsetPlacement) is \ref ipBorderAligned, this function
+  is used to set the alignment of the element with the specified \a index to \a alignment.
+  
+  \a alignment is an or combination of the following alignment flags: Qt::AlignLeft,
+  Qt::AlignHCenter, Qt::AlighRight, Qt::AlignTop, Qt::AlignVCenter, Qt::AlignBottom. Any other
+  alignment flags will be ignored.
+*/
+void QCPLayoutInset::setInsetAlignment(int index, Qt::Alignment alignment)
+{
+  if (elementAt(index))
+    mInsetAlignment[index] = alignment;
+  else
+    qDebug() << Q_FUNC_INFO << "Invalid element index:" << index;
+}
+
+/*!
+  If the inset placement (\ref setInsetPlacement) is \ref ipFree, this function is used to set the
+  position and size of the element with the specified \a index to \a rect.
+  
+  \a rect is given in fractions of the whole inset layout rect. So an inset with rect (0, 0, 1, 1)
+  will span the entire layout. An inset with rect (0.6, 0.1, 0.35, 0.35) will be in the top right
+  corner of the layout, with 35% width and height of the parent layout.
+  
+  Note that the minimum and maximum sizes of the embedded element (\ref
+  QCPLayoutElement::setMinimumSize, \ref QCPLayoutElement::setMaximumSize) are enforced.
+*/
+void QCPLayoutInset::setInsetRect(int index, const QRectF &rect)
+{
+  if (elementAt(index))
+    mInsetRect[index] = rect;
+  else
+    qDebug() << Q_FUNC_INFO << "Invalid element index:" << index;
+}
+
+/* inherits documentation from base class */
+void QCPLayoutInset::updateLayout()
+{
+  for (int i=0; i<mElements.size(); ++i)
+  {
+    QRect insetRect;
+    QSize finalMinSize, finalMaxSize;
+    QSize minSizeHint = mElements.at(i)->minimumSizeHint();
+    QSize maxSizeHint = mElements.at(i)->maximumSizeHint();
+    finalMinSize.setWidth(mElements.at(i)->minimumSize().width() > 0 ? mElements.at(i)->minimumSize().width() : minSizeHint.width());
+    finalMinSize.setHeight(mElements.at(i)->minimumSize().height() > 0 ? mElements.at(i)->minimumSize().height() : minSizeHint.height());
+    finalMaxSize.setWidth(mElements.at(i)->maximumSize().width() < QWIDGETSIZE_MAX ? mElements.at(i)->maximumSize().width() : maxSizeHint.width());
+    finalMaxSize.setHeight(mElements.at(i)->maximumSize().height() < QWIDGETSIZE_MAX ? mElements.at(i)->maximumSize().height() : maxSizeHint.height());
+    if (mInsetPlacement.at(i) == ipFree)
+    {
+      insetRect = QRect(rect().x()+rect().width()*mInsetRect.at(i).x(),
+                        rect().y()+rect().height()*mInsetRect.at(i).y(),
+                        rect().width()*mInsetRect.at(i).width(),
+                        rect().height()*mInsetRect.at(i).height());
+      if (insetRect.size().width() < finalMinSize.width())
+        insetRect.setWidth(finalMinSize.width());
+      if (insetRect.size().height() < finalMinSize.height())
+        insetRect.setHeight(finalMinSize.height());
+      if (insetRect.size().width() > finalMaxSize.width())
+        insetRect.setWidth(finalMaxSize.width());
+      if (insetRect.size().height() > finalMaxSize.height())
+        insetRect.setHeight(finalMaxSize.height());
+    } else if (mInsetPlacement.at(i) == ipBorderAligned)
+    {
+      insetRect.setSize(finalMinSize);
+      Qt::Alignment al = mInsetAlignment.at(i);
+      if (al.testFlag(Qt::AlignLeft)) insetRect.moveLeft(rect().x());
+      else if (al.testFlag(Qt::AlignRight)) insetRect.moveRight(rect().x()+rect().width());
+      else insetRect.moveLeft(rect().x()+rect().width()*0.5-finalMinSize.width()*0.5); // default to Qt::AlignHCenter
+      if (al.testFlag(Qt::AlignTop)) insetRect.moveTop(rect().y());
+      else if (al.testFlag(Qt::AlignBottom)) insetRect.moveBottom(rect().y()+rect().height());
+      else insetRect.moveTop(rect().y()+rect().height()*0.5-finalMinSize.height()*0.5); // default to Qt::AlignVCenter
+    }
+    mElements.at(i)->setOuterRect(insetRect);
+  }
+}
+
+/* inherits documentation from base class */
+int QCPLayoutInset::elementCount() const
+{
+  return mElements.size();
+}
+
+/* inherits documentation from base class */
+QCPLayoutElement *QCPLayoutInset::elementAt(int index) const
+{
+  if (index >= 0 && index < mElements.size())
+    return mElements.at(index);
+  else
+    return 0;
+}
+
+/* inherits documentation from base class */
+QCPLayoutElement *QCPLayoutInset::takeAt(int index)
+{
+  if (QCPLayoutElement *el = elementAt(index))
+  {
+    releaseElement(el);
+    mElements.removeAt(index);
+    mInsetPlacement.removeAt(index);
+    mInsetAlignment.removeAt(index);
+    mInsetRect.removeAt(index);
+    return el;
+  } else
+  {
+    qDebug() << Q_FUNC_INFO << "Attempt to take invalid index:" << index;
+    return 0;
+  }
+}
+
+/* inherits documentation from base class */
+bool QCPLayoutInset::take(QCPLayoutElement *element)
+{
+  if (element)
+  {
+    for (int i=0; i<elementCount(); ++i)
+    {
+      if (elementAt(i) == element)
+      {
+        takeAt(i);
+        return true;
+      }
+    }
+    qDebug() << Q_FUNC_INFO << "Element not in this layout, couldn't take";
+  } else
+    qDebug() << Q_FUNC_INFO << "Can't take null element";
+  return false;
+}
+
+/*!
+  The inset layout is sensitive to events only at areas where its (visible) child elements are
+  sensitive. If the selectTest method of any of the child elements returns a positive number for \a
+  pos, this method returns a value corresponding to 0.99 times the parent plot's selection
+  tolerance. The inset layout is not selectable itself by default. So if \a onlySelectable is true,
+  -1.0 is returned.
+  
+  See \ref QCPLayerable::selectTest for a general explanation of this virtual method.
+*/
+double QCPLayoutInset::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  if (onlySelectable)
+    return -1;
+  
+  for (int i=0; i<mElements.size(); ++i)
+  {
+    // inset layout shall only return positive selectTest, if actually an inset object is at pos
+    // else it would block the entire underlying QCPAxisRect with its surface.
+    if (mElements.at(i)->realVisibility() && mElements.at(i)->selectTest(pos, onlySelectable) >= 0)
+      return mParentPlot->selectionTolerance()*0.99;
+  }
+  return -1;
+}
+
+/*!
+  Adds the specified \a element to the layout as an inset aligned at the border (\ref
+  setInsetAlignment is initialized with \ref ipBorderAligned). The alignment is set to \a
+  alignment.
+  
+  \a alignment is an or combination of the following alignment flags: Qt::AlignLeft,
+  Qt::AlignHCenter, Qt::AlighRight, Qt::AlignTop, Qt::AlignVCenter, Qt::AlignBottom. Any other
+  alignment flags will be ignored.
+  
+  \see addElement(QCPLayoutElement *element, const QRectF &rect)
+*/
+void QCPLayoutInset::addElement(QCPLayoutElement *element, Qt::Alignment alignment)
+{
+  if (element)
+  {
+    if (element->layout()) // remove from old layout first
+      element->layout()->take(element);
+    mElements.append(element);
+    mInsetPlacement.append(ipBorderAligned);
+    mInsetAlignment.append(alignment);
+    mInsetRect.append(QRectF(0.6, 0.6, 0.4, 0.4));
+    adoptElement(element);
+  } else
+    qDebug() << Q_FUNC_INFO << "Can't add null element";
+}
+
+/*!
+  Adds the specified \a element to the layout as an inset with free positioning/sizing (\ref
+  setInsetAlignment is initialized with \ref ipFree). The position and size is set to \a
+  rect.
+  
+  \a rect is given in fractions of the whole inset layout rect. So an inset with rect (0, 0, 1, 1)
+  will span the entire layout. An inset with rect (0.6, 0.1, 0.35, 0.35) will be in the top right
+  corner of the layout, with 35% width and height of the parent layout.
+  
+  \see addElement(QCPLayoutElement *element, Qt::Alignment alignment)
+*/
+void QCPLayoutInset::addElement(QCPLayoutElement *element, const QRectF &rect)
+{
+  if (element)
+  {
+    if (element->layout()) // remove from old layout first
+      element->layout()->take(element);
+    mElements.append(element);
+    mInsetPlacement.append(ipFree);
+    mInsetAlignment.append(Qt::AlignRight|Qt::AlignTop);
+    mInsetRect.append(rect);
+    adoptElement(element);
+  } else
+    qDebug() << Q_FUNC_INFO << "Can't add null element";
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPLineEnding
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPLineEnding
+  \brief Handles the different ending decorations for line-like items
+  
+  \image html QCPLineEnding.png "The various ending styles currently supported"
+  
+  For every ending a line-like item has, an instance of this class exists. For example, QCPItemLine
+  has two endings which can be set with QCPItemLine::setHead and QCPItemLine::setTail.
+ 
+  The styles themselves are defined via the enum QCPLineEnding::EndingStyle. Most decorations can
+  be modified regarding width and length, see \ref setWidth and \ref setLength. The direction of
+  the ending decoration (e.g. direction an arrow is pointing) is controlled by the line-like item.
+  For example, when both endings of a QCPItemLine are set to be arrows, they will point to opposite
+  directions, e.g. "outward". This can be changed by \ref setInverted, which would make the
+  respective arrow point inward.
+  
+  Note that due to the overloaded QCPLineEnding constructor, you may directly specify a
+  QCPLineEnding::EndingStyle where actually a QCPLineEnding is expected, e.g.
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcplineending-sethead
+*/
+
+/*!
+  Creates a QCPLineEnding instance with default values (style \ref esNone).
+*/
+QCPLineEnding::QCPLineEnding() :
+  mStyle(esNone),
+  mWidth(8),
+  mLength(10),
+  mInverted(false)
+{
+}
+
+/*!
+  Creates a QCPLineEnding instance with the specified values.
+*/
+QCPLineEnding::QCPLineEnding(QCPLineEnding::EndingStyle style, double width, double length, bool inverted) :
+  mStyle(style),
+  mWidth(width),
+  mLength(length),
+  mInverted(inverted)
+{
+}
+
+/*!
+  Sets the style of the ending decoration.
+*/
+void QCPLineEnding::setStyle(QCPLineEnding::EndingStyle style)
+{
+  mStyle = style;
+}
+
+/*!
+  Sets the width of the ending decoration, if the style supports it. On arrows, for example, the
+  width defines the size perpendicular to the arrow's pointing direction.
+  
+  \see setLength
+*/
+void QCPLineEnding::setWidth(double width)
+{
+  mWidth = width;
+}
+
+/*!
+  Sets the length of the ending decoration, if the style supports it. On arrows, for example, the
+  length defines the size in pointing direction.
+  
+  \see setWidth
+*/
+void QCPLineEnding::setLength(double length)
+{
+  mLength = length;
+}
+
+/*!
+  Sets whether the ending decoration shall be inverted. For example, an arrow decoration will point
+  inward when \a inverted is set to true.
+
+  Note that also the \a width direction is inverted. For symmetrical ending styles like arrows or
+  discs, this doesn't make a difference. However, asymmetric styles like \ref esHalfBar are
+  affected by it, which can be used to control to which side the half bar points to.
+*/
+void QCPLineEnding::setInverted(bool inverted)
+{
+  mInverted = inverted;
+}
+
+/*! \internal
+  
+  Returns the maximum pixel radius the ending decoration might cover, starting from the position
+  the decoration is drawn at (typically a line ending/\ref QCPItemPosition of an item).
+  
+  This is relevant for clipping. Only omit painting of the decoration when the position where the
+  decoration is supposed to be drawn is farther away from the clipping rect than the returned
+  distance.
+*/
+double QCPLineEnding::boundingDistance() const
+{
+  switch (mStyle)
+  {
+    case esNone:
+      return 0;
+      
+    case esFlatArrow:
+    case esSpikeArrow:
+    case esLineArrow:
+    case esSkewedBar:
+      return qSqrt(mWidth*mWidth+mLength*mLength); // items that have width and length
+      
+    case esDisc:
+    case esSquare:
+    case esDiamond:
+    case esBar:
+    case esHalfBar:
+      return mWidth*1.42; // items that only have a width -> width*sqrt(2)
+
+  }
+  return 0;
+}
+
+/*!
+  Starting from the origin of this line ending (which is style specific), returns the length
+  covered by the line ending symbol, in backward direction.
+  
+  For example, the \ref esSpikeArrow has a shorter real length than a \ref esFlatArrow, even if
+  both have the same \ref setLength value, because the spike arrow has an inward curved back, which
+  reduces the length along its center axis (the drawing origin for arrows is at the tip).
+  
+  This function is used for precise, style specific placement of line endings, for example in
+  QCPAxes.
+*/
+double QCPLineEnding::realLength() const
+{
+  switch (mStyle)
+  {
+    case esNone:
+    case esLineArrow:
+    case esSkewedBar:
+    case esBar:
+    case esHalfBar:
+      return 0;
+      
+    case esFlatArrow:
+      return mLength;
+      
+    case esDisc:
+    case esSquare:
+    case esDiamond:
+      return mWidth*0.5;
+      
+    case esSpikeArrow:
+      return mLength*0.8;
+  }
+  return 0;
+}
+
+/*! \internal
+  
+  Draws the line ending with the specified \a painter at the position \a pos. The direction of the
+  line ending is controlled with \a dir.
+*/
+void QCPLineEnding::draw(QCPPainter *painter, const QVector2D &pos, const QVector2D &dir) const
+{
+  if (mStyle == esNone)
+    return;
+  
+  QVector2D lengthVec(dir.normalized());
+  if (lengthVec.isNull())
+    lengthVec = QVector2D(1, 0);
+  QVector2D widthVec(-lengthVec.y(), lengthVec.x());
+  lengthVec *= (float)(mLength*(mInverted ? -1 : 1));
+  widthVec *= (float)(mWidth*0.5*(mInverted ? -1 : 1));
+  
+  QPen penBackup = painter->pen();
+  QBrush brushBackup = painter->brush();
+  QPen miterPen = penBackup;
+  miterPen.setJoinStyle(Qt::MiterJoin); // to make arrow heads spikey
+  QBrush brush(painter->pen().color(), Qt::SolidPattern);
+  switch (mStyle)
+  {
+    case esNone: break;
+    case esFlatArrow:
+    {
+      QPointF points[3] = {pos.toPointF(),
+                           (pos-lengthVec+widthVec).toPointF(),
+                           (pos-lengthVec-widthVec).toPointF()
+                          };
+      painter->setPen(miterPen);
+      painter->setBrush(brush);
+      painter->drawConvexPolygon(points, 3);
+      painter->setBrush(brushBackup);
+      painter->setPen(penBackup);
+      break;
+    }
+    case esSpikeArrow:
+    {
+      QPointF points[4] = {pos.toPointF(),
+                           (pos-lengthVec+widthVec).toPointF(),
+                           (pos-lengthVec*0.8f).toPointF(),
+                           (pos-lengthVec-widthVec).toPointF()
+                          };
+      painter->setPen(miterPen);
+      painter->setBrush(brush);
+      painter->drawConvexPolygon(points, 4);
+      painter->setBrush(brushBackup);
+      painter->setPen(penBackup);
+      break;
+    }
+    case esLineArrow:
+    {
+      QPointF points[3] = {(pos-lengthVec+widthVec).toPointF(),
+                           pos.toPointF(),
+                           (pos-lengthVec-widthVec).toPointF()
+                          };
+      painter->setPen(miterPen);
+      painter->drawPolyline(points, 3);
+      painter->setPen(penBackup);
+      break;
+    }
+    case esDisc:
+    {
+      painter->setBrush(brush);
+      painter->drawEllipse(pos.toPointF(),  mWidth*0.5, mWidth*0.5);
+      painter->setBrush(brushBackup);
+      break;
+    }
+    case esSquare:
+    {
+      QVector2D widthVecPerp(-widthVec.y(), widthVec.x());
+      QPointF points[4] = {(pos-widthVecPerp+widthVec).toPointF(),
+                           (pos-widthVecPerp-widthVec).toPointF(),
+                           (pos+widthVecPerp-widthVec).toPointF(),
+                           (pos+widthVecPerp+widthVec).toPointF()
+                          };
+      painter->setPen(miterPen);
+      painter->setBrush(brush);
+      painter->drawConvexPolygon(points, 4);
+      painter->setBrush(brushBackup);
+      painter->setPen(penBackup);
+      break;
+    }
+    case esDiamond:
+    {
+      QVector2D widthVecPerp(-widthVec.y(), widthVec.x());
+      QPointF points[4] = {(pos-widthVecPerp).toPointF(),
+                           (pos-widthVec).toPointF(),
+                           (pos+widthVecPerp).toPointF(),
+                           (pos+widthVec).toPointF()
+                          };
+      painter->setPen(miterPen);
+      painter->setBrush(brush);
+      painter->drawConvexPolygon(points, 4);
+      painter->setBrush(brushBackup);
+      painter->setPen(penBackup);
+      break;
+    }
+    case esBar:
+    {
+      painter->drawLine((pos+widthVec).toPointF(), (pos-widthVec).toPointF());
+      break;
+    }
+    case esHalfBar:
+    {
+      painter->drawLine((pos+widthVec).toPointF(), pos.toPointF());
+      break;
+    }
+    case esSkewedBar:
+    {
+      if (qFuzzyIsNull(painter->pen().widthF()) && !painter->modes().testFlag(QCPPainter::pmNonCosmetic))
+      {
+        // if drawing with cosmetic pen (perfectly thin stroke, happens only in vector exports), draw bar exactly on tip of line
+        painter->drawLine((pos+widthVec+lengthVec*0.2f*(mInverted?-1:1)).toPointF(),
+                          (pos-widthVec-lengthVec*0.2f*(mInverted?-1:1)).toPointF());
+      } else
+      {
+        // if drawing with thick (non-cosmetic) pen, shift bar a little in line direction to prevent line from sticking through bar slightly
+        painter->drawLine((pos+widthVec+lengthVec*0.2f*(mInverted?-1:1)+dir.normalized()*qMax(1.0f, (float)painter->pen().widthF())*0.5f).toPointF(),
+                          (pos-widthVec-lengthVec*0.2f*(mInverted?-1:1)+dir.normalized()*qMax(1.0f, (float)painter->pen().widthF())*0.5f).toPointF());
+      }
+      break;
+    }
+  }
+}
+
+/*! \internal
+  \overload
+  
+  Draws the line ending. The direction is controlled with the \a angle parameter in radians.
+*/
+void QCPLineEnding::draw(QCPPainter *painter, const QVector2D &pos, double angle) const
+{
+  draw(painter, pos, QVector2D(qCos(angle), qSin(angle)));
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPGrid
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPGrid
+  \brief Responsible for drawing the grid of a QCPAxis.
+  
+  This class is tightly bound to QCPAxis. Every axis owns a grid instance and uses it to draw the
+  grid lines, sub grid lines and zero-line. You can interact with the grid of an axis via \ref
+  QCPAxis::grid. Normally, you don't need to create an instance of QCPGrid yourself.
+  
+  The axis and grid drawing was split into two classes to allow them to be placed on different
+  layers (both QCPAxis and QCPGrid inherit from QCPLayerable). Thus it is possible to have the grid
+  in the background and the axes in the foreground, and any plottables/items in between. This
+  described situation is the default setup, see the QCPLayer documentation.
+*/
+
+/*!
+  Creates a QCPGrid instance and sets default values.
+  
+  You shouldn't instantiate grids on their own, since every QCPAxis brings its own QCPGrid.
+*/
+QCPGrid::QCPGrid(QCPAxis *parentAxis) :
+  QCPLayerable(parentAxis->parentPlot(), QString(), parentAxis),
+  mParentAxis(parentAxis)
+{
+  // warning: this is called in QCPAxis constructor, so parentAxis members should not be accessed/called
+  setParent(parentAxis);
+  setPen(QPen(QColor(200,200,200), 0, Qt::DotLine));
+  setSubGridPen(QPen(QColor(220,220,220), 0, Qt::DotLine));
+  setZeroLinePen(QPen(QColor(200,200,200), 0, Qt::SolidLine));
+  setSubGridVisible(false);
+  setAntialiased(false);
+  setAntialiasedSubGrid(false);
+  setAntialiasedZeroLine(false);
+}
+
+/*!
+  Sets whether grid lines at sub tick marks are drawn.
+  
+  \see setSubGridPen
+*/
+void QCPGrid::setSubGridVisible(bool visible)
+{
+  mSubGridVisible = visible;
+}
+
+/*!
+  Sets whether sub grid lines are drawn antialiased.
+*/
+void QCPGrid::setAntialiasedSubGrid(bool enabled)
+{
+  mAntialiasedSubGrid = enabled;
+}
+
+/*!
+  Sets whether zero lines are drawn antialiased.
+*/
+void QCPGrid::setAntialiasedZeroLine(bool enabled)
+{
+  mAntialiasedZeroLine = enabled;
+}
+
+/*!
+  Sets the pen with which (major) grid lines are drawn.
+*/
+void QCPGrid::setPen(const QPen &pen)
+{
+  mPen = pen;
+}
+
+/*!
+  Sets the pen with which sub grid lines are drawn.
+*/
+void QCPGrid::setSubGridPen(const QPen &pen)
+{
+  mSubGridPen = pen;
+}
+
+/*!
+  Sets the pen with which zero lines are drawn.
+  
+  Zero lines are lines at value coordinate 0 which may be drawn with a different pen than other grid
+  lines. To disable zero lines and just draw normal grid lines at zero, set \a pen to Qt::NoPen.
+*/
+void QCPGrid::setZeroLinePen(const QPen &pen)
+{
+  mZeroLinePen = pen;
+}
+
+/*! \internal
+
+  A convenience function to easily set the QPainter::Antialiased hint on the provided \a painter
+  before drawing the major grid lines.
+
+  This is the antialiasing state the painter passed to the \ref draw method is in by default.
+  
+  This function takes into account the local setting of the antialiasing flag as well as the
+  overrides set with \ref QCustomPlot::setAntialiasedElements and \ref
+  QCustomPlot::setNotAntialiasedElements.
+  
+  \see setAntialiased
+*/
+void QCPGrid::applyDefaultAntialiasingHint(QCPPainter *painter) const
+{
+  applyAntialiasingHint(painter, mAntialiased, QCP::aeGrid);
+}
+
+/*! \internal
+  
+  Draws grid lines and sub grid lines at the positions of (sub) ticks of the parent axis, spanning
+  over the complete axis rect. Also draws the zero line, if appropriate (\ref setZeroLinePen).
+*/
+void QCPGrid::draw(QCPPainter *painter)
+{
+  if (!mParentAxis) { qDebug() << Q_FUNC_INFO << "invalid parent axis"; return; }
+  
+  if (mSubGridVisible)
+    drawSubGridLines(painter);
+  drawGridLines(painter);
+}
+
+/*! \internal
+  
+  Draws the main grid lines and possibly a zero line with the specified painter.
+  
+  This is a helper function called by \ref draw.
+*/
+void QCPGrid::drawGridLines(QCPPainter *painter) const
+{
+  if (!mParentAxis) { qDebug() << Q_FUNC_INFO << "invalid parent axis"; return; }
+  
+  int lowTick = mParentAxis->mLowestVisibleTick;
+  int highTick = mParentAxis->mHighestVisibleTick;
+  double t; // helper variable, result of coordinate-to-pixel transforms
+  if (mParentAxis->orientation() == Qt::Horizontal)
+  {
+    // draw zeroline:
+    int zeroLineIndex = -1;
+    if (mZeroLinePen.style() != Qt::NoPen && mParentAxis->mRange.lower < 0 && mParentAxis->mRange.upper > 0)
+    {
+      applyAntialiasingHint(painter, mAntialiasedZeroLine, QCP::aeZeroLine);
+      painter->setPen(mZeroLinePen);
+      double epsilon = mParentAxis->range().size()*1E-6; // for comparing double to zero
+      for (int i=lowTick; i <= highTick; ++i)
+      {
+        if (qAbs(mParentAxis->mTickVector.at(i)) < epsilon)
+        {
+          zeroLineIndex = i;
+          t = mParentAxis->coordToPixel(mParentAxis->mTickVector.at(i)); // x
+          painter->drawLine(QLineF(t, mParentAxis->mAxisRect->bottom(), t, mParentAxis->mAxisRect->top()));
+          break;
+        }
+      }
+    }
+    // draw grid lines:
+    applyDefaultAntialiasingHint(painter);
+    painter->setPen(mPen);
+    for (int i=lowTick; i <= highTick; ++i)
+    {
+      if (i == zeroLineIndex) continue; // don't draw a gridline on top of the zeroline
+      t = mParentAxis->coordToPixel(mParentAxis->mTickVector.at(i)); // x
+      painter->drawLine(QLineF(t, mParentAxis->mAxisRect->bottom(), t, mParentAxis->mAxisRect->top()));
+    }
+  } else
+  {
+    // draw zeroline:
+    int zeroLineIndex = -1;
+    if (mZeroLinePen.style() != Qt::NoPen && mParentAxis->mRange.lower < 0 && mParentAxis->mRange.upper > 0)
+    {
+      applyAntialiasingHint(painter, mAntialiasedZeroLine, QCP::aeZeroLine);
+      painter->setPen(mZeroLinePen);
+      double epsilon = mParentAxis->mRange.size()*1E-6; // for comparing double to zero
+      for (int i=lowTick; i <= highTick; ++i)
+      {
+        if (qAbs(mParentAxis->mTickVector.at(i)) < epsilon)
+        {
+          zeroLineIndex = i;
+          t = mParentAxis->coordToPixel(mParentAxis->mTickVector.at(i)); // y
+          painter->drawLine(QLineF(mParentAxis->mAxisRect->left(), t, mParentAxis->mAxisRect->right(), t));
+          break;
+        }
+      }
+    }
+    // draw grid lines:
+    applyDefaultAntialiasingHint(painter);
+    painter->setPen(mPen);
+    for (int i=lowTick; i <= highTick; ++i)
+    {
+      if (i == zeroLineIndex) continue; // don't draw a gridline on top of the zeroline
+      t = mParentAxis->coordToPixel(mParentAxis->mTickVector.at(i)); // y
+      painter->drawLine(QLineF(mParentAxis->mAxisRect->left(), t, mParentAxis->mAxisRect->right(), t));
+    }
+  }
+}
+
+/*! \internal
+  
+  Draws the sub grid lines with the specified painter.
+  
+  This is a helper function called by \ref draw.
+*/
+void QCPGrid::drawSubGridLines(QCPPainter *painter) const
+{
+  if (!mParentAxis) { qDebug() << Q_FUNC_INFO << "invalid parent axis"; return; }
+  
+  applyAntialiasingHint(painter, mAntialiasedSubGrid, QCP::aeSubGrid);
+  double t; // helper variable, result of coordinate-to-pixel transforms
+  painter->setPen(mSubGridPen);
+  if (mParentAxis->orientation() == Qt::Horizontal)
+  {
+    for (int i=0; i<mParentAxis->mSubTickVector.size(); ++i)
+    {
+      t = mParentAxis->coordToPixel(mParentAxis->mSubTickVector.at(i)); // x
+      painter->drawLine(QLineF(t, mParentAxis->mAxisRect->bottom(), t, mParentAxis->mAxisRect->top()));
+    }
+  } else
+  {
+    for (int i=0; i<mParentAxis->mSubTickVector.size(); ++i)
+    {
+      t = mParentAxis->coordToPixel(mParentAxis->mSubTickVector.at(i)); // y
+      painter->drawLine(QLineF(mParentAxis->mAxisRect->left(), t, mParentAxis->mAxisRect->right(), t));
+    }
+  }
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPAxis
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPAxis
+  \brief Manages a single axis inside a QCustomPlot.
+
+  Usually doesn't need to be instantiated externally. Access %QCustomPlot's default four axes via
+  QCustomPlot::xAxis (bottom), QCustomPlot::yAxis (left), QCustomPlot::xAxis2 (top) and
+  QCustomPlot::yAxis2 (right).
+  
+  Axes are always part of an axis rect, see QCPAxisRect.
+  \image html AxisNamesOverview.png
+  <center>Naming convention of axis parts</center>
+  \n
+    
+  \image html AxisRectSpacingOverview.png
+  <center>Overview of the spacings and paddings that define the geometry of an axis. The dashed gray line
+  on the left represents the QCustomPlot widget border.</center>
+
+*/
+
+/* start of documentation of inline functions */
+
+/*! \fn Qt::Orientation QCPAxis::orientation() const
+  
+  Returns the orientation of this axis. The axis orientation (horizontal or vertical) is deduced
+  from the axis type (left, top, right or bottom).
+  
+  \see orientation(AxisType type)
+*/
+
+/*! \fn QCPGrid *QCPAxis::grid() const
+  
+  Returns the \ref QCPGrid instance belonging to this axis. Access it to set details about the way the
+  grid is displayed.
+*/
+
+/*! \fn static Qt::Orientation QCPAxis::orientation(AxisType type)
+  
+  Returns the orientation of the specified axis type
+  
+  \see orientation()
+*/
+
+/* end of documentation of inline functions */
+/* start of documentation of signals */
+
+/*! \fn void QCPAxis::ticksRequest()
+  
+  This signal is emitted when \ref setAutoTicks is false and the axis is about to generate tick
+  labels for a replot.
+  
+  Modifying the tick positions can be done with \ref setTickVector. If you also want to control the
+  tick labels, set \ref setAutoTickLabels to false and also provide the labels with \ref
+  setTickVectorLabels.
+  
+  If you only want static ticks you probably don't need this signal, since you can just set the
+  tick vector (and possibly tick label vector) once. However, if you want to provide ticks (and
+  maybe labels) dynamically, e.g. depending on the current axis range, connect a slot to this
+  signal and set the vector/vectors there.
+*/
+
+/*! \fn void QCPAxis::rangeChanged(const QCPRange &newRange)
+
+  This signal is emitted when the range of this axis has changed. You can connect it to the \ref
+  setRange slot of another axis to communicate the new range to the other axis, in order for it to
+  be synchronized.
+  
+  You may also manipulate/correct the range with \ref setRange in a slot connected to this signal.
+  This is useful if for example a maximum range span shall not be exceeded, or if the lower/upper
+  range shouldn't go beyond certain values. For example, the following slot would limit the x axis
+  to only positive ranges:
+  \code
+  if (newRange.lower < 0)
+    plot->xAxis->setRange(0, newRange.size());
+  \endcode
+*/
+
+/*! \fn void QCPAxis::rangeChanged(const QCPRange &newRange, const QCPRange &oldRange)
+  \overload
+  
+  Additionally to the new range, this signal also provides the previous range held by the axis as
+  \a oldRange.
+*/
+
+/*! \fn void QCPAxis::scaleTypeChanged(QCPAxis::ScaleType scaleType);
+  
+  This signal is emitted when the scale type changes, by calls to \ref setScaleType
+*/
+
+/*! \fn void QCPAxis::selectionChanged(QCPAxis::SelectableParts selection)
+  
+  This signal is emitted when the selection state of this axis has changed, either by user interaction
+  or by a direct call to \ref setSelectedParts.
+*/
+
+/*! \fn void QCPAxis::selectableChanged(const QCPAxis::SelectableParts &parts);
+  
+  This signal is emitted when the selectability changes, by calls to \ref setSelectableParts
+*/
+
+/* end of documentation of signals */
+
+/*!
+  Constructs an Axis instance of Type \a type for the axis rect \a parent.
+  
+  Usually it isn't necessary to instantiate axes directly, because you can let QCustomPlot create
+  them for you with \ref QCPAxisRect::addAxis. If you want to use own QCPAxis-subclasses however,
+  create them manually and then inject them also via \ref QCPAxisRect::addAxis.
+*/
+QCPAxis::QCPAxis(QCPAxisRect *parent, AxisType type) :
+  QCPLayerable(parent->parentPlot(), QString(), parent),
+  // axis base:
+  mAxisType(type),
+  mAxisRect(parent),
+  mPadding(5),
+  mOrientation(orientation(type)),
+  mSelectableParts(spAxis | spTickLabels | spAxisLabel),
+  mSelectedParts(spNone),
+  mBasePen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),
+  mSelectedBasePen(QPen(Qt::blue, 2)),
+  // axis label:
+  mLabel(),
+  mLabelFont(mParentPlot->font()),
+  mSelectedLabelFont(QFont(mLabelFont.family(), mLabelFont.pointSize(), QFont::Bold)),
+  mLabelColor(Qt::black),
+  mSelectedLabelColor(Qt::blue),
+  // tick labels:
+  mTickLabels(true),
+  mAutoTickLabels(true),
+  mTickLabelType(ltNumber),
+  mTickLabelFont(mParentPlot->font()),
+  mSelectedTickLabelFont(QFont(mTickLabelFont.family(), mTickLabelFont.pointSize(), QFont::Bold)),
+  mTickLabelColor(Qt::black),
+  mSelectedTickLabelColor(Qt::blue),
+  mDateTimeFormat(QLatin1String("hh:mm:ss\ndd.MM.yy")),
+  mDateTimeSpec(Qt::LocalTime),
+  mNumberPrecision(6),
+  mNumberFormatChar('g'),
+  mNumberBeautifulPowers(true),
+  // ticks and subticks:
+  mTicks(true),
+  mTickStep(1),
+  mSubTickCount(4),
+  mAutoTickCount(6),
+  mAutoTicks(true),
+  mAutoTickStep(true),
+  mAutoSubTicks(true),
+  mTickPen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),
+  mSelectedTickPen(QPen(Qt::blue, 2)),
+  mSubTickPen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),
+  mSelectedSubTickPen(QPen(Qt::blue, 2)),
+  // scale and range:
+  mRange(0, 5),
+  mRangeReversed(false),
+  mScaleType(stLinear),
+  mScaleLogBase(10),
+  mScaleLogBaseLogInv(1.0/qLn(mScaleLogBase)),
+  // internal members:
+  mGrid(new QCPGrid(this)),
+  mAxisPainter(new QCPAxisPainterPrivate(parent->parentPlot())),
+  mLowestVisibleTick(0),
+  mHighestVisibleTick(-1),
+  mCachedMarginValid(false),
+  mCachedMargin(0)
+{
+  setParent(parent);
+  mGrid->setVisible(false);
+  setAntialiased(false);
+  setLayer(mParentPlot->currentLayer()); // it's actually on that layer already, but we want it in front of the grid, so we place it on there again
+  
+  if (type == atTop)
+  {
+    setTickLabelPadding(3);
+    setLabelPadding(6);
+  } else if (type == atRight)
+  {
+    setTickLabelPadding(7);
+    setLabelPadding(12);
+  } else if (type == atBottom)
+  {
+    setTickLabelPadding(3);
+    setLabelPadding(3);
+  } else if (type == atLeft)
+  {
+    setTickLabelPadding(5);
+    setLabelPadding(10);
+  }
+}
+
+QCPAxis::~QCPAxis()
+{
+  delete mAxisPainter;
+  delete mGrid; // delete grid here instead of via parent ~QObject for better defined deletion order
+}
+
+/* No documentation as it is a property getter */
+int QCPAxis::tickLabelPadding() const
+{
+  return mAxisPainter->tickLabelPadding;
+}
+
+/* No documentation as it is a property getter */
+double QCPAxis::tickLabelRotation() const
+{
+  return mAxisPainter->tickLabelRotation;
+}
+
+/* No documentation as it is a property getter */
+QCPAxis::LabelSide QCPAxis::tickLabelSide() const
+{
+  return mAxisPainter->tickLabelSide;
+}
+
+/* No documentation as it is a property getter */
+QString QCPAxis::numberFormat() const
+{
+  QString result;
+  result.append(mNumberFormatChar);
+  if (mNumberBeautifulPowers)
+  {
+    result.append(QLatin1Char('b'));
+    if (mAxisPainter->numberMultiplyCross)
+      result.append(QLatin1Char('c'));
+  }
+  return result;
+}
+
+/* No documentation as it is a property getter */
+int QCPAxis::tickLengthIn() const
+{
+  return mAxisPainter->tickLengthIn;
+}
+
+/* No documentation as it is a property getter */
+int QCPAxis::tickLengthOut() const
+{
+  return mAxisPainter->tickLengthOut;
+}
+
+/* No documentation as it is a property getter */
+int QCPAxis::subTickLengthIn() const
+{
+  return mAxisPainter->subTickLengthIn;
+}
+
+/* No documentation as it is a property getter */
+int QCPAxis::subTickLengthOut() const
+{
+  return mAxisPainter->subTickLengthOut;
+}
+
+/* No documentation as it is a property getter */
+int QCPAxis::labelPadding() const
+{
+  return mAxisPainter->labelPadding;
+}
+
+/* No documentation as it is a property getter */
+int QCPAxis::offset() const
+{
+  return mAxisPainter->offset;
+}
+
+/* No documentation as it is a property getter */
+QCPLineEnding QCPAxis::lowerEnding() const
+{
+  return mAxisPainter->lowerEnding;
+}
+
+/* No documentation as it is a property getter */
+QCPLineEnding QCPAxis::upperEnding() const
+{
+  return mAxisPainter->upperEnding;
+}
+
+/*!
+  Sets whether the axis uses a linear scale or a logarithmic scale. If \a type is set to \ref
+  stLogarithmic, the logarithm base can be set with \ref setScaleLogBase. In logarithmic axis
+  scaling, major tick marks appear at all powers of the logarithm base. Properties like tick step
+  (\ref setTickStep) don't apply in logarithmic scaling. If you wish a decimal base but less major
+  ticks, consider choosing a logarithm base of 100, 1000 or even higher.
+  
+  If \a type is \ref stLogarithmic and the number format (\ref setNumberFormat) uses the 'b' option
+  (beautifully typeset decimal powers), the display usually is "1 [multiplication sign] 10
+  [superscript] n", which looks unnatural for logarithmic scaling (the "1 [multiplication sign]"
+  part). To only display the decimal power, set the number precision to zero with
+  \ref setNumberPrecision.
+*/
+void QCPAxis::setScaleType(QCPAxis::ScaleType type)
+{
+  if (mScaleType != type)
+  {
+    mScaleType = type;
+    if (mScaleType == stLogarithmic)
+      setRange(mRange.sanitizedForLogScale());
+    mCachedMarginValid = false;
+    emit scaleTypeChanged(mScaleType);
+  }
+}
+
+/*!
+  If \ref setScaleType is set to \ref stLogarithmic, \a base will be the logarithm base of the
+  scaling. In logarithmic axis scaling, major tick marks appear at all powers of \a base.
+  
+  Properties like tick step (\ref setTickStep) don't apply in logarithmic scaling. If you wish a decimal base but
+  less major ticks, consider choosing \a base 100, 1000 or even higher.
+*/
+void QCPAxis::setScaleLogBase(double base)
+{
+  if (base > 1)
+  {
+    mScaleLogBase = base;
+    mScaleLogBaseLogInv = 1.0/qLn(mScaleLogBase); // buffer for faster baseLog() calculation
+    mCachedMarginValid = false;
+  } else
+    qDebug() << Q_FUNC_INFO << "Invalid logarithmic scale base (must be greater 1):" << base;
+}
+
+/*!
+  Sets the range of the axis.
+  
+  This slot may be connected with the \ref rangeChanged signal of another axis so this axis
+  is always synchronized with the other axis range, when it changes.
+  
+  To invert the direction of an axis, use \ref setRangeReversed.
+*/
+void QCPAxis::setRange(const QCPRange &range)
+{
+  if (range.lower == mRange.lower && range.upper == mRange.upper)
+    return;
+  
+  if (!QCPRange::validRange(range)) return;
+  QCPRange oldRange = mRange;
+  if (mScaleType == stLogarithmic)
+  {
+    mRange = range.sanitizedForLogScale();
+  } else
+  {
+    mRange = range.sanitizedForLinScale();
+  }
+  mCachedMarginValid = false;
+  emit rangeChanged(mRange);
+  emit rangeChanged(mRange, oldRange);
+}
+
+/*!
+  Sets whether the user can (de-)select the parts in \a selectable by clicking on the QCustomPlot surface.
+  (When \ref QCustomPlot::setInteractions contains iSelectAxes.)
+  
+  However, even when \a selectable is set to a value not allowing the selection of a specific part,
+  it is still possible to set the selection of this part manually, by calling \ref setSelectedParts
+  directly.
+  
+  \see SelectablePart, setSelectedParts
+*/
+void QCPAxis::setSelectableParts(const SelectableParts &selectable)
+{
+  if (mSelectableParts != selectable)
+  {
+    mSelectableParts = selectable;
+    emit selectableChanged(mSelectableParts);
+  }
+}
+
+/*!
+  Sets the selected state of the respective axis parts described by \ref SelectablePart. When a part
+  is selected, it uses a different pen/font.
+  
+  The entire selection mechanism for axes is handled automatically when \ref
+  QCustomPlot::setInteractions contains iSelectAxes. You only need to call this function when you
+  wish to change the selection state manually.
+  
+  This function can change the selection state of a part, independent of the \ref setSelectableParts setting.
+  
+  emits the \ref selectionChanged signal when \a selected is different from the previous selection state.
+  
+  \see SelectablePart, setSelectableParts, selectTest, setSelectedBasePen, setSelectedTickPen, setSelectedSubTickPen,
+  setSelectedTickLabelFont, setSelectedLabelFont, setSelectedTickLabelColor, setSelectedLabelColor
+*/
+void QCPAxis::setSelectedParts(const SelectableParts &selected)
+{
+  if (mSelectedParts != selected)
+  {
+    mSelectedParts = selected;
+    emit selectionChanged(mSelectedParts);
+  }
+}
+
+/*!
+  \overload
+  
+  Sets the lower and upper bound of the axis range.
+  
+  To invert the direction of an axis, use \ref setRangeReversed.
+  
+  There is also a slot to set a range, see \ref setRange(const QCPRange &range).
+*/
+void QCPAxis::setRange(double lower, double upper)
+{
+  if (lower == mRange.lower && upper == mRange.upper)
+    return;
+  
+  if (!QCPRange::validRange(lower, upper)) return;
+  QCPRange oldRange = mRange;
+  mRange.lower = lower;
+  mRange.upper = upper;
+  if (mScaleType == stLogarithmic)
+  {
+    mRange = mRange.sanitizedForLogScale();
+  } else
+  {
+    mRange = mRange.sanitizedForLinScale();
+  }
+  mCachedMarginValid = false;
+  emit rangeChanged(mRange);
+  emit rangeChanged(mRange, oldRange);
+}
+
+/*!
+  \overload
+  
+  Sets the range of the axis.
+  
+  The \a position coordinate indicates together with the \a alignment parameter, where the new
+  range will be positioned. \a size defines the size of the new axis range. \a alignment may be
+  Qt::AlignLeft, Qt::AlignRight or Qt::AlignCenter. This will cause the left border, right border,
+  or center of the range to be aligned with \a position. Any other values of \a alignment will
+  default to Qt::AlignCenter.
+*/
+void QCPAxis::setRange(double position, double size, Qt::AlignmentFlag alignment)
+{
+  if (alignment == Qt::AlignLeft)
+    setRange(position, position+size);
+  else if (alignment == Qt::AlignRight)
+    setRange(position-size, position);
+  else // alignment == Qt::AlignCenter
+    setRange(position-size/2.0, position+size/2.0);
+}
+
+/*!
+  Sets the lower bound of the axis range. The upper bound is not changed.
+  \see setRange
+*/
+void QCPAxis::setRangeLower(double lower)
+{
+  if (mRange.lower == lower)
+    return;
+  
+  QCPRange oldRange = mRange;
+  mRange.lower = lower;
+  if (mScaleType == stLogarithmic)
+  {
+    mRange = mRange.sanitizedForLogScale();
+  } else
+  {
+    mRange = mRange.sanitizedForLinScale();
+  }
+  mCachedMarginValid = false;
+  emit rangeChanged(mRange);
+  emit rangeChanged(mRange, oldRange);
+}
+
+/*!
+  Sets the upper bound of the axis range. The lower bound is not changed.
+  \see setRange
+*/
+void QCPAxis::setRangeUpper(double upper)
+{
+  if (mRange.upper == upper)
+    return;
+  
+  QCPRange oldRange = mRange;
+  mRange.upper = upper;
+  if (mScaleType == stLogarithmic)
+  {
+    mRange = mRange.sanitizedForLogScale();
+  } else
+  {
+    mRange = mRange.sanitizedForLinScale();
+  }
+  mCachedMarginValid = false;
+  emit rangeChanged(mRange);
+  emit rangeChanged(mRange, oldRange);
+}
+
+/*!
+  Sets whether the axis range (direction) is displayed reversed. Normally, the values on horizontal
+  axes increase left to right, on vertical axes bottom to top. When \a reversed is set to true, the
+  direction of increasing values is inverted.
+
+  Note that the range and data interface stays the same for reversed axes, e.g. the \a lower part
+  of the \ref setRange interface will still reference the mathematically smaller number than the \a
+  upper part.
+*/
+void QCPAxis::setRangeReversed(bool reversed)
+{
+  if (mRangeReversed != reversed)
+  {
+    mRangeReversed = reversed;
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  Sets whether the tick positions should be calculated automatically (either from an automatically
+  generated tick step or a tick step provided manually via \ref setTickStep, see \ref setAutoTickStep).
+  
+  If \a on is set to false, you must provide the tick positions manually via \ref setTickVector.
+  For these manual ticks you may let QCPAxis generate the appropriate labels automatically by
+  leaving \ref setAutoTickLabels set to true. If you also wish to control the displayed labels
+  manually, set \ref setAutoTickLabels to false and provide the label strings with \ref
+  setTickVectorLabels.
+  
+  If you need dynamically calculated tick vectors (and possibly tick label vectors), set the
+  vectors in a slot connected to the \ref ticksRequest signal.
+  
+  \see setAutoTickLabels, setAutoSubTicks, setAutoTickCount, setAutoTickStep
+*/
+void QCPAxis::setAutoTicks(bool on)
+{
+  if (mAutoTicks != on)
+  {
+    mAutoTicks = on;
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  When \ref setAutoTickStep is true, \a approximateCount determines how many ticks should be
+  generated in the visible range, approximately.
+  
+  It's not guaranteed that this number of ticks is met exactly, but approximately within a
+  tolerance of about two.
+  
+  Only values greater than zero are accepted as \a approximateCount.
+  
+  \see setAutoTickStep, setAutoTicks, setAutoSubTicks
+*/
+void QCPAxis::setAutoTickCount(int approximateCount)
+{
+  if (mAutoTickCount != approximateCount)
+  {
+    if (approximateCount > 0)
+    {
+      mAutoTickCount = approximateCount;
+      mCachedMarginValid = false;
+    } else
+      qDebug() << Q_FUNC_INFO << "approximateCount must be greater than zero:" << approximateCount;
+  }
+}
+
+/*!
+  Sets whether the tick labels are generated automatically. Depending on the tick label type (\ref
+  ltNumber or \ref ltDateTime), the labels will either show the coordinate as floating point
+  number (\ref setNumberFormat), or a date/time formatted according to \ref setDateTimeFormat.
+  
+  If \a on is set to false, you should provide the tick labels via \ref setTickVectorLabels. This
+  is usually used in a combination with \ref setAutoTicks set to false for complete control over
+  tick positions and labels, e.g. when the ticks should be at multiples of pi and show "2pi", "3pi"
+  etc. as tick labels.
+  
+  If you need dynamically calculated tick vectors (and possibly tick label vectors), set the
+  vectors in a slot connected to the \ref ticksRequest signal.
+  
+  \see setAutoTicks
+*/
+void QCPAxis::setAutoTickLabels(bool on)
+{
+  if (mAutoTickLabels != on)
+  {
+    mAutoTickLabels = on;
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  Sets whether the tick step, i.e. the interval between two (major) ticks, is calculated
+  automatically. If \a on is set to true, the axis finds a tick step that is reasonable for human
+  readable plots.
+
+  The number of ticks the algorithm aims for within the visible range can be specified with \ref
+  setAutoTickCount.
+  
+  If \a on is set to false, you may set the tick step manually with \ref setTickStep.
+  
+  \see setAutoTicks, setAutoSubTicks, setAutoTickCount
+*/
+void QCPAxis::setAutoTickStep(bool on)
+{
+  if (mAutoTickStep != on)
+  {
+    mAutoTickStep = on;
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  Sets whether the number of sub ticks in one tick interval is determined automatically. This
+  works, as long as the tick step mantissa is a multiple of 0.5. When \ref setAutoTickStep is
+  enabled, this is always the case.
+  
+  When \a on is set to false, you may set the sub tick count with \ref setSubTickCount manually.
+  
+  \see setAutoTickCount, setAutoTicks, setAutoTickStep
+*/
+void QCPAxis::setAutoSubTicks(bool on)
+{
+  if (mAutoSubTicks != on)
+  {
+    mAutoSubTicks = on;
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  Sets whether tick marks are displayed.
+
+  Note that setting \a show to false does not imply that tick labels are invisible, too. To achieve
+  that, see \ref setTickLabels.
+*/
+void QCPAxis::setTicks(bool show)
+{
+  if (mTicks != show)
+  {
+    mTicks = show;
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  Sets whether tick labels are displayed. Tick labels are the numbers drawn next to tick marks.
+*/
+void QCPAxis::setTickLabels(bool show)
+{
+  if (mTickLabels != show)
+  {
+    mTickLabels = show;
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  Sets the distance between the axis base line (including any outward ticks) and the tick labels.
+  \see setLabelPadding, setPadding
+*/
+void QCPAxis::setTickLabelPadding(int padding)
+{
+  if (mAxisPainter->tickLabelPadding != padding)
+  {
+    mAxisPainter->tickLabelPadding = padding;
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  Sets whether the tick labels display numbers or dates/times.
+  
+  If \a type is set to \ref ltNumber, the format specifications of \ref setNumberFormat apply.
+  
+  If \a type is set to \ref ltDateTime, the format specifications of \ref setDateTimeFormat apply.
+  
+  In QCustomPlot, date/time coordinates are <tt>double</tt> numbers representing the seconds since
+  1970-01-01T00:00:00 UTC. This format can be retrieved from QDateTime objects with the
+  QDateTime::toTime_t() function. Since this only gives a resolution of one second, there is also
+  the QDateTime::toMSecsSinceEpoch() function which returns the timespan described above in
+  milliseconds. Divide its return value by 1000.0 to get a value with the format needed for
+  date/time plotting, with a resolution of one millisecond.
+  
+  Using the toMSecsSinceEpoch function allows dates that go back to 2nd January 4713 B.C.
+  (represented by a negative number), unlike the toTime_t function, which works with unsigned
+  integers and thus only goes back to 1st January 1970. So both for range and accuracy, use of
+  toMSecsSinceEpoch()/1000.0 should be preferred as key coordinate for date/time axes.
+  
+  \see setTickLabels
+*/
+void QCPAxis::setTickLabelType(LabelType type)
+{
+  if (mTickLabelType != type)
+  {
+    mTickLabelType = type;
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  Sets the font of the tick labels.
+  
+  \see setTickLabels, setTickLabelColor
+*/
+void QCPAxis::setTickLabelFont(const QFont &font)
+{
+  if (font != mTickLabelFont)
+  {
+    mTickLabelFont = font;
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  Sets the color of the tick labels.
+  
+  \see setTickLabels, setTickLabelFont
+*/
+void QCPAxis::setTickLabelColor(const QColor &color)
+{
+  if (color != mTickLabelColor)
+  {
+    mTickLabelColor = color;
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  Sets the rotation of the tick labels. If \a degrees is zero, the labels are drawn normally. Else,
+  the tick labels are drawn rotated by \a degrees clockwise. The specified angle is bound to values
+  from -90 to 90 degrees.
+  
+  If \a degrees is exactly -90, 0 or 90, the tick labels are centered on the tick coordinate. For
+  other angles, the label is drawn with an offset such that it seems to point toward or away from
+  the tick mark.
+*/
+void QCPAxis::setTickLabelRotation(double degrees)
+{
+  if (!qFuzzyIsNull(degrees-mAxisPainter->tickLabelRotation))
+  {
+    mAxisPainter->tickLabelRotation = qBound(-90.0, degrees, 90.0);
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  Sets whether the tick labels (numbers) shall appear inside or outside the axis rect.
+  
+  The usual and default setting is \ref lsOutside. Very compact plots sometimes require tick labels
+  to be inside the axis rect, to save space. If \a side is set to \ref lsInside, the tick labels
+  appear on the inside are additionally clipped to the axis rect.
+*/
+void QCPAxis::setTickLabelSide(LabelSide side)
+{
+  mAxisPainter->tickLabelSide = side;
+  mCachedMarginValid = false;
+}
+
+/*!
+  Sets the format in which dates and times are displayed as tick labels, if \ref setTickLabelType is \ref ltDateTime.
+  for details about the \a format string, see the documentation of QDateTime::toString().
+  
+  Newlines can be inserted with "\n".
+  
+  \see setDateTimeSpec
+*/
+void QCPAxis::setDateTimeFormat(const QString &format)
+{
+  if (mDateTimeFormat != format)
+  {
+    mDateTimeFormat = format;
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  Sets the time spec that is used for the date time values when \ref setTickLabelType is \ref
+  ltDateTime.
+
+  The default value of QDateTime objects (and also QCustomPlot) is <tt>Qt::LocalTime</tt>. However,
+  if the date time values passed to QCustomPlot are given in the UTC spec, set \a
+  timeSpec to <tt>Qt::UTC</tt> to get the correct axis labels.
+  
+  \see setDateTimeFormat
+*/
+void QCPAxis::setDateTimeSpec(const Qt::TimeSpec &timeSpec)
+{
+  mDateTimeSpec = timeSpec;
+}
+
+/*!
+  Sets the number format for the numbers drawn as tick labels (if tick label type is \ref
+  ltNumber). This \a formatCode is an extended version of the format code used e.g. by
+  QString::number() and QLocale::toString(). For reference about that, see the "Argument Formats"
+  section in the detailed description of the QString class. \a formatCode is a string of one, two
+  or three characters. The first character is identical to the normal format code used by Qt. In
+  short, this means: 'e'/'E' scientific format, 'f' fixed format, 'g'/'G' scientific or fixed,
+  whichever is shorter.
+  
+  The second and third characters are optional and specific to QCustomPlot:\n
+  If the first char was 'e' or 'g', numbers are/might be displayed in the scientific format, e.g.
+  "5.5e9", which is ugly in a plot. So when the second char of \a formatCode is set to 'b' (for
+  "beautiful"), those exponential numbers are formatted in a more natural way, i.e. "5.5
+  [multiplication sign] 10 [superscript] 9". By default, the multiplication sign is a centered dot.
+  If instead a cross should be shown (as is usual in the USA), the third char of \a formatCode can
+  be set to 'c'. The inserted multiplication signs are the UTF-8 characters 215 (0xD7) for the
+  cross and 183 (0xB7) for the dot.
+  
+  If the scale type (\ref setScaleType) is \ref stLogarithmic and the \a formatCode uses the 'b'
+  option (beautifully typeset decimal powers), the display usually is "1 [multiplication sign] 10
+  [superscript] n", which looks unnatural for logarithmic scaling (the "1 [multiplication sign]"
+  part). To only display the decimal power, set the number precision to zero with \ref
+  setNumberPrecision.
+  
+  Examples for \a formatCode:
+  \li \c g normal format code behaviour. If number is small, fixed format is used, if number is large,
+  normal scientific format is used
+  \li \c gb If number is small, fixed format is used, if number is large, scientific format is used with
+  beautifully typeset decimal powers and a dot as multiplication sign
+  \li \c ebc All numbers are in scientific format with beautifully typeset decimal power and a cross as
+  multiplication sign
+  \li \c fb illegal format code, since fixed format doesn't support (or need) beautifully typeset decimal
+  powers. Format code will be reduced to 'f'.
+  \li \c hello illegal format code, since first char is not 'e', 'E', 'f', 'g' or 'G'. Current format
+  code will not be changed.
+*/
+void QCPAxis::setNumberFormat(const QString &formatCode)
+{
+  if (formatCode.isEmpty())
+  {
+    qDebug() << Q_FUNC_INFO << "Passed formatCode is empty";
+    return;
+  }
+  mCachedMarginValid = false;
+  
+  // interpret first char as number format char:
+  QString allowedFormatChars(QLatin1String("eEfgG"));
+  if (allowedFormatChars.contains(formatCode.at(0)))
+  {
+    mNumberFormatChar = QLatin1Char(formatCode.at(0).toLatin1());
+  } else
+  {
+    qDebug() << Q_FUNC_INFO << "Invalid number format code (first char not in 'eEfgG'):" << formatCode;
+    return;
+  }
+  if (formatCode.length() < 2)
+  {
+    mNumberBeautifulPowers = false;
+    mAxisPainter->numberMultiplyCross = false;
+    return;
+  }
+  
+  // interpret second char as indicator for beautiful decimal powers:
+  if (formatCode.at(1) == QLatin1Char('b') && (mNumberFormatChar == QLatin1Char('e') || mNumberFormatChar == QLatin1Char('g')))
+  {
+    mNumberBeautifulPowers = true;
+  } else
+  {
+    qDebug() << Q_FUNC_INFO << "Invalid number format code (second char not 'b' or first char neither 'e' nor 'g'):" << formatCode;
+    return;
+  }
+  if (formatCode.length() < 3)
+  {
+    mAxisPainter->numberMultiplyCross = false;
+    return;
+  }
+  
+  // interpret third char as indicator for dot or cross multiplication symbol:
+  if (formatCode.at(2) == QLatin1Char('c'))
+  {
+    mAxisPainter->numberMultiplyCross = true;
+  } else if (formatCode.at(2) == QLatin1Char('d'))
+  {
+    mAxisPainter->numberMultiplyCross = false;
+  } else
+  {
+    qDebug() << Q_FUNC_INFO << "Invalid number format code (third char neither 'c' nor 'd'):" << formatCode;
+    return;
+  }
+}
+
+/*!
+  Sets the precision of the tick label numbers. See QLocale::toString(double i, char f, int prec)
+  for details. The effect of precisions are most notably for number Formats starting with 'e', see
+  \ref setNumberFormat
+
+  If the scale type (\ref setScaleType) is \ref stLogarithmic and the number format (\ref
+  setNumberFormat) uses the 'b' format code (beautifully typeset decimal powers), the display
+  usually is "1 [multiplication sign] 10 [superscript] n", which looks unnatural for logarithmic
+  scaling (the redundant "1 [multiplication sign]" part). To only display the decimal power "10
+  [superscript] n", set \a precision to zero.
+*/
+void QCPAxis::setNumberPrecision(int precision)
+{
+  if (mNumberPrecision != precision)
+  {
+    mNumberPrecision = precision;
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  If \ref setAutoTickStep is set to false, use this function to set the tick step manually.
+  The tick step is the interval between (major) ticks, in plot coordinates.
+  \see setSubTickCount
+*/
+void QCPAxis::setTickStep(double step)
+{
+  if (mTickStep != step)
+  {
+    mTickStep = step;
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  If you want full control over what ticks (and possibly labels) the axes show, this function is
+  used to set the coordinates at which ticks will appear.\ref setAutoTicks must be disabled, else
+  the provided tick vector will be overwritten with automatically generated tick coordinates upon
+  replot. The labels of the ticks can be generated automatically when \ref setAutoTickLabels is
+  left enabled. If it is disabled, you can set the labels manually with \ref setTickVectorLabels.
+  
+  \a vec is a vector containing the positions of the ticks, in plot coordinates.
+  
+  \warning \a vec must be sorted in ascending order, no additional checks are made to ensure this.
+
+  \see setTickVectorLabels
+*/
+void QCPAxis::setTickVector(const QVector<double> &vec)
+{
+  // don't check whether mTickVector != vec here, because it takes longer than we would save
+  mTickVector = vec;
+  mCachedMarginValid = false;
+}
+
+/*!
+  If you want full control over what ticks and labels the axes show, this function is used to set a
+  number of QStrings that will be displayed at the tick positions which you need to provide with
+  \ref setTickVector. These two vectors should have the same size. (Note that you need to disable
+  \ref setAutoTicks and \ref setAutoTickLabels first.)
+  
+  \a vec is a vector containing the labels of the ticks. The entries correspond to the respective
+  indices in the tick vector, passed via \ref setTickVector.
+  
+  \see setTickVector
+*/
+void QCPAxis::setTickVectorLabels(const QVector<QString> &vec)
+{
+  // don't check whether mTickVectorLabels != vec here, because it takes longer than we would save
+  mTickVectorLabels = vec;
+  mCachedMarginValid = false;
+}
+
+/*!
+  Sets the length of the ticks in pixels. \a inside is the length the ticks will reach inside the
+  plot and \a outside is the length they will reach outside the plot. If \a outside is greater than
+  zero, the tick labels and axis label will increase their distance to the axis accordingly, so
+  they won't collide with the ticks.
+  
+  \see setSubTickLength, setTickLengthIn, setTickLengthOut
+*/
+void QCPAxis::setTickLength(int inside, int outside)
+{
+  setTickLengthIn(inside);
+  setTickLengthOut(outside);
+}
+
+/*!
+  Sets the length of the inward ticks in pixels. \a inside is the length the ticks will reach
+  inside the plot.
+  
+  \see setTickLengthOut, setTickLength, setSubTickLength
+*/
+void QCPAxis::setTickLengthIn(int inside)
+{
+  if (mAxisPainter->tickLengthIn != inside)
+  {
+    mAxisPainter->tickLengthIn = inside;
+  }
+}
+
+/*!
+  Sets the length of the outward ticks in pixels. \a outside is the length the ticks will reach
+  outside the plot. If \a outside is greater than zero, the tick labels and axis label will
+  increase their distance to the axis accordingly, so they won't collide with the ticks.
+  
+  \see setTickLengthIn, setTickLength, setSubTickLength
+*/
+void QCPAxis::setTickLengthOut(int outside)
+{
+  if (mAxisPainter->tickLengthOut != outside)
+  {
+    mAxisPainter->tickLengthOut = outside;
+    mCachedMarginValid = false; // only outside tick length can change margin
+  }
+}
+
+/*!
+  Sets the number of sub ticks in one (major) tick step. A sub tick count of three for example,
+  divides the tick intervals in four sub intervals.
+  
+  By default, the number of sub ticks is chosen automatically in a reasonable manner as long as the
+  mantissa of the tick step is a multiple of 0.5. When \ref setAutoTickStep is enabled, this is
+  always the case.
+
+  If you want to disable automatic sub tick count and use this function to set the count manually,
+  see \ref setAutoSubTicks.
+*/
+void QCPAxis::setSubTickCount(int count)
+{
+  mSubTickCount = count;
+}
+
+/*!
+  Sets the length of the subticks in pixels. \a inside is the length the subticks will reach inside
+  the plot and \a outside is the length they will reach outside the plot. If \a outside is greater
+  than zero, the tick labels and axis label will increase their distance to the axis accordingly,
+  so they won't collide with the ticks.
+  
+  \see setTickLength, setSubTickLengthIn, setSubTickLengthOut
+*/
+void QCPAxis::setSubTickLength(int inside, int outside)
+{
+  setSubTickLengthIn(inside);
+  setSubTickLengthOut(outside);
+}
+
+/*!
+  Sets the length of the inward subticks in pixels. \a inside is the length the subticks will reach inside
+  the plot.
+  
+  \see setSubTickLengthOut, setSubTickLength, setTickLength
+*/
+void QCPAxis::setSubTickLengthIn(int inside)
+{
+  if (mAxisPainter->subTickLengthIn != inside)
+  {
+    mAxisPainter->subTickLengthIn = inside;
+  }
+}
+
+/*!
+  Sets the length of the outward subticks in pixels. \a outside is the length the subticks will reach
+  outside the plot. If \a outside is greater than zero, the tick labels will increase their
+  distance to the axis accordingly, so they won't collide with the ticks.
+  
+  \see setSubTickLengthIn, setSubTickLength, setTickLength
+*/
+void QCPAxis::setSubTickLengthOut(int outside)
+{
+  if (mAxisPainter->subTickLengthOut != outside)
+  {
+    mAxisPainter->subTickLengthOut = outside;
+    mCachedMarginValid = false; // only outside tick length can change margin
+  }
+}
+
+/*!
+  Sets the pen, the axis base line is drawn with.
+  
+  \see setTickPen, setSubTickPen
+*/
+void QCPAxis::setBasePen(const QPen &pen)
+{
+  mBasePen = pen;
+}
+
+/*!
+  Sets the pen, tick marks will be drawn with.
+  
+  \see setTickLength, setBasePen
+*/
+void QCPAxis::setTickPen(const QPen &pen)
+{
+  mTickPen = pen;
+}
+
+/*!
+  Sets the pen, subtick marks will be drawn with.
+  
+  \see setSubTickCount, setSubTickLength, setBasePen
+*/
+void QCPAxis::setSubTickPen(const QPen &pen)
+{
+  mSubTickPen = pen;
+}
+
+/*!
+  Sets the font of the axis label.
+  
+  \see setLabelColor
+*/
+void QCPAxis::setLabelFont(const QFont &font)
+{
+  if (mLabelFont != font)
+  {
+    mLabelFont = font;
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  Sets the color of the axis label.
+  
+  \see setLabelFont
+*/
+void QCPAxis::setLabelColor(const QColor &color)
+{
+  mLabelColor = color;
+}
+
+/*!
+  Sets the text of the axis label that will be shown below/above or next to the axis, depending on
+  its orientation. To disable axis labels, pass an empty string as \a str.
+*/
+void QCPAxis::setLabel(const QString &str)
+{
+  if (mLabel != str)
+  {
+    mLabel = str;
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  Sets the distance between the tick labels and the axis label.
+  
+  \see setTickLabelPadding, setPadding
+*/
+void QCPAxis::setLabelPadding(int padding)
+{
+  if (mAxisPainter->labelPadding != padding)
+  {
+    mAxisPainter->labelPadding = padding;
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  Sets the padding of the axis.
+
+  When \ref QCPAxisRect::setAutoMargins is enabled, the padding is the additional outer most space,
+  that is left blank.
+  
+  The axis padding has no meaning if \ref QCPAxisRect::setAutoMargins is disabled.
+  
+  \see setLabelPadding, setTickLabelPadding
+*/
+void QCPAxis::setPadding(int padding)
+{
+  if (mPadding != padding)
+  {
+    mPadding = padding;
+    mCachedMarginValid = false;
+  }
+}
+
+/*!
+  Sets the offset the axis has to its axis rect side.
+  
+  If an axis rect side has multiple axes and automatic margin calculation is enabled for that side,
+  only the offset of the inner most axis has meaning (even if it is set to be invisible). The
+  offset of the other, outer axes is controlled automatically, to place them at appropriate
+  positions.
+*/
+void QCPAxis::setOffset(int offset)
+{
+  mAxisPainter->offset = offset;
+}
+
+/*!
+  Sets the font that is used for tick labels when they are selected.
+  
+  \see setTickLabelFont, setSelectableParts, setSelectedParts, QCustomPlot::setInteractions
+*/
+void QCPAxis::setSelectedTickLabelFont(const QFont &font)
+{
+  if (font != mSelectedTickLabelFont)
+  {
+    mSelectedTickLabelFont = font;
+    // don't set mCachedMarginValid to false here because margin calculation is always done with non-selected fonts
+  }
+}
+
+/*!
+  Sets the font that is used for the axis label when it is selected.
+  
+  \see setLabelFont, setSelectableParts, setSelectedParts, QCustomPlot::setInteractions
+*/
+void QCPAxis::setSelectedLabelFont(const QFont &font)
+{
+  mSelectedLabelFont = font;
+  // don't set mCachedMarginValid to false here because margin calculation is always done with non-selected fonts
+}
+
+/*!
+  Sets the color that is used for tick labels when they are selected.
+  
+  \see setTickLabelColor, setSelectableParts, setSelectedParts, QCustomPlot::setInteractions
+*/
+void QCPAxis::setSelectedTickLabelColor(const QColor &color)
+{
+  if (color != mSelectedTickLabelColor)
+  {
+    mSelectedTickLabelColor = color;
+  }
+}
+
+/*!
+  Sets the color that is used for the axis label when it is selected.
+  
+  \see setLabelColor, setSelectableParts, setSelectedParts, QCustomPlot::setInteractions
+*/
+void QCPAxis::setSelectedLabelColor(const QColor &color)
+{
+  mSelectedLabelColor = color;
+}
+
+/*!
+  Sets the pen that is used to draw the axis base line when selected.
+  
+  \see setBasePen, setSelectableParts, setSelectedParts, QCustomPlot::setInteractions
+*/
+void QCPAxis::setSelectedBasePen(const QPen &pen)
+{
+  mSelectedBasePen = pen;
+}
+
+/*!
+  Sets the pen that is used to draw the (major) ticks when selected.
+  
+  \see setTickPen, setSelectableParts, setSelectedParts, QCustomPlot::setInteractions
+*/
+void QCPAxis::setSelectedTickPen(const QPen &pen)
+{
+  mSelectedTickPen = pen;
+}
+
+/*!
+  Sets the pen that is used to draw the subticks when selected.
+  
+  \see setSubTickPen, setSelectableParts, setSelectedParts, QCustomPlot::setInteractions
+*/
+void QCPAxis::setSelectedSubTickPen(const QPen &pen)
+{
+  mSelectedSubTickPen = pen;
+}
+
+/*!
+  Sets the style for the lower axis ending. See the documentation of QCPLineEnding for available
+  styles.
+  
+  For horizontal axes, this method refers to the left ending, for vertical axes the bottom ending.
+  Note that this meaning does not change when the axis range is reversed with \ref
+  setRangeReversed.
+  
+  \see setUpperEnding
+*/
+void QCPAxis::setLowerEnding(const QCPLineEnding &ending)
+{
+  mAxisPainter->lowerEnding = ending;
+}
+
+/*!
+  Sets the style for the upper axis ending. See the documentation of QCPLineEnding for available
+  styles.
+  
+  For horizontal axes, this method refers to the right ending, for vertical axes the top ending.
+  Note that this meaning does not change when the axis range is reversed with \ref
+  setRangeReversed.
+  
+  \see setLowerEnding
+*/
+void QCPAxis::setUpperEnding(const QCPLineEnding &ending)
+{
+  mAxisPainter->upperEnding = ending;
+}
+
+/*!
+  If the scale type (\ref setScaleType) is \ref stLinear, \a diff is added to the lower and upper
+  bounds of the range. The range is simply moved by \a diff.
+  
+  If the scale type is \ref stLogarithmic, the range bounds are multiplied by \a diff. This
+  corresponds to an apparent "linear" move in logarithmic scaling by a distance of log(diff).
+*/
+void QCPAxis::moveRange(double diff)
+{
+  QCPRange oldRange = mRange;
+  if (mScaleType == stLinear)
+  {
+    mRange.lower += diff;
+    mRange.upper += diff;
+  } else // mScaleType == stLogarithmic
+  {
+    mRange.lower *= diff;
+    mRange.upper *= diff;
+  }
+  mCachedMarginValid = false;
+  emit rangeChanged(mRange);
+  emit rangeChanged(mRange, oldRange);
+}
+
+/*!
+  Scales the range of this axis by \a factor around the coordinate \a center. For example, if \a
+  factor is 2.0, \a center is 1.0, then the axis range will double its size, and the point at
+  coordinate 1.0 won't have changed its position in the QCustomPlot widget (i.e. coordinates
+  around 1.0 will have moved symmetrically closer to 1.0).
+*/
+void QCPAxis::scaleRange(double factor, double center)
+{
+  QCPRange oldRange = mRange;
+  if (mScaleType == stLinear)
+  {
+    QCPRange newRange;
+    newRange.lower = (mRange.lower-center)*factor + center;
+    newRange.upper = (mRange.upper-center)*factor + center;
+    if (QCPRange::validRange(newRange))
+      mRange = newRange.sanitizedForLinScale();
+  } else // mScaleType == stLogarithmic
+  {
+    if ((mRange.upper < 0 && center < 0) || (mRange.upper > 0 && center > 0)) // make sure center has same sign as range
+    {
+      QCPRange newRange;
+      newRange.lower = qPow(mRange.lower/center, factor)*center;
+      newRange.upper = qPow(mRange.upper/center, factor)*center;
+      if (QCPRange::validRange(newRange))
+        mRange = newRange.sanitizedForLogScale();
+    } else
+      qDebug() << Q_FUNC_INFO << "Center of scaling operation doesn't lie in same logarithmic sign domain as range:" << center;
+  }
+  mCachedMarginValid = false;
+  emit rangeChanged(mRange);
+  emit rangeChanged(mRange, oldRange);
+}
+
+/*!
+  Scales the range of this axis to have a certain scale \a ratio to \a otherAxis. The scaling will
+  be done around the center of the current axis range.
+
+  For example, if \a ratio is 1, this axis is the \a yAxis and \a otherAxis is \a xAxis, graphs
+  plotted with those axes will appear in a 1:1 aspect ratio, independent of the aspect ratio the
+  axis rect has.
+
+  This is an operation that changes the range of this axis once, it doesn't fix the scale ratio
+  indefinitely. Note that calling this function in the constructor of the QCustomPlot's parent
+  won't have the desired effect, since the widget dimensions aren't defined yet, and a resizeEvent
+  will follow.
+*/
+void QCPAxis::setScaleRatio(const QCPAxis *otherAxis, double ratio)
+{
+  int otherPixelSize, ownPixelSize;
+  
+  if (otherAxis->orientation() == Qt::Horizontal)
+    otherPixelSize = otherAxis->axisRect()->width();
+  else
+    otherPixelSize = otherAxis->axisRect()->height();
+  
+  if (orientation() == Qt::Horizontal)
+    ownPixelSize = axisRect()->width();
+  else
+    ownPixelSize = axisRect()->height();
+  
+  double newRangeSize = ratio*otherAxis->range().size()*ownPixelSize/(double)otherPixelSize;
+  setRange(range().center(), newRangeSize, Qt::AlignCenter);
+}
+
+/*!
+  Changes the axis range such that all plottables associated with this axis are fully visible in
+  that dimension.
+  
+  \see QCPAbstractPlottable::rescaleAxes, QCustomPlot::rescaleAxes
+*/
+void QCPAxis::rescale(bool onlyVisiblePlottables)
+{
+  QList<QCPAbstractPlottable*> p = plottables();
+  QCPRange newRange;
+  bool haveRange = false;
+  for (int i=0; i<p.size(); ++i)
+  {
+    if (!p.at(i)->realVisibility() && onlyVisiblePlottables)
+      continue;
+    QCPRange plottableRange;
+    bool currentFoundRange;
+    QCPAbstractPlottable::SignDomain signDomain = QCPAbstractPlottable::sdBoth;
+    if (mScaleType == stLogarithmic)
+      signDomain = (mRange.upper < 0 ? QCPAbstractPlottable::sdNegative : QCPAbstractPlottable::sdPositive);
+    if (p.at(i)->keyAxis() == this)
+      plottableRange = p.at(i)->getKeyRange(currentFoundRange, signDomain);
+    else
+      plottableRange = p.at(i)->getValueRange(currentFoundRange, signDomain);
+    if (currentFoundRange)
+    {
+      if (!haveRange)
+        newRange = plottableRange;
+      else
+        newRange.expand(plottableRange);
+      haveRange = true;
+    }
+  }
+  if (haveRange)
+  {
+    if (!QCPRange::validRange(newRange)) // likely due to range being zero (plottable has only constant data in this axis dimension), shift current range to at least center the plottable
+    {
+      double center = (newRange.lower+newRange.upper)*0.5; // upper and lower should be equal anyway, but just to make sure, incase validRange returned false for other reason
+      if (mScaleType == stLinear)
+      {
+        newRange.lower = center-mRange.size()/2.0;
+        newRange.upper = center+mRange.size()/2.0;
+      } else // mScaleType == stLogarithmic
+      {
+        newRange.lower = center/qSqrt(mRange.upper/mRange.lower);
+        newRange.upper = center*qSqrt(mRange.upper/mRange.lower);
+      }
+    }
+    setRange(newRange);
+  }
+}
+
+/*!
+  Transforms \a value, in pixel coordinates of the QCustomPlot widget, to axis coordinates.
+*/
+double QCPAxis::pixelToCoord(double value) const
+{
+  if (orientation() == Qt::Horizontal)
+  {
+    if (mScaleType == stLinear)
+    {
+      if (!mRangeReversed)
+        return (value-mAxisRect->left())/(double)mAxisRect->width()*mRange.size()+mRange.lower;
+      else
+        return -(value-mAxisRect->left())/(double)mAxisRect->width()*mRange.size()+mRange.upper;
+    } else // mScaleType == stLogarithmic
+    {
+      if (!mRangeReversed)
+        return qPow(mRange.upper/mRange.lower, (value-mAxisRect->left())/(double)mAxisRect->width())*mRange.lower;
+      else
+        return qPow(mRange.upper/mRange.lower, (mAxisRect->left()-value)/(double)mAxisRect->width())*mRange.upper;
+    }
+  } else // orientation() == Qt::Vertical
+  {
+    if (mScaleType == stLinear)
+    {
+      if (!mRangeReversed)
+        return (mAxisRect->bottom()-value)/(double)mAxisRect->height()*mRange.size()+mRange.lower;
+      else
+        return -(mAxisRect->bottom()-value)/(double)mAxisRect->height()*mRange.size()+mRange.upper;
+    } else // mScaleType == stLogarithmic
+    {
+      if (!mRangeReversed)
+        return qPow(mRange.upper/mRange.lower, (mAxisRect->bottom()-value)/(double)mAxisRect->height())*mRange.lower;
+      else
+        return qPow(mRange.upper/mRange.lower, (value-mAxisRect->bottom())/(double)mAxisRect->height())*mRange.upper;
+    }
+  }
+}
+
+/*!
+  Transforms \a value, in coordinates of the axis, to pixel coordinates of the QCustomPlot widget.
+*/
+double QCPAxis::coordToPixel(double value) const
+{
+  if (orientation() == Qt::Horizontal)
+  {
+    if (mScaleType == stLinear)
+    {
+      if (!mRangeReversed)
+        return (value-mRange.lower)/mRange.size()*mAxisRect->width()+mAxisRect->left();
+      else
+        return (mRange.upper-value)/mRange.size()*mAxisRect->width()+mAxisRect->left();
+    } else // mScaleType == stLogarithmic
+    {
+      if (value >= 0 && mRange.upper < 0) // invalid value for logarithmic scale, just draw it outside visible range
+        return !mRangeReversed ? mAxisRect->right()+200 : mAxisRect->left()-200;
+      else if (value <= 0 && mRange.upper > 0) // invalid value for logarithmic scale, just draw it outside visible range
+        return !mRangeReversed ? mAxisRect->left()-200 : mAxisRect->right()+200;
+      else
+      {
+        if (!mRangeReversed)
+          return baseLog(value/mRange.lower)/baseLog(mRange.upper/mRange.lower)*mAxisRect->width()+mAxisRect->left();
+        else
+          return baseLog(mRange.upper/value)/baseLog(mRange.upper/mRange.lower)*mAxisRect->width()+mAxisRect->left();
+      }
+    }
+  } else // orientation() == Qt::Vertical
+  {
+    if (mScaleType == stLinear)
+    {
+      if (!mRangeReversed)
+        return mAxisRect->bottom()-(value-mRange.lower)/mRange.size()*mAxisRect->height();
+      else
+        return mAxisRect->bottom()-(mRange.upper-value)/mRange.size()*mAxisRect->height();
+    } else // mScaleType == stLogarithmic
+    {
+      if (value >= 0 && mRange.upper < 0) // invalid value for logarithmic scale, just draw it outside visible range
+        return !mRangeReversed ? mAxisRect->top()-200 : mAxisRect->bottom()+200;
+      else if (value <= 0 && mRange.upper > 0) // invalid value for logarithmic scale, just draw it outside visible range
+        return !mRangeReversed ? mAxisRect->bottom()+200 : mAxisRect->top()-200;
+      else
+      {
+        if (!mRangeReversed)
+          return mAxisRect->bottom()-baseLog(value/mRange.lower)/baseLog(mRange.upper/mRange.lower)*mAxisRect->height();
+        else
+          return mAxisRect->bottom()-baseLog(mRange.upper/value)/baseLog(mRange.upper/mRange.lower)*mAxisRect->height();
+      }
+    }
+  }
+}
+
+/*!
+  Returns the part of the axis that is hit by \a pos (in pixels). The return value of this function
+  is independent of the user-selectable parts defined with \ref setSelectableParts. Further, this
+  function does not change the current selection state of the axis.
+  
+  If the axis is not visible (\ref setVisible), this function always returns \ref spNone.
+  
+  \see setSelectedParts, setSelectableParts, QCustomPlot::setInteractions
+*/
+QCPAxis::SelectablePart QCPAxis::getPartAt(const QPointF &pos) const
+{
+  if (!mVisible)
+    return spNone;
+  
+  if (mAxisPainter->axisSelectionBox().contains(pos.toPoint()))
+    return spAxis;
+  else if (mAxisPainter->tickLabelsSelectionBox().contains(pos.toPoint()))
+    return spTickLabels;
+  else if (mAxisPainter->labelSelectionBox().contains(pos.toPoint()))
+    return spAxisLabel;
+  else
+    return spNone;
+}
+
+/* inherits documentation from base class */
+double QCPAxis::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  if (!mParentPlot) return -1;
+  SelectablePart part = getPartAt(pos);
+  if ((onlySelectable && !mSelectableParts.testFlag(part)) || part == spNone)
+    return -1;
+  
+  if (details)
+    details->setValue(part);
+  return mParentPlot->selectionTolerance()*0.99;
+}
+
+/*!
+  Returns a list of all the plottables that have this axis as key or value axis.
+  
+  If you are only interested in plottables of type QCPGraph, see \ref graphs.
+  
+  \see graphs, items
+*/
+QList<QCPAbstractPlottable*> QCPAxis::plottables() const
+{
+  QList<QCPAbstractPlottable*> result;
+  if (!mParentPlot) return result;
+  
+  for (int i=0; i<mParentPlot->mPlottables.size(); ++i)
+  {
+    if (mParentPlot->mPlottables.at(i)->keyAxis() == this ||mParentPlot->mPlottables.at(i)->valueAxis() == this)
+      result.append(mParentPlot->mPlottables.at(i));
+  }
+  return result;
+}
+
+/*!
+  Returns a list of all the graphs that have this axis as key or value axis.
+  
+  \see plottables, items
+*/
+QList<QCPGraph*> QCPAxis::graphs() const
+{
+  QList<QCPGraph*> result;
+  if (!mParentPlot) return result;
+  
+  for (int i=0; i<mParentPlot->mGraphs.size(); ++i)
+  {
+    if (mParentPlot->mGraphs.at(i)->keyAxis() == this || mParentPlot->mGraphs.at(i)->valueAxis() == this)
+      result.append(mParentPlot->mGraphs.at(i));
+  }
+  return result;
+}
+
+/*!
+  Returns a list of all the items that are associated with this axis. An item is considered
+  associated with an axis if at least one of its positions uses the axis as key or value axis.
+  
+  \see plottables, graphs
+*/
+QList<QCPAbstractItem*> QCPAxis::items() const
+{
+  QList<QCPAbstractItem*> result;
+  if (!mParentPlot) return result;
+  
+  for (int itemId=0; itemId<mParentPlot->mItems.size(); ++itemId)
+  {
+    QList<QCPItemPosition*> positions = mParentPlot->mItems.at(itemId)->positions();
+    for (int posId=0; posId<positions.size(); ++posId)
+    {
+      if (positions.at(posId)->keyAxis() == this || positions.at(posId)->valueAxis() == this)
+      {
+        result.append(mParentPlot->mItems.at(itemId));
+        break;
+      }
+    }
+  }
+  return result;
+}
+
+/*!
+  Transforms a margin side to the logically corresponding axis type. (QCP::msLeft to
+  QCPAxis::atLeft, QCP::msRight to QCPAxis::atRight, etc.)
+*/
+QCPAxis::AxisType QCPAxis::marginSideToAxisType(QCP::MarginSide side)
+{
+  switch (side)
+  {
+    case QCP::msLeft: return atLeft;
+    case QCP::msRight: return atRight;
+    case QCP::msTop: return atTop;
+    case QCP::msBottom: return atBottom;
+    default: break;
+  }
+  qDebug() << Q_FUNC_INFO << "Invalid margin side passed:" << (int)side;
+  return atLeft;
+}
+
+/*!
+  Returns the axis type that describes the opposite axis of an axis with the specified \a type.
+*/
+QCPAxis::AxisType QCPAxis::opposite(QCPAxis::AxisType type)
+{
+  switch (type)
+  {
+    case atLeft: return atRight; break;
+    case atRight: return atLeft; break;
+    case atBottom: return atTop; break;
+    case atTop: return atBottom; break;
+    default: qDebug() << Q_FUNC_INFO << "invalid axis type"; return atLeft; break;
+  }
+}
+
+/*! \internal
+  
+  This function is called to prepare the tick vector, sub tick vector and tick label vector. If
+  \ref setAutoTicks is set to true, appropriate tick values are determined automatically via \ref
+  generateAutoTicks. If it's set to false, the signal ticksRequest is emitted, which can be used to
+  provide external tick positions. Then the sub tick vectors and tick label vectors are created.
+*/
+void QCPAxis::setupTickVectors()
+{
+  if (!mParentPlot) return;
+  if ((!mTicks && !mTickLabels && !mGrid->visible()) || mRange.size() <= 0) return;
+  
+  // fill tick vectors, either by auto generating or by notifying user to fill the vectors himself
+  if (mAutoTicks)
+  {
+    generateAutoTicks();
+  } else
+  {
+    emit ticksRequest();
+  }
+  
+  visibleTickBounds(mLowestVisibleTick, mHighestVisibleTick);
+  if (mTickVector.isEmpty())
+  {
+    mSubTickVector.clear();
+    return;
+  }
+  
+  // generate subticks between ticks:
+  mSubTickVector.resize((mTickVector.size()-1)*mSubTickCount);
+  if (mSubTickCount > 0)
+  {
+    double subTickStep = 0;
+    double subTickPosition = 0;
+    int subTickIndex = 0;
+    bool done = false;
+    int lowTick = mLowestVisibleTick > 0 ? mLowestVisibleTick-1 : mLowestVisibleTick;
+    int highTick = mHighestVisibleTick < mTickVector.size()-1 ? mHighestVisibleTick+1 : mHighestVisibleTick;
+    for (int i=lowTick+1; i<=highTick; ++i)
+    {
+      subTickStep = (mTickVector.at(i)-mTickVector.at(i-1))/(double)(mSubTickCount+1);
+      for (int k=1; k<=mSubTickCount; ++k)
+      {
+        subTickPosition = mTickVector.at(i-1) + k*subTickStep;
+        if (subTickPosition < mRange.lower)
+          continue;
+        if (subTickPosition > mRange.upper)
+        {
+          done = true;
+          break;
+        }
+        mSubTickVector[subTickIndex] = subTickPosition;
+        subTickIndex++;
+      }
+      if (done) break;
+    }
+    mSubTickVector.resize(subTickIndex);
+  }
+
+  // generate tick labels according to tick positions:
+  if (mAutoTickLabels)
+  {
+    int vecsize = mTickVector.size();
+    mTickVectorLabels.resize(vecsize);
+    if (mTickLabelType == ltNumber)
+    {
+      for (int i=mLowestVisibleTick; i<=mHighestVisibleTick; ++i)
+        mTickVectorLabels[i] = mParentPlot->locale().toString(mTickVector.at(i), mNumberFormatChar.toLatin1(), mNumberPrecision);
+    } else if (mTickLabelType == ltDateTime)
+    {
+      for (int i=mLowestVisibleTick; i<=mHighestVisibleTick; ++i)
+      {
+#if QT_VERSION < QT_VERSION_CHECK(4, 7, 0) // use fromMSecsSinceEpoch function if available, to gain sub-second accuracy on tick labels (e.g. for format "hh:mm:ss:zzz")
+        mTickVectorLabels[i] = mParentPlot->locale().toString(QDateTime::fromTime_t(mTickVector.at(i)).toTimeSpec(mDateTimeSpec), mDateTimeFormat);
+#else
+        mTickVectorLabels[i] = mParentPlot->locale().toString(QDateTime::fromMSecsSinceEpoch(mTickVector.at(i)*1000).toTimeSpec(mDateTimeSpec), mDateTimeFormat);
+#endif
+      }
+    }
+  } else // mAutoTickLabels == false
+  {
+    if (mAutoTicks) // ticks generated automatically, but not ticklabels, so emit ticksRequest here for labels
+    {
+      emit ticksRequest();
+    }
+    // make sure provided tick label vector has correct (minimal) length:
+    if (mTickVectorLabels.size() < mTickVector.size())
+      mTickVectorLabels.resize(mTickVector.size());
+  }
+}
+
+/*! \internal
+  
+  If \ref setAutoTicks is set to true, this function is called by \ref setupTickVectors to
+  generate reasonable tick positions (and subtick count). The algorithm tries to create
+  approximately <tt>mAutoTickCount</tt> ticks (set via \ref setAutoTickCount).
+ 
+  If the scale is logarithmic, \ref setAutoTickCount is ignored, and one tick is generated at every
+  power of the current logarithm base, set via \ref setScaleLogBase.
+*/
+void QCPAxis::generateAutoTicks()
+{
+  if (mScaleType == stLinear)
+  {
+    if (mAutoTickStep)
+    {
+      // Generate tick positions according to linear scaling:
+      mTickStep = mRange.size()/(double)(mAutoTickCount+1e-10); // mAutoTickCount ticks on average, the small addition is to prevent jitter on exact integers
+      double magnitudeFactor = qPow(10.0, qFloor(qLn(mTickStep)/qLn(10.0))); // get magnitude factor e.g. 0.01, 1, 10, 1000 etc.
+      double tickStepMantissa = mTickStep/magnitudeFactor;
+      if (tickStepMantissa < 5)
+      {
+        // round digit after decimal point to 0.5
+        mTickStep = (int)(tickStepMantissa*2)/2.0*magnitudeFactor;
+      } else
+      {
+        // round to first digit in multiples of 2
+        mTickStep = (int)(tickStepMantissa/2.0)*2.0*magnitudeFactor;
+      }
+    }
+    if (mAutoSubTicks)
+      mSubTickCount = calculateAutoSubTickCount(mTickStep);
+    // Generate tick positions according to mTickStep:
+    qint64 firstStep = floor(mRange.lower/mTickStep); // do not use qFloor here, or we'll lose 64 bit precision
+    qint64 lastStep = ceil(mRange.upper/mTickStep); // do not use qCeil here, or we'll lose 64 bit precision
+    int tickcount = lastStep-firstStep+1;
+    if (tickcount < 0) tickcount = 0;
+    mTickVector.resize(tickcount);
+    for (int i=0; i<tickcount; ++i)
+      mTickVector[i] = (firstStep+i)*mTickStep;
+  } else // mScaleType == stLogarithmic
+  {
+    // Generate tick positions according to logbase scaling:
+    if (mRange.lower > 0 && mRange.upper > 0) // positive range
+    {
+      double lowerMag = basePow(qFloor(baseLog(mRange.lower)));
+      double currentMag = lowerMag;
+      mTickVector.clear();
+      mTickVector.append(currentMag);
+      while (currentMag < mRange.upper && currentMag > 0) // currentMag might be zero for ranges ~1e-300, just cancel in that case
+      {
+        currentMag *= mScaleLogBase;
+        mTickVector.append(currentMag);
+      }
+    } else if (mRange.lower < 0 && mRange.upper < 0) // negative range
+    {
+      double lowerMag = -basePow(qCeil(baseLog(-mRange.lower)));
+      double currentMag = lowerMag;
+      mTickVector.clear();
+      mTickVector.append(currentMag);
+      while (currentMag < mRange.upper && currentMag < 0) // currentMag might be zero for ranges ~1e-300, just cancel in that case
+      {
+        currentMag /= mScaleLogBase;
+        mTickVector.append(currentMag);
+      }
+    } else // invalid range for logarithmic scale, because lower and upper have different sign
+    {
+      mTickVector.clear();
+      qDebug() << Q_FUNC_INFO << "Invalid range for logarithmic plot: " << mRange.lower << "-" << mRange.upper;
+    }
+  }
+}
+
+/*! \internal
+  
+  Called by generateAutoTicks when \ref setAutoSubTicks is set to true. Depending on the \a
+  tickStep between two major ticks on the axis, a different number of sub ticks is appropriate. For
+  Example taking 4 sub ticks for a \a tickStep of 1 makes more sense than taking 5 sub ticks,
+  because this corresponds to a sub tick step of 0.2, instead of the less intuitive 0.16667. Note
+  that a subtick count of 4 means dividing the major tick step into 5 sections.
+  
+  This is implemented by a hand made lookup for integer tick steps as well as fractional tick steps
+  with a fractional part of (approximately) 0.5. If a tick step is different (i.e. has no
+  fractional part close to 0.5), the currently set sub tick count (\ref setSubTickCount) is
+  returned.
+*/
+int QCPAxis::calculateAutoSubTickCount(double tickStep) const
+{
+  int result = mSubTickCount; // default to current setting, if no proper value can be found
+  
+  // get mantissa of tickstep:
+  double magnitudeFactor = qPow(10.0, qFloor(qLn(tickStep)/qLn(10.0))); // get magnitude factor e.g. 0.01, 1, 10, 1000 etc.
+  double tickStepMantissa = tickStep/magnitudeFactor;
+  
+  // separate integer and fractional part of mantissa:
+  double epsilon = 0.01;
+  double intPartf;
+  int intPart;
+  double fracPart = modf(tickStepMantissa, &intPartf);
+  intPart = intPartf;
+  
+  // handle cases with (almost) integer mantissa:
+  if (fracPart < epsilon || 1.0-fracPart < epsilon)
+  {
+    if (1.0-fracPart < epsilon)
+      ++intPart;
+    switch (intPart)
+    {
+      case 1: result = 4; break; // 1.0 -> 0.2 substep
+      case 2: result = 3; break; // 2.0 -> 0.5 substep
+      case 3: result = 2; break; // 3.0 -> 1.0 substep
+      case 4: result = 3; break; // 4.0 -> 1.0 substep
+      case 5: result = 4; break; // 5.0 -> 1.0 substep
+      case 6: result = 2; break; // 6.0 -> 2.0 substep
+      case 7: result = 6; break; // 7.0 -> 1.0 substep
+      case 8: result = 3; break; // 8.0 -> 2.0 substep
+      case 9: result = 2; break; // 9.0 -> 3.0 substep
+    }
+  } else
+  {
+    // handle cases with significantly fractional mantissa:
+    if (qAbs(fracPart-0.5) < epsilon) // *.5 mantissa
+    {
+      switch (intPart)
+      {
+        case 1: result = 2; break; // 1.5 -> 0.5 substep
+        case 2: result = 4; break; // 2.5 -> 0.5 substep
+        case 3: result = 4; break; // 3.5 -> 0.7 substep
+        case 4: result = 2; break; // 4.5 -> 1.5 substep
+        case 5: result = 4; break; // 5.5 -> 1.1 substep (won't occur with autoTickStep from here on)
+        case 6: result = 4; break; // 6.5 -> 1.3 substep
+        case 7: result = 2; break; // 7.5 -> 2.5 substep
+        case 8: result = 4; break; // 8.5 -> 1.7 substep
+        case 9: result = 4; break; // 9.5 -> 1.9 substep
+      }
+    }
+    // if mantissa fraction isnt 0.0 or 0.5, don't bother finding good sub tick marks, leave default
+  }
+  
+  return result;
+}
+
+/* inherits documentation from base class */
+void QCPAxis::selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)
+{
+  Q_UNUSED(event)
+  SelectablePart part = details.value<SelectablePart>();
+  if (mSelectableParts.testFlag(part))
+  {
+    SelectableParts selBefore = mSelectedParts;
+    setSelectedParts(additive ? mSelectedParts^part : part);
+    if (selectionStateChanged)
+      *selectionStateChanged = mSelectedParts != selBefore;
+  }
+}
+
+/* inherits documentation from base class */
+void QCPAxis::deselectEvent(bool *selectionStateChanged)
+{
+  SelectableParts selBefore = mSelectedParts;
+  setSelectedParts(mSelectedParts & ~mSelectableParts);
+  if (selectionStateChanged)
+    *selectionStateChanged = mSelectedParts != selBefore;
+}
+
+/*! \internal
+
+  A convenience function to easily set the QPainter::Antialiased hint on the provided \a painter
+  before drawing axis lines.
+
+  This is the antialiasing state the painter passed to the \ref draw method is in by default.
+  
+  This function takes into account the local setting of the antialiasing flag as well as the
+  overrides set with \ref QCustomPlot::setAntialiasedElements and \ref
+  QCustomPlot::setNotAntialiasedElements.
+  
+  \see setAntialiased
+*/
+void QCPAxis::applyDefaultAntialiasingHint(QCPPainter *painter) const
+{
+  applyAntialiasingHint(painter, mAntialiased, QCP::aeAxes);
+}
+
+/*! \internal
+  
+  Draws the axis with the specified \a painter, using the internal QCPAxisPainterPrivate instance.
+
+*/
+void QCPAxis::draw(QCPPainter *painter)
+{
+  const int lowTick = mLowestVisibleTick;
+  const int highTick = mHighestVisibleTick;
+  QVector<double> subTickPositions; // the final coordToPixel transformed vector passed to QCPAxisPainter
+  QVector<double> tickPositions; // the final coordToPixel transformed vector passed to QCPAxisPainter
+  QVector<QString> tickLabels; // the final vector passed to QCPAxisPainter
+  tickPositions.reserve(highTick-lowTick+1);
+  tickLabels.reserve(highTick-lowTick+1);
+  subTickPositions.reserve(mSubTickVector.size());
+  
+  if (mTicks)
+  {
+    for (int i=lowTick; i<=highTick; ++i)
+    {
+      tickPositions.append(coordToPixel(mTickVector.at(i)));
+      if (mTickLabels)
+        tickLabels.append(mTickVectorLabels.at(i));
+    }
+    
+    if (mSubTickCount > 0)
+    {
+      const int subTickCount = mSubTickVector.size();
+      for (int i=0; i<subTickCount; ++i) // no need to check bounds because subticks are always only created inside current mRange
+        subTickPositions.append(coordToPixel(mSubTickVector.at(i)));
+    }
+  }
+  // transfer all properties of this axis to QCPAxisPainterPrivate which it needs to draw the axis.
+  // Note that some axis painter properties are already set by direct feed-through with QCPAxis setters
+  mAxisPainter->type = mAxisType;
+  mAxisPainter->basePen = getBasePen();
+  mAxisPainter->labelFont = getLabelFont();
+  mAxisPainter->labelColor = getLabelColor();
+  mAxisPainter->label = mLabel;
+  mAxisPainter->substituteExponent = mAutoTickLabels && mNumberBeautifulPowers && mTickLabelType == ltNumber;
+  mAxisPainter->tickPen = getTickPen();
+  mAxisPainter->subTickPen = getSubTickPen();
+  mAxisPainter->tickLabelFont = getTickLabelFont();
+  mAxisPainter->tickLabelColor = getTickLabelColor();
+  mAxisPainter->axisRect = mAxisRect->rect();
+  mAxisPainter->viewportRect = mParentPlot->viewport();
+  mAxisPainter->abbreviateDecimalPowers = mScaleType == stLogarithmic;
+  mAxisPainter->reversedEndings = mRangeReversed;
+  mAxisPainter->tickPositions = tickPositions;
+  mAxisPainter->tickLabels = tickLabels;
+  mAxisPainter->subTickPositions = subTickPositions;
+  mAxisPainter->draw(painter);
+}
+
+/*! \internal
+  
+  Returns via \a lowIndex and \a highIndex, which ticks in the current tick vector are visible in
+  the current range. The return values are indices of the tick vector, not the positions of the
+  ticks themselves.
+  
+  The actual use of this function is when an external tick vector is provided, since it might
+  exceed far beyond the currently displayed range, and would cause unnecessary calculations e.g. of
+  subticks.
+  
+  If all ticks are outside the axis range, an inverted range is returned, i.e. highIndex will be
+  smaller than lowIndex. There is one case, where this function returns indices that are not really
+  visible in the current axis range: When the tick spacing is larger than the axis range size and
+  one tick is below the axis range and the next tick is already above the axis range. Because in
+  such cases it is usually desirable to know the tick pair, to draw proper subticks.
+*/
+void QCPAxis::visibleTickBounds(int &lowIndex, int &highIndex) const
+{
+  bool lowFound = false;
+  bool highFound = false;
+  lowIndex = 0;
+  highIndex = -1;
+  
+  for (int i=0; i < mTickVector.size(); ++i)
+  {
+    if (mTickVector.at(i) >= mRange.lower)
+    {
+      lowFound = true;
+      lowIndex = i;
+      break;
+    }
+  }
+  for (int i=mTickVector.size()-1; i >= 0; --i)
+  {
+    if (mTickVector.at(i) <= mRange.upper)
+    {
+      highFound = true;
+      highIndex = i;
+      break;
+    }
+  }
+  
+  if (!lowFound && highFound)
+    lowIndex = highIndex+1;
+  else if (lowFound && !highFound)
+    highIndex = lowIndex-1;
+}
+
+/*! \internal
+  
+  A log function with the base mScaleLogBase, used mostly for coordinate transforms in logarithmic
+  scales with arbitrary log base. Uses the buffered mScaleLogBaseLogInv for faster calculation.
+  This is set to <tt>1.0/qLn(mScaleLogBase)</tt> in \ref setScaleLogBase.
+  
+  \see basePow, setScaleLogBase, setScaleType
+*/
+double QCPAxis::baseLog(double value) const
+{
+  return qLn(value)*mScaleLogBaseLogInv;
+}
+
+/*! \internal
+  
+  A power function with the base mScaleLogBase, used mostly for coordinate transforms in
+  logarithmic scales with arbitrary log base.
+  
+  \see baseLog, setScaleLogBase, setScaleType
+*/
+double QCPAxis::basePow(double value) const
+{
+  return qPow(mScaleLogBase, value);
+}
+
+/*! \internal
+  
+  Returns the pen that is used to draw the axis base line. Depending on the selection state, this
+  is either mSelectedBasePen or mBasePen.
+*/
+QPen QCPAxis::getBasePen() const
+{
+  return mSelectedParts.testFlag(spAxis) ? mSelectedBasePen : mBasePen;
+}
+
+/*! \internal
+  
+  Returns the pen that is used to draw the (major) ticks. Depending on the selection state, this
+  is either mSelectedTickPen or mTickPen.
+*/
+QPen QCPAxis::getTickPen() const
+{
+  return mSelectedParts.testFlag(spAxis) ? mSelectedTickPen : mTickPen;
+}
+
+/*! \internal
+  
+  Returns the pen that is used to draw the subticks. Depending on the selection state, this
+  is either mSelectedSubTickPen or mSubTickPen.
+*/
+QPen QCPAxis::getSubTickPen() const
+{
+  return mSelectedParts.testFlag(spAxis) ? mSelectedSubTickPen : mSubTickPen;
+}
+
+/*! \internal
+  
+  Returns the font that is used to draw the tick labels. Depending on the selection state, this
+  is either mSelectedTickLabelFont or mTickLabelFont.
+*/
+QFont QCPAxis::getTickLabelFont() const
+{
+  return mSelectedParts.testFlag(spTickLabels) ? mSelectedTickLabelFont : mTickLabelFont;
+}
+
+/*! \internal
+  
+  Returns the font that is used to draw the axis label. Depending on the selection state, this
+  is either mSelectedLabelFont or mLabelFont.
+*/
+QFont QCPAxis::getLabelFont() const
+{
+  return mSelectedParts.testFlag(spAxisLabel) ? mSelectedLabelFont : mLabelFont;
+}
+
+/*! \internal
+  
+  Returns the color that is used to draw the tick labels. Depending on the selection state, this
+  is either mSelectedTickLabelColor or mTickLabelColor.
+*/
+QColor QCPAxis::getTickLabelColor() const
+{
+  return mSelectedParts.testFlag(spTickLabels) ? mSelectedTickLabelColor : mTickLabelColor;
+}
+
+/*! \internal
+  
+  Returns the color that is used to draw the axis label. Depending on the selection state, this
+  is either mSelectedLabelColor or mLabelColor.
+*/
+QColor QCPAxis::getLabelColor() const
+{
+  return mSelectedParts.testFlag(spAxisLabel) ? mSelectedLabelColor : mLabelColor;
+}
+
+/*! \internal
+  
+  Returns the appropriate outward margin for this axis. It is needed if \ref
+  QCPAxisRect::setAutoMargins is set to true on the parent axis rect. An axis with axis type \ref
+  atLeft will return an appropriate left margin, \ref atBottom will return an appropriate bottom
+  margin and so forth. For the calculation, this function goes through similar steps as \ref draw,
+  so changing one function likely requires the modification of the other one as well.
+  
+  The margin consists of the outward tick length, tick label padding, tick label size, label
+  padding, label size, and padding.
+  
+  The margin is cached internally, so repeated calls while leaving the axis range, fonts, etc.
+  unchanged are very fast.
+*/
+int QCPAxis::calculateMargin()
+{
+  if (!mVisible) // if not visible, directly return 0, don't cache 0 because we can't react to setVisible in QCPAxis
+    return 0;
+  
+  if (mCachedMarginValid)
+    return mCachedMargin;
+  
+  // run through similar steps as QCPAxis::draw, and caluclate margin needed to fit axis and its labels
+  int margin = 0;
+  
+  int lowTick, highTick;
+  visibleTickBounds(lowTick, highTick);
+  QVector<double> tickPositions; // the final coordToPixel transformed vector passed to QCPAxisPainter
+  QVector<QString> tickLabels; // the final vector passed to QCPAxisPainter
+  tickPositions.reserve(highTick-lowTick+1);
+  tickLabels.reserve(highTick-lowTick+1);
+  if (mTicks)
+  {
+    for (int i=lowTick; i<=highTick; ++i)
+    {
+      tickPositions.append(coordToPixel(mTickVector.at(i)));
+      if (mTickLabels)
+        tickLabels.append(mTickVectorLabels.at(i));
+    }
+  }
+  // transfer all properties of this axis to QCPAxisPainterPrivate which it needs to calculate the size.
+  // Note that some axis painter properties are already set by direct feed-through with QCPAxis setters
+  mAxisPainter->type = mAxisType;
+  mAxisPainter->labelFont = getLabelFont();
+  mAxisPainter->label = mLabel;
+  mAxisPainter->tickLabelFont = mTickLabelFont;
+  mAxisPainter->axisRect = mAxisRect->rect();
+  mAxisPainter->viewportRect = mParentPlot->viewport();
+  mAxisPainter->tickPositions = tickPositions;
+  mAxisPainter->tickLabels = tickLabels;
+  margin += mAxisPainter->size();
+  margin += mPadding;
+
+  mCachedMargin = margin;
+  mCachedMarginValid = true;
+  return margin;
+}
+
+/* inherits documentation from base class */
+QCP::Interaction QCPAxis::selectionCategory() const
+{
+  return QCP::iSelectAxes;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPAxisPainterPrivate
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPAxisPainterPrivate
+
+  \internal
+  \brief (Private)
+  
+  This is a private class and not part of the public QCustomPlot interface.
+  
+  It is used by QCPAxis to do the low-level drawing of axis backbone, tick marks, tick labels and
+  axis label. It also buffers the labels to reduce replot times. The parameters are configured by
+  directly accessing the public member variables.
+*/
+
+/*!
+  Constructs a QCPAxisPainterPrivate instance. Make sure to not create a new instance on every
+  redraw, to utilize the caching mechanisms.
+*/
+QCPAxisPainterPrivate::QCPAxisPainterPrivate(QCustomPlot *parentPlot) :
+  type(QCPAxis::atLeft),
+  basePen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),
+  lowerEnding(QCPLineEnding::esNone),
+  upperEnding(QCPLineEnding::esNone),
+  labelPadding(0),
+  tickLabelPadding(0),
+  tickLabelRotation(0),
+  tickLabelSide(QCPAxis::lsOutside),
+  substituteExponent(true),
+  numberMultiplyCross(false),
+  tickLengthIn(5),
+  tickLengthOut(0),
+  subTickLengthIn(2),
+  subTickLengthOut(0),
+  tickPen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),
+  subTickPen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),
+  offset(0),
+  abbreviateDecimalPowers(false),
+  reversedEndings(false),
+  mParentPlot(parentPlot),
+  mLabelCache(16) // cache at most 16 (tick) labels
+{
+}
+
+QCPAxisPainterPrivate::~QCPAxisPainterPrivate()
+{
+}
+
+/*! \internal
+  
+  Draws the axis with the specified \a painter.
+  
+  The selection boxes (mAxisSelectionBox, mTickLabelsSelectionBox, mLabelSelectionBox) are set
+  here, too.
+*/
+void QCPAxisPainterPrivate::draw(QCPPainter *painter)
+{
+  QByteArray newHash = generateLabelParameterHash();
+  if (newHash != mLabelParameterHash)
+  {
+    mLabelCache.clear();
+    mLabelParameterHash = newHash;
+  }
+  
+  QPoint origin;
+  switch (type)
+  {
+    case QCPAxis::atLeft:   origin = axisRect.bottomLeft() +QPoint(-offset, 0); break;
+    case QCPAxis::atRight:  origin = axisRect.bottomRight()+QPoint(+offset, 0); break;
+    case QCPAxis::atTop:    origin = axisRect.topLeft()    +QPoint(0, -offset); break;
+    case QCPAxis::atBottom: origin = axisRect.bottomLeft() +QPoint(0, +offset); break;
+  }
+
+  double xCor = 0, yCor = 0; // paint system correction, for pixel exact matches (affects baselines and ticks of top/right axes)
+  switch (type)
+  {
+    case QCPAxis::atTop: yCor = -1; break;
+    case QCPAxis::atRight: xCor = 1; break;
+    default: break;
+  }
+  int margin = 0;
+  // draw baseline:
+  QLineF baseLine;
+  painter->setPen(basePen);
+  if (QCPAxis::orientation(type) == Qt::Horizontal)
+    baseLine.setPoints(origin+QPointF(xCor, yCor), origin+QPointF(axisRect.width()+xCor, yCor));
+  else
+    baseLine.setPoints(origin+QPointF(xCor, yCor), origin+QPointF(xCor, -axisRect.height()+yCor));
+  if (reversedEndings)
+    baseLine = QLineF(baseLine.p2(), baseLine.p1()); // won't make a difference for line itself, but for line endings later
+  painter->drawLine(baseLine);
+  
+  // draw ticks:
+  if (!tickPositions.isEmpty())
+  {
+    painter->setPen(tickPen);
+    int tickDir = (type == QCPAxis::atBottom || type == QCPAxis::atRight) ? -1 : 1; // direction of ticks ("inward" is right for left axis and left for right axis)
+    if (QCPAxis::orientation(type) == Qt::Horizontal)
+    {
+      for (int i=0; i<tickPositions.size(); ++i)
+        painter->drawLine(QLineF(tickPositions.at(i)+xCor, origin.y()-tickLengthOut*tickDir+yCor, tickPositions.at(i)+xCor, origin.y()+tickLengthIn*tickDir+yCor));
+    } else
+    {
+      for (int i=0; i<tickPositions.size(); ++i)
+        painter->drawLine(QLineF(origin.x()-tickLengthOut*tickDir+xCor, tickPositions.at(i)+yCor, origin.x()+tickLengthIn*tickDir+xCor, tickPositions.at(i)+yCor));
+    }
+  }
+  
+  // draw subticks:
+  if (!subTickPositions.isEmpty())
+  {
+    painter->setPen(subTickPen);
+    // direction of ticks ("inward" is right for left axis and left for right axis)
+    int tickDir = (type == QCPAxis::atBottom || type == QCPAxis::atRight) ? -1 : 1;
+    if (QCPAxis::orientation(type) == Qt::Horizontal)
+    {
+      for (int i=0; i<subTickPositions.size(); ++i)
+        painter->drawLine(QLineF(subTickPositions.at(i)+xCor, origin.y()-subTickLengthOut*tickDir+yCor, subTickPositions.at(i)+xCor, origin.y()+subTickLengthIn*tickDir+yCor));
+    } else
+    {
+      for (int i=0; i<subTickPositions.size(); ++i)
+        painter->drawLine(QLineF(origin.x()-subTickLengthOut*tickDir+xCor, subTickPositions.at(i)+yCor, origin.x()+subTickLengthIn*tickDir+xCor, subTickPositions.at(i)+yCor));
+    }
+  }
+  margin += qMax(0, qMax(tickLengthOut, subTickLengthOut));
+  
+  // draw axis base endings:
+  bool antialiasingBackup = painter->antialiasing();
+  painter->setAntialiasing(true); // always want endings to be antialiased, even if base and ticks themselves aren't
+  painter->setBrush(QBrush(basePen.color()));
+  QVector2D baseLineVector(baseLine.dx(), baseLine.dy());
+  if (lowerEnding.style() != QCPLineEnding::esNone)
+    lowerEnding.draw(painter, QVector2D(baseLine.p1())-baseLineVector.normalized()*lowerEnding.realLength()*(lowerEnding.inverted()?-1:1), -baseLineVector);
+  if (upperEnding.style() != QCPLineEnding::esNone)
+    upperEnding.draw(painter, QVector2D(baseLine.p2())+baseLineVector.normalized()*upperEnding.realLength()*(upperEnding.inverted()?-1:1), baseLineVector);
+  painter->setAntialiasing(antialiasingBackup);
+  
+  // tick labels:
+  QRect oldClipRect;
+  if (tickLabelSide == QCPAxis::lsInside) // if using inside labels, clip them to the axis rect
+  {
+    oldClipRect = painter->clipRegion().boundingRect();
+    painter->setClipRect(axisRect);
+  }
+  QSize tickLabelsSize(0, 0); // size of largest tick label, for offset calculation of axis label
+  if (!tickLabels.isEmpty())
+  {
+    if (tickLabelSide == QCPAxis::lsOutside)
+      margin += tickLabelPadding;
+    painter->setFont(tickLabelFont);
+    painter->setPen(QPen(tickLabelColor));
+    const int maxLabelIndex = qMin(tickPositions.size(), tickLabels.size());
+    int distanceToAxis = margin;
+    if (tickLabelSide == QCPAxis::lsInside)
+      distanceToAxis = -(qMax(tickLengthIn, subTickLengthIn)+tickLabelPadding);
+    for (int i=0; i<maxLabelIndex; ++i)
+      placeTickLabel(painter, tickPositions.at(i), distanceToAxis, tickLabels.at(i), &tickLabelsSize);
+    if (tickLabelSide == QCPAxis::lsOutside)
+      margin += (QCPAxis::orientation(type) == Qt::Horizontal) ? tickLabelsSize.height() : tickLabelsSize.width();
+  }
+  if (tickLabelSide == QCPAxis::lsInside)
+    painter->setClipRect(oldClipRect);
+  
+  // axis label:
+  QRect labelBounds;
+  if (!label.isEmpty())
+  {
+    margin += labelPadding;
+    painter->setFont(labelFont);
+    painter->setPen(QPen(labelColor));
+    labelBounds = painter->fontMetrics().boundingRect(0, 0, 0, 0, Qt::TextDontClip, label);
+    if (type == QCPAxis::atLeft)
+    {
+      QTransform oldTransform = painter->transform();
+      painter->translate((origin.x()-margin-labelBounds.height()), origin.y());
+      painter->rotate(-90);
+      painter->drawText(0, 0, axisRect.height(), labelBounds.height(), Qt::TextDontClip | Qt::AlignCenter, label);
+      painter->setTransform(oldTransform);
+    }
+    else if (type == QCPAxis::atRight)
+    {
+      QTransform oldTransform = painter->transform();
+      painter->translate((origin.x()+margin+labelBounds.height()), origin.y()-axisRect.height());
+      painter->rotate(90);
+      painter->drawText(0, 0, axisRect.height(), labelBounds.height(), Qt::TextDontClip | Qt::AlignCenter, label);
+      painter->setTransform(oldTransform);
+    }
+    else if (type == QCPAxis::atTop)
+      painter->drawText(origin.x(), origin.y()-margin-labelBounds.height(), axisRect.width(), labelBounds.height(), Qt::TextDontClip | Qt::AlignCenter, label);
+    else if (type == QCPAxis::atBottom)
+      painter->drawText(origin.x(), origin.y()+margin, axisRect.width(), labelBounds.height(), Qt::TextDontClip | Qt::AlignCenter, label);
+  }
+  
+  // set selection boxes:
+  int selectionTolerance = 0;
+  if (mParentPlot)
+    selectionTolerance = mParentPlot->selectionTolerance();
+  else
+    qDebug() << Q_FUNC_INFO << "mParentPlot is null";
+  int selAxisOutSize = qMax(qMax(tickLengthOut, subTickLengthOut), selectionTolerance);
+  int selAxisInSize = selectionTolerance;
+  int selTickLabelSize;
+  int selTickLabelOffset;
+  if (tickLabelSide == QCPAxis::lsOutside)
+  {
+    selTickLabelSize = (QCPAxis::orientation(type) == Qt::Horizontal ? tickLabelsSize.height() : tickLabelsSize.width());
+    selTickLabelOffset = qMax(tickLengthOut, subTickLengthOut)+tickLabelPadding;
+  } else
+  {
+    selTickLabelSize = -(QCPAxis::orientation(type) == Qt::Horizontal ? tickLabelsSize.height() : tickLabelsSize.width());
+    selTickLabelOffset = -(qMax(tickLengthIn, subTickLengthIn)+tickLabelPadding);
+  }
+  int selLabelSize = labelBounds.height();
+  int selLabelOffset = qMax(tickLengthOut, subTickLengthOut)+(!tickLabels.isEmpty() && tickLabelSide == QCPAxis::lsOutside ? tickLabelPadding+selTickLabelSize : 0)+labelPadding;
+  if (type == QCPAxis::atLeft)
+  {
+    mAxisSelectionBox.setCoords(origin.x()-selAxisOutSize, axisRect.top(), origin.x()+selAxisInSize, axisRect.bottom());
+    mTickLabelsSelectionBox.setCoords(origin.x()-selTickLabelOffset-selTickLabelSize, axisRect.top(), origin.x()-selTickLabelOffset, axisRect.bottom());
+    mLabelSelectionBox.setCoords(origin.x()-selLabelOffset-selLabelSize, axisRect.top(), origin.x()-selLabelOffset, axisRect.bottom());
+  } else if (type == QCPAxis::atRight)
+  {
+    mAxisSelectionBox.setCoords(origin.x()-selAxisInSize, axisRect.top(), origin.x()+selAxisOutSize, axisRect.bottom());
+    mTickLabelsSelectionBox.setCoords(origin.x()+selTickLabelOffset+selTickLabelSize, axisRect.top(), origin.x()+selTickLabelOffset, axisRect.bottom());
+    mLabelSelectionBox.setCoords(origin.x()+selLabelOffset+selLabelSize, axisRect.top(), origin.x()+selLabelOffset, axisRect.bottom());
+  } else if (type == QCPAxis::atTop)
+  {
+    mAxisSelectionBox.setCoords(axisRect.left(), origin.y()-selAxisOutSize, axisRect.right(), origin.y()+selAxisInSize);
+    mTickLabelsSelectionBox.setCoords(axisRect.left(), origin.y()-selTickLabelOffset-selTickLabelSize, axisRect.right(), origin.y()-selTickLabelOffset);
+    mLabelSelectionBox.setCoords(axisRect.left(), origin.y()-selLabelOffset-selLabelSize, axisRect.right(), origin.y()-selLabelOffset);
+  } else if (type == QCPAxis::atBottom)
+  {
+    mAxisSelectionBox.setCoords(axisRect.left(), origin.y()-selAxisInSize, axisRect.right(), origin.y()+selAxisOutSize);
+    mTickLabelsSelectionBox.setCoords(axisRect.left(), origin.y()+selTickLabelOffset+selTickLabelSize, axisRect.right(), origin.y()+selTickLabelOffset);
+    mLabelSelectionBox.setCoords(axisRect.left(), origin.y()+selLabelOffset+selLabelSize, axisRect.right(), origin.y()+selLabelOffset);
+  }
+  mAxisSelectionBox = mAxisSelectionBox.normalized();
+  mTickLabelsSelectionBox = mTickLabelsSelectionBox.normalized();
+  mLabelSelectionBox = mLabelSelectionBox.normalized();
+  // draw hitboxes for debug purposes:
+  //painter->setBrush(Qt::NoBrush);
+  //painter->drawRects(QVector<QRect>() << mAxisSelectionBox << mTickLabelsSelectionBox << mLabelSelectionBox);
+}
+
+/*! \internal
+  
+  Returns the size ("margin" in QCPAxisRect context, so measured perpendicular to the axis backbone
+  direction) needed to fit the axis.
+*/
+int QCPAxisPainterPrivate::size() const
+{
+  int result = 0;
+  
+  // get length of tick marks pointing outwards:
+  if (!tickPositions.isEmpty())
+    result += qMax(0, qMax(tickLengthOut, subTickLengthOut));
+  
+  // calculate size of tick labels:
+  if (tickLabelSide == QCPAxis::lsOutside)
+  {
+    QSize tickLabelsSize(0, 0);
+    if (!tickLabels.isEmpty())
+    {
+      for (int i=0; i<tickLabels.size(); ++i)
+        getMaxTickLabelSize(tickLabelFont, tickLabels.at(i), &tickLabelsSize);
+      result += QCPAxis::orientation(type) == Qt::Horizontal ? tickLabelsSize.height() : tickLabelsSize.width();
+    result += tickLabelPadding;
+    }
+  }
+  
+  // calculate size of axis label (only height needed, because left/right labels are rotated by 90 degrees):
+  if (!label.isEmpty())
+  {
+    QFontMetrics fontMetrics(labelFont);
+    QRect bounds;
+    bounds = fontMetrics.boundingRect(0, 0, 0, 0, Qt::TextDontClip | Qt::AlignHCenter | Qt::AlignVCenter, label);
+    result += bounds.height() + labelPadding;
+  }
+  
+  return result;
+}
+
+/*! \internal
+  
+  Clears the internal label cache. Upon the next \ref draw, all labels will be created new. This
+  method is called automatically in \ref draw, if any parameters have changed that invalidate the
+  cached labels, such as font, color, etc.
+*/
+void QCPAxisPainterPrivate::clearCache()
+{
+  mLabelCache.clear();
+}
+
+/*! \internal
+  
+  Returns a hash that allows uniquely identifying whether the label parameters have changed such
+  that the cached labels must be refreshed (\ref clearCache). It is used in \ref draw. If the
+  return value of this method hasn't changed since the last redraw, the respective label parameters
+  haven't changed and cached labels may be used.
+*/
+QByteArray QCPAxisPainterPrivate::generateLabelParameterHash() const
+{
+  QByteArray result;
+  result.append(QByteArray::number(tickLabelRotation));
+  result.append(QByteArray::number((int)tickLabelSide));
+  result.append(QByteArray::number((int)substituteExponent));
+  result.append(QByteArray::number((int)numberMultiplyCross));
+  result.append(tickLabelColor.name().toLatin1()+QByteArray::number(tickLabelColor.alpha(), 16));
+  result.append(tickLabelFont.toString().toLatin1());
+  return result;
+}
+
+/*! \internal
+  
+  Draws a single tick label with the provided \a painter, utilizing the internal label cache to
+  significantly speed up drawing of labels that were drawn in previous calls. The tick label is
+  always bound to an axis, the distance to the axis is controllable via \a distanceToAxis in
+  pixels. The pixel position in the axis direction is passed in the \a position parameter. Hence
+  for the bottom axis, \a position would indicate the horizontal pixel position (not coordinate),
+  at which the label should be drawn.
+  
+  In order to later draw the axis label in a place that doesn't overlap with the tick labels, the
+  largest tick label size is needed. This is acquired by passing a \a tickLabelsSize to the \ref
+  drawTickLabel calls during the process of drawing all tick labels of one axis. In every call, \a
+  tickLabelsSize is expanded, if the drawn label exceeds the value \a tickLabelsSize currently
+  holds.
+  
+  The label is drawn with the font and pen that are currently set on the \a painter. To draw
+  superscripted powers, the font is temporarily made smaller by a fixed factor (see \ref
+  getTickLabelData).
+*/
+void QCPAxisPainterPrivate::placeTickLabel(QCPPainter *painter, double position, int distanceToAxis, const QString &text, QSize *tickLabelsSize)
+{
+  // warning: if you change anything here, also adapt getMaxTickLabelSize() accordingly!
+  if (text.isEmpty()) return;
+  QSize finalSize;
+  QPointF labelAnchor;
+  switch (type)
+  {
+    case QCPAxis::atLeft:   labelAnchor = QPointF(axisRect.left()-distanceToAxis-offset, position); break;
+    case QCPAxis::atRight:  labelAnchor = QPointF(axisRect.right()+distanceToAxis+offset, position); break;
+    case QCPAxis::atTop:    labelAnchor = QPointF(position, axisRect.top()-distanceToAxis-offset); break;
+    case QCPAxis::atBottom: labelAnchor = QPointF(position, axisRect.bottom()+distanceToAxis+offset); break;
+  }
+  if (mParentPlot->plottingHints().testFlag(QCP::phCacheLabels) && !painter->modes().testFlag(QCPPainter::pmNoCaching)) // label caching enabled
+  {
+    CachedLabel *cachedLabel = mLabelCache.take(text); // attempt to get label from cache
+    if (!cachedLabel)  // no cached label existed, create it
+    {
+      cachedLabel = new CachedLabel;
+      TickLabelData labelData = getTickLabelData(painter->font(), text);
+      cachedLabel->offset = getTickLabelDrawOffset(labelData)+labelData.rotatedTotalBounds.topLeft();
+      cachedLabel->pixmap = QPixmap(labelData.rotatedTotalBounds.size());
+      cachedLabel->pixmap.fill(Qt::transparent);
+      QCPPainter cachePainter(&cachedLabel->pixmap);
+      cachePainter.setPen(painter->pen());
+      drawTickLabel(&cachePainter, -labelData.rotatedTotalBounds.topLeft().x(), -labelData.rotatedTotalBounds.topLeft().y(), labelData);
+    }
+    // if label would be partly clipped by widget border on sides, don't draw it (only for outside tick labels):
+    bool labelClippedByBorder = false;
+    if (tickLabelSide == QCPAxis::lsOutside)
+    {
+      if (QCPAxis::orientation(type) == Qt::Horizontal)
+        labelClippedByBorder = labelAnchor.x()+cachedLabel->offset.x()+cachedLabel->pixmap.width() > viewportRect.right() || labelAnchor.x()+cachedLabel->offset.x() < viewportRect.left();
+      else
+        labelClippedByBorder = labelAnchor.y()+cachedLabel->offset.y()+cachedLabel->pixmap.height() > viewportRect.bottom() || labelAnchor.y()+cachedLabel->offset.y() < viewportRect.top();
+    }
+    if (!labelClippedByBorder)
+    {
+      painter->drawPixmap(labelAnchor+cachedLabel->offset, cachedLabel->pixmap);
+      finalSize = cachedLabel->pixmap.size();
+    }
+    mLabelCache.insert(text, cachedLabel); // return label to cache or insert for the first time if newly created
+  } else // label caching disabled, draw text directly on surface:
+  {
+    TickLabelData labelData = getTickLabelData(painter->font(), text);
+    QPointF finalPosition = labelAnchor + getTickLabelDrawOffset(labelData);
+    // if label would be partly clipped by widget border on sides, don't draw it (only for outside tick labels):
+     bool labelClippedByBorder = false;
+    if (tickLabelSide == QCPAxis::lsOutside)
+    {
+      if (QCPAxis::orientation(type) == Qt::Horizontal)
+        labelClippedByBorder = finalPosition.x()+(labelData.rotatedTotalBounds.width()+labelData.rotatedTotalBounds.left()) > viewportRect.right() || finalPosition.x()+labelData.rotatedTotalBounds.left() < viewportRect.left();
+      else
+        labelClippedByBorder = finalPosition.y()+(labelData.rotatedTotalBounds.height()+labelData.rotatedTotalBounds.top()) > viewportRect.bottom() || finalPosition.y()+labelData.rotatedTotalBounds.top() < viewportRect.top();
+    }
+    if (!labelClippedByBorder)
+    {
+      drawTickLabel(painter, finalPosition.x(), finalPosition.y(), labelData);
+      finalSize = labelData.rotatedTotalBounds.size();
+    }
+  }
+  
+  // expand passed tickLabelsSize if current tick label is larger:
+  if (finalSize.width() > tickLabelsSize->width())
+    tickLabelsSize->setWidth(finalSize.width());
+  if (finalSize.height() > tickLabelsSize->height())
+    tickLabelsSize->setHeight(finalSize.height());
+}
+
+/*! \internal
+  
+  This is a \ref placeTickLabel helper function.
+  
+  Draws the tick label specified in \a labelData with \a painter at the pixel positions \a x and \a
+  y. This function is used by \ref placeTickLabel to create new tick labels for the cache, or to
+  directly draw the labels on the QCustomPlot surface when label caching is disabled, i.e. when
+  QCP::phCacheLabels plotting hint is not set.
+*/
+void QCPAxisPainterPrivate::drawTickLabel(QCPPainter *painter, double x, double y, const TickLabelData &labelData) const
+{
+  // backup painter settings that we're about to change:
+  QTransform oldTransform = painter->transform();
+  QFont oldFont = painter->font();
+  
+  // transform painter to position/rotation:
+  painter->translate(x, y);
+  if (!qFuzzyIsNull(tickLabelRotation))
+    painter->rotate(tickLabelRotation);
+  
+  // draw text:
+  if (!labelData.expPart.isEmpty()) // indicator that beautiful powers must be used
+  {
+    painter->setFont(labelData.baseFont);
+    painter->drawText(0, 0, 0, 0, Qt::TextDontClip, labelData.basePart);
+    painter->setFont(labelData.expFont);
+    painter->drawText(labelData.baseBounds.width()+1, 0, labelData.expBounds.width(), labelData.expBounds.height(), Qt::TextDontClip,  labelData.expPart);
+  } else
+  {
+    painter->setFont(labelData.baseFont);
+    painter->drawText(0, 0, labelData.totalBounds.width(), labelData.totalBounds.height(), Qt::TextDontClip | Qt::AlignHCenter, labelData.basePart);
+  }
+  
+  // reset painter settings to what it was before:
+  painter->setTransform(oldTransform);
+  painter->setFont(oldFont);
+}
+
+/*! \internal
+  
+  This is a \ref placeTickLabel helper function.
+  
+  Transforms the passed \a text and \a font to a tickLabelData structure that can then be further
+  processed by \ref getTickLabelDrawOffset and \ref drawTickLabel. It splits the text into base and
+  exponent if necessary (member substituteExponent) and calculates appropriate bounding boxes.
+*/
+QCPAxisPainterPrivate::TickLabelData QCPAxisPainterPrivate::getTickLabelData(const QFont &font, const QString &text) const
+{
+  TickLabelData result;
+  
+  // determine whether beautiful decimal powers should be used
+  bool useBeautifulPowers = false;
+  int ePos = -1; // first index of exponent part, text before that will be basePart, text until eLast will be expPart
+  int eLast = -1; // last index of exponent part, rest of text after this will be suffixPart
+  if (substituteExponent)
+  {
+    ePos = text.indexOf(QLatin1Char('e'));
+    if (ePos > 0 && text.at(ePos-1).isDigit())
+    {
+      eLast = ePos;
+      while (eLast+1 < text.size() && (text.at(eLast+1) == QLatin1Char('+') || text.at(eLast+1) == QLatin1Char('-') || text.at(eLast+1).isDigit()))
+        ++eLast;
+      if (eLast > ePos) // only if also to right of 'e' is a digit/+/- interpret it as beautifiable power
+        useBeautifulPowers = true;
+    }
+  }
+  
+  // calculate text bounding rects and do string preparation for beautiful decimal powers:
+  result.baseFont = font;
+  if (result.baseFont.pointSizeF() > 0) // might return -1 if specified with setPixelSize, in that case we can't do correction in next line
+    result.baseFont.setPointSizeF(result.baseFont.pointSizeF()+0.05); // QFontMetrics.boundingRect has a bug for exact point sizes that make the results oscillate due to internal rounding
+  if (useBeautifulPowers)
+  {
+    // split text into parts of number/symbol that will be drawn normally and part that will be drawn as exponent:
+    result.basePart = text.left(ePos);
+    // in log scaling, we want to turn "1*10^n" into "10^n", else add multiplication sign and decimal base:
+    if (abbreviateDecimalPowers && result.basePart == QLatin1String("1"))
+      result.basePart = QLatin1String("10");
+    else
+      result.basePart += (numberMultiplyCross ? QString(QChar(215)) : QString(QChar(183))) + QLatin1String("10");
+    result.expPart = text.mid(ePos+1);
+    // clip "+" and leading zeros off expPart:
+    while (result.expPart.length() > 2 && result.expPart.at(1) == QLatin1Char('0')) // length > 2 so we leave one zero when numberFormatChar is 'e'
+      result.expPart.remove(1, 1);
+    if (!result.expPart.isEmpty() && result.expPart.at(0) == QLatin1Char('+'))
+      result.expPart.remove(0, 1);
+    // prepare smaller font for exponent:
+    result.expFont = font;
+    if (result.expFont.pointSize() > 0)
+      result.expFont.setPointSize(result.expFont.pointSize()*0.75);
+    else
+      result.expFont.setPixelSize(result.expFont.pixelSize()*0.75);
+    // calculate bounding rects of base part, exponent part and total one:
+    result.baseBounds = QFontMetrics(result.baseFont).boundingRect(0, 0, 0, 0, Qt::TextDontClip, result.basePart);
+    result.expBounds = QFontMetrics(result.expFont).boundingRect(0, 0, 0, 0, Qt::TextDontClip, result.expPart);
+    result.totalBounds = result.baseBounds.adjusted(0, 0, result.expBounds.width()+2, 0); // +2 consists of the 1 pixel spacing between base and exponent (see drawTickLabel) and an extra pixel to include AA
+  } else // useBeautifulPowers == false
+  {
+    result.basePart = text;
+    result.totalBounds = QFontMetrics(result.baseFont).boundingRect(0, 0, 0, 0, Qt::TextDontClip | Qt::AlignHCenter, result.basePart);
+  }
+  result.totalBounds.moveTopLeft(QPoint(0, 0)); // want bounding box aligned top left at origin, independent of how it was created, to make further processing simpler
+  
+  // calculate possibly different bounding rect after rotation:
+  result.rotatedTotalBounds = result.totalBounds;
+  if (!qFuzzyIsNull(tickLabelRotation))
+  {
+    QTransform transform;
+    transform.rotate(tickLabelRotation);
+    result.rotatedTotalBounds = transform.mapRect(result.rotatedTotalBounds);
+  }
+  
+  return result;
+}
+
+/*! \internal
+  
+  This is a \ref placeTickLabel helper function.
+  
+  Calculates the offset at which the top left corner of the specified tick label shall be drawn.
+  The offset is relative to a point right next to the tick the label belongs to.
+  
+  This function is thus responsible for e.g. centering tick labels under ticks and positioning them
+  appropriately when they are rotated.
+*/
+QPointF QCPAxisPainterPrivate::getTickLabelDrawOffset(const TickLabelData &labelData) const
+{
+  /*
+    calculate label offset from base point at tick (non-trivial, for best visual appearance): short
+    explanation for bottom axis: The anchor, i.e. the point in the label that is placed
+    horizontally under the corresponding tick is always on the label side that is closer to the
+    axis (e.g. the left side of the text when we're rotating clockwise). On that side, the height
+    is halved and the resulting point is defined the anchor. This way, a 90 degree rotated text
+    will be centered under the tick (i.e. displaced horizontally by half its height). At the same
+    time, a 45 degree rotated text will "point toward" its tick, as is typical for rotated tick
+    labels.
+  */
+  bool doRotation = !qFuzzyIsNull(tickLabelRotation);
+  bool flip = qFuzzyCompare(qAbs(tickLabelRotation), 90.0); // perfect +/-90 degree flip. Indicates vertical label centering on vertical axes.
+  double radians = tickLabelRotation/180.0*M_PI;
+  int x=0, y=0;
+  if ((type == QCPAxis::atLeft && tickLabelSide == QCPAxis::lsOutside) || (type == QCPAxis::atRight && tickLabelSide == QCPAxis::lsInside)) // Anchor at right side of tick label
+  {
+    if (doRotation)
+    {
+      if (tickLabelRotation > 0)
+      {
+        x = -qCos(radians)*labelData.totalBounds.width();
+        y = flip ? -labelData.totalBounds.width()/2.0 : -qSin(radians)*labelData.totalBounds.width()-qCos(radians)*labelData.totalBounds.height()/2.0;
+      } else
+      {
+        x = -qCos(-radians)*labelData.totalBounds.width()-qSin(-radians)*labelData.totalBounds.height();
+        y = flip ? +labelData.totalBounds.width()/2.0 : +qSin(-radians)*labelData.totalBounds.width()-qCos(-radians)*labelData.totalBounds.height()/2.0;
+      }
+    } else
+    {
+      x = -labelData.totalBounds.width();
+      y = -labelData.totalBounds.height()/2.0;
+    }
+  } else if ((type == QCPAxis::atRight && tickLabelSide == QCPAxis::lsOutside) || (type == QCPAxis::atLeft && tickLabelSide == QCPAxis::lsInside)) // Anchor at left side of tick label
+  {
+    if (doRotation)
+    {
+      if (tickLabelRotation > 0)
+      {
+        x = +qSin(radians)*labelData.totalBounds.height();
+        y = flip ? -labelData.totalBounds.width()/2.0 : -qCos(radians)*labelData.totalBounds.height()/2.0;
+      } else
+      {
+        x = 0;
+        y = flip ? +labelData.totalBounds.width()/2.0 : -qCos(-radians)*labelData.totalBounds.height()/2.0;
+      }
+    } else
+    {
+      x = 0;
+      y = -labelData.totalBounds.height()/2.0;
+    }
+  } else if ((type == QCPAxis::atTop && tickLabelSide == QCPAxis::lsOutside) || (type == QCPAxis::atBottom && tickLabelSide == QCPAxis::lsInside)) // Anchor at bottom side of tick label
+  {
+    if (doRotation)
+    {
+      if (tickLabelRotation > 0)
+      {
+        x = -qCos(radians)*labelData.totalBounds.width()+qSin(radians)*labelData.totalBounds.height()/2.0;
+        y = -qSin(radians)*labelData.totalBounds.width()-qCos(radians)*labelData.totalBounds.height();
+      } else
+      {
+        x = -qSin(-radians)*labelData.totalBounds.height()/2.0;
+        y = -qCos(-radians)*labelData.totalBounds.height();
+      }
+    } else
+    {
+      x = -labelData.totalBounds.width()/2.0;
+      y = -labelData.totalBounds.height();
+    }
+  } else if ((type == QCPAxis::atBottom && tickLabelSide == QCPAxis::lsOutside) || (type == QCPAxis::atTop && tickLabelSide == QCPAxis::lsInside)) // Anchor at top side of tick label
+  {
+    if (doRotation)
+    {
+      if (tickLabelRotation > 0)
+      {
+        x = +qSin(radians)*labelData.totalBounds.height()/2.0;
+        y = 0;
+      } else
+      {
+        x = -qCos(-radians)*labelData.totalBounds.width()-qSin(-radians)*labelData.totalBounds.height()/2.0;
+        y = +qSin(-radians)*labelData.totalBounds.width();
+      }
+    } else
+    {
+      x = -labelData.totalBounds.width()/2.0;
+      y = 0;
+    }
+  }
+  
+  return QPointF(x, y);
+}
+
+/*! \internal
+  
+  Simulates the steps done by \ref placeTickLabel by calculating bounding boxes of the text label
+  to be drawn, depending on number format etc. Since only the largest tick label is wanted for the
+  margin calculation, the passed \a tickLabelsSize is only expanded, if it's currently set to a
+  smaller width/height.
+*/
+void QCPAxisPainterPrivate::getMaxTickLabelSize(const QFont &font, const QString &text,  QSize *tickLabelsSize) const
+{
+  // note: this function must return the same tick label sizes as the placeTickLabel function.
+  QSize finalSize;
+  if (mParentPlot->plottingHints().testFlag(QCP::phCacheLabels) && mLabelCache.contains(text)) // label caching enabled and have cached label
+  {
+    const CachedLabel *cachedLabel = mLabelCache.object(text);
+    finalSize = cachedLabel->pixmap.size();
+  } else // label caching disabled or no label with this text cached:
+  {
+    TickLabelData labelData = getTickLabelData(font, text);
+    finalSize = labelData.rotatedTotalBounds.size();
+  }
+  
+  // expand passed tickLabelsSize if current tick label is larger:
+  if (finalSize.width() > tickLabelsSize->width())
+    tickLabelsSize->setWidth(finalSize.width());
+  if (finalSize.height() > tickLabelsSize->height())
+    tickLabelsSize->setHeight(finalSize.height());
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPAbstractPlottable
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPAbstractPlottable
+  \brief The abstract base class for all data representing objects in a plot.
+
+  It defines a very basic interface like name, pen, brush, visibility etc. Since this class is
+  abstract, it can't be instantiated. Use one of the subclasses or create a subclass yourself to
+  create new ways of displaying data (see "Creating own plottables" below).
+  
+  All further specifics are in the subclasses, for example:
+  \li A normal graph with possibly a line, scatter points and error bars: \ref QCPGraph
+  (typically created with \ref QCustomPlot::addGraph)
+  \li A parametric curve: \ref QCPCurve
+  \li A bar chart: \ref QCPBars
+  \li A statistical box plot: \ref QCPStatisticalBox
+  \li A color encoded two-dimensional map: \ref QCPColorMap
+  \li An OHLC/Candlestick chart: \ref QCPFinancial
+  
+  \section plottables-subclassing Creating own plottables
+  
+  To create an own plottable, you implement a subclass of QCPAbstractPlottable. These are the pure
+  virtual functions, you must implement:
+  \li \ref clearData
+  \li \ref selectTest
+  \li \ref draw
+  \li \ref drawLegendIcon
+  \li \ref getKeyRange
+  \li \ref getValueRange
+  
+  See the documentation of those functions for what they need to do.
+  
+  For drawing your plot, you can use the \ref coordsToPixels functions to translate a point in plot
+  coordinates to pixel coordinates. This function is quite convenient, because it takes the
+  orientation of the key and value axes into account for you (x and y are swapped when the key axis
+  is vertical and the value axis horizontal). If you are worried about performance (i.e. you need
+  to translate many points in a loop like QCPGraph), you can directly use \ref
+  QCPAxis::coordToPixel. However, you must then take care about the orientation of the axis
+  yourself.
+  
+  Here are some important members you inherit from QCPAbstractPlottable:
+  <table>
+  <tr>
+    <td>QCustomPlot *\b mParentPlot</td>
+    <td>A pointer to the parent QCustomPlot instance. The parent plot is inferred from the axes that are passed in the constructor.</td>
+  </tr><tr>
+    <td>QString \b mName</td>
+    <td>The name of the plottable.</td>
+  </tr><tr>
+    <td>QPen \b mPen</td>
+    <td>The generic pen of the plottable. You should use this pen for the most prominent data representing lines in the plottable (e.g QCPGraph uses this pen for its graph lines and scatters)</td>
+  </tr><tr>
+    <td>QPen \b mSelectedPen</td>
+    <td>The generic pen that should be used when the plottable is selected (hint: \ref mainPen gives you the right pen, depending on selection state).</td>
+  </tr><tr>
+    <td>QBrush \b mBrush</td>
+    <td>The generic brush of the plottable. You should use this brush for the most prominent fillable structures in the plottable (e.g. QCPGraph uses this brush to control filling under the graph)</td>
+  </tr><tr>
+    <td>QBrush \b mSelectedBrush</td>
+    <td>The generic brush that should be used when the plottable is selected (hint: \ref mainBrush gives you the right brush, depending on selection state).</td>
+  </tr><tr>
+    <td>QPointer<QCPAxis>\b mKeyAxis, \b mValueAxis</td>
+    <td>The key and value axes this plottable is attached to. Call their QCPAxis::coordToPixel functions to translate coordinates to pixels in either the key or value dimension.
+        Make sure to check whether the pointer is null before using it. If one of the axes is null, don't draw the plottable.</td>
+  </tr><tr>
+    <td>bool \b mSelected</td>
+    <td>indicates whether the plottable is selected or not.</td>
+  </tr>
+  </table>
+*/
+
+/* start of documentation of pure virtual functions */
+
+/*! \fn void QCPAbstractPlottable::clearData() = 0
+  Clears all data in the plottable.
+*/
+
+/*! \fn void QCPAbstractPlottable::drawLegendIcon(QCPPainter *painter, const QRect &rect) const = 0
+  \internal
+  
+  called by QCPLegend::draw (via QCPPlottableLegendItem::draw) to create a graphical representation
+  of this plottable inside \a rect, next to the plottable name.
+  
+  The passed \a painter has its cliprect set to \a rect, so painting outside of \a rect won't
+  appear outside the legend icon border.
+*/
+
+/*! \fn QCPRange QCPAbstractPlottable::getKeyRange(bool &foundRange, SignDomain inSignDomain) const = 0
+  \internal
+  
+  called by rescaleAxes functions to get the full data key bounds. For logarithmic plots, one can
+  set \a inSignDomain to either \ref sdNegative or \ref sdPositive in order to restrict the
+  returned range to that sign domain. E.g. when only negative range is wanted, set \a inSignDomain
+  to \ref sdNegative and all positive points will be ignored for range calculation. For no
+  restriction, just set \a inSignDomain to \ref sdBoth (default). \a foundRange is an output
+  parameter that indicates whether a range could be found or not. If this is false, you shouldn't
+  use the returned range (e.g. no points in data).
+
+  Note that \a foundRange is not the same as \ref QCPRange::validRange, since the range returned by
+  this function may have size zero, which wouldn't count as a valid range.
+  
+  \see rescaleAxes, getValueRange
+*/
+
+/*! \fn QCPRange QCPAbstractPlottable::getValueRange(bool &foundRange, SignDomain inSignDomain) const = 0
+  \internal
+  
+  called by rescaleAxes functions to get the full data value bounds. For logarithmic plots, one can
+  set \a inSignDomain to either \ref sdNegative or \ref sdPositive in order to restrict the
+  returned range to that sign domain. E.g. when only negative range is wanted, set \a inSignDomain
+  to \ref sdNegative and all positive points will be ignored for range calculation. For no
+  restriction, just set \a inSignDomain to \ref sdBoth (default). \a foundRange is an output
+  parameter that indicates whether a range could be found or not. If this is false, you shouldn't
+  use the returned range (e.g. no points in data).
+
+  Note that \a foundRange is not the same as \ref QCPRange::validRange, since the range returned by
+  this function may have size zero, which wouldn't count as a valid range.
+  
+  \see rescaleAxes, getKeyRange
+*/
+
+/* end of documentation of pure virtual functions */
+/* start of documentation of signals */
+
+/*! \fn void QCPAbstractPlottable::selectionChanged(bool selected)
+  
+  This signal is emitted when the selection state of this plottable has changed, either by user
+  interaction or by a direct call to \ref setSelected.
+*/
+
+/*! \fn void QCPAbstractPlottable::selectableChanged(bool selectable);
+  
+  This signal is emitted when the selectability of this plottable has changed.
+  
+  \see setSelectable
+*/
+
+/* end of documentation of signals */
+
+/*!
+  Constructs an abstract plottable which uses \a keyAxis as its key axis ("x") and \a valueAxis as
+  its value axis ("y"). \a keyAxis and \a valueAxis must reside in the same QCustomPlot instance
+  and have perpendicular orientations. If either of these restrictions is violated, a corresponding
+  message is printed to the debug output (qDebug), the construction is not aborted, though.
+  
+  Since QCPAbstractPlottable is an abstract class that defines the basic interface to plottables,
+  it can't be directly instantiated.
+  
+  You probably want one of the subclasses like \ref QCPGraph or \ref QCPCurve instead.
+*/
+QCPAbstractPlottable::QCPAbstractPlottable(QCPAxis *keyAxis, QCPAxis *valueAxis) :
+  QCPLayerable(keyAxis->parentPlot(), QString(), keyAxis->axisRect()),
+  mName(),
+  mAntialiasedFill(true),
+  mAntialiasedScatters(true),
+  mAntialiasedErrorBars(false),
+  mPen(Qt::black),
+  mSelectedPen(Qt::black),
+  mBrush(Qt::NoBrush),
+  mSelectedBrush(Qt::NoBrush),
+  mKeyAxis(keyAxis),
+  mValueAxis(valueAxis),
+  mSelectable(true),
+  mSelected(false)
+{
+  if (keyAxis->parentPlot() != valueAxis->parentPlot())
+    qDebug() << Q_FUNC_INFO << "Parent plot of keyAxis is not the same as that of valueAxis.";
+  if (keyAxis->orientation() == valueAxis->orientation())
+    qDebug() << Q_FUNC_INFO << "keyAxis and valueAxis must be orthogonal to each other.";
+}
+
+/*!
+   The name is the textual representation of this plottable as it is displayed in the legend
+   (\ref QCPLegend). It may contain any UTF-8 characters, including newlines.
+*/
+void QCPAbstractPlottable::setName(const QString &name)
+{
+  mName = name;
+}
+
+/*!
+  Sets whether fills of this plottable are drawn antialiased or not.
+  
+  Note that this setting may be overridden by \ref QCustomPlot::setAntialiasedElements and \ref
+  QCustomPlot::setNotAntialiasedElements.
+*/
+void QCPAbstractPlottable::setAntialiasedFill(bool enabled)
+{
+  mAntialiasedFill = enabled;
+}
+
+/*!
+  Sets whether the scatter symbols of this plottable are drawn antialiased or not.
+  
+  Note that this setting may be overridden by \ref QCustomPlot::setAntialiasedElements and \ref
+  QCustomPlot::setNotAntialiasedElements.
+*/
+void QCPAbstractPlottable::setAntialiasedScatters(bool enabled)
+{
+  mAntialiasedScatters = enabled;
+}
+
+/*!
+  Sets whether the error bars of this plottable are drawn antialiased or not.
+  
+  Note that this setting may be overridden by \ref QCustomPlot::setAntialiasedElements and \ref
+  QCustomPlot::setNotAntialiasedElements.
+*/
+void QCPAbstractPlottable::setAntialiasedErrorBars(bool enabled)
+{
+  mAntialiasedErrorBars = enabled;
+}
+
+
+/*!
+  The pen is used to draw basic lines that make up the plottable representation in the
+  plot.
+  
+  For example, the \ref QCPGraph subclass draws its graph lines with this pen.
+
+  \see setBrush
+*/
+void QCPAbstractPlottable::setPen(const QPen &pen)
+{
+  mPen = pen;
+}
+
+/*!
+  When the plottable is selected, this pen is used to draw basic lines instead of the normal
+  pen set via \ref setPen.
+
+  \see setSelected, setSelectable, setSelectedBrush, selectTest
+*/
+void QCPAbstractPlottable::setSelectedPen(const QPen &pen)
+{
+  mSelectedPen = pen;
+}
+
+/*!
+  The brush is used to draw basic fills of the plottable representation in the
+  plot. The Fill can be a color, gradient or texture, see the usage of QBrush.
+  
+  For example, the \ref QCPGraph subclass draws the fill under the graph with this brush, when
+  it's not set to Qt::NoBrush.
+
+  \see setPen
+*/
+void QCPAbstractPlottable::setBrush(const QBrush &brush)
+{
+  mBrush = brush;
+}
+
+/*!
+  When the plottable is selected, this brush is used to draw fills instead of the normal
+  brush set via \ref setBrush.
+
+  \see setSelected, setSelectable, setSelectedPen, selectTest
+*/
+void QCPAbstractPlottable::setSelectedBrush(const QBrush &brush)
+{
+  mSelectedBrush = brush;
+}
+
+/*!
+  The key axis of a plottable can be set to any axis of a QCustomPlot, as long as it is orthogonal
+  to the plottable's value axis. This function performs no checks to make sure this is the case.
+  The typical mathematical choice is to use the x-axis (QCustomPlot::xAxis) as key axis and the
+  y-axis (QCustomPlot::yAxis) as value axis.
+  
+  Normally, the key and value axes are set in the constructor of the plottable (or \ref
+  QCustomPlot::addGraph when working with QCPGraphs through the dedicated graph interface).
+
+  \see setValueAxis
+*/
+void QCPAbstractPlottable::setKeyAxis(QCPAxis *axis)
+{
+  mKeyAxis = axis;
+}
+
+/*!
+  The value axis of a plottable can be set to any axis of a QCustomPlot, as long as it is
+  orthogonal to the plottable's key axis. This function performs no checks to make sure this is the
+  case. The typical mathematical choice is to use the x-axis (QCustomPlot::xAxis) as key axis and
+  the y-axis (QCustomPlot::yAxis) as value axis.
+
+  Normally, the key and value axes are set in the constructor of the plottable (or \ref
+  QCustomPlot::addGraph when working with QCPGraphs through the dedicated graph interface).
+  
+  \see setKeyAxis
+*/
+void QCPAbstractPlottable::setValueAxis(QCPAxis *axis)
+{
+  mValueAxis = axis;
+}
+
+/*!
+  Sets whether the user can (de-)select this plottable by clicking on the QCustomPlot surface.
+  (When \ref QCustomPlot::setInteractions contains iSelectPlottables.)
+  
+  However, even when \a selectable was set to false, it is possible to set the selection manually,
+  by calling \ref setSelected directly.
+  
+  \see setSelected
+*/
+void QCPAbstractPlottable::setSelectable(bool selectable)
+{
+  if (mSelectable != selectable)
+  {
+    mSelectable = selectable;
+    emit selectableChanged(mSelectable);
+  }
+}
+
+/*!
+  Sets whether this plottable is selected or not. When selected, it uses a different pen and brush
+  to draw its lines and fills, see \ref setSelectedPen and \ref setSelectedBrush.
+
+  The entire selection mechanism for plottables is handled automatically when \ref
+  QCustomPlot::setInteractions contains iSelectPlottables. You only need to call this function when
+  you wish to change the selection state manually.
+  
+  This function can change the selection state even when \ref setSelectable was set to false.
+  
+  emits the \ref selectionChanged signal when \a selected is different from the previous selection state.
+  
+  \see setSelectable, selectTest
+*/
+void QCPAbstractPlottable::setSelected(bool selected)
+{
+  if (mSelected != selected)
+  {
+    mSelected = selected;
+    emit selectionChanged(mSelected);
+  }
+}
+
+/*!
+  Rescales the key and value axes associated with this plottable to contain all displayed data, so
+  the whole plottable is visible. If the scaling of an axis is logarithmic, rescaleAxes will make
+  sure not to rescale to an illegal range i.e. a range containing different signs and/or zero.
+  Instead it will stay in the current sign domain and ignore all parts of the plottable that lie
+  outside of that domain.
+  
+  \a onlyEnlarge makes sure the ranges are only expanded, never reduced. So it's possible to show
+  multiple plottables in their entirety by multiple calls to rescaleAxes where the first call has
+  \a onlyEnlarge set to false (the default), and all subsequent set to true.
+  
+  \see rescaleKeyAxis, rescaleValueAxis, QCustomPlot::rescaleAxes, QCPAxis::rescale
+*/
+void QCPAbstractPlottable::rescaleAxes(bool onlyEnlarge) const
+{
+  rescaleKeyAxis(onlyEnlarge);
+  rescaleValueAxis(onlyEnlarge);
+}
+
+/*!
+  Rescales the key axis of the plottable so the whole plottable is visible.
+  
+  See \ref rescaleAxes for detailed behaviour.
+*/
+void QCPAbstractPlottable::rescaleKeyAxis(bool onlyEnlarge) const
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  if (!keyAxis) { qDebug() << Q_FUNC_INFO << "invalid key axis"; return; }
+  
+  SignDomain signDomain = sdBoth;
+  if (keyAxis->scaleType() == QCPAxis::stLogarithmic)
+    signDomain = (keyAxis->range().upper < 0 ? sdNegative : sdPositive);
+  
+  bool foundRange;
+  QCPRange newRange = getKeyRange(foundRange, signDomain);
+  if (foundRange)
+  {
+    if (onlyEnlarge)
+      newRange.expand(keyAxis->range());
+    if (!QCPRange::validRange(newRange)) // likely due to range being zero (plottable has only constant data in this axis dimension), shift current range to at least center the plottable
+    {
+      double center = (newRange.lower+newRange.upper)*0.5; // upper and lower should be equal anyway, but just to make sure, incase validRange returned false for other reason
+      if (keyAxis->scaleType() == QCPAxis::stLinear)
+      {
+        newRange.lower = center-keyAxis->range().size()/2.0;
+        newRange.upper = center+keyAxis->range().size()/2.0;
+      } else // scaleType() == stLogarithmic
+      {
+        newRange.lower = center/qSqrt(keyAxis->range().upper/keyAxis->range().lower);
+        newRange.upper = center*qSqrt(keyAxis->range().upper/keyAxis->range().lower);
+      }
+    }
+    keyAxis->setRange(newRange);
+  }
+}
+
+/*!
+  Rescales the value axis of the plottable so the whole plottable is visible.
+  
+  Returns true if the axis was actually scaled. This might not be the case if this plottable has an
+  invalid range, e.g. because it has no data points.
+  
+  See \ref rescaleAxes for detailed behaviour.
+*/
+void QCPAbstractPlottable::rescaleValueAxis(bool onlyEnlarge) const
+{
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!valueAxis) { qDebug() << Q_FUNC_INFO << "invalid value axis"; return; }
+  
+  SignDomain signDomain = sdBoth;
+  if (valueAxis->scaleType() == QCPAxis::stLogarithmic)
+    signDomain = (valueAxis->range().upper < 0 ? sdNegative : sdPositive);
+  
+  bool foundRange;
+  QCPRange newRange = getValueRange(foundRange, signDomain);
+  if (foundRange)
+  {
+    if (onlyEnlarge)
+      newRange.expand(valueAxis->range());
+    if (!QCPRange::validRange(newRange)) // likely due to range being zero (plottable has only constant data in this axis dimension), shift current range to at least center the plottable
+    {
+      double center = (newRange.lower+newRange.upper)*0.5; // upper and lower should be equal anyway, but just to make sure, incase validRange returned false for other reason
+      if (valueAxis->scaleType() == QCPAxis::stLinear)
+      {
+        newRange.lower = center-valueAxis->range().size()/2.0;
+        newRange.upper = center+valueAxis->range().size()/2.0;
+      } else // scaleType() == stLogarithmic
+      {
+        newRange.lower = center/qSqrt(valueAxis->range().upper/valueAxis->range().lower);
+        newRange.upper = center*qSqrt(valueAxis->range().upper/valueAxis->range().lower);
+      }
+    }
+    valueAxis->setRange(newRange);
+  }
+}
+
+/*!
+  Adds this plottable to the legend of the parent QCustomPlot (QCustomPlot::legend).
+    
+  Normally, a QCPPlottableLegendItem is created and inserted into the legend. If the plottable
+  needs a more specialized representation in the legend, this function will take this into account
+  and instead create the specialized subclass of QCPAbstractLegendItem.
+    
+  Returns true on success, i.e. when the legend exists and a legend item associated with this plottable isn't already in
+  the legend.
+    
+  \see removeFromLegend, QCPLegend::addItem
+*/
+bool QCPAbstractPlottable::addToLegend()
+{
+  if (!mParentPlot || !mParentPlot->legend)
+    return false;
+  
+  if (!mParentPlot->legend->hasItemWithPlottable(this))
+  {
+    mParentPlot->legend->addItem(new QCPPlottableLegendItem(mParentPlot->legend, this));
+    return true;
+  } else
+    return false;
+}
+
+/*!
+  Removes the plottable from the legend of the parent QCustomPlot. This means the
+  QCPAbstractLegendItem (usually a QCPPlottableLegendItem) that is associated with this plottable
+  is removed.
+    
+  Returns true on success, i.e. if the legend exists and a legend item associated with this
+  plottable was found and removed.
+    
+  \see addToLegend, QCPLegend::removeItem
+*/
+bool QCPAbstractPlottable::removeFromLegend() const
+{
+  if (!mParentPlot->legend)
+    return false;
+  
+  if (QCPPlottableLegendItem *lip = mParentPlot->legend->itemWithPlottable(this))
+    return mParentPlot->legend->removeItem(lip);
+  else
+    return false;
+}
+
+/* inherits documentation from base class */
+QRect QCPAbstractPlottable::clipRect() const
+{
+  if (mKeyAxis && mValueAxis)
+    return mKeyAxis.data()->axisRect()->rect() & mValueAxis.data()->axisRect()->rect();
+  else
+    return QRect();
+}
+
+/* inherits documentation from base class */
+QCP::Interaction QCPAbstractPlottable::selectionCategory() const
+{
+  return QCP::iSelectPlottables;
+}
+
+/*! \internal
+  
+  Convenience function for transforming a key/value pair to pixels on the QCustomPlot surface,
+  taking the orientations of the axes associated with this plottable into account (e.g. whether key
+  represents x or y).
+  
+  \a key and \a value are transformed to the coodinates in pixels and are written to \a x and \a y.
+    
+  \see pixelsToCoords, QCPAxis::coordToPixel
+*/
+void QCPAbstractPlottable::coordsToPixels(double key, double value, double &x, double &y) const
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
+  
+  if (keyAxis->orientation() == Qt::Horizontal)
+  {
+    x = keyAxis->coordToPixel(key);
+    y = valueAxis->coordToPixel(value);
+  } else
+  {
+    y = keyAxis->coordToPixel(key);
+    x = valueAxis->coordToPixel(value);
+  }
+}
+
+/*! \internal
+  \overload
+  
+  Returns the input as pixel coordinates in a QPointF.
+*/
+const QPointF QCPAbstractPlottable::coordsToPixels(double key, double value) const
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPointF(); }
+  
+  if (keyAxis->orientation() == Qt::Horizontal)
+    return QPointF(keyAxis->coordToPixel(key), valueAxis->coordToPixel(value));
+  else
+    return QPointF(valueAxis->coordToPixel(value), keyAxis->coordToPixel(key));
+}
+
+/*! \internal
+  
+  Convenience function for transforming a x/y pixel pair on the QCustomPlot surface to plot coordinates,
+  taking the orientations of the axes associated with this plottable into account (e.g. whether key
+  represents x or y).
+  
+  \a x and \a y are transformed to the plot coodinates and are written to \a key and \a value.
+    
+  \see coordsToPixels, QCPAxis::coordToPixel
+*/
+void QCPAbstractPlottable::pixelsToCoords(double x, double y, double &key, double &value) const
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
+  
+  if (keyAxis->orientation() == Qt::Horizontal)
+  {
+    key = keyAxis->pixelToCoord(x);
+    value = valueAxis->pixelToCoord(y);
+  } else
+  {
+    key = keyAxis->pixelToCoord(y);
+    value = valueAxis->pixelToCoord(x);
+  }
+}
+
+/*! \internal
+  \overload
+
+  Returns the pixel input \a pixelPos as plot coordinates \a key and \a value.
+*/
+void QCPAbstractPlottable::pixelsToCoords(const QPointF &pixelPos, double &key, double &value) const
+{
+  pixelsToCoords(pixelPos.x(), pixelPos.y(), key, value);
+}
+
+/*! \internal
+
+  Returns the pen that should be used for drawing lines of the plottable. Returns mPen when the
+  graph is not selected and mSelectedPen when it is.
+*/
+QPen QCPAbstractPlottable::mainPen() const
+{
+  return mSelected ? mSelectedPen : mPen;
+}
+
+/*! \internal
+
+  Returns the brush that should be used for drawing fills of the plottable. Returns mBrush when the
+  graph is not selected and mSelectedBrush when it is.
+*/
+QBrush QCPAbstractPlottable::mainBrush() const
+{
+  return mSelected ? mSelectedBrush : mBrush;
+}
+
+/*! \internal
+
+  A convenience function to easily set the QPainter::Antialiased hint on the provided \a painter
+  before drawing plottable lines.
+
+  This is the antialiasing state the painter passed to the \ref draw method is in by default.
+  
+  This function takes into account the local setting of the antialiasing flag as well as the
+  overrides set with \ref QCustomPlot::setAntialiasedElements and \ref
+  QCustomPlot::setNotAntialiasedElements.
+  
+  \see setAntialiased, applyFillAntialiasingHint, applyScattersAntialiasingHint, applyErrorBarsAntialiasingHint
+*/
+void QCPAbstractPlottable::applyDefaultAntialiasingHint(QCPPainter *painter) const
+{
+  applyAntialiasingHint(painter, mAntialiased, QCP::aePlottables);
+}
+
+/*! \internal
+
+  A convenience function to easily set the QPainter::Antialiased hint on the provided \a painter
+  before drawing plottable fills.
+  
+  This function takes into account the local setting of the antialiasing flag as well as the
+  overrides set with \ref QCustomPlot::setAntialiasedElements and \ref
+  QCustomPlot::setNotAntialiasedElements.
+  
+  \see setAntialiased, applyDefaultAntialiasingHint, applyScattersAntialiasingHint, applyErrorBarsAntialiasingHint
+*/
+void QCPAbstractPlottable::applyFillAntialiasingHint(QCPPainter *painter) const
+{
+  applyAntialiasingHint(painter, mAntialiasedFill, QCP::aeFills);
+}
+
+/*! \internal
+
+  A convenience function to easily set the QPainter::Antialiased hint on the provided \a painter
+  before drawing plottable scatter points.
+  
+  This function takes into account the local setting of the antialiasing flag as well as the
+  overrides set with \ref QCustomPlot::setAntialiasedElements and \ref
+  QCustomPlot::setNotAntialiasedElements.
+  
+  \see setAntialiased, applyFillAntialiasingHint, applyDefaultAntialiasingHint, applyErrorBarsAntialiasingHint
+*/
+void QCPAbstractPlottable::applyScattersAntialiasingHint(QCPPainter *painter) const
+{
+  applyAntialiasingHint(painter, mAntialiasedScatters, QCP::aeScatters);
+}
+
+/*! \internal
+
+  A convenience function to easily set the QPainter::Antialiased hint on the provided \a painter
+  before drawing plottable error bars.
+  
+  This function takes into account the local setting of the antialiasing flag as well as the
+  overrides set with \ref QCustomPlot::setAntialiasedElements and \ref
+  QCustomPlot::setNotAntialiasedElements.
+  
+  \see setAntialiased, applyFillAntialiasingHint, applyScattersAntialiasingHint, applyDefaultAntialiasingHint
+*/
+void QCPAbstractPlottable::applyErrorBarsAntialiasingHint(QCPPainter *painter) const
+{
+  applyAntialiasingHint(painter, mAntialiasedErrorBars, QCP::aeErrorBars);
+}
+
+/*! \internal
+
+  Finds the shortest squared distance of \a point to the line segment defined by \a start and \a
+  end.
+  
+  This function may be used to help with the implementation of the \ref selectTest function for
+  specific plottables.
+  
+  \note This function is identical to QCPAbstractItem::distSqrToLine
+*/
+double QCPAbstractPlottable::distSqrToLine(const QPointF &start, const QPointF &end, const QPointF &point) const
+{
+  QVector2D a(start);
+  QVector2D b(end);
+  QVector2D p(point);
+  QVector2D v(b-a);
+  
+  double vLengthSqr = v.lengthSquared();
+  if (!qFuzzyIsNull(vLengthSqr))
+  {
+    double mu = QVector2D::dotProduct(p-a, v)/vLengthSqr;
+    if (mu < 0)
+      return (a-p).lengthSquared();
+    else if (mu > 1)
+      return (b-p).lengthSquared();
+    else
+      return ((a + mu*v)-p).lengthSquared();
+  } else
+    return (a-p).lengthSquared();
+}
+
+/* inherits documentation from base class */
+void QCPAbstractPlottable::selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)
+{
+  Q_UNUSED(event)
+  Q_UNUSED(details)
+  if (mSelectable)
+  {
+    bool selBefore = mSelected;
+    setSelected(additive ? !mSelected : true);
+    if (selectionStateChanged)
+      *selectionStateChanged = mSelected != selBefore;
+  }
+}
+
+/* inherits documentation from base class */
+void QCPAbstractPlottable::deselectEvent(bool *selectionStateChanged)
+{
+  if (mSelectable)
+  {
+    bool selBefore = mSelected;
+    setSelected(false);
+    if (selectionStateChanged)
+      *selectionStateChanged = mSelected != selBefore;
+  }
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPItemAnchor
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPItemAnchor
+  \brief An anchor of an item to which positions can be attached to.
+  
+  An item (QCPAbstractItem) may have one or more anchors. Unlike QCPItemPosition, an anchor doesn't
+  control anything on its item, but provides a way to tie other items via their positions to the
+  anchor.
+
+  For example, a QCPItemRect is defined by its positions \a topLeft and \a bottomRight.
+  Additionally it has various anchors like \a top, \a topRight or \a bottomLeft etc. So you can
+  attach the \a start (which is a QCPItemPosition) of a QCPItemLine to one of the anchors by
+  calling QCPItemPosition::setParentAnchor on \a start, passing the wanted anchor of the
+  QCPItemRect. This way the start of the line will now always follow the respective anchor location
+  on the rect item.
+  
+  Note that QCPItemPosition derives from QCPItemAnchor, so every position can also serve as an
+  anchor to other positions.
+  
+  To learn how to provide anchors in your own item subclasses, see the subclassing section of the
+  QCPAbstractItem documentation.
+*/
+
+/* start documentation of inline functions */
+
+/*! \fn virtual QCPItemPosition *QCPItemAnchor::toQCPItemPosition()
+  
+  Returns 0 if this instance is merely a QCPItemAnchor, and a valid pointer of type QCPItemPosition* if
+  it actually is a QCPItemPosition (which is a subclass of QCPItemAnchor).
+  
+  This safe downcast functionality could also be achieved with a dynamic_cast. However, QCustomPlot avoids
+  dynamic_cast to work with projects that don't have RTTI support enabled (e.g. -fno-rtti flag with
+  gcc compiler).
+*/
+
+/* end documentation of inline functions */
+
+/*!
+  Creates a new QCPItemAnchor. You shouldn't create QCPItemAnchor instances directly, even if
+  you want to make a new item subclass. Use \ref QCPAbstractItem::createAnchor instead, as
+  explained in the subclassing section of the QCPAbstractItem documentation.
+*/
+QCPItemAnchor::QCPItemAnchor(QCustomPlot *parentPlot, QCPAbstractItem *parentItem, const QString name, int anchorId) :
+  mName(name),
+  mParentPlot(parentPlot),
+  mParentItem(parentItem),
+  mAnchorId(anchorId)
+{
+}
+
+QCPItemAnchor::~QCPItemAnchor()
+{
+  // unregister as parent at children:
+  foreach (QCPItemPosition *child, mChildrenX.toList())
+  {
+    if (child->parentAnchorX() == this)
+      child->setParentAnchorX(0); // this acts back on this anchor and child removes itself from mChildrenX
+  }
+  foreach (QCPItemPosition *child, mChildrenY.toList())
+  {
+    if (child->parentAnchorY() == this)
+      child->setParentAnchorY(0); // this acts back on this anchor and child removes itself from mChildrenY
+  }
+}
+
+/*!
+  Returns the final absolute pixel position of the QCPItemAnchor on the QCustomPlot surface.
+  
+  The pixel information is internally retrieved via QCPAbstractItem::anchorPixelPosition of the
+  parent item, QCPItemAnchor is just an intermediary.
+*/
+QPointF QCPItemAnchor::pixelPoint() const
+{
+  if (mParentItem)
+  {
+    if (mAnchorId > -1)
+    {
+      return mParentItem->anchorPixelPoint(mAnchorId);
+    } else
+    {
+      qDebug() << Q_FUNC_INFO << "no valid anchor id set:" << mAnchorId;
+      return QPointF();
+    }
+  } else
+  {
+    qDebug() << Q_FUNC_INFO << "no parent item set";
+    return QPointF();
+  }
+}
+
+/*! \internal
+
+  Adds \a pos to the childX list of this anchor, which keeps track of which children use this
+  anchor as parent anchor for the respective coordinate. This is necessary to notify the children
+  prior to destruction of the anchor.
+  
+  Note that this function does not change the parent setting in \a pos.
+*/
+void QCPItemAnchor::addChildX(QCPItemPosition *pos)
+{
+  if (!mChildrenX.contains(pos))
+    mChildrenX.insert(pos);
+  else
+    qDebug() << Q_FUNC_INFO << "provided pos is child already" << reinterpret_cast<quintptr>(pos);
+}
+
+/*! \internal
+
+  Removes \a pos from the childX list of this anchor.
+  
+  Note that this function does not change the parent setting in \a pos.
+*/
+void QCPItemAnchor::removeChildX(QCPItemPosition *pos)
+{
+  if (!mChildrenX.remove(pos))
+    qDebug() << Q_FUNC_INFO << "provided pos isn't child" << reinterpret_cast<quintptr>(pos);
+}
+
+/*! \internal
+
+  Adds \a pos to the childY list of this anchor, which keeps track of which children use this
+  anchor as parent anchor for the respective coordinate. This is necessary to notify the children
+  prior to destruction of the anchor.
+  
+  Note that this function does not change the parent setting in \a pos.
+*/
+void QCPItemAnchor::addChildY(QCPItemPosition *pos)
+{
+  if (!mChildrenY.contains(pos))
+    mChildrenY.insert(pos);
+  else
+    qDebug() << Q_FUNC_INFO << "provided pos is child already" << reinterpret_cast<quintptr>(pos);
+}
+
+/*! \internal
+
+  Removes \a pos from the childY list of this anchor.
+  
+  Note that this function does not change the parent setting in \a pos.
+*/
+void QCPItemAnchor::removeChildY(QCPItemPosition *pos)
+{
+  if (!mChildrenY.remove(pos))
+    qDebug() << Q_FUNC_INFO << "provided pos isn't child" << reinterpret_cast<quintptr>(pos);
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPItemPosition
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPItemPosition
+  \brief Manages the position of an item.
+  
+  Every item has at least one public QCPItemPosition member pointer which provides ways to position the
+  item on the QCustomPlot surface. Some items have multiple positions, for example QCPItemRect has two:
+  \a topLeft and \a bottomRight.
+
+  QCPItemPosition has a type (\ref PositionType) that can be set with \ref setType. This type
+  defines how coordinates passed to \ref setCoords are to be interpreted, e.g. as absolute pixel
+  coordinates, as plot coordinates of certain axes, etc. For more advanced plots it is also
+  possible to assign different types per X/Y coordinate of the position (see \ref setTypeX, \ref
+  setTypeY). This way an item could be positioned at a fixed pixel distance from the top in the Y
+  direction, while following a plot coordinate in the X direction.
+
+  A QCPItemPosition may have a parent QCPItemAnchor, see \ref setParentAnchor. This way you can tie
+  multiple items together. If the QCPItemPosition has a parent, its coordinates (\ref setCoords)
+  are considered to be absolute pixels in the reference frame of the parent anchor, where (0, 0)
+  means directly ontop of the parent anchor. For example, You could attach the \a start position of
+  a QCPItemLine to the \a bottom anchor of a QCPItemText to make the starting point of the line
+  always be centered under the text label, no matter where the text is moved to. For more advanced
+  plots, it is possible to assign different parent anchors per X/Y coordinate of the position, see
+  \ref setParentAnchorX, \ref setParentAnchorY. This way an item could follow another item in the X
+  direction but stay at a fixed position in the Y direction. Or even follow item A in X, and item B
+  in Y.
+
+  Note that every QCPItemPosition inherits from QCPItemAnchor and thus can itself be used as parent
+  anchor for other positions.
+
+  To set the apparent pixel position on the QCustomPlot surface directly, use \ref setPixelPoint. This
+  works no matter what type this QCPItemPosition is or what parent-child situation it is in, as \ref
+  setPixelPoint transforms the coordinates appropriately, to make the position appear at the specified
+  pixel values.
+*/
+
+/* start documentation of inline functions */
+
+/*! \fn QCPItemPosition::PositionType *QCPItemPosition::type() const
+  
+  Returns the current position type.
+  
+  If different types were set for X and Y (\ref setTypeX, \ref setTypeY), this method returns the
+  type of the X coordinate. In that case rather use \a typeX() and \a typeY().
+  
+  \see setType
+*/
+
+/*! \fn QCPItemAnchor *QCPItemPosition::parentAnchor() const
+  
+  Returns the current parent anchor.
+  
+  If different parent anchors were set for X and Y (\ref setParentAnchorX, \ref setParentAnchorY),
+  this method returns the parent anchor of the Y coordinate. In that case rather use \a
+  parentAnchorX() and \a parentAnchorY().
+  
+  \see setParentAnchor
+*/
+
+/* end documentation of inline functions */
+
+/*!
+  Creates a new QCPItemPosition. You shouldn't create QCPItemPosition instances directly, even if
+  you want to make a new item subclass. Use \ref QCPAbstractItem::createPosition instead, as
+  explained in the subclassing section of the QCPAbstractItem documentation.
+*/
+QCPItemPosition::QCPItemPosition(QCustomPlot *parentPlot, QCPAbstractItem *parentItem, const QString name) :
+  QCPItemAnchor(parentPlot, parentItem, name),
+  mPositionTypeX(ptAbsolute),
+  mPositionTypeY(ptAbsolute),
+  mKey(0),
+  mValue(0),
+  mParentAnchorX(0),
+  mParentAnchorY(0)
+{
+}
+
+QCPItemPosition::~QCPItemPosition()
+{
+  // unregister as parent at children:
+  // Note: this is done in ~QCPItemAnchor again, but it's important QCPItemPosition does it itself, because only then
+  //       the setParentAnchor(0) call the correct QCPItemPosition::pixelPoint function instead of QCPItemAnchor::pixelPoint
+  foreach (QCPItemPosition *child, mChildrenX.toList())
+  {
+    if (child->parentAnchorX() == this)
+      child->setParentAnchorX(0); // this acts back on this anchor and child removes itself from mChildrenX
+  }
+  foreach (QCPItemPosition *child, mChildrenY.toList())
+  {
+    if (child->parentAnchorY() == this)
+      child->setParentAnchorY(0); // this acts back on this anchor and child removes itself from mChildrenY
+  }
+  // unregister as child in parent:
+  if (mParentAnchorX)
+    mParentAnchorX->removeChildX(this);
+  if (mParentAnchorY)
+    mParentAnchorY->removeChildY(this);
+}
+
+/* can't make this a header inline function, because QPointer breaks with forward declared types, see QTBUG-29588 */
+QCPAxisRect *QCPItemPosition::axisRect() const
+{
+  return mAxisRect.data();
+}
+
+/*!
+  Sets the type of the position. The type defines how the coordinates passed to \ref setCoords
+  should be handled and how the QCPItemPosition should behave in the plot.
+  
+  The possible values for \a type can be separated in two main categories:
+
+  \li The position is regarded as a point in plot coordinates. This corresponds to \ref ptPlotCoords
+  and requires two axes that define the plot coordinate system. They can be specified with \ref setAxes.
+  By default, the QCustomPlot's x- and yAxis are used.
+  
+  \li The position is fixed on the QCustomPlot surface, i.e. independent of axis ranges. This
+  corresponds to all other types, i.e. \ref ptAbsolute, \ref ptViewportRatio and \ref
+  ptAxisRectRatio. They differ only in the way the absolute position is described, see the
+  documentation of \ref PositionType for details. For \ref ptAxisRectRatio, note that you can specify
+  the axis rect with \ref setAxisRect. By default this is set to the main axis rect.
+  
+  Note that the position type \ref ptPlotCoords is only available (and sensible) when the position
+  has no parent anchor (\ref setParentAnchor).
+  
+  If the type is changed, the apparent pixel position on the plot is preserved. This means
+  the coordinates as retrieved with coords() and set with \ref setCoords may change in the process.
+  
+  This method sets the type for both X and Y directions. It is also possible to set different types
+  for X and Y, see \ref setTypeX, \ref setTypeY.
+*/
+void QCPItemPosition::setType(QCPItemPosition::PositionType type)
+{
+  setTypeX(type);
+  setTypeY(type);
+}
+
+/*!
+  This method sets the position type of the X coordinate to \a type.
+  
+  For a detailed description of what a position type is, see the documentation of \ref setType.
+  
+  \see setType, setTypeY
+*/
+void QCPItemPosition::setTypeX(QCPItemPosition::PositionType type)
+{
+  if (mPositionTypeX != type)
+  {
+    // if switching from or to coordinate type that isn't valid (e.g. because axes or axis rect
+    // were deleted), don't try to recover the pixelPoint() because it would output a qDebug warning.
+    bool retainPixelPosition = true;
+    if ((mPositionTypeX == ptPlotCoords || type == ptPlotCoords) && (!mKeyAxis || !mValueAxis))
+      retainPixelPosition = false;
+    if ((mPositionTypeX == ptAxisRectRatio || type == ptAxisRectRatio) && (!mAxisRect))
+      retainPixelPosition = false;
+    
+    QPointF pixel;
+    if (retainPixelPosition)
+      pixel = pixelPoint();
+    
+    mPositionTypeX = type;
+    
+    if (retainPixelPosition)
+      setPixelPoint(pixel);
+  }
+}
+
+/*!
+  This method sets the position type of the Y coordinate to \a type.
+  
+  For a detailed description of what a position type is, see the documentation of \ref setType.
+  
+  \see setType, setTypeX
+*/
+void QCPItemPosition::setTypeY(QCPItemPosition::PositionType type)
+{
+  if (mPositionTypeY != type)
+  {
+    // if switching from or to coordinate type that isn't valid (e.g. because axes or axis rect
+    // were deleted), don't try to recover the pixelPoint() because it would output a qDebug warning.
+    bool retainPixelPosition = true;
+    if ((mPositionTypeY == ptPlotCoords || type == ptPlotCoords) && (!mKeyAxis || !mValueAxis))
+      retainPixelPosition = false;
+    if ((mPositionTypeY == ptAxisRectRatio || type == ptAxisRectRatio) && (!mAxisRect))
+      retainPixelPosition = false;
+    
+    QPointF pixel;
+    if (retainPixelPosition)
+      pixel = pixelPoint();
+    
+    mPositionTypeY = type;
+    
+    if (retainPixelPosition)
+      setPixelPoint(pixel);
+  }
+}
+
+/*!
+  Sets the parent of this QCPItemPosition to \a parentAnchor. This means the position will now
+  follow any position changes of the anchor. The local coordinate system of positions with a parent
+  anchor always is absolute pixels, with (0, 0) being exactly on top of the parent anchor. (Hence
+  the type shouldn't be set to \ref ptPlotCoords for positions with parent anchors.)
+  
+  if \a keepPixelPosition is true, the current pixel position of the QCPItemPosition is preserved
+  during reparenting. If it's set to false, the coordinates are set to (0, 0), i.e. the position
+  will be exactly on top of the parent anchor.
+  
+  To remove this QCPItemPosition from any parent anchor, set \a parentAnchor to 0.
+  
+  If the QCPItemPosition previously had no parent and the type is \ref ptPlotCoords, the type is
+  set to \ref ptAbsolute, to keep the position in a valid state.
+  
+  This method sets the parent anchor for both X and Y directions. It is also possible to set
+  different parents for X and Y, see \ref setParentAnchorX, \ref setParentAnchorY.
+*/
+bool QCPItemPosition::setParentAnchor(QCPItemAnchor *parentAnchor, bool keepPixelPosition)
+{
+  bool successX = setParentAnchorX(parentAnchor, keepPixelPosition);
+  bool successY = setParentAnchorY(parentAnchor, keepPixelPosition);
+  return successX && successY;
+}
+
+/*!
+  This method sets the parent anchor of the X coordinate to \a parentAnchor.
+  
+  For a detailed description of what a parent anchor is, see the documentation of \ref setParentAnchor.
+  
+  \see setParentAnchor, setParentAnchorY
+*/
+bool QCPItemPosition::setParentAnchorX(QCPItemAnchor *parentAnchor, bool keepPixelPosition)
+{
+  // make sure self is not assigned as parent:
+  if (parentAnchor == this)
+  {
+    qDebug() << Q_FUNC_INFO << "can't set self as parent anchor" << reinterpret_cast<quintptr>(parentAnchor);
+    return false;
+  }
+  // make sure no recursive parent-child-relationships are created:
+  QCPItemAnchor *currentParent = parentAnchor;
+  while (currentParent)
+  {
+    if (QCPItemPosition *currentParentPos = currentParent->toQCPItemPosition())
+    {
+      // is a QCPItemPosition, might have further parent, so keep iterating
+      if (currentParentPos == this)
+      {
+        qDebug() << Q_FUNC_INFO << "can't create recursive parent-child-relationship" << reinterpret_cast<quintptr>(parentAnchor);
+        return false;
+      }
+      currentParent = currentParentPos->parentAnchorX();
+    } else
+    {
+      // is a QCPItemAnchor, can't have further parent. Now make sure the parent items aren't the
+      // same, to prevent a position being child of an anchor which itself depends on the position,
+      // because they're both on the same item:
+      if (currentParent->mParentItem == mParentItem)
+      {
+        qDebug() << Q_FUNC_INFO << "can't set parent to be an anchor which itself depends on this position" << reinterpret_cast<quintptr>(parentAnchor);
+        return false;
+      }
+      break;
+    }
+  }
+  
+  // if previously no parent set and PosType is still ptPlotCoords, set to ptAbsolute:
+  if (!mParentAnchorX && mPositionTypeX == ptPlotCoords)
+    setTypeX(ptAbsolute);
+  
+  // save pixel position:
+  QPointF pixelP;
+  if (keepPixelPosition)
+    pixelP = pixelPoint();
+  // unregister at current parent anchor:
+  if (mParentAnchorX)
+    mParentAnchorX->removeChildX(this);
+  // register at new parent anchor:
+  if (parentAnchor)
+    parentAnchor->addChildX(this);
+  mParentAnchorX = parentAnchor;
+  // restore pixel position under new parent:
+  if (keepPixelPosition)
+    setPixelPoint(pixelP);
+  else
+    setCoords(0, coords().y());
+  return true;
+}
+
+/*!
+  This method sets the parent anchor of the Y coordinate to \a parentAnchor.
+  
+  For a detailed description of what a parent anchor is, see the documentation of \ref setParentAnchor.
+  
+  \see setParentAnchor, setParentAnchorX
+*/
+bool QCPItemPosition::setParentAnchorY(QCPItemAnchor *parentAnchor, bool keepPixelPosition)
+{
+  // make sure self is not assigned as parent:
+  if (parentAnchor == this)
+  {
+    qDebug() << Q_FUNC_INFO << "can't set self as parent anchor" << reinterpret_cast<quintptr>(parentAnchor);
+    return false;
+  }
+  // make sure no recursive parent-child-relationships are created:
+  QCPItemAnchor *currentParent = parentAnchor;
+  while (currentParent)
+  {
+    if (QCPItemPosition *currentParentPos = currentParent->toQCPItemPosition())
+    {
+      // is a QCPItemPosition, might have further parent, so keep iterating
+      if (currentParentPos == this)
+      {
+        qDebug() << Q_FUNC_INFO << "can't create recursive parent-child-relationship" << reinterpret_cast<quintptr>(parentAnchor);
+        return false;
+      }
+      currentParent = currentParentPos->parentAnchorY();
+    } else
+    {
+      // is a QCPItemAnchor, can't have further parent. Now make sure the parent items aren't the
+      // same, to prevent a position being child of an anchor which itself depends on the position,
+      // because they're both on the same item:
+      if (currentParent->mParentItem == mParentItem)
+      {
+        qDebug() << Q_FUNC_INFO << "can't set parent to be an anchor which itself depends on this position" << reinterpret_cast<quintptr>(parentAnchor);
+        return false;
+      }
+      break;
+    }
+  }
+  
+  // if previously no parent set and PosType is still ptPlotCoords, set to ptAbsolute:
+  if (!mParentAnchorY && mPositionTypeY == ptPlotCoords)
+    setTypeY(ptAbsolute);
+  
+  // save pixel position:
+  QPointF pixelP;
+  if (keepPixelPosition)
+    pixelP = pixelPoint();
+  // unregister at current parent anchor:
+  if (mParentAnchorY)
+    mParentAnchorY->removeChildY(this);
+  // register at new parent anchor:
+  if (parentAnchor)
+    parentAnchor->addChildY(this);
+  mParentAnchorY = parentAnchor;
+  // restore pixel position under new parent:
+  if (keepPixelPosition)
+    setPixelPoint(pixelP);
+  else
+    setCoords(coords().x(), 0);
+  return true;
+}
+
+/*!
+  Sets the coordinates of this QCPItemPosition. What the coordinates mean, is defined by the type
+  (\ref setType, \ref setTypeX, \ref setTypeY).
+  
+  For example, if the type is \ref ptAbsolute, \a key and \a value mean the x and y pixel position
+  on the QCustomPlot surface. In that case the origin (0, 0) is in the top left corner of the
+  QCustomPlot viewport. If the type is \ref ptPlotCoords, \a key and \a value mean a point in the
+  plot coordinate system defined by the axes set by \ref setAxes. By default those are the
+  QCustomPlot's xAxis and yAxis. See the documentation of \ref setType for other available
+  coordinate types and their meaning.
+  
+  If different types were configured for X and Y (\ref setTypeX, \ref setTypeY), \a key and \a
+  value must also be provided in the different coordinate systems. Here, the X type refers to \a
+  key, and the Y type refers to \a value.
+
+  \see setPixelPoint
+*/
+void QCPItemPosition::setCoords(double key, double value)
+{
+  mKey = key;
+  mValue = value;
+}
+
+/*! \overload
+
+  Sets the coordinates as a QPointF \a pos where pos.x has the meaning of \a key and pos.y the
+  meaning of \a value of the \ref setCoords(double key, double value) method.
+*/
+void QCPItemPosition::setCoords(const QPointF &pos)
+{
+  setCoords(pos.x(), pos.y());
+}
+
+/*!
+  Returns the final absolute pixel position of the QCPItemPosition on the QCustomPlot surface. It
+  includes all effects of type (\ref setType) and possible parent anchors (\ref setParentAnchor).
+
+  \see setPixelPoint
+*/
+QPointF QCPItemPosition::pixelPoint() const
+{
+  QPointF result;
+  
+  // determine X:
+  switch (mPositionTypeX)
+  {
+    case ptAbsolute:
+    {
+      result.rx() = mKey;
+      if (mParentAnchorX)
+        result.rx() += mParentAnchorX->pixelPoint().x();
+      break;
+    }
+    case ptViewportRatio:
+    {
+      result.rx() = mKey*mParentPlot->viewport().width();
+      if (mParentAnchorX)
+        result.rx() += mParentAnchorX->pixelPoint().x();
+      else
+        result.rx() += mParentPlot->viewport().left();
+      break;
+    }
+    case ptAxisRectRatio:
+    {
+      if (mAxisRect)
+      {
+        result.rx() = mKey*mAxisRect.data()->width();
+        if (mParentAnchorX)
+          result.rx() += mParentAnchorX->pixelPoint().x();
+        else
+          result.rx() += mAxisRect.data()->left();
+      } else
+        qDebug() << Q_FUNC_INFO << "Item position type x is ptAxisRectRatio, but no axis rect was defined";
+      break;
+    }
+    case ptPlotCoords:
+    {
+      if (mKeyAxis && mKeyAxis.data()->orientation() == Qt::Horizontal)
+        result.rx() = mKeyAxis.data()->coordToPixel(mKey);
+      else if (mValueAxis && mValueAxis.data()->orientation() == Qt::Horizontal)
+        result.rx() = mValueAxis.data()->coordToPixel(mValue);
+      else
+        qDebug() << Q_FUNC_INFO << "Item position type x is ptPlotCoords, but no axes were defined";
+      break;
+    }
+  }
+  
+  // determine Y:
+  switch (mPositionTypeY)
+  {
+    case ptAbsolute:
+    {
+      result.ry() = mValue;
+      if (mParentAnchorY)
+        result.ry() += mParentAnchorY->pixelPoint().y();
+      break;
+    }
+    case ptViewportRatio:
+    {
+      result.ry() = mValue*mParentPlot->viewport().height();
+      if (mParentAnchorY)
+        result.ry() += mParentAnchorY->pixelPoint().y();
+      else
+        result.ry() += mParentPlot->viewport().top();
+      break;
+    }
+    case ptAxisRectRatio:
+    {
+      if (mAxisRect)
+      {
+        result.ry() = mValue*mAxisRect.data()->height();
+        if (mParentAnchorY)
+          result.ry() += mParentAnchorY->pixelPoint().y();
+        else
+          result.ry() += mAxisRect.data()->top();
+      } else
+        qDebug() << Q_FUNC_INFO << "Item position type y is ptAxisRectRatio, but no axis rect was defined";
+      break;
+    }
+    case ptPlotCoords:
+    {
+      if (mKeyAxis && mKeyAxis.data()->orientation() == Qt::Vertical)
+        result.ry() = mKeyAxis.data()->coordToPixel(mKey);
+      else if (mValueAxis && mValueAxis.data()->orientation() == Qt::Vertical)
+        result.ry() = mValueAxis.data()->coordToPixel(mValue);
+      else
+        qDebug() << Q_FUNC_INFO << "Item position type y is ptPlotCoords, but no axes were defined";
+      break;
+    }
+  }
+  
+  return result;
+}
+
+/*!
+  When \ref setType is \ref ptPlotCoords, this function may be used to specify the axes the
+  coordinates set with \ref setCoords relate to. By default they are set to the initial xAxis and
+  yAxis of the QCustomPlot.
+*/
+void QCPItemPosition::setAxes(QCPAxis *keyAxis, QCPAxis *valueAxis)
+{
+  mKeyAxis = keyAxis;
+  mValueAxis = valueAxis;
+}
+
+/*!
+  When \ref setType is \ref ptAxisRectRatio, this function may be used to specify the axis rect the
+  coordinates set with \ref setCoords relate to. By default this is set to the main axis rect of
+  the QCustomPlot.
+*/
+void QCPItemPosition::setAxisRect(QCPAxisRect *axisRect)
+{
+  mAxisRect = axisRect;
+}
+
+/*!
+  Sets the apparent pixel position. This works no matter what type (\ref setType) this
+  QCPItemPosition is or what parent-child situation it is in, as coordinates are transformed
+  appropriately, to make the position finally appear at the specified pixel values.
+
+  Only if the type is \ref ptAbsolute and no parent anchor is set, this function's effect is
+  identical to that of \ref setCoords.
+
+  \see pixelPoint, setCoords
+*/
+void QCPItemPosition::setPixelPoint(const QPointF &pixelPoint)
+{
+  double x = pixelPoint.x();
+  double y = pixelPoint.y();
+  
+  switch (mPositionTypeX)
+  {
+    case ptAbsolute:
+    {
+      if (mParentAnchorX)
+        x -= mParentAnchorX->pixelPoint().x();
+      break;
+    }
+    case ptViewportRatio:
+    {
+      if (mParentAnchorX)
+        x -= mParentAnchorX->pixelPoint().x();
+      else
+        x -= mParentPlot->viewport().left();
+      x /= (double)mParentPlot->viewport().width();
+      break;
+    }
+    case ptAxisRectRatio:
+    {
+      if (mAxisRect)
+      {
+        if (mParentAnchorX)
+          x -= mParentAnchorX->pixelPoint().x();
+        else
+          x -= mAxisRect.data()->left();
+        x /= (double)mAxisRect.data()->width();
+      } else
+        qDebug() << Q_FUNC_INFO << "Item position type x is ptAxisRectRatio, but no axis rect was defined";
+      break;
+    }
+    case ptPlotCoords:
+    {
+      if (mKeyAxis && mKeyAxis.data()->orientation() == Qt::Horizontal)
+        x = mKeyAxis.data()->pixelToCoord(x);
+      else if (mValueAxis && mValueAxis.data()->orientation() == Qt::Horizontal)
+        y = mValueAxis.data()->pixelToCoord(x);
+      else
+        qDebug() << Q_FUNC_INFO << "Item position type x is ptPlotCoords, but no axes were defined";
+      break;
+    }
+  }
+  
+  switch (mPositionTypeY)
+  {
+    case ptAbsolute:
+    {
+      if (mParentAnchorY)
+        y -= mParentAnchorY->pixelPoint().y();
+      break;
+    }
+    case ptViewportRatio:
+    {
+      if (mParentAnchorY)
+        y -= mParentAnchorY->pixelPoint().y();
+      else
+        y -= mParentPlot->viewport().top();
+      y /= (double)mParentPlot->viewport().height();
+      break;
+    }
+    case ptAxisRectRatio:
+    {
+      if (mAxisRect)
+      {
+        if (mParentAnchorY)
+          y -= mParentAnchorY->pixelPoint().y();
+        else
+          y -= mAxisRect.data()->top();
+        y /= (double)mAxisRect.data()->height();
+      } else
+        qDebug() << Q_FUNC_INFO << "Item position type y is ptAxisRectRatio, but no axis rect was defined";
+      break;
+    }
+    case ptPlotCoords:
+    {
+      if (mKeyAxis && mKeyAxis.data()->orientation() == Qt::Vertical)
+        x = mKeyAxis.data()->pixelToCoord(y);
+      else if (mValueAxis && mValueAxis.data()->orientation() == Qt::Vertical)
+        y = mValueAxis.data()->pixelToCoord(y);
+      else
+        qDebug() << Q_FUNC_INFO << "Item position type y is ptPlotCoords, but no axes were defined";
+      break;
+    }
+  }
+  
+  setCoords(x, y);
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPAbstractItem
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPAbstractItem
+  \brief The abstract base class for all items in a plot.
+  
+  In QCustomPlot, items are supplemental graphical elements that are neither plottables
+  (QCPAbstractPlottable) nor axes (QCPAxis). While plottables are always tied to two axes and thus
+  plot coordinates, items can also be placed in absolute coordinates independent of any axes. Each
+  specific item has at least one QCPItemPosition member which controls the positioning. Some items
+  are defined by more than one coordinate and thus have two or more QCPItemPosition members (For
+  example, QCPItemRect has \a topLeft and \a bottomRight).
+  
+  This abstract base class defines a very basic interface like visibility and clipping. Since this
+  class is abstract, it can't be instantiated. Use one of the subclasses or create a subclass
+  yourself to create new items.
+  
+  The built-in items are:
+  <table>
+  <tr><td>QCPItemLine</td><td>A line defined by a start and an end point. May have different ending styles on each side (e.g. arrows).</td></tr>
+  <tr><td>QCPItemStraightLine</td><td>A straight line defined by a start and a direction point. Unlike QCPItemLine, the straight line is infinitely long and has no endings.</td></tr>
+  <tr><td>QCPItemCurve</td><td>A curve defined by start, end and two intermediate control points. May have different ending styles on each side (e.g. arrows).</td></tr>
+  <tr><td>QCPItemRect</td><td>A rectangle</td></tr>
+  <tr><td>QCPItemEllipse</td><td>An ellipse</td></tr>
+  <tr><td>QCPItemPixmap</td><td>An arbitrary pixmap</td></tr>
+  <tr><td>QCPItemText</td><td>A text label</td></tr>
+  <tr><td>QCPItemBracket</td><td>A bracket which may be used to reference/highlight certain parts in the plot.</td></tr>
+  <tr><td>QCPItemTracer</td><td>An item that can be attached to a QCPGraph and sticks to its data points, given a key coordinate.</td></tr>
+  </table>
+  
+  \section items-clipping Clipping
+
+  Items are by default clipped to the main axis rect (they are only visible inside the axis rect).
+  To make an item visible outside that axis rect, disable clipping via \ref setClipToAxisRect
+  "setClipToAxisRect(false)".
+
+  On the other hand if you want the item to be clipped to a different axis rect, specify it via
+  \ref setClipAxisRect. This clipAxisRect property of an item is only used for clipping behaviour, and
+  in principle is independent of the coordinate axes the item might be tied to via its position
+  members (\ref QCPItemPosition::setAxes). However, it is common that the axis rect for clipping
+  also contains the axes used for the item positions.
+  
+  \section items-using Using items
+  
+  First you instantiate the item you want to use and add it to the plot:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpitemline-creation-1
+  by default, the positions of the item are bound to the x- and y-Axis of the plot. So we can just
+  set the plot coordinates where the line should start/end:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpitemline-creation-2
+  If we don't want the line to be positioned in plot coordinates but a different coordinate system,
+  e.g. absolute pixel positions on the QCustomPlot surface, we need to change the position type like this:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpitemline-creation-3
+  Then we can set the coordinates, this time in pixels:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpitemline-creation-4
+  and make the line visible on the entire QCustomPlot, by disabling clipping to the axis rect:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpitemline-creation-5
+  
+  For more advanced plots, it is even possible to set different types and parent anchors per X/Y
+  coordinate of an item position, using for example \ref QCPItemPosition::setTypeX or \ref
+  QCPItemPosition::setParentAnchorX. For details, see the documentation of \ref QCPItemPosition.
+  
+  \section items-subclassing Creating own items
+  
+  To create an own item, you implement a subclass of QCPAbstractItem. These are the pure
+  virtual functions, you must implement:
+  \li \ref selectTest
+  \li \ref draw
+  
+  See the documentation of those functions for what they need to do.
+  
+  \subsection items-positioning Allowing the item to be positioned
+  
+  As mentioned, item positions are represented by QCPItemPosition members. Let's assume the new item shall
+  have only one point as its position (as opposed to two like a rect or multiple like a polygon). You then add
+  a public member of type QCPItemPosition like so:
+  
+  \code QCPItemPosition * const myPosition;\endcode
+  
+  the const makes sure the pointer itself can't be modified from the user of your new item (the QCPItemPosition
+  instance it points to, can be modified, of course).
+  The initialization of this pointer is made easy with the \ref createPosition function. Just assign
+  the return value of this function to each QCPItemPosition in the constructor of your item. \ref createPosition
+  takes a string which is the name of the position, typically this is identical to the variable name.
+  For example, the constructor of QCPItemExample could look like this:
+  
+  \code
+  QCPItemExample::QCPItemExample(QCustomPlot *parentPlot) :
+    QCPAbstractItem(parentPlot),
+    myPosition(createPosition("myPosition"))
+  {
+    // other constructor code
+  }
+  \endcode
+  
+  \subsection items-drawing The draw function
+  
+  To give your item a visual representation, reimplement the \ref draw function and use the passed
+  QCPPainter to draw the item. You can retrieve the item position in pixel coordinates from the
+  position member(s) via \ref QCPItemPosition::pixelPoint.
+
+  To optimize performance you should calculate a bounding rect first (don't forget to take the pen
+  width into account), check whether it intersects the \ref clipRect, and only draw the item at all
+  if this is the case.
+  
+  \subsection items-selection The selectTest function
+  
+  Your implementation of the \ref selectTest function may use the helpers \ref distSqrToLine and
+  \ref rectSelectTest. With these, the implementation of the selection test becomes significantly
+  simpler for most items. See the documentation of \ref selectTest for what the function parameters
+  mean and what the function should return.
+  
+  \subsection anchors Providing anchors
+  
+  Providing anchors (QCPItemAnchor) starts off like adding a position. First you create a public
+  member, e.g.
+  
+  \code QCPItemAnchor * const bottom;\endcode
+
+  and create it in the constructor with the \ref createAnchor function, assigning it a name and an
+  anchor id (an integer enumerating all anchors on the item, you may create an own enum for this).
+  Since anchors can be placed anywhere, relative to the item's position(s), your item needs to
+  provide the position of every anchor with the reimplementation of the \ref anchorPixelPoint(int
+  anchorId) function.
+  
+  In essence the QCPItemAnchor is merely an intermediary that itself asks your item for the pixel
+  position when anything attached to the anchor needs to know the coordinates.
+*/
+
+/* start of documentation of inline functions */
+
+/*! \fn QList<QCPItemPosition*> QCPAbstractItem::positions() const
+  
+  Returns all positions of the item in a list.
+  
+  \see anchors, position
+*/
+
+/*! \fn QList<QCPItemAnchor*> QCPAbstractItem::anchors() const
+  
+  Returns all anchors of the item in a list. Note that since a position (QCPItemPosition) is always
+  also an anchor, the list will also contain the positions of this item.
+  
+  \see positions, anchor
+*/
+
+/* end of documentation of inline functions */
+/* start documentation of pure virtual functions */
+
+/*! \fn void QCPAbstractItem::draw(QCPPainter *painter) = 0
+  \internal
+  
+  Draws this item with the provided \a painter.
+  
+  The cliprect of the provided painter is set to the rect returned by \ref clipRect before this
+  function is called. The clipRect depends on the clipping settings defined by \ref
+  setClipToAxisRect and \ref setClipAxisRect.
+*/
+
+/* end documentation of pure virtual functions */
+/* start documentation of signals */
+
+/*! \fn void QCPAbstractItem::selectionChanged(bool selected)
+  This signal is emitted when the selection state of this item has changed, either by user interaction
+  or by a direct call to \ref setSelected.
+*/
+
+/* end documentation of signals */
+
+/*!
+  Base class constructor which initializes base class members.
+*/
+QCPAbstractItem::QCPAbstractItem(QCustomPlot *parentPlot) :
+  QCPLayerable(parentPlot),
+  mClipToAxisRect(false),
+  mSelectable(true),
+  mSelected(false)
+{
+  QList<QCPAxisRect*> rects = parentPlot->axisRects();
+  if (rects.size() > 0)
+  {
+    setClipToAxisRect(true);
+    setClipAxisRect(rects.first());
+  }
+}
+
+QCPAbstractItem::~QCPAbstractItem()
+{
+  // don't delete mPositions because every position is also an anchor and thus in mAnchors
+  qDeleteAll(mAnchors);
+}
+
+/* can't make this a header inline function, because QPointer breaks with forward declared types, see QTBUG-29588 */
+QCPAxisRect *QCPAbstractItem::clipAxisRect() const
+{
+  return mClipAxisRect.data();
+}
+
+/*!
+  Sets whether the item shall be clipped to an axis rect or whether it shall be visible on the
+  entire QCustomPlot. The axis rect can be set with \ref setClipAxisRect.
+  
+  \see setClipAxisRect
+*/
+void QCPAbstractItem::setClipToAxisRect(bool clip)
+{
+  mClipToAxisRect = clip;
+  if (mClipToAxisRect)
+    setParentLayerable(mClipAxisRect.data());
+}
+
+/*!
+  Sets the clip axis rect. It defines the rect that will be used to clip the item when \ref
+  setClipToAxisRect is set to true.
+  
+  \see setClipToAxisRect
+*/
+void QCPAbstractItem::setClipAxisRect(QCPAxisRect *rect)
+{
+  mClipAxisRect = rect;
+  if (mClipToAxisRect)
+    setParentLayerable(mClipAxisRect.data());
+}
+
+/*!
+  Sets whether the user can (de-)select this item by clicking on the QCustomPlot surface.
+  (When \ref QCustomPlot::setInteractions contains QCustomPlot::iSelectItems.)
+  
+  However, even when \a selectable was set to false, it is possible to set the selection manually,
+  by calling \ref setSelected.
+  
+  \see QCustomPlot::setInteractions, setSelected
+*/
+void QCPAbstractItem::setSelectable(bool selectable)
+{
+  if (mSelectable != selectable)
+  {
+    mSelectable = selectable;
+    emit selectableChanged(mSelectable);
+  }
+}
+
+/*!
+  Sets whether this item is selected or not. When selected, it might use a different visual
+  appearance (e.g. pen and brush), this depends on the specific item though.
+
+  The entire selection mechanism for items is handled automatically when \ref
+  QCustomPlot::setInteractions contains QCustomPlot::iSelectItems. You only need to call this
+  function when you wish to change the selection state manually.
+  
+  This function can change the selection state even when \ref setSelectable was set to false.
+  
+  emits the \ref selectionChanged signal when \a selected is different from the previous selection state.
+  
+  \see setSelectable, selectTest
+*/
+void QCPAbstractItem::setSelected(bool selected)
+{
+  if (mSelected != selected)
+  {
+    mSelected = selected;
+    emit selectionChanged(mSelected);
+  }
+}
+
+/*!
+  Returns the QCPItemPosition with the specified \a name. If this item doesn't have a position by
+  that name, returns 0.
+  
+  This function provides an alternative way to access item positions. Normally, you access
+  positions direcly by their member pointers (which typically have the same variable name as \a
+  name).
+  
+  \see positions, anchor
+*/
+QCPItemPosition *QCPAbstractItem::position(const QString &name) const
+{
+  for (int i=0; i<mPositions.size(); ++i)
+  {
+    if (mPositions.at(i)->name() == name)
+      return mPositions.at(i);
+  }
+  qDebug() << Q_FUNC_INFO << "position with name not found:" << name;
+  return 0;
+}
+
+/*!
+  Returns the QCPItemAnchor with the specified \a name. If this item doesn't have an anchor by
+  that name, returns 0.
+  
+  This function provides an alternative way to access item anchors. Normally, you access
+  anchors direcly by their member pointers (which typically have the same variable name as \a
+  name).
+  
+  \see anchors, position
+*/
+QCPItemAnchor *QCPAbstractItem::anchor(const QString &name) const
+{
+  for (int i=0; i<mAnchors.size(); ++i)
+  {
+    if (mAnchors.at(i)->name() == name)
+      return mAnchors.at(i);
+  }
+  qDebug() << Q_FUNC_INFO << "anchor with name not found:" << name;
+  return 0;
+}
+
+/*!
+  Returns whether this item has an anchor with the specified \a name.
+  
+  Note that you can check for positions with this function, too. This is because every position is
+  also an anchor (QCPItemPosition inherits from QCPItemAnchor).
+  
+  \see anchor, position
+*/
+bool QCPAbstractItem::hasAnchor(const QString &name) const
+{
+  for (int i=0; i<mAnchors.size(); ++i)
+  {
+    if (mAnchors.at(i)->name() == name)
+      return true;
+  }
+  return false;
+}
+
+/*! \internal
+  
+  Returns the rect the visual representation of this item is clipped to. This depends on the
+  current setting of \ref setClipToAxisRect as well as the axis rect set with \ref setClipAxisRect.
+  
+  If the item is not clipped to an axis rect, the \ref QCustomPlot::viewport rect is returned.
+  
+  \see draw
+*/
+QRect QCPAbstractItem::clipRect() const
+{
+  if (mClipToAxisRect && mClipAxisRect)
+    return mClipAxisRect.data()->rect();
+  else
+    return mParentPlot->viewport();
+}
+
+/*! \internal
+
+  A convenience function to easily set the QPainter::Antialiased hint on the provided \a painter
+  before drawing item lines.
+
+  This is the antialiasing state the painter passed to the \ref draw method is in by default.
+  
+  This function takes into account the local setting of the antialiasing flag as well as the
+  overrides set with \ref QCustomPlot::setAntialiasedElements and \ref
+  QCustomPlot::setNotAntialiasedElements.
+  
+  \see setAntialiased
+*/
+void QCPAbstractItem::applyDefaultAntialiasingHint(QCPPainter *painter) const
+{
+  applyAntialiasingHint(painter, mAntialiased, QCP::aeItems);
+}
+
+/*! \internal
+
+  Finds the shortest squared distance of \a point to the line segment defined by \a start and \a
+  end.
+  
+  This function may be used to help with the implementation of the \ref selectTest function for
+  specific items.
+  
+  \note This function is identical to QCPAbstractPlottable::distSqrToLine
+  
+  \see rectSelectTest
+*/
+double QCPAbstractItem::distSqrToLine(const QPointF &start, const QPointF &end, const QPointF &point) const
+{
+  QVector2D a(start);
+  QVector2D b(end);
+  QVector2D p(point);
+  QVector2D v(b-a);
+  
+  double vLengthSqr = v.lengthSquared();
+  if (!qFuzzyIsNull(vLengthSqr))
+  {
+    double mu = QVector2D::dotProduct(p-a, v)/vLengthSqr;
+    if (mu < 0)
+      return (a-p).lengthSquared();
+    else if (mu > 1)
+      return (b-p).lengthSquared();
+    else
+      return ((a + mu*v)-p).lengthSquared();
+  } else
+    return (a-p).lengthSquared();
+}
+
+/*! \internal
+
+  A convenience function which returns the selectTest value for a specified \a rect and a specified
+  click position \a pos. \a filledRect defines whether a click inside the rect should also be
+  considered a hit or whether only the rect border is sensitive to hits.
+  
+  This function may be used to help with the implementation of the \ref selectTest function for
+  specific items.
+  
+  For example, if your item consists of four rects, call this function four times, once for each
+  rect, in your \ref selectTest reimplementation. Finally, return the minimum of all four returned
+  values.
+  
+  \see distSqrToLine
+*/
+double QCPAbstractItem::rectSelectTest(const QRectF &rect, const QPointF &pos, bool filledRect) const
+{
+  double result = -1;
+
+  // distance to border:
+  QList<QLineF> lines;
+  lines << QLineF(rect.topLeft(), rect.topRight()) << QLineF(rect.bottomLeft(), rect.bottomRight())
+        << QLineF(rect.topLeft(), rect.bottomLeft()) << QLineF(rect.topRight(), rect.bottomRight());
+  double minDistSqr = std::numeric_limits<double>::max();
+  for (int i=0; i<lines.size(); ++i)
+  {
+    double distSqr = distSqrToLine(lines.at(i).p1(), lines.at(i).p2(), pos);
+    if (distSqr < minDistSqr)
+      minDistSqr = distSqr;
+  }
+  result = qSqrt(minDistSqr);
+  
+  // filled rect, allow click inside to count as hit:
+  if (filledRect && result > mParentPlot->selectionTolerance()*0.99)
+  {
+    if (rect.contains(pos))
+      result = mParentPlot->selectionTolerance()*0.99;
+  }
+  return result;
+}
+
+/*! \internal
+
+  Returns the pixel position of the anchor with Id \a anchorId. This function must be reimplemented in
+  item subclasses if they want to provide anchors (QCPItemAnchor).
+  
+  For example, if the item has two anchors with id 0 and 1, this function takes one of these anchor
+  ids and returns the respective pixel points of the specified anchor.
+  
+  \see createAnchor
+*/
+QPointF QCPAbstractItem::anchorPixelPoint(int anchorId) const
+{
+  qDebug() << Q_FUNC_INFO << "called on item which shouldn't have any anchors (this method not reimplemented). anchorId" << anchorId;
+  return QPointF();
+}
+
+/*! \internal
+
+  Creates a QCPItemPosition, registers it with this item and returns a pointer to it. The specified
+  \a name must be a unique string that is usually identical to the variable name of the position
+  member (This is needed to provide the name-based \ref position access to positions).
+  
+  Don't delete positions created by this function manually, as the item will take care of it.
+  
+  Use this function in the constructor (initialization list) of the specific item subclass to
+  create each position member. Don't create QCPItemPositions with \b new yourself, because they
+  won't be registered with the item properly.
+  
+  \see createAnchor
+*/
+QCPItemPosition *QCPAbstractItem::createPosition(const QString &name)
+{
+  if (hasAnchor(name))
+    qDebug() << Q_FUNC_INFO << "anchor/position with name exists already:" << name;
+  QCPItemPosition *newPosition = new QCPItemPosition(mParentPlot, this, name);
+  mPositions.append(newPosition);
+  mAnchors.append(newPosition); // every position is also an anchor
+  newPosition->setAxes(mParentPlot->xAxis, mParentPlot->yAxis);
+  newPosition->setType(QCPItemPosition::ptPlotCoords);
+  if (mParentPlot->axisRect())
+    newPosition->setAxisRect(mParentPlot->axisRect());
+  newPosition->setCoords(0, 0);
+  return newPosition;
+}
+
+/*! \internal
+
+  Creates a QCPItemAnchor, registers it with this item and returns a pointer to it. The specified
+  \a name must be a unique string that is usually identical to the variable name of the anchor
+  member (This is needed to provide the name based \ref anchor access to anchors).
+  
+  The \a anchorId must be a number identifying the created anchor. It is recommended to create an
+  enum (e.g. "AnchorIndex") for this on each item that uses anchors. This id is used by the anchor
+  to identify itself when it calls QCPAbstractItem::anchorPixelPoint. That function then returns
+  the correct pixel coordinates for the passed anchor id.
+  
+  Don't delete anchors created by this function manually, as the item will take care of it.
+  
+  Use this function in the constructor (initialization list) of the specific item subclass to
+  create each anchor member. Don't create QCPItemAnchors with \b new yourself, because then they
+  won't be registered with the item properly.
+  
+  \see createPosition
+*/
+QCPItemAnchor *QCPAbstractItem::createAnchor(const QString &name, int anchorId)
+{
+  if (hasAnchor(name))
+    qDebug() << Q_FUNC_INFO << "anchor/position with name exists already:" << name;
+  QCPItemAnchor *newAnchor = new QCPItemAnchor(mParentPlot, this, name, anchorId);
+  mAnchors.append(newAnchor);
+  return newAnchor;
+}
+
+/* inherits documentation from base class */
+void QCPAbstractItem::selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)
+{
+  Q_UNUSED(event)
+  Q_UNUSED(details)
+  if (mSelectable)
+  {
+    bool selBefore = mSelected;
+    setSelected(additive ? !mSelected : true);
+    if (selectionStateChanged)
+      *selectionStateChanged = mSelected != selBefore;
+  }
+}
+
+/* inherits documentation from base class */
+void QCPAbstractItem::deselectEvent(bool *selectionStateChanged)
+{
+  if (mSelectable)
+  {
+    bool selBefore = mSelected;
+    setSelected(false);
+    if (selectionStateChanged)
+      *selectionStateChanged = mSelected != selBefore;
+  }
+}
+
+/* inherits documentation from base class */
+QCP::Interaction QCPAbstractItem::selectionCategory() const
+{
+  return QCP::iSelectItems;
+}
+
+
+/*! \file */
+
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCustomPlot
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCustomPlot
+  
+  \brief The central class of the library. This is the QWidget which displays the plot and
+  interacts with the user.
+  
+  For tutorials on how to use QCustomPlot, see the website\n
+  http://www.qcustomplot.com/
+*/
+
+/* start of documentation of inline functions */
+
+/*! \fn QRect QCustomPlot::viewport() const
+  
+  Returns the viewport rect of this QCustomPlot instance. The viewport is the area the plot is
+  drawn in, all mechanisms, e.g. margin caluclation take the viewport to be the outer border of the
+  plot. The viewport normally is the rect() of the QCustomPlot widget, i.e. a rect with top left
+  (0, 0) and size of the QCustomPlot widget.
+  
+  Don't confuse the viewport with the axis rect (QCustomPlot::axisRect). An axis rect is typically
+  an area enclosed by four axes, where the graphs/plottables are drawn in. The viewport is larger
+  and contains also the axes themselves, their tick numbers, their labels, the plot title etc.
+  
+  Only when saving to a file (see \ref savePng, \ref savePdf etc.) the viewport is temporarily
+  modified to allow saving plots with sizes independent of the current widget size.
+*/
+
+/*! \fn QCPLayoutGrid *QCustomPlot::plotLayout() const
+  
+  Returns the top level layout of this QCustomPlot instance. It is a \ref QCPLayoutGrid, initially containing just
+  one cell with the main QCPAxisRect inside.
+*/
+
+/* end of documentation of inline functions */
+/* start of documentation of signals */
+
+/*! \fn void QCustomPlot::mouseDoubleClick(QMouseEvent *event)
+
+  This signal is emitted when the QCustomPlot receives a mouse double click event.
+*/
+
+/*! \fn void QCustomPlot::mousePress(QMouseEvent *event)
+
+  This signal is emitted when the QCustomPlot receives a mouse press event.
+  
+  It is emitted before QCustomPlot handles any other mechanism like range dragging. So a slot
+  connected to this signal can still influence the behaviour e.g. with \ref QCPAxisRect::setRangeDrag or \ref
+  QCPAxisRect::setRangeDragAxes.
+*/
+
+/*! \fn void QCustomPlot::mouseMove(QMouseEvent *event)
+
+  This signal is emitted when the QCustomPlot receives a mouse move event.
+  
+  It is emitted before QCustomPlot handles any other mechanism like range dragging. So a slot
+  connected to this signal can still influence the behaviour e.g. with \ref QCPAxisRect::setRangeDrag or \ref
+  QCPAxisRect::setRangeDragAxes.
+  
+  \warning It is discouraged to change the drag-axes with \ref QCPAxisRect::setRangeDragAxes here,
+  because the dragging starting point was saved the moment the mouse was pressed. Thus it only has
+  a meaning for the range drag axes that were set at that moment. If you want to change the drag
+  axes, consider doing this in the \ref mousePress signal instead.
+*/
+
+/*! \fn void QCustomPlot::mouseRelease(QMouseEvent *event)
+
+  This signal is emitted when the QCustomPlot receives a mouse release event.
+  
+  It is emitted before QCustomPlot handles any other mechanisms like object selection. So a
+  slot connected to this signal can still influence the behaviour e.g. with \ref setInteractions or
+  \ref QCPAbstractPlottable::setSelectable.
+*/
+
+/*! \fn void QCustomPlot::mouseWheel(QMouseEvent *event)
+
+  This signal is emitted when the QCustomPlot receives a mouse wheel event.
+  
+  It is emitted before QCustomPlot handles any other mechanisms like range zooming. So a slot
+  connected to this signal can still influence the behaviour e.g. with \ref QCPAxisRect::setRangeZoom, \ref
+  QCPAxisRect::setRangeZoomAxes or \ref QCPAxisRect::setRangeZoomFactor.
+*/
+
+/*! \fn void QCustomPlot::plottableClick(QCPAbstractPlottable *plottable, QMouseEvent *event)
+  
+  This signal is emitted when a plottable is clicked.
+
+  \a event is the mouse event that caused the click and \a plottable is the plottable that received
+  the click.
+  
+  \see plottableDoubleClick
+*/
+
+/*! \fn void QCustomPlot::plottableDoubleClick(QCPAbstractPlottable *plottable, QMouseEvent *event)
+  
+  This signal is emitted when a plottable is double clicked.
+  
+  \a event is the mouse event that caused the click and \a plottable is the plottable that received
+  the click.
+  
+  \see plottableClick
+*/
+
+/*! \fn void QCustomPlot::itemClick(QCPAbstractItem *item, QMouseEvent *event)
+  
+  This signal is emitted when an item is clicked.
+
+  \a event is the mouse event that caused the click and \a item is the item that received the
+  click.
+  
+  \see itemDoubleClick
+*/
+
+/*! \fn void QCustomPlot::itemDoubleClick(QCPAbstractItem *item, QMouseEvent *event)
+  
+  This signal is emitted when an item is double clicked.
+  
+  \a event is the mouse event that caused the click and \a item is the item that received the
+  click.
+  
+  \see itemClick
+*/
+
+/*! \fn void QCustomPlot::axisClick(QCPAxis *axis, QCPAxis::SelectablePart part, QMouseEvent *event)
+  
+  This signal is emitted when an axis is clicked.
+  
+  \a event is the mouse event that caused the click, \a axis is the axis that received the click and
+  \a part indicates the part of the axis that was clicked.
+  
+  \see axisDoubleClick
+*/
+
+/*! \fn void QCustomPlot::axisDoubleClick(QCPAxis *axis, QCPAxis::SelectablePart part, QMouseEvent *event)
+
+  This signal is emitted when an axis is double clicked.
+  
+  \a event is the mouse event that caused the click, \a axis is the axis that received the click and
+  \a part indicates the part of the axis that was clicked.
+  
+  \see axisClick
+*/
+
+/*! \fn void QCustomPlot::legendClick(QCPLegend *legend, QCPAbstractLegendItem *item, QMouseEvent *event)
+
+  This signal is emitted when a legend (item) is clicked.
+  
+  \a event is the mouse event that caused the click, \a legend is the legend that received the
+  click and \a item is the legend item that received the click. If only the legend and no item is
+  clicked, \a item is 0. This happens for a click inside the legend padding or the space between
+  two items.
+  
+  \see legendDoubleClick
+*/
+
+/*! \fn void QCustomPlot::legendDoubleClick(QCPLegend *legend,  QCPAbstractLegendItem *item, QMouseEvent *event)
+
+  This signal is emitted when a legend (item) is double clicked.
+  
+  \a event is the mouse event that caused the click, \a legend is the legend that received the
+  click and \a item is the legend item that received the click. If only the legend and no item is
+  clicked, \a item is 0. This happens for a click inside the legend padding or the space between
+  two items.
+  
+  \see legendClick
+*/
+
+/*! \fn void QCustomPlot:: titleClick(QMouseEvent *event, QCPPlotTitle *title)
+
+  This signal is emitted when a plot title is clicked.
+  
+  \a event is the mouse event that caused the click and \a title is the plot title that received
+  the click.
+  
+  \see titleDoubleClick
+*/
+
+/*! \fn void QCustomPlot::titleDoubleClick(QMouseEvent *event, QCPPlotTitle *title)
+
+  This signal is emitted when a plot title is double clicked.
+  
+  \a event is the mouse event that caused the click and \a title is the plot title that received
+  the click.
+  
+  \see titleClick
+*/
+
+/*! \fn void QCustomPlot::selectionChangedByUser()
+  
+  This signal is emitted after the user has changed the selection in the QCustomPlot, e.g. by
+  clicking. It is not emitted when the selection state of an object has changed programmatically by
+  a direct call to setSelected() on an object or by calling \ref deselectAll.
+  
+  In addition to this signal, selectable objects also provide individual signals, for example
+  QCPAxis::selectionChanged or QCPAbstractPlottable::selectionChanged. Note that those signals are
+  emitted even if the selection state is changed programmatically.
+  
+  See the documentation of \ref setInteractions for details about the selection mechanism.
+  
+  \see selectedPlottables, selectedGraphs, selectedItems, selectedAxes, selectedLegends
+*/
+
+/*! \fn void QCustomPlot::beforeReplot()
+  
+  This signal is emitted immediately before a replot takes place (caused by a call to the slot \ref
+  replot).
+  
+  It is safe to mutually connect the replot slot with this signal on two QCustomPlots to make them
+  replot synchronously, it won't cause an infinite recursion.
+  
+  \see replot, afterReplot
+*/
+
+/*! \fn void QCustomPlot::afterReplot()
+  
+  This signal is emitted immediately after a replot has taken place (caused by a call to the slot \ref
+  replot).
+  
+  It is safe to mutually connect the replot slot with this signal on two QCustomPlots to make them
+  replot synchronously, it won't cause an infinite recursion.
+  
+  \see replot, beforeReplot
+*/
+
+/* end of documentation of signals */
+/* start of documentation of public members */
+
+/*! \var QCPAxis *QCustomPlot::xAxis
+
+  A pointer to the primary x Axis (bottom) of the main axis rect of the plot.
+  
+  QCustomPlot offers convenient pointers to the axes (\ref xAxis, \ref yAxis, \ref xAxis2, \ref
+  yAxis2) and the \ref legend. They make it very easy working with plots that only have a single
+  axis rect and at most one axis at each axis rect side. If you use \link thelayoutsystem the
+  layout system\endlink to add multiple axis rects or multiple axes to one side, use the \ref
+  QCPAxisRect::axis interface to access the new axes. If one of the four default axes or the
+  default legend is removed due to manipulation of the layout system (e.g. by removing the main
+  axis rect), the corresponding pointers become 0.
+*/
+
+/*! \var QCPAxis *QCustomPlot::yAxis
+
+  A pointer to the primary y Axis (left) of the main axis rect of the plot.
+  
+  QCustomPlot offers convenient pointers to the axes (\ref xAxis, \ref yAxis, \ref xAxis2, \ref
+  yAxis2) and the \ref legend. They make it very easy working with plots that only have a single
+  axis rect and at most one axis at each axis rect side. If you use \link thelayoutsystem the
+  layout system\endlink to add multiple axis rects or multiple axes to one side, use the \ref
+  QCPAxisRect::axis interface to access the new axes. If one of the four default axes or the
+  default legend is removed due to manipulation of the layout system (e.g. by removing the main
+  axis rect), the corresponding pointers become 0.
+*/
+
+/*! \var QCPAxis *QCustomPlot::xAxis2
+
+  A pointer to the secondary x Axis (top) of the main axis rect of the plot. Secondary axes are
+  invisible by default. Use QCPAxis::setVisible to change this (or use \ref
+  QCPAxisRect::setupFullAxesBox).
+  
+  QCustomPlot offers convenient pointers to the axes (\ref xAxis, \ref yAxis, \ref xAxis2, \ref
+  yAxis2) and the \ref legend. They make it very easy working with plots that only have a single
+  axis rect and at most one axis at each axis rect side. If you use \link thelayoutsystem the
+  layout system\endlink to add multiple axis rects or multiple axes to one side, use the \ref
+  QCPAxisRect::axis interface to access the new axes. If one of the four default axes or the
+  default legend is removed due to manipulation of the layout system (e.g. by removing the main
+  axis rect), the corresponding pointers become 0.
+*/
+
+/*! \var QCPAxis *QCustomPlot::yAxis2
+
+  A pointer to the secondary y Axis (right) of the main axis rect of the plot. Secondary axes are
+  invisible by default. Use QCPAxis::setVisible to change this (or use \ref
+  QCPAxisRect::setupFullAxesBox).
+  
+  QCustomPlot offers convenient pointers to the axes (\ref xAxis, \ref yAxis, \ref xAxis2, \ref
+  yAxis2) and the \ref legend. They make it very easy working with plots that only have a single
+  axis rect and at most one axis at each axis rect side. If you use \link thelayoutsystem the
+  layout system\endlink to add multiple axis rects or multiple axes to one side, use the \ref
+  QCPAxisRect::axis interface to access the new axes. If one of the four default axes or the
+  default legend is removed due to manipulation of the layout system (e.g. by removing the main
+  axis rect), the corresponding pointers become 0.
+*/
+
+/*! \var QCPLegend *QCustomPlot::legend
+
+  A pointer to the default legend of the main axis rect. The legend is invisible by default. Use
+  QCPLegend::setVisible to change this.
+  
+  QCustomPlot offers convenient pointers to the axes (\ref xAxis, \ref yAxis, \ref xAxis2, \ref
+  yAxis2) and the \ref legend. They make it very easy working with plots that only have a single
+  axis rect and at most one axis at each axis rect side. If you use \link thelayoutsystem the
+  layout system\endlink to add multiple legends to the plot, use the layout system interface to
+  access the new legend. For example, legends can be placed inside an axis rect's \ref
+  QCPAxisRect::insetLayout "inset layout", and must then also be accessed via the inset layout. If
+  the default legend is removed due to manipulation of the layout system (e.g. by removing the main
+  axis rect), the corresponding pointer becomes 0.
+*/
+
+/* end of documentation of public members */
+
+/*!
+  Constructs a QCustomPlot and sets reasonable default values.
+*/
+QCustomPlot::QCustomPlot(QWidget *parent) :
+  QWidget(parent),
+  xAxis(0),
+  yAxis(0),
+  xAxis2(0),
+  yAxis2(0),
+  legend(0),
+  mPlotLayout(0),
+  mAutoAddPlottableToLegend(true),
+  mAntialiasedElements(QCP::aeNone),
+  mNotAntialiasedElements(QCP::aeNone),
+  mInteractions(0),
+  mSelectionTolerance(8),
+  mNoAntialiasingOnDrag(false),
+  mBackgroundBrush(Qt::white, Qt::SolidPattern),
+  mBackgroundScaled(true),
+  mBackgroundScaledMode(Qt::KeepAspectRatioByExpanding),
+  mCurrentLayer(0),
+  mPlottingHints(QCP::phCacheLabels|QCP::phForceRepaint),
+  mMultiSelectModifier(Qt::ControlModifier),
+  mPaintBuffer(size()),
+  mMouseEventElement(0),
+  mReplotting(false)
+{
+  setAttribute(Qt::WA_NoMousePropagation);
+  setAttribute(Qt::WA_OpaquePaintEvent);
+  setMouseTracking(true);
+  QLocale currentLocale = locale();
+  currentLocale.setNumberOptions(QLocale::OmitGroupSeparator);
+  setLocale(currentLocale);
+  
+  // create initial layers:
+  mLayers.append(new QCPLayer(this, QLatin1String("background")));
+  mLayers.append(new QCPLayer(this, QLatin1String("grid")));
+  mLayers.append(new QCPLayer(this, QLatin1String("main")));
+  mLayers.append(new QCPLayer(this, QLatin1String("axes")));
+  mLayers.append(new QCPLayer(this, QLatin1String("legend")));
+  updateLayerIndices();
+  setCurrentLayer(QLatin1String("main"));
+  
+  // create initial layout, axis rect and legend:
+  mPlotLayout = new QCPLayoutGrid;
+  mPlotLayout->initializeParentPlot(this);
+  mPlotLayout->setParent(this); // important because if parent is QWidget, QCPLayout::sizeConstraintsChanged will call QWidget::updateGeometry
+  mPlotLayout->setLayer(QLatin1String("main"));
+  QCPAxisRect *defaultAxisRect = new QCPAxisRect(this, true);
+  mPlotLayout->addElement(0, 0, defaultAxisRect);
+  xAxis = defaultAxisRect->axis(QCPAxis::atBottom);
+  yAxis = defaultAxisRect->axis(QCPAxis::atLeft);
+  xAxis2 = defaultAxisRect->axis(QCPAxis::atTop);
+  yAxis2 = defaultAxisRect->axis(QCPAxis::atRight);
+  legend = new QCPLegend;
+  legend->setVisible(false);
+  defaultAxisRect->insetLayout()->addElement(legend, Qt::AlignRight|Qt::AlignTop);
+  defaultAxisRect->insetLayout()->setMargins(QMargins(12, 12, 12, 12));
+  
+  defaultAxisRect->setLayer(QLatin1String("background"));
+  xAxis->setLayer(QLatin1String("axes"));
+  yAxis->setLayer(QLatin1String("axes"));
+  xAxis2->setLayer(QLatin1String("axes"));
+  yAxis2->setLayer(QLatin1String("axes"));
+  xAxis->grid()->setLayer(QLatin1String("grid"));
+  yAxis->grid()->setLayer(QLatin1String("grid"));
+  xAxis2->grid()->setLayer(QLatin1String("grid"));
+  yAxis2->grid()->setLayer(QLatin1String("grid"));
+  legend->setLayer(QLatin1String("legend"));
+  
+  setViewport(rect()); // needs to be called after mPlotLayout has been created
+  
+  replot();
+}
+
+QCustomPlot::~QCustomPlot()
+{
+  clearPlottables();
+  clearItems();
+
+  if (mPlotLayout)
+  {
+    delete mPlotLayout;
+    mPlotLayout = 0;
+  }
+  
+  mCurrentLayer = 0;
+  qDeleteAll(mLayers); // don't use removeLayer, because it would prevent the last layer to be removed
+  mLayers.clear();
+}
+
+/*!
+  Sets which elements are forcibly drawn antialiased as an \a or combination of QCP::AntialiasedElement.
+  
+  This overrides the antialiasing settings for whole element groups, normally controlled with the
+  \a setAntialiasing function on the individual elements. If an element is neither specified in
+  \ref setAntialiasedElements nor in \ref setNotAntialiasedElements, the antialiasing setting on
+  each individual element instance is used.
+  
+  For example, if \a antialiasedElements contains \ref QCP::aePlottables, all plottables will be
+  drawn antialiased, no matter what the specific QCPAbstractPlottable::setAntialiased value was set
+  to.
+  
+  if an element in \a antialiasedElements is already set in \ref setNotAntialiasedElements, it is
+  removed from there.
+  
+  \see setNotAntialiasedElements
+*/
+void QCustomPlot::setAntialiasedElements(const QCP::AntialiasedElements &antialiasedElements)
+{
+  mAntialiasedElements = antialiasedElements;
+  
+  // make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously:
+  if ((mNotAntialiasedElements & mAntialiasedElements) != 0)
+    mNotAntialiasedElements |= ~mAntialiasedElements;
+}
+
+/*!
+  Sets whether the specified \a antialiasedElement is forcibly drawn antialiased.
+  
+  See \ref setAntialiasedElements for details.
+  
+  \see setNotAntialiasedElement
+*/
+void QCustomPlot::setAntialiasedElement(QCP::AntialiasedElement antialiasedElement, bool enabled)
+{
+  if (!enabled && mAntialiasedElements.testFlag(antialiasedElement))
+    mAntialiasedElements &= ~antialiasedElement;
+  else if (enabled && !mAntialiasedElements.testFlag(antialiasedElement))
+    mAntialiasedElements |= antialiasedElement;
+  
+  // make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously:
+  if ((mNotAntialiasedElements & mAntialiasedElements) != 0)
+    mNotAntialiasedElements |= ~mAntialiasedElements;
+}
+
+/*!
+  Sets which elements are forcibly drawn not antialiased as an \a or combination of
+  QCP::AntialiasedElement.
+  
+  This overrides the antialiasing settings for whole element groups, normally controlled with the
+  \a setAntialiasing function on the individual elements. If an element is neither specified in
+  \ref setAntialiasedElements nor in \ref setNotAntialiasedElements, the antialiasing setting on
+  each individual element instance is used.
+  
+  For example, if \a notAntialiasedElements contains \ref QCP::aePlottables, no plottables will be
+  drawn antialiased, no matter what the specific QCPAbstractPlottable::setAntialiased value was set
+  to.
+  
+  if an element in \a notAntialiasedElements is already set in \ref setAntialiasedElements, it is
+  removed from there.
+  
+  \see setAntialiasedElements
+*/
+void QCustomPlot::setNotAntialiasedElements(const QCP::AntialiasedElements &notAntialiasedElements)
+{
+  mNotAntialiasedElements = notAntialiasedElements;
+  
+  // make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously:
+  if ((mNotAntialiasedElements & mAntialiasedElements) != 0)
+    mAntialiasedElements |= ~mNotAntialiasedElements;
+}
+
+/*!
+  Sets whether the specified \a notAntialiasedElement is forcibly drawn not antialiased.
+  
+  See \ref setNotAntialiasedElements for details.
+  
+  \see setAntialiasedElement
+*/
+void QCustomPlot::setNotAntialiasedElement(QCP::AntialiasedElement notAntialiasedElement, bool enabled)
+{
+  if (!enabled && mNotAntialiasedElements.testFlag(notAntialiasedElement))
+    mNotAntialiasedElements &= ~notAntialiasedElement;
+  else if (enabled && !mNotAntialiasedElements.testFlag(notAntialiasedElement))
+    mNotAntialiasedElements |= notAntialiasedElement;
+  
+  // make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously:
+  if ((mNotAntialiasedElements & mAntialiasedElements) != 0)
+    mAntialiasedElements |= ~mNotAntialiasedElements;
+}
+
+/*!
+  If set to true, adding a plottable (e.g. a graph) to the QCustomPlot automatically also adds the
+  plottable to the legend (QCustomPlot::legend).
+  
+  \see addPlottable, addGraph, QCPLegend::addItem
+*/
+void QCustomPlot::setAutoAddPlottableToLegend(bool on)
+{
+  mAutoAddPlottableToLegend = on;
+}
+
+/*!
+  Sets the possible interactions of this QCustomPlot as an or-combination of \ref QCP::Interaction
+  enums. There are the following types of interactions:
+  
+  <b>Axis range manipulation</b> is controlled via \ref QCP::iRangeDrag and \ref QCP::iRangeZoom. When the
+  respective interaction is enabled, the user may drag axes ranges and zoom with the mouse wheel.
+  For details how to control which axes the user may drag/zoom and in what orientations, see \ref
+  QCPAxisRect::setRangeDrag, \ref QCPAxisRect::setRangeZoom, \ref QCPAxisRect::setRangeDragAxes,
+  \ref QCPAxisRect::setRangeZoomAxes.
+  
+  <b>Plottable selection</b> is controlled by \ref QCP::iSelectPlottables. If \ref QCP::iSelectPlottables is
+  set, the user may select plottables (graphs, curves, bars,...) by clicking on them or in their
+  vicinity (\ref setSelectionTolerance). Whether the user can actually select a plottable can
+  further be restricted with the \ref QCPAbstractPlottable::setSelectable function on the specific
+  plottable. To find out whether a specific plottable is selected, call
+  QCPAbstractPlottable::selected(). To retrieve a list of all currently selected plottables, call
+  \ref selectedPlottables. If you're only interested in QCPGraphs, you may use the convenience
+  function \ref selectedGraphs.
+  
+  <b>Item selection</b> is controlled by \ref QCP::iSelectItems. If \ref QCP::iSelectItems is set, the user
+  may select items (QCPItemLine, QCPItemText,...) by clicking on them or in their vicinity. To find
+  out whether a specific item is selected, call QCPAbstractItem::selected(). To retrieve a list of
+  all currently selected items, call \ref selectedItems.
+  
+  <b>Axis selection</b> is controlled with \ref QCP::iSelectAxes. If \ref QCP::iSelectAxes is set, the user
+  may select parts of the axes by clicking on them. What parts exactly (e.g. Axis base line, tick
+  labels, axis label) are selectable can be controlled via \ref QCPAxis::setSelectableParts for
+  each axis. To retrieve a list of all axes that currently contain selected parts, call \ref
+  selectedAxes. Which parts of an axis are selected, can be retrieved with QCPAxis::selectedParts().
+  
+  <b>Legend selection</b> is controlled with \ref QCP::iSelectLegend. If this is set, the user may
+  select the legend itself or individual items by clicking on them. What parts exactly are
+  selectable can be controlled via \ref QCPLegend::setSelectableParts. To find out whether the
+  legend or any of its child items are selected, check the value of QCPLegend::selectedParts. To
+  find out which child items are selected, call \ref QCPLegend::selectedItems.
+  
+  <b>All other selectable elements</b> The selection of all other selectable objects (e.g.
+  QCPPlotTitle, or your own layerable subclasses) is controlled with \ref QCP::iSelectOther. If set, the
+  user may select those objects by clicking on them. To find out which are currently selected, you
+  need to check their selected state explicitly.
+  
+  If the selection state has changed by user interaction, the \ref selectionChangedByUser signal is
+  emitted. Each selectable object additionally emits an individual selectionChanged signal whenever
+  their selection state has changed, i.e. not only by user interaction.
+  
+  To allow multiple objects to be selected by holding the selection modifier (\ref
+  setMultiSelectModifier), set the flag \ref QCP::iMultiSelect.
+  
+  \note In addition to the selection mechanism presented here, QCustomPlot always emits
+  corresponding signals, when an object is clicked or double clicked. see \ref plottableClick and
+  \ref plottableDoubleClick for example.
+  
+  \see setInteraction, setSelectionTolerance
+*/
+void QCustomPlot::setInteractions(const QCP::Interactions &interactions)
+{
+  mInteractions = interactions;
+}
+
+/*!
+  Sets the single \a interaction of this QCustomPlot to \a enabled.
+  
+  For details about the interaction system, see \ref setInteractions.
+  
+  \see setInteractions
+*/
+void QCustomPlot::setInteraction(const QCP::Interaction &interaction, bool enabled)
+{
+  if (!enabled && mInteractions.testFlag(interaction))
+    mInteractions &= ~interaction;
+  else if (enabled && !mInteractions.testFlag(interaction))
+    mInteractions |= interaction;
+}
+
+/*!
+  Sets the tolerance that is used to decide whether a click selects an object (e.g. a plottable) or
+  not.
+  
+  If the user clicks in the vicinity of the line of e.g. a QCPGraph, it's only regarded as a
+  potential selection when the minimum distance between the click position and the graph line is
+  smaller than \a pixels. Objects that are defined by an area (e.g. QCPBars) only react to clicks
+  directly inside the area and ignore this selection tolerance. In other words, it only has meaning
+  for parts of objects that are too thin to exactly hit with a click and thus need such a
+  tolerance.
+  
+  \see setInteractions, QCPLayerable::selectTest
+*/
+void QCustomPlot::setSelectionTolerance(int pixels)
+{
+  mSelectionTolerance = pixels;
+}
+
+/*!
+  Sets whether antialiasing is disabled for this QCustomPlot while the user is dragging axes
+  ranges. If many objects, especially plottables, are drawn antialiased, this greatly improves
+  performance during dragging. Thus it creates a more responsive user experience. As soon as the
+  user stops dragging, the last replot is done with normal antialiasing, to restore high image
+  quality.
+  
+  \see setAntialiasedElements, setNotAntialiasedElements
+*/
+void QCustomPlot::setNoAntialiasingOnDrag(bool enabled)
+{
+  mNoAntialiasingOnDrag = enabled;
+}
+
+/*!
+  Sets the plotting hints for this QCustomPlot instance as an \a or combination of QCP::PlottingHint.
+  
+  \see setPlottingHint
+*/
+void QCustomPlot::setPlottingHints(const QCP::PlottingHints &hints)
+{
+  mPlottingHints = hints;
+}
+
+/*!
+  Sets the specified plotting \a hint to \a enabled.
+  
+  \see setPlottingHints
+*/
+void QCustomPlot::setPlottingHint(QCP::PlottingHint hint, bool enabled)
+{
+  QCP::PlottingHints newHints = mPlottingHints;
+  if (!enabled)
+    newHints &= ~hint;
+  else
+    newHints |= hint;
+  
+  if (newHints != mPlottingHints)
+    setPlottingHints(newHints);
+}
+
+/*!
+  Sets the keyboard modifier that will be recognized as multi-select-modifier.
+  
+  If \ref QCP::iMultiSelect is specified in \ref setInteractions, the user may select multiple objects
+  by clicking on them one after the other while holding down \a modifier.
+  
+  By default the multi-select-modifier is set to Qt::ControlModifier.
+  
+  \see setInteractions
+*/
+void QCustomPlot::setMultiSelectModifier(Qt::KeyboardModifier modifier)
+{
+  mMultiSelectModifier = modifier;
+}
+
+/*!
+  Sets the viewport of this QCustomPlot. The Viewport is the area that the top level layout
+  (QCustomPlot::plotLayout()) uses as its rect. Normally, the viewport is the entire widget rect.
+  
+  This function is used to allow arbitrary size exports with \ref toPixmap, \ref savePng, \ref
+  savePdf, etc. by temporarily changing the viewport size.
+*/
+void QCustomPlot::setViewport(const QRect &rect)
+{
+  mViewport = rect;
+  if (mPlotLayout)
+    mPlotLayout->setOuterRect(mViewport);
+}
+
+/*!
+  Sets \a pm as the viewport background pixmap (see \ref setViewport). The pixmap is always drawn
+  below all other objects in the plot.
+
+  For cases where the provided pixmap doesn't have the same size as the viewport, scaling can be
+  enabled with \ref setBackgroundScaled and the scaling mode (whether and how the aspect ratio is
+  preserved) can be set with \ref setBackgroundScaledMode. To set all these options in one call,
+  consider using the overloaded version of this function.
+  
+  If a background brush was set with \ref setBackground(const QBrush &brush), the viewport will
+  first be filled with that brush, before drawing the background pixmap. This can be useful for
+  background pixmaps with translucent areas.
+
+  \see setBackgroundScaled, setBackgroundScaledMode
+*/
+void QCustomPlot::setBackground(const QPixmap &pm)
+{
+  mBackgroundPixmap = pm;
+  mScaledBackgroundPixmap = QPixmap();
+}
+
+/*!
+  Sets the background brush of the viewport (see \ref setViewport).
+
+  Before drawing everything else, the background is filled with \a brush. If a background pixmap
+  was set with \ref setBackground(const QPixmap &pm), this brush will be used to fill the viewport
+  before the background pixmap is drawn. This can be useful for background pixmaps with translucent
+  areas.
+  
+  Set \a brush to Qt::NoBrush or Qt::Transparent to leave background transparent. This can be
+  useful for exporting to image formats which support transparency, e.g. \ref savePng.
+
+  \see setBackgroundScaled, setBackgroundScaledMode
+*/
+void QCustomPlot::setBackground(const QBrush &brush)
+{
+  mBackgroundBrush = brush;
+}
+
+/*! \overload
+  
+  Allows setting the background pixmap of the viewport, whether it shall be scaled and how it
+  shall be scaled in one call.
+
+  \see setBackground(const QPixmap &pm), setBackgroundScaled, setBackgroundScaledMode
+*/
+void QCustomPlot::setBackground(const QPixmap &pm, bool scaled, Qt::AspectRatioMode mode)
+{
+  mBackgroundPixmap = pm;
+  mScaledBackgroundPixmap = QPixmap();
+  mBackgroundScaled = scaled;
+  mBackgroundScaledMode = mode;
+}
+
+/*!
+  Sets whether the viewport background pixmap shall be scaled to fit the viewport. If \a scaled is
+  set to true, control whether and how the aspect ratio of the original pixmap is preserved with
+  \ref setBackgroundScaledMode.
+  
+  Note that the scaled version of the original pixmap is buffered, so there is no performance
+  penalty on replots. (Except when the viewport dimensions are changed continuously.)
+  
+  \see setBackground, setBackgroundScaledMode
+*/
+void QCustomPlot::setBackgroundScaled(bool scaled)
+{
+  mBackgroundScaled = scaled;
+}
+
+/*!
+  If scaling of the viewport background pixmap is enabled (\ref setBackgroundScaled), use this
+  function to define whether and how the aspect ratio of the original pixmap is preserved.
+  
+  \see setBackground, setBackgroundScaled
+*/
+void QCustomPlot::setBackgroundScaledMode(Qt::AspectRatioMode mode)
+{
+  mBackgroundScaledMode = mode;
+}
+
+/*!
+  Returns the plottable with \a index. If the index is invalid, returns 0.
+  
+  There is an overloaded version of this function with no parameter which returns the last added
+  plottable, see QCustomPlot::plottable()
+  
+  \see plottableCount, addPlottable
+*/
+QCPAbstractPlottable *QCustomPlot::plottable(int index)
+{
+  if (index >= 0 && index < mPlottables.size())
+  {
+    return mPlottables.at(index);
+  } else
+  {
+    qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;
+    return 0;
+  }
+}
+
+/*! \overload
+  
+  Returns the last plottable that was added with \ref addPlottable. If there are no plottables in
+  the plot, returns 0.
+  
+  \see plottableCount, addPlottable
+*/
+QCPAbstractPlottable *QCustomPlot::plottable()
+{
+  if (!mPlottables.isEmpty())
+  {
+    return mPlottables.last();
+  } else
+    return 0;
+}
+
+/*!
+  Adds the specified plottable to the plot and, if \ref setAutoAddPlottableToLegend is enabled, to
+  the legend (QCustomPlot::legend). QCustomPlot takes ownership of the plottable.
+  
+  Returns true on success, i.e. when \a plottable isn't already in the plot and the parent plot of
+  \a plottable is this QCustomPlot (the latter is controlled by what axes were passed in the
+  plottable's constructor).
+  
+  \see plottable, plottableCount, removePlottable, clearPlottables
+*/
+bool QCustomPlot::addPlottable(QCPAbstractPlottable *plottable)
+{
+  if (mPlottables.contains(plottable))
+  {
+    qDebug() << Q_FUNC_INFO << "plottable already added to this QCustomPlot:" << reinterpret_cast<quintptr>(plottable);
+    return false;
+  }
+  if (plottable->parentPlot() != this)
+  {
+    qDebug() << Q_FUNC_INFO << "plottable not created with this QCustomPlot as parent:" << reinterpret_cast<quintptr>(plottable);
+    return false;
+  }
+  
+  mPlottables.append(plottable);
+  // possibly add plottable to legend:
+  if (mAutoAddPlottableToLegend)
+    plottable->addToLegend();
+  // special handling for QCPGraphs to maintain the simple graph interface:
+  if (QCPGraph *graph = qobject_cast<QCPGraph*>(plottable))
+    mGraphs.append(graph);
+  if (!plottable->layer()) // usually the layer is already set in the constructor of the plottable (via QCPLayerable constructor)
+    plottable->setLayer(currentLayer());
+  return true;
+}
+
+/*!
+  Removes the specified plottable from the plot and, if necessary, from the legend (QCustomPlot::legend).
+  
+  Returns true on success.
+  
+  \see addPlottable, clearPlottables
+*/
+bool QCustomPlot::removePlottable(QCPAbstractPlottable *plottable)
+{
+  if (!mPlottables.contains(plottable))
+  {
+    qDebug() << Q_FUNC_INFO << "plottable not in list:" << reinterpret_cast<quintptr>(plottable);
+    return false;
+  }
+  
+  // remove plottable from legend:
+  plottable->removeFromLegend();
+  // special handling for QCPGraphs to maintain the simple graph interface:
+  if (QCPGraph *graph = qobject_cast<QCPGraph*>(plottable))
+    mGraphs.removeOne(graph);
+  // remove plottable:
+  delete plottable;
+  mPlottables.removeOne(plottable);
+  return true;
+}
+
+/*! \overload
+  
+  Removes the plottable by its \a index.
+*/
+bool QCustomPlot::removePlottable(int index)
+{
+  if (index >= 0 && index < mPlottables.size())
+    return removePlottable(mPlottables[index]);
+  else
+  {
+    qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;
+    return false;
+  }
+}
+
+/*!
+  Removes all plottables from the plot (and the QCustomPlot::legend, if necessary).
+  
+  Returns the number of plottables removed.
+  
+  \see removePlottable
+*/
+int QCustomPlot::clearPlottables()
+{
+  int c = mPlottables.size();
+  for (int i=c-1; i >= 0; --i)
+    removePlottable(mPlottables[i]);
+  return c;
+}
+
+/*!
+  Returns the number of currently existing plottables in the plot
+  
+  \see plottable, addPlottable
+*/
+int QCustomPlot::plottableCount() const
+{
+  return mPlottables.size();
+}
+
+/*!
+  Returns a list of the selected plottables. If no plottables are currently selected, the list is empty.
+  
+  There is a convenience function if you're only interested in selected graphs, see \ref selectedGraphs.
+  
+  \see setInteractions, QCPAbstractPlottable::setSelectable, QCPAbstractPlottable::setSelected
+*/
+QList<QCPAbstractPlottable*> QCustomPlot::selectedPlottables() const
+{
+  QList<QCPAbstractPlottable*> result;
+  foreach (QCPAbstractPlottable *plottable, mPlottables)
+  {
+    if (plottable->selected())
+      result.append(plottable);
+  }
+  return result;
+}
+
+/*!
+  Returns the plottable at the pixel position \a pos. Plottables that only consist of single lines
+  (like graphs) have a tolerance band around them, see \ref setSelectionTolerance. If multiple
+  plottables come into consideration, the one closest to \a pos is returned.
+  
+  If \a onlySelectable is true, only plottables that are selectable
+  (QCPAbstractPlottable::setSelectable) are considered.
+  
+  If there is no plottable at \a pos, the return value is 0.
+  
+  \see itemAt, layoutElementAt
+*/
+QCPAbstractPlottable *QCustomPlot::plottableAt(const QPointF &pos, bool onlySelectable) const
+{
+  QCPAbstractPlottable *resultPlottable = 0;
+  double resultDistance = mSelectionTolerance; // only regard clicks with distances smaller than mSelectionTolerance as selections, so initialize with that value
+  
+  foreach (QCPAbstractPlottable *plottable, mPlottables)
+  {
+    if (onlySelectable && !plottable->selectable()) // we could have also passed onlySelectable to the selectTest function, but checking here is faster, because we have access to QCPabstractPlottable::selectable
+      continue;
+    if ((plottable->keyAxis()->axisRect()->rect() & plottable->valueAxis()->axisRect()->rect()).contains(pos.toPoint())) // only consider clicks inside the rect that is spanned by the plottable's key/value axes
+    {
+      double currentDistance = plottable->selectTest(pos, false);
+      if (currentDistance >= 0 && currentDistance < resultDistance)
+      {
+        resultPlottable = plottable;
+        resultDistance = currentDistance;
+      }
+    }
+  }
+  
+  return resultPlottable;
+}
+
+/*!
+  Returns whether this QCustomPlot instance contains the \a plottable.
+  
+  \see addPlottable
+*/
+bool QCustomPlot::hasPlottable(QCPAbstractPlottable *plottable) const
+{
+  return mPlottables.contains(plottable);
+}
+
+/*!
+  Returns the graph with \a index. If the index is invalid, returns 0.
+  
+  There is an overloaded version of this function with no parameter which returns the last created
+  graph, see QCustomPlot::graph()
+  
+  \see graphCount, addGraph
+*/
+QCPGraph *QCustomPlot::graph(int index) const
+{
+  if (index >= 0 && index < mGraphs.size())
+  {
+    return mGraphs.at(index);
+  } else
+  {
+    qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;
+    return 0;
+  }
+}
+
+/*! \overload
+  
+  Returns the last graph, that was created with \ref addGraph. If there are no graphs in the plot,
+  returns 0.
+  
+  \see graphCount, addGraph
+*/
+QCPGraph *QCustomPlot::graph() const
+{
+  if (!mGraphs.isEmpty())
+  {
+    return mGraphs.last();
+  } else
+    return 0;
+}
+
+/*!
+  Creates a new graph inside the plot. If \a keyAxis and \a valueAxis are left unspecified (0), the
+  bottom (xAxis) is used as key and the left (yAxis) is used as value axis. If specified, \a
+  keyAxis and \a valueAxis must reside in this QCustomPlot.
+  
+  \a keyAxis will be used as key axis (typically "x") and \a valueAxis as value axis (typically
+  "y") for the graph.
+  
+  Returns a pointer to the newly created graph, or 0 if adding the graph failed.
+  
+  \see graph, graphCount, removeGraph, clearGraphs
+*/
+QCPGraph *QCustomPlot::addGraph(QCPAxis *keyAxis, QCPAxis *valueAxis)
+{
+  if (!keyAxis) keyAxis = xAxis;
+  if (!valueAxis) valueAxis = yAxis;
+  if (!keyAxis || !valueAxis)
+  {
+    qDebug() << Q_FUNC_INFO << "can't use default QCustomPlot xAxis or yAxis, because at least one is invalid (has been deleted)";
+    return 0;
+  }
+  if (keyAxis->parentPlot() != this || valueAxis->parentPlot() != this)
+  {
+    qDebug() << Q_FUNC_INFO << "passed keyAxis or valueAxis doesn't have this QCustomPlot as parent";
+    return 0;
+  }
+  
+  QCPGraph *newGraph = new QCPGraph(keyAxis, valueAxis);
+  if (addPlottable(newGraph))
+  {
+    newGraph->setName(QLatin1String("Graph ")+QString::number(mGraphs.size()));
+    return newGraph;
+  } else
+  {
+    delete newGraph;
+    return 0;
+  }
+}
+
+/*!
+  Removes the specified \a graph from the plot and, if necessary, from the QCustomPlot::legend. If
+  any other graphs in the plot have a channel fill set towards the removed graph, the channel fill
+  property of those graphs is reset to zero (no channel fill).
+  
+  Returns true on success.
+  
+  \see clearGraphs
+*/
+bool QCustomPlot::removeGraph(QCPGraph *graph)
+{
+  return removePlottable(graph);
+}
+
+/*! \overload
+  
+  Removes the graph by its \a index.
+*/
+bool QCustomPlot::removeGraph(int index)
+{
+  if (index >= 0 && index < mGraphs.size())
+    return removeGraph(mGraphs[index]);
+  else
+    return false;
+}
+
+/*!
+  Removes all graphs from the plot (and the QCustomPlot::legend, if necessary).
+
+  Returns the number of graphs removed.
+  
+  \see removeGraph
+*/
+int QCustomPlot::clearGraphs()
+{
+  int c = mGraphs.size();
+  for (int i=c-1; i >= 0; --i)
+    removeGraph(mGraphs[i]);
+  return c;
+}
+
+/*!
+  Returns the number of currently existing graphs in the plot
+  
+  \see graph, addGraph
+*/
+int QCustomPlot::graphCount() const
+{
+  return mGraphs.size();
+}
+
+/*!
+  Returns a list of the selected graphs. If no graphs are currently selected, the list is empty.
+  
+  If you are not only interested in selected graphs but other plottables like QCPCurve, QCPBars,
+  etc., use \ref selectedPlottables.
+  
+  \see setInteractions, selectedPlottables, QCPAbstractPlottable::setSelectable, QCPAbstractPlottable::setSelected
+*/
+QList<QCPGraph*> QCustomPlot::selectedGraphs() const
+{
+  QList<QCPGraph*> result;
+  foreach (QCPGraph *graph, mGraphs)
+  {
+    if (graph->selected())
+      result.append(graph);
+  }
+  return result;
+}
+
+/*!
+  Returns the item with \a index. If the index is invalid, returns 0.
+  
+  There is an overloaded version of this function with no parameter which returns the last added
+  item, see QCustomPlot::item()
+  
+  \see itemCount, addItem
+*/
+QCPAbstractItem *QCustomPlot::item(int index) const
+{
+  if (index >= 0 && index < mItems.size())
+  {
+    return mItems.at(index);
+  } else
+  {
+    qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;
+    return 0;
+  }
+}
+
+/*! \overload
+  
+  Returns the last item, that was added with \ref addItem. If there are no items in the plot,
+  returns 0.
+  
+  \see itemCount, addItem
+*/
+QCPAbstractItem *QCustomPlot::item() const
+{
+  if (!mItems.isEmpty())
+  {
+    return mItems.last();
+  } else
+    return 0;
+}
+
+/*!
+  Adds the specified item to the plot. QCustomPlot takes ownership of the item.
+  
+  Returns true on success, i.e. when \a item wasn't already in the plot and the parent plot of \a
+  item is this QCustomPlot.
+  
+  \see item, itemCount, removeItem, clearItems
+*/
+bool QCustomPlot::addItem(QCPAbstractItem *item)
+{
+  if (!mItems.contains(item) && item->parentPlot() == this)
+  {
+    mItems.append(item);
+    return true;
+  } else
+  {
+    qDebug() << Q_FUNC_INFO << "item either already in list or not created with this QCustomPlot as parent:" << reinterpret_cast<quintptr>(item);
+    return false;
+  }
+}
+
+/*!
+  Removes the specified item from the plot.
+  
+  Returns true on success.
+  
+  \see addItem, clearItems
+*/
+bool QCustomPlot::removeItem(QCPAbstractItem *item)
+{
+  if (mItems.contains(item))
+  {
+    delete item;
+    mItems.removeOne(item);
+    return true;
+  } else
+  {
+    qDebug() << Q_FUNC_INFO << "item not in list:" << reinterpret_cast<quintptr>(item);
+    return false;
+  }
+}
+
+/*! \overload
+  
+  Removes the item by its \a index.
+*/
+bool QCustomPlot::removeItem(int index)
+{
+  if (index >= 0 && index < mItems.size())
+    return removeItem(mItems[index]);
+  else
+  {
+    qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;
+    return false;
+  }
+}
+
+/*!
+  Removes all items from the plot.
+  
+  Returns the number of items removed.
+  
+  \see removeItem
+*/
+int QCustomPlot::clearItems()
+{
+  int c = mItems.size();
+  for (int i=c-1; i >= 0; --i)
+    removeItem(mItems[i]);
+  return c;
+}
+
+/*!
+  Returns the number of currently existing items in the plot
+  
+  \see item, addItem
+*/
+int QCustomPlot::itemCount() const
+{
+  return mItems.size();
+}
+
+/*!
+  Returns a list of the selected items. If no items are currently selected, the list is empty.
+  
+  \see setInteractions, QCPAbstractItem::setSelectable, QCPAbstractItem::setSelected
+*/
+QList<QCPAbstractItem*> QCustomPlot::selectedItems() const
+{
+  QList<QCPAbstractItem*> result;
+  foreach (QCPAbstractItem *item, mItems)
+  {
+    if (item->selected())
+      result.append(item);
+  }
+  return result;
+}
+
+/*!
+  Returns the item at the pixel position \a pos. Items that only consist of single lines (e.g. \ref
+  QCPItemLine or \ref QCPItemCurve) have a tolerance band around them, see \ref
+  setSelectionTolerance. If multiple items come into consideration, the one closest to \a pos is
+  returned.
+  
+  If \a onlySelectable is true, only items that are selectable (QCPAbstractItem::setSelectable) are
+  considered.
+  
+  If there is no item at \a pos, the return value is 0.
+  
+  \see plottableAt, layoutElementAt
+*/
+QCPAbstractItem *QCustomPlot::itemAt(const QPointF &pos, bool onlySelectable) const
+{
+  QCPAbstractItem *resultItem = 0;
+  double resultDistance = mSelectionTolerance; // only regard clicks with distances smaller than mSelectionTolerance as selections, so initialize with that value
+  
+  foreach (QCPAbstractItem *item, mItems)
+  {
+    if (onlySelectable && !item->selectable()) // we could have also passed onlySelectable to the selectTest function, but checking here is faster, because we have access to QCPAbstractItem::selectable
+      continue;
+    if (!item->clipToAxisRect() || item->clipRect().contains(pos.toPoint())) // only consider clicks inside axis cliprect of the item if actually clipped to it
+    {
+      double currentDistance = item->selectTest(pos, false);
+      if (currentDistance >= 0 && currentDistance < resultDistance)
+      {
+        resultItem = item;
+        resultDistance = currentDistance;
+      }
+    }
+  }
+  
+  return resultItem;
+}
+
+/*!
+  Returns whether this QCustomPlot contains the \a item.
+  
+  \see addItem
+*/
+bool QCustomPlot::hasItem(QCPAbstractItem *item) const
+{
+  return mItems.contains(item);
+}
+
+/*!
+  Returns the layer with the specified \a name. If there is no layer with the specified name, 0 is
+  returned.
+  
+  Layer names are case-sensitive.
+  
+  \see addLayer, moveLayer, removeLayer
+*/
+QCPLayer *QCustomPlot::layer(const QString &name) const
+{
+  foreach (QCPLayer *layer, mLayers)
+  {
+    if (layer->name() == name)
+      return layer;
+  }
+  return 0;
+}
+
+/*! \overload
+  
+  Returns the layer by \a index. If the index is invalid, 0 is returned.
+  
+  \see addLayer, moveLayer, removeLayer
+*/
+QCPLayer *QCustomPlot::layer(int index) const
+{
+  if (index >= 0 && index < mLayers.size())
+  {
+    return mLayers.at(index);
+  } else
+  {
+    qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;
+    return 0;
+  }
+}
+
+/*!
+  Returns the layer that is set as current layer (see \ref setCurrentLayer).
+*/
+QCPLayer *QCustomPlot::currentLayer() const
+{
+  return mCurrentLayer;
+}
+
+/*!
+  Sets the layer with the specified \a name to be the current layer. All layerables (\ref
+  QCPLayerable), e.g. plottables and items, are created on the current layer.
+  
+  Returns true on success, i.e. if there is a layer with the specified \a name in the QCustomPlot.
+  
+  Layer names are case-sensitive.
+  
+  \see addLayer, moveLayer, removeLayer, QCPLayerable::setLayer
+*/
+bool QCustomPlot::setCurrentLayer(const QString &name)
+{
+  if (QCPLayer *newCurrentLayer = layer(name))
+  {
+    return setCurrentLayer(newCurrentLayer);
+  } else
+  {
+    qDebug() << Q_FUNC_INFO << "layer with name doesn't exist:" << name;
+    return false;
+  }
+}
+
+/*! \overload
+  
+  Sets the provided \a layer to be the current layer.
+  
+  Returns true on success, i.e. when \a layer is a valid layer in the QCustomPlot.
+  
+  \see addLayer, moveLayer, removeLayer
+*/
+bool QCustomPlot::setCurrentLayer(QCPLayer *layer)
+{
+  if (!mLayers.contains(layer))
+  {
+    qDebug() << Q_FUNC_INFO << "layer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(layer);
+    return false;
+  }
+  
+  mCurrentLayer = layer;
+  return true;
+}
+
+/*!
+  Returns the number of currently existing layers in the plot
+  
+  \see layer, addLayer
+*/
+int QCustomPlot::layerCount() const
+{
+  return mLayers.size();
+}
+
+/*!
+  Adds a new layer to this QCustomPlot instance. The new layer will have the name \a name, which
+  must be unique. Depending on \a insertMode, it is positioned either below or above \a otherLayer.
+  
+  Returns true on success, i.e. if there is no other layer named \a name and \a otherLayer is a
+  valid layer inside this QCustomPlot.
+  
+  If \a otherLayer is 0, the highest layer in the QCustomPlot will be used.
+  
+  For an explanation of what layers are in QCustomPlot, see the documentation of \ref QCPLayer.
+  
+  \see layer, moveLayer, removeLayer
+*/
+bool QCustomPlot::addLayer(const QString &name, QCPLayer *otherLayer, QCustomPlot::LayerInsertMode insertMode)
+{
+  if (!otherLayer)
+    otherLayer = mLayers.last();
+  if (!mLayers.contains(otherLayer))
+  {
+    qDebug() << Q_FUNC_INFO << "otherLayer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(otherLayer);
+    return false;
+  }
+  if (layer(name))
+  {
+    qDebug() << Q_FUNC_INFO << "A layer exists already with the name" << name;
+    return false;
+  }
+    
+  QCPLayer *newLayer = new QCPLayer(this, name);
+  mLayers.insert(otherLayer->index() + (insertMode==limAbove ? 1:0), newLayer);
+  updateLayerIndices();
+  return true;
+}
+
+/*!
+  Removes the specified \a layer and returns true on success.
+  
+  All layerables (e.g. plottables and items) on the removed layer will be moved to the layer below
+  \a layer. If \a layer is the bottom layer, the layerables are moved to the layer above. In both
+  cases, the total rendering order of all layerables in the QCustomPlot is preserved.
+  
+  If \a layer is the current layer (\ref setCurrentLayer), the layer below (or above, if bottom
+  layer) becomes the new current layer.
+  
+  It is not possible to remove the last layer of the plot.
+  
+  \see layer, addLayer, moveLayer
+*/
+bool QCustomPlot::removeLayer(QCPLayer *layer)
+{
+  if (!mLayers.contains(layer))
+  {
+    qDebug() << Q_FUNC_INFO << "layer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(layer);
+    return false;
+  }
+  if (mLayers.size() < 2)
+  {
+    qDebug() << Q_FUNC_INFO << "can't remove last layer";
+    return false;
+  }
+  
+  // append all children of this layer to layer below (if this is lowest layer, prepend to layer above)
+  int removedIndex = layer->index();
+  bool isFirstLayer = removedIndex==0;
+  QCPLayer *targetLayer = isFirstLayer ? mLayers.at(removedIndex+1) : mLayers.at(removedIndex-1);
+  QList<QCPLayerable*> children = layer->children();
+  if (isFirstLayer) // prepend in reverse order (so order relative to each other stays the same)
+  {
+    for (int i=children.size()-1; i>=0; --i)
+      children.at(i)->moveToLayer(targetLayer, true);
+  } else  // append normally
+  {
+    for (int i=0; i<children.size(); ++i)
+      children.at(i)->moveToLayer(targetLayer, false);
+  }
+  // if removed layer is current layer, change current layer to layer below/above:
+  if (layer == mCurrentLayer)
+    setCurrentLayer(targetLayer);
+  // remove layer:
+  delete layer;
+  mLayers.removeOne(layer);
+  updateLayerIndices();
+  return true;
+}
+
+/*!
+  Moves the specified \a layer either above or below \a otherLayer. Whether it's placed above or
+  below is controlled with \a insertMode.
+  
+  Returns true on success, i.e. when both \a layer and \a otherLayer are valid layers in the
+  QCustomPlot.
+  
+  \see layer, addLayer, moveLayer
+*/
+bool QCustomPlot::moveLayer(QCPLayer *layer, QCPLayer *otherLayer, QCustomPlot::LayerInsertMode insertMode)
+{
+  if (!mLayers.contains(layer))
+  {
+    qDebug() << Q_FUNC_INFO << "layer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(layer);
+    return false;
+  }
+  if (!mLayers.contains(otherLayer))
+  {
+    qDebug() << Q_FUNC_INFO << "otherLayer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(otherLayer);
+    return false;
+  }
+  
+  if (layer->index() > otherLayer->index())
+    mLayers.move(layer->index(), otherLayer->index() + (insertMode==limAbove ? 1:0));
+  else if (layer->index() < otherLayer->index())
+    mLayers.move(layer->index(), otherLayer->index() + (insertMode==limAbove ? 0:-1));
+  
+  updateLayerIndices();
+  return true;
+}
+
+/*!
+  Returns the number of axis rects in the plot.
+  
+  All axis rects can be accessed via QCustomPlot::axisRect().
+  
+  Initially, only one axis rect exists in the plot.
+  
+  \see axisRect, axisRects
+*/
+int QCustomPlot::axisRectCount() const
+{
+  return axisRects().size();
+}
+
+/*!
+  Returns the axis rect with \a index.
+  
+  Initially, only one axis rect (with index 0) exists in the plot. If multiple axis rects were
+  added, all of them may be accessed with this function in a linear fashion (even when they are
+  nested in a layout hierarchy or inside other axis rects via QCPAxisRect::insetLayout).
+  
+  \see axisRectCount, axisRects
+*/
+QCPAxisRect *QCustomPlot::axisRect(int index) const
+{
+  const QList<QCPAxisRect*> rectList = axisRects();
+  if (index >= 0 && index < rectList.size())
+  {
+    return rectList.at(index);
+  } else
+  {
+    qDebug() << Q_FUNC_INFO << "invalid axis rect index" << index;
+    return 0;
+  }
+}
+
+/*!
+  Returns all axis rects in the plot.
+  
+  \see axisRectCount, axisRect
+*/
+QList<QCPAxisRect*> QCustomPlot::axisRects() const
+{
+  QList<QCPAxisRect*> result;
+  QStack<QCPLayoutElement*> elementStack;
+  if (mPlotLayout)
+    elementStack.push(mPlotLayout);
+  
+  while (!elementStack.isEmpty())
+  {
+    foreach (QCPLayoutElement *element, elementStack.pop()->elements(false))
+    {
+      if (element)
+      {
+        elementStack.push(element);
+        if (QCPAxisRect *ar = qobject_cast<QCPAxisRect*>(element))
+          result.append(ar);
+      }
+    }
+  }
+  
+  return result;
+}
+
+/*!
+  Returns the layout element at pixel position \a pos. If there is no element at that position,
+  returns 0.
+  
+  Only visible elements are used. If \ref QCPLayoutElement::setVisible on the element itself or on
+  any of its parent elements is set to false, it will not be considered.
+  
+  \see itemAt, plottableAt
+*/
+QCPLayoutElement *QCustomPlot::layoutElementAt(const QPointF &pos) const
+{
+  QCPLayoutElement *currentElement = mPlotLayout;
+  bool searchSubElements = true;
+  while (searchSubElements && currentElement)
+  {
+    searchSubElements = false;
+    foreach (QCPLayoutElement *subElement, currentElement->elements(false))
+    {
+      if (subElement && subElement->realVisibility() && subElement->selectTest(pos, false) >= 0)
+      {
+        currentElement = subElement;
+        searchSubElements = true;
+        break;
+      }
+    }
+  }
+  return currentElement;
+}
+
+/*!
+  Returns the axes that currently have selected parts, i.e. whose selection state is not \ref
+  QCPAxis::spNone.
+  
+  \see selectedPlottables, selectedLegends, setInteractions, QCPAxis::setSelectedParts,
+  QCPAxis::setSelectableParts
+*/
+QList<QCPAxis*> QCustomPlot::selectedAxes() const
+{
+  QList<QCPAxis*> result, allAxes;
+  foreach (QCPAxisRect *rect, axisRects())
+    allAxes << rect->axes();
+  
+  foreach (QCPAxis *axis, allAxes)
+  {
+    if (axis->selectedParts() != QCPAxis::spNone)
+      result.append(axis);
+  }
+  
+  return result;
+}
+
+/*!
+  Returns the legends that currently have selected parts, i.e. whose selection state is not \ref
+  QCPLegend::spNone.
+  
+  \see selectedPlottables, selectedAxes, setInteractions, QCPLegend::setSelectedParts,
+  QCPLegend::setSelectableParts, QCPLegend::selectedItems
+*/
+QList<QCPLegend*> QCustomPlot::selectedLegends() const
+{
+  QList<QCPLegend*> result;
+  
+  QStack<QCPLayoutElement*> elementStack;
+  if (mPlotLayout)
+    elementStack.push(mPlotLayout);
+  
+  while (!elementStack.isEmpty())
+  {
+    foreach (QCPLayoutElement *subElement, elementStack.pop()->elements(false))
+    {
+      if (subElement)
+      {
+        elementStack.push(subElement);
+        if (QCPLegend *leg = qobject_cast<QCPLegend*>(subElement))
+        {
+          if (leg->selectedParts() != QCPLegend::spNone)
+            result.append(leg);
+        }
+      }
+    }
+  }
+  
+  return result;
+}
+
+/*!
+  Deselects all layerables (plottables, items, axes, legends,...) of the QCustomPlot.
+  
+  Since calling this function is not a user interaction, this does not emit the \ref
+  selectionChangedByUser signal. The individual selectionChanged signals are emitted though, if the
+  objects were previously selected.
+  
+  \see setInteractions, selectedPlottables, selectedItems, selectedAxes, selectedLegends
+*/
+void QCustomPlot::deselectAll()
+{
+  foreach (QCPLayer *layer, mLayers)
+  {
+    foreach (QCPLayerable *layerable, layer->children())
+      layerable->deselectEvent(0);
+  }
+}
+
+/*!
+  Causes a complete replot into the internal buffer. Finally, update() is called, to redraw the
+  buffer on the QCustomPlot widget surface. This is the method that must be called to make changes,
+  for example on the axis ranges or data points of graphs, visible.
+  
+  Under a few circumstances, QCustomPlot causes a replot by itself. Those are resize events of the
+  QCustomPlot widget and user interactions (object selection and range dragging/zooming).
+  
+  Before the replot happens, the signal \ref beforeReplot is emitted. After the replot, \ref
+  afterReplot is emitted. It is safe to mutually connect the replot slot with any of those two
+  signals on two QCustomPlots to make them replot synchronously, it won't cause an infinite
+  recursion.
+*/
+void QCustomPlot::replot(QCustomPlot::RefreshPriority refreshPriority)
+{
+  if (mReplotting) // incase signals loop back to replot slot
+    return;
+  mReplotting = true;
+  emit beforeReplot();
+  
+  mPaintBuffer.fill(mBackgroundBrush.style() == Qt::SolidPattern ? mBackgroundBrush.color() : Qt::transparent);
+  QCPPainter painter;
+  painter.begin(&mPaintBuffer);
+  if (painter.isActive())
+  {
+    painter.setRenderHint(QPainter::HighQualityAntialiasing); // to make Antialiasing look good if using the OpenGL graphicssystem
+    if (mBackgroundBrush.style() != Qt::SolidPattern && mBackgroundBrush.style() != Qt::NoBrush)
+      painter.fillRect(mViewport, mBackgroundBrush);
+    draw(&painter);
+    painter.end();
+    if ((refreshPriority == rpHint && mPlottingHints.testFlag(QCP::phForceRepaint)) || refreshPriority==rpImmediate)
+      repaint();
+    else
+      update();
+  } else // might happen if QCustomPlot has width or height zero
+    qDebug() << Q_FUNC_INFO << "Couldn't activate painter on buffer. This usually happens because QCustomPlot has width or height zero.";
+  
+  emit afterReplot();
+  mReplotting = false;
+}
+
+/*!
+  Rescales the axes such that all plottables (like graphs) in the plot are fully visible.
+  
+  if \a onlyVisiblePlottables is set to true, only the plottables that have their visibility set to true
+  (QCPLayerable::setVisible), will be used to rescale the axes.
+  
+  \see QCPAbstractPlottable::rescaleAxes, QCPAxis::rescale
+*/
+void QCustomPlot::rescaleAxes(bool onlyVisiblePlottables)
+{
+  QList<QCPAxis*> allAxes;
+  foreach (QCPAxisRect *rect, axisRects())
+    allAxes << rect->axes();
+  
+  foreach (QCPAxis *axis, allAxes)
+    axis->rescale(onlyVisiblePlottables);
+}
+
+/*!
+  Saves a PDF with the vectorized plot to the file \a fileName. The axis ratio as well as the scale
+  of texts and lines will be derived from the specified \a width and \a height. This means, the
+  output will look like the normal on-screen output of a QCustomPlot widget with the corresponding
+  pixel width and height. If either \a width or \a height is zero, the exported image will have the
+  same dimensions as the QCustomPlot widget currently has.
+
+  \a noCosmeticPen disables the use of cosmetic pens when drawing to the PDF file. Cosmetic pens
+  are pens with numerical width 0, which are always drawn as a one pixel wide line, no matter what
+  zoom factor is set in the PDF-Viewer. For more information about cosmetic pens, see the QPainter
+  and QPen documentation.
+  
+  The objects of the plot will appear in the current selection state. If you don't want any
+  selected objects to be painted in their selected look, deselect everything with \ref deselectAll
+  before calling this function.
+
+  Returns true on success.
+  
+  \warning
+  \li If you plan on editing the exported PDF file with a vector graphics editor like
+  Inkscape, it is advised to set \a noCosmeticPen to true to avoid losing those cosmetic lines
+  (which might be quite many, because cosmetic pens are the default for e.g. axes and tick marks).
+  \li If calling this function inside the constructor of the parent of the QCustomPlot widget
+  (i.e. the MainWindow constructor, if QCustomPlot is inside the MainWindow), always provide
+  explicit non-zero widths and heights. If you leave \a width or \a height as 0 (default), this
+  function uses the current width and height of the QCustomPlot widget. However, in Qt, these
+  aren't defined yet inside the constructor, so you would get an image that has strange
+  widths/heights.
+  
+  \a pdfCreator and \a pdfTitle may be used to set the according metadata fields in the resulting
+  PDF file.
+  
+  \note On Android systems, this method does nothing and issues an according qDebug warning
+  message. This is also the case if for other reasons the define flag QT_NO_PRINTER is set.
+  
+  \see savePng, saveBmp, saveJpg, saveRastered
+*/
+bool QCustomPlot::savePdf(const QString &fileName, bool noCosmeticPen, int width, int height, const QString &pdfCreator, const QString &pdfTitle)
+{
+  bool success = false;
+#ifdef QT_NO_PRINTER
+  Q_UNUSED(fileName)
+  Q_UNUSED(noCosmeticPen)
+  Q_UNUSED(width)
+  Q_UNUSED(height)
+  Q_UNUSED(pdfCreator)
+  Q_UNUSED(pdfTitle)
+  qDebug() << Q_FUNC_INFO << "Qt was built without printer support (QT_NO_PRINTER). PDF not created.";
+#else
+  int newWidth, newHeight;
+  if (width == 0 || height == 0)
+  {
+    newWidth = this->width();
+    newHeight = this->height();
+  } else
+  {
+    newWidth = width;
+    newHeight = height;
+  }
+  
+  QPrinter printer(QPrinter::ScreenResolution);
+  printer.setOutputFileName(fileName);
+  printer.setOutputFormat(QPrinter::PdfFormat);
+  printer.setColorMode(QPrinter::Color);
+  printer.printEngine()->setProperty(QPrintEngine::PPK_Creator, pdfCreator);
+  printer.printEngine()->setProperty(QPrintEngine::PPK_DocumentName, pdfTitle);
+  QRect oldViewport = viewport();
+  setViewport(QRect(0, 0, newWidth, newHeight));
+#if QT_VERSION < QT_VERSION_CHECK(5, 3, 0)
+  printer.setFullPage(true);
+  printer.setPaperSize(viewport().size(), QPrinter::DevicePixel);
+#else
+  QPageLayout pageLayout;
+  pageLayout.setMode(QPageLayout::FullPageMode);
+  pageLayout.setOrientation(QPageLayout::Portrait);
+  pageLayout.setMargins(QMarginsF(0, 0, 0, 0));
+  pageLayout.setPageSize(QPageSize(viewport().size(), QPageSize::Point, QString(), QPageSize::ExactMatch));
+  printer.setPageLayout(pageLayout);
+#endif
+  QCPPainter printpainter;
+  if (printpainter.begin(&printer))
+  {
+    printpainter.setMode(QCPPainter::pmVectorized);
+    printpainter.setMode(QCPPainter::pmNoCaching);
+    printpainter.setMode(QCPPainter::pmNonCosmetic, noCosmeticPen);
+    printpainter.setWindow(mViewport);
+    if (mBackgroundBrush.style() != Qt::NoBrush &&
+        mBackgroundBrush.color() != Qt::white &&
+        mBackgroundBrush.color() != Qt::transparent &&
+        mBackgroundBrush.color().alpha() > 0) // draw pdf background color if not white/transparent
+      printpainter.fillRect(viewport(), mBackgroundBrush);
+    draw(&printpainter);
+    printpainter.end();
+    success = true;
+  }
+  setViewport(oldViewport);
+#endif // QT_NO_PRINTER
+  return success;
+}
+
+/*!
+  Saves a PNG image file to \a fileName on disc. The output plot will have the dimensions \a width
+  and \a height in pixels. If either \a width or \a height is zero, the exported image will have
+  the same dimensions as the QCustomPlot widget currently has. Line widths and texts etc. are not
+  scaled up when larger widths/heights are used. If you want that effect, use the \a scale parameter.
+
+  For example, if you set both \a width and \a height to 100 and \a scale to 2, you will end up with an
+  image file of size 200*200 in which all graphical elements are scaled up by factor 2 (line widths,
+  texts, etc.). This scaling is not done by stretching a 100*100 image, the result will have full
+  200*200 pixel resolution.
+  
+  If you use a high scaling factor, it is recommended to enable antialiasing for all elements via
+  temporarily setting \ref QCustomPlot::setAntialiasedElements to \ref QCP::aeAll as this allows
+  QCustomPlot to place objects with sub-pixel accuracy.
+
+  \warning If calling this function inside the constructor of the parent of the QCustomPlot widget
+  (i.e. the MainWindow constructor, if QCustomPlot is inside the MainWindow), always provide
+  explicit non-zero widths and heights. If you leave \a width or \a height as 0 (default), this
+  function uses the current width and height of the QCustomPlot widget. However, in Qt, these
+  aren't defined yet inside the constructor, so you would get an image that has strange
+  widths/heights.
+  
+  The objects of the plot will appear in the current selection state. If you don't want any selected
+  objects to be painted in their selected look, deselect everything with \ref deselectAll before calling
+  this function.
+
+  If you want the PNG to have a transparent background, call \ref setBackground(const QBrush
+  &brush) with no brush (Qt::NoBrush) or a transparent color (Qt::transparent), before saving.
+
+  PNG compression can be controlled with the \a quality parameter which must be between 0 and 100 or
+  -1 to use the default setting.
+  
+  Returns true on success. If this function fails, most likely the PNG format isn't supported by
+  the system, see Qt docs about QImageWriter::supportedImageFormats().
+
+  \see savePdf, saveBmp, saveJpg, saveRastered
+*/
+bool QCustomPlot::savePng(const QString &fileName, int width, int height, double scale, int quality)
+{
+  return saveRastered(fileName, width, height, scale, "PNG", quality);
+}
+
+/*!
+  Saves a JPG image file to \a fileName on disc. The output plot will have the dimensions \a width
+  and \a height in pixels. If either \a width or \a height is zero, the exported image will have
+  the same dimensions as the QCustomPlot widget currently has. Line widths and texts etc. are not
+  scaled up when larger widths/heights are used. If you want that effect, use the \a scale parameter.
+
+  For example, if you set both \a width and \a height to 100 and \a scale to 2, you will end up with an
+  image file of size 200*200 in which all graphical elements are scaled up by factor 2 (line widths,
+  texts, etc.). This scaling is not done by stretching a 100*100 image, the result will have full
+  200*200 pixel resolution.
+  
+  If you use a high scaling factor, it is recommended to enable antialiasing for all elements via
+  temporarily setting \ref QCustomPlot::setAntialiasedElements to \ref QCP::aeAll as this allows
+  QCustomPlot to place objects with sub-pixel accuracy.
+
+  \warning If calling this function inside the constructor of the parent of the QCustomPlot widget
+  (i.e. the MainWindow constructor, if QCustomPlot is inside the MainWindow), always provide
+  explicit non-zero widths and heights. If you leave \a width or \a height as 0 (default), this
+  function uses the current width and height of the QCustomPlot widget. However, in Qt, these
+  aren't defined yet inside the constructor, so you would get an image that has strange
+  widths/heights.
+
+  The objects of the plot will appear in the current selection state. If you don't want any selected
+  objects to be painted in their selected look, deselect everything with \ref deselectAll before calling
+  this function.
+
+  JPG compression can be controlled with the \a quality parameter which must be between 0 and 100 or
+  -1 to use the default setting.
+  
+  Returns true on success. If this function fails, most likely the JPG format isn't supported by
+  the system, see Qt docs about QImageWriter::supportedImageFormats().
+
+  \see savePdf, savePng, saveBmp, saveRastered
+*/
+bool QCustomPlot::saveJpg(const QString &fileName, int width, int height, double scale, int quality)
+{
+  return saveRastered(fileName, width, height, scale, "JPG", quality);
+}
+
+/*!
+  Saves a BMP image file to \a fileName on disc. The output plot will have the dimensions \a width
+  and \a height in pixels. If either \a width or \a height is zero, the exported image will have
+  the same dimensions as the QCustomPlot widget currently has. Line widths and texts etc. are not
+  scaled up when larger widths/heights are used. If you want that effect, use the \a scale parameter.
+
+  For example, if you set both \a width and \a height to 100 and \a scale to 2, you will end up with an
+  image file of size 200*200 in which all graphical elements are scaled up by factor 2 (line widths,
+  texts, etc.). This scaling is not done by stretching a 100*100 image, the result will have full
+  200*200 pixel resolution.
+  
+  If you use a high scaling factor, it is recommended to enable antialiasing for all elements via
+  temporarily setting \ref QCustomPlot::setAntialiasedElements to \ref QCP::aeAll as this allows
+  QCustomPlot to place objects with sub-pixel accuracy.
+
+  \warning If calling this function inside the constructor of the parent of the QCustomPlot widget
+  (i.e. the MainWindow constructor, if QCustomPlot is inside the MainWindow), always provide
+  explicit non-zero widths and heights. If you leave \a width or \a height as 0 (default), this
+  function uses the current width and height of the QCustomPlot widget. However, in Qt, these
+  aren't defined yet inside the constructor, so you would get an image that has strange
+  widths/heights.
+
+  The objects of the plot will appear in the current selection state. If you don't want any selected
+  objects to be painted in their selected look, deselect everything with \ref deselectAll before calling
+  this function.
+  
+  Returns true on success. If this function fails, most likely the BMP format isn't supported by
+  the system, see Qt docs about QImageWriter::supportedImageFormats().
+
+  \see savePdf, savePng, saveJpg, saveRastered
+*/
+bool QCustomPlot::saveBmp(const QString &fileName, int width, int height, double scale)
+{
+  return saveRastered(fileName, width, height, scale, "BMP");
+}
+
+/*! \internal
+  
+  Returns a minimum size hint that corresponds to the minimum size of the top level layout
+  (\ref plotLayout). To prevent QCustomPlot from being collapsed to size/width zero, set a minimum
+  size (setMinimumSize) either on the whole QCustomPlot or on any layout elements inside the plot.
+  This is especially important, when placed in a QLayout where other components try to take in as
+  much space as possible (e.g. QMdiArea).
+*/
+QSize QCustomPlot::minimumSizeHint() const
+{
+  return mPlotLayout->minimumSizeHint();
+}
+
+/*! \internal
+  
+  Returns a size hint that is the same as \ref minimumSizeHint.
+  
+*/
+QSize QCustomPlot::sizeHint() const
+{
+  return mPlotLayout->minimumSizeHint();
+}
+
+/*! \internal
+  
+  Event handler for when the QCustomPlot widget needs repainting. This does not cause a \ref replot, but
+  draws the internal buffer on the widget surface.
+*/
+void QCustomPlot::paintEvent(QPaintEvent *event)
+{
+  Q_UNUSED(event);
+  QPainter painter(this);
+  painter.drawPixmap(0, 0, mPaintBuffer);
+}
+
+/*! \internal
+  
+  Event handler for a resize of the QCustomPlot widget. Causes the internal buffer to be resized to
+  the new size. The viewport (which becomes the outer rect of mPlotLayout) is resized
+  appropriately. Finally a \ref replot is performed.
+*/
+void QCustomPlot::resizeEvent(QResizeEvent *event)
+{
+  // resize and repaint the buffer:
+  mPaintBuffer = QPixmap(event->size());
+  setViewport(rect());
+  replot(rpQueued); // queued update is important here, to prevent painting issues in some contexts
+}
+
+/*! \internal
+  
+ Event handler for when a double click occurs. Emits the \ref mouseDoubleClick signal, then emits
+ the specialized signals when certain objecs are clicked (e.g. \ref plottableDoubleClick, \ref
+ axisDoubleClick, etc.). Finally determines the affected layout element and forwards the event to
+ it.
+ 
+ \see mousePressEvent, mouseReleaseEvent
+*/
+void QCustomPlot::mouseDoubleClickEvent(QMouseEvent *event)
+{
+  emit mouseDoubleClick(event);
+  
+  QVariant details;
+  QCPLayerable *clickedLayerable = layerableAt(event->pos(), false, &details);
+  
+  // emit specialized object double click signals:
+  if (QCPAbstractPlottable *ap = qobject_cast<QCPAbstractPlottable*>(clickedLayerable))
+    emit plottableDoubleClick(ap, event);
+  else if (QCPAxis *ax = qobject_cast<QCPAxis*>(clickedLayerable))
+    emit axisDoubleClick(ax, details.value<QCPAxis::SelectablePart>(), event);
+  else if (QCPAbstractItem *ai = qobject_cast<QCPAbstractItem*>(clickedLayerable))
+    emit itemDoubleClick(ai, event);
+  else if (QCPLegend *lg = qobject_cast<QCPLegend*>(clickedLayerable))
+    emit legendDoubleClick(lg, 0, event);
+  else if (QCPAbstractLegendItem *li = qobject_cast<QCPAbstractLegendItem*>(clickedLayerable))
+    emit legendDoubleClick(li->parentLegend(), li, event);
+  else if (QCPPlotTitle *pt = qobject_cast<QCPPlotTitle*>(clickedLayerable))
+    emit titleDoubleClick(event, pt);
+  
+  // call double click event of affected layout element:
+  if (QCPLayoutElement *el = layoutElementAt(event->pos()))
+    el->mouseDoubleClickEvent(event);
+  
+  // call release event of affected layout element (as in mouseReleaseEvent, since the mouseDoubleClick replaces the second release event in double click case):
+  if (mMouseEventElement)
+  {
+    mMouseEventElement->mouseReleaseEvent(event);
+    mMouseEventElement = 0;
+  }
+  
+  //QWidget::mouseDoubleClickEvent(event); don't call base class implementation because it would just cause a mousePress/ReleaseEvent, which we don't want.
+}
+
+/*! \internal
+  
+  Event handler for when a mouse button is pressed. Emits the mousePress signal. Then determines
+  the affected layout element and forwards the event to it.
+  
+  \see mouseMoveEvent, mouseReleaseEvent
+*/
+void QCustomPlot::mousePressEvent(QMouseEvent *event)
+{
+  emit mousePress(event);
+  mMousePressPos = event->pos(); // need this to determine in releaseEvent whether it was a click (no position change between press and release)
+  
+  // call event of affected layout element:
+  mMouseEventElement = layoutElementAt(event->pos());
+  if (mMouseEventElement)
+    mMouseEventElement->mousePressEvent(event);
+  
+  QWidget::mousePressEvent(event);
+}
+
+/*! \internal
+  
+  Event handler for when the cursor is moved. Emits the \ref mouseMove signal.
+
+  If a layout element has mouse capture focus (a mousePressEvent happened on top of the layout
+  element before), the mouseMoveEvent is forwarded to that element.
+  
+  \see mousePressEvent, mouseReleaseEvent
+*/
+void QCustomPlot::mouseMoveEvent(QMouseEvent *event)
+{
+  emit mouseMove(event);
+
+  // call event of affected layout element:
+  if (mMouseEventElement)
+    mMouseEventElement->mouseMoveEvent(event);
+  
+  QWidget::mouseMoveEvent(event);
+}
+
+/*! \internal
+  
+  Event handler for when a mouse button is released. Emits the \ref mouseRelease signal.
+  
+  If the mouse was moved less than a certain threshold in any direction since the \ref
+  mousePressEvent, it is considered a click which causes the selection mechanism (if activated via
+  \ref setInteractions) to possibly change selection states accordingly. Further, specialized mouse
+  click signals are emitted (e.g. \ref plottableClick, \ref axisClick, etc.)
+  
+  If a layout element has mouse capture focus (a \ref mousePressEvent happened on top of the layout
+  element before), the \ref mouseReleaseEvent is forwarded to that element.
+  
+  \see mousePressEvent, mouseMoveEvent
+*/
+void QCustomPlot::mouseReleaseEvent(QMouseEvent *event)
+{
+  emit mouseRelease(event);
+  bool doReplot = false;
+  
+  if ((mMousePressPos-event->pos()).manhattanLength() < 5) // determine whether it was a click operation
+  {
+    if (event->button() == Qt::LeftButton)
+    {
+      // handle selection mechanism:
+      QVariant details;
+      QCPLayerable *clickedLayerable = layerableAt(event->pos(), true, &details);
+      bool selectionStateChanged = false;
+      bool additive = mInteractions.testFlag(QCP::iMultiSelect) && event->modifiers().testFlag(mMultiSelectModifier);
+      // deselect all other layerables if not additive selection:
+      if (!additive)
+      {
+        foreach (QCPLayer *layer, mLayers)
+        {
+          foreach (QCPLayerable *layerable, layer->children())
+          {
+            if (layerable != clickedLayerable && mInteractions.testFlag(layerable->selectionCategory()))
+            {
+              bool selChanged = false;
+              layerable->deselectEvent(&selChanged);
+              selectionStateChanged |= selChanged;
+            }
+          }
+        }
+      }
+      if (clickedLayerable && mInteractions.testFlag(clickedLayerable->selectionCategory()))
+      {
+        // a layerable was actually clicked, call its selectEvent:
+        bool selChanged = false;
+        clickedLayerable->selectEvent(event, additive, details, &selChanged);
+        selectionStateChanged |= selChanged;
+      }
+      if (selectionStateChanged)
+      {
+        doReplot = true;
+        emit selectionChangedByUser();
+      }
+    }
+    
+    // emit specialized object click signals:
+    QVariant details;
+    QCPLayerable *clickedLayerable = layerableAt(event->pos(), false, &details); // for these signals, selectability is ignored, that's why we call this again with onlySelectable set to false
+    if (QCPAbstractPlottable *ap = qobject_cast<QCPAbstractPlottable*>(clickedLayerable))
+      emit plottableClick(ap, event);
+    else if (QCPAxis *ax = qobject_cast<QCPAxis*>(clickedLayerable))
+      emit axisClick(ax, details.value<QCPAxis::SelectablePart>(), event);
+    else if (QCPAbstractItem *ai = qobject_cast<QCPAbstractItem*>(clickedLayerable))
+      emit itemClick(ai, event);
+    else if (QCPLegend *lg = qobject_cast<QCPLegend*>(clickedLayerable))
+      emit legendClick(lg, 0, event);
+    else if (QCPAbstractLegendItem *li = qobject_cast<QCPAbstractLegendItem*>(clickedLayerable))
+      emit legendClick(li->parentLegend(), li, event);
+    else if (QCPPlotTitle *pt = qobject_cast<QCPPlotTitle*>(clickedLayerable))
+      emit titleClick(event, pt);
+  }
+  
+  // call event of affected layout element:
+  if (mMouseEventElement)
+  {
+    mMouseEventElement->mouseReleaseEvent(event);
+    mMouseEventElement = 0;
+  }
+  
+  if (doReplot || noAntialiasingOnDrag())
+    replot();
+  
+  QWidget::mouseReleaseEvent(event);
+}
+
+/*! \internal
+  
+  Event handler for mouse wheel events. First, the \ref mouseWheel signal is emitted. Then
+  determines the affected layout element and forwards the event to it.
+  
+*/
+void QCustomPlot::wheelEvent(QWheelEvent *event)
+{
+  emit mouseWheel(event);
+  
+  // call event of affected layout element:
+  if (QCPLayoutElement *el = layoutElementAt(event->pos()))
+    el->wheelEvent(event);
+  
+  QWidget::wheelEvent(event);
+}
+
+/*! \internal
+  
+  This is the main draw function. It draws the entire plot, including background pixmap, with the
+  specified \a painter. Note that it does not fill the background with the background brush (as the
+  user may specify with \ref setBackground(const QBrush &brush)), this is up to the respective
+  functions calling this method (e.g. \ref replot, \ref toPixmap and \ref toPainter).
+*/
+void QCustomPlot::draw(QCPPainter *painter)
+{
+  // run through layout phases:
+  mPlotLayout->update(QCPLayoutElement::upPreparation);
+  mPlotLayout->update(QCPLayoutElement::upMargins);
+  mPlotLayout->update(QCPLayoutElement::upLayout);
+  
+  // draw viewport background pixmap:
+  drawBackground(painter);
+
+  // draw all layered objects (grid, axes, plottables, items, legend,...):
+  foreach (QCPLayer *layer, mLayers)
+  {
+    foreach (QCPLayerable *child, layer->children())
+    {
+      if (child->realVisibility())
+      {
+        painter->save();
+        painter->setClipRect(child->clipRect().translated(0, -1));
+        child->applyDefaultAntialiasingHint(painter);
+        child->draw(painter);
+        painter->restore();
+      }
+    }
+  }
+  
+  /* Debug code to draw all layout element rects
+  foreach (QCPLayoutElement* el, findChildren<QCPLayoutElement*>())
+  {
+    painter->setBrush(Qt::NoBrush);
+    painter->setPen(QPen(QColor(0, 0, 0, 100), 0, Qt::DashLine));
+    painter->drawRect(el->rect());
+    painter->setPen(QPen(QColor(255, 0, 0, 100), 0, Qt::DashLine));
+    painter->drawRect(el->outerRect());
+  }
+  */
+}
+
+/*! \internal
+  
+  Draws the viewport background pixmap of the plot.
+  
+  If a pixmap was provided via \ref setBackground, this function buffers the scaled version
+  depending on \ref setBackgroundScaled and \ref setBackgroundScaledMode and then draws it inside
+  the viewport with the provided \a painter. The scaled version is buffered in
+  mScaledBackgroundPixmap to prevent expensive rescaling at every redraw. It is only updated, when
+  the axis rect has changed in a way that requires a rescale of the background pixmap (this is
+  dependent on the \ref setBackgroundScaledMode), or when a differend axis background pixmap was
+  set.
+  
+  Note that this function does not draw a fill with the background brush (\ref setBackground(const
+  QBrush &brush)) beneath the pixmap.
+  
+  \see setBackground, setBackgroundScaled, setBackgroundScaledMode
+*/
+void QCustomPlot::drawBackground(QCPPainter *painter)
+{
+  // Note: background color is handled in individual replot/save functions
+
+  // draw background pixmap (on top of fill, if brush specified):
+  if (!mBackgroundPixmap.isNull())
+  {
+    if (mBackgroundScaled)
+    {
+      // check whether mScaledBackground needs to be updated:
+      QSize scaledSize(mBackgroundPixmap.size());
+      scaledSize.scale(mViewport.size(), mBackgroundScaledMode);
+      if (mScaledBackgroundPixmap.size() != scaledSize)
+        mScaledBackgroundPixmap = mBackgroundPixmap.scaled(mViewport.size(), mBackgroundScaledMode, Qt::SmoothTransformation);
+      painter->drawPixmap(mViewport.topLeft(), mScaledBackgroundPixmap, QRect(0, 0, mViewport.width(), mViewport.height()) & mScaledBackgroundPixmap.rect());
+    } else
+    {
+      painter->drawPixmap(mViewport.topLeft(), mBackgroundPixmap, QRect(0, 0, mViewport.width(), mViewport.height()));
+    }
+  }
+}
+
+
+/*! \internal
+  
+  This method is used by \ref QCPAxisRect::removeAxis to report removed axes to the QCustomPlot
+  so it may clear its QCustomPlot::xAxis, yAxis, xAxis2 and yAxis2 members accordingly.
+*/
+void QCustomPlot::axisRemoved(QCPAxis *axis)
+{
+  if (xAxis == axis)
+    xAxis = 0;
+  if (xAxis2 == axis)
+    xAxis2 = 0;
+  if (yAxis == axis)
+    yAxis = 0;
+  if (yAxis2 == axis)
+    yAxis2 = 0;
+  
+  // Note: No need to take care of range drag axes and range zoom axes, because they are stored in smart pointers
+}
+
+/*! \internal
+  
+  This method is used by the QCPLegend destructor to report legend removal to the QCustomPlot so
+  it may clear its QCustomPlot::legend member accordingly.
+*/
+void QCustomPlot::legendRemoved(QCPLegend *legend)
+{
+  if (this->legend == legend)
+    this->legend = 0;
+}
+
+/*! \internal
+  
+  Assigns all layers their index (QCPLayer::mIndex) in the mLayers list. This method is thus called
+  after every operation that changes the layer indices, like layer removal, layer creation, layer
+  moving.
+*/
+void QCustomPlot::updateLayerIndices() const
+{
+  for (int i=0; i<mLayers.size(); ++i)
+    mLayers.at(i)->mIndex = i;
+}
+
+/*! \internal
+  
+  Returns the layerable at pixel position \a pos. If \a onlySelectable is set to true, only those
+  layerables that are selectable will be considered. (Layerable subclasses communicate their
+  selectability via the QCPLayerable::selectTest method, by returning -1.)
+
+  \a selectionDetails is an output parameter that contains selection specifics of the affected
+  layerable. This is useful if the respective layerable shall be given a subsequent
+  QCPLayerable::selectEvent (like in \ref mouseReleaseEvent). \a selectionDetails usually contains
+  information about which part of the layerable was hit, in multi-part layerables (e.g.
+  QCPAxis::SelectablePart).
+*/
+QCPLayerable *QCustomPlot::layerableAt(const QPointF &pos, bool onlySelectable, QVariant *selectionDetails) const
+{
+  for (int layerIndex=mLayers.size()-1; layerIndex>=0; --layerIndex)
+  {
+    const QList<QCPLayerable*> layerables = mLayers.at(layerIndex)->children();
+    double minimumDistance = selectionTolerance()*1.1;
+    QCPLayerable *minimumDistanceLayerable = 0;
+    for (int i=layerables.size()-1; i>=0; --i)
+    {
+      if (!layerables.at(i)->realVisibility())
+        continue;
+      QVariant details;
+      double dist = layerables.at(i)->selectTest(pos, onlySelectable, &details);
+      if (dist >= 0 && dist < minimumDistance)
+      {
+        minimumDistance = dist;
+        minimumDistanceLayerable = layerables.at(i);
+        if (selectionDetails) *selectionDetails = details;
+      }
+    }
+    if (minimumDistance < selectionTolerance())
+      return minimumDistanceLayerable;
+  }
+  return 0;
+}
+
+/*!
+  Saves the plot to a rastered image file \a fileName in the image format \a format. The plot is
+  sized to \a width and \a height in pixels and scaled with \a scale. (width 100 and scale 2.0 lead
+  to a full resolution file with width 200.) If the \a format supports compression, \a quality may
+  be between 0 and 100 to control it.
+  
+  Returns true on success. If this function fails, most likely the given \a format isn't supported
+  by the system, see Qt docs about QImageWriter::supportedImageFormats().
+  
+  \see saveBmp, saveJpg, savePng, savePdf
+*/
+bool QCustomPlot::saveRastered(const QString &fileName, int width, int height, double scale, const char *format, int quality)
+{
+  QPixmap buffer = toPixmap(width, height, scale);
+  if (!buffer.isNull())
+    return buffer.save(fileName, format, quality);
+  else
+    return false;
+}
+
+/*!
+  Renders the plot to a pixmap and returns it.
+  
+  The plot is sized to \a width and \a height in pixels and scaled with \a scale. (width 100 and
+  scale 2.0 lead to a full resolution pixmap with width 200.)
+  
+  \see toPainter, saveRastered, saveBmp, savePng, saveJpg, savePdf
+*/
+QPixmap QCustomPlot::toPixmap(int width, int height, double scale)
+{
+  // this method is somewhat similar to toPainter. Change something here, and a change in toPainter might be necessary, too.
+  int newWidth, newHeight;
+  if (width == 0 || height == 0)
+  {
+    newWidth = this->width();
+    newHeight = this->height();
+  } else
+  {
+    newWidth = width;
+    newHeight = height;
+  }
+  int scaledWidth = qRound(scale*newWidth);
+  int scaledHeight = qRound(scale*newHeight);
+
+  QPixmap result(scaledWidth, scaledHeight);
+  result.fill(mBackgroundBrush.style() == Qt::SolidPattern ? mBackgroundBrush.color() : Qt::transparent); // if using non-solid pattern, make transparent now and draw brush pattern later
+  QCPPainter painter;
+  painter.begin(&result);
+  if (painter.isActive())
+  {
+    QRect oldViewport = viewport();
+    setViewport(QRect(0, 0, newWidth, newHeight));
+    painter.setMode(QCPPainter::pmNoCaching);
+    if (!qFuzzyCompare(scale, 1.0))
+    {
+      if (scale > 1.0) // for scale < 1 we always want cosmetic pens where possible, because else lines might disappear for very small scales
+        painter.setMode(QCPPainter::pmNonCosmetic);
+      painter.scale(scale, scale);
+    }
+    if (mBackgroundBrush.style() != Qt::SolidPattern && mBackgroundBrush.style() != Qt::NoBrush) // solid fills were done a few lines above with QPixmap::fill
+      painter.fillRect(mViewport, mBackgroundBrush);
+    draw(&painter);
+    setViewport(oldViewport);
+    painter.end();
+  } else // might happen if pixmap has width or height zero
+  {
+    qDebug() << Q_FUNC_INFO << "Couldn't activate painter on pixmap";
+    return QPixmap();
+  }
+  return result;
+}
+
+/*!
+  Renders the plot using the passed \a painter.
+  
+  The plot is sized to \a width and \a height in pixels. If the \a painter's scale is not 1.0, the resulting plot will
+  appear scaled accordingly.
+  
+  \note If you are restricted to using a QPainter (instead of QCPPainter), create a temporary QPicture and open a QCPPainter
+  on it. Then call \ref toPainter with this QCPPainter. After ending the paint operation on the picture, draw it with
+  the QPainter. This will reproduce the painter actions the QCPPainter took, with a QPainter.
+  
+  \see toPixmap
+*/
+void QCustomPlot::toPainter(QCPPainter *painter, int width, int height)
+{
+  // this method is somewhat similar to toPixmap. Change something here, and a change in toPixmap might be necessary, too.
+  int newWidth, newHeight;
+  if (width == 0 || height == 0)
+  {
+    newWidth = this->width();
+    newHeight = this->height();
+  } else
+  {
+    newWidth = width;
+    newHeight = height;
+  }
+
+  if (painter->isActive())
+  {
+    QRect oldViewport = viewport();
+    setViewport(QRect(0, 0, newWidth, newHeight));
+    painter->setMode(QCPPainter::pmNoCaching);
+    if (mBackgroundBrush.style() != Qt::NoBrush) // unlike in toPixmap, we can't do QPixmap::fill for Qt::SolidPattern brush style, so we also draw solid fills with fillRect here
+      painter->fillRect(mViewport, mBackgroundBrush);
+    draw(painter);
+    setViewport(oldViewport);
+  } else
+    qDebug() << Q_FUNC_INFO << "Passed painter is not active";
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPColorGradient
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPColorGradient
+  \brief Defines a color gradient for use with e.g. \ref QCPColorMap
+  
+  This class describes a color gradient which can be used to encode data with color. For example,
+  QCPColorMap and QCPColorScale have \ref QCPColorMap::setGradient "setGradient" methods which
+  take an instance of this class. Colors are set with \ref setColorStopAt(double position, const QColor &color)
+  with a \a position from 0 to 1. In between these defined color positions, the
+  color will be interpolated linearly either in RGB or HSV space, see \ref setColorInterpolation.
+
+  Alternatively, load one of the preset color gradients shown in the image below, with \ref
+  loadPreset, or by directly specifying the preset in the constructor.
+  
+  \image html QCPColorGradient.png
+  
+  The fact that the \ref QCPColorGradient(GradientPreset preset) constructor allows directly
+  converting a \ref GradientPreset to a QCPColorGradient, you can also directly pass \ref
+  GradientPreset to all the \a setGradient methods, e.g.:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpcolorgradient-setgradient
+  
+  The total number of levels used in the gradient can be set with \ref setLevelCount. Whether the
+  color gradient shall be applied periodically (wrapping around) to data values that lie outside
+  the data range specified on the plottable instance can be controlled with \ref setPeriodic.
+*/
+
+/*!
+  Constructs a new QCPColorGradient initialized with the colors and color interpolation according
+  to \a preset.
+  
+  The color level count is initialized to 350.
+*/
+QCPColorGradient::QCPColorGradient(GradientPreset preset) :
+  mLevelCount(350),
+  mColorInterpolation(ciRGB),
+  mPeriodic(false),
+  mColorBufferInvalidated(true)
+{
+  mColorBuffer.fill(qRgb(0, 0, 0), mLevelCount);
+  loadPreset(preset);
+}
+
+/* undocumented operator */
+bool QCPColorGradient::operator==(const QCPColorGradient &other) const
+{
+  return ((other.mLevelCount == this->mLevelCount) &&
+          (other.mColorInterpolation == this->mColorInterpolation) &&
+          (other.mPeriodic == this->mPeriodic) &&
+          (other.mColorStops == this->mColorStops));
+}
+
+/*!
+  Sets the number of discretization levels of the color gradient to \a n. The default is 350 which
+  is typically enough to create a smooth appearance.
+  
+  \image html QCPColorGradient-levelcount.png
+*/
+void QCPColorGradient::setLevelCount(int n)
+{
+  if (n < 2)
+  {
+    qDebug() << Q_FUNC_INFO << "n must be greater or equal 2 but was" << n;
+    n = 2;
+  }
+  if (n != mLevelCount)
+  {
+    mLevelCount = n;
+    mColorBufferInvalidated = true;
+  }
+}
+
+/*!
+  Sets at which positions from 0 to 1 which color shall occur. The positions are the keys, the
+  colors are the values of the passed QMap \a colorStops. In between these color stops, the color
+  is interpolated according to \ref setColorInterpolation.
+  
+  A more convenient way to create a custom gradient may be to clear all color stops with \ref
+  clearColorStops and then adding them one by one with \ref setColorStopAt.
+  
+  \see clearColorStops
+*/
+void QCPColorGradient::setColorStops(const QMap<double, QColor> &colorStops)
+{
+  mColorStops = colorStops;
+  mColorBufferInvalidated = true;
+}
+
+/*!
+  Sets the \a color the gradient will have at the specified \a position (from 0 to 1). In between
+  these color stops, the color is interpolated according to \ref setColorInterpolation.
+  
+  \see setColorStops, clearColorStops
+*/
+void QCPColorGradient::setColorStopAt(double position, const QColor &color)
+{
+  mColorStops.insert(position, color);
+  mColorBufferInvalidated = true;
+}
+
+/*!
+  Sets whether the colors in between the configured color stops (see \ref setColorStopAt) shall be
+  interpolated linearly in RGB or in HSV color space.
+  
+  For example, a sweep in RGB space from red to green will have a muddy brown intermediate color,
+  whereas in HSV space the intermediate color is yellow.
+*/
+void QCPColorGradient::setColorInterpolation(QCPColorGradient::ColorInterpolation interpolation)
+{
+  if (interpolation != mColorInterpolation)
+  {
+    mColorInterpolation = interpolation;
+    mColorBufferInvalidated = true;
+  }
+}
+
+/*!
+  Sets whether data points that are outside the configured data range (e.g. \ref
+  QCPColorMap::setDataRange) are colored by periodically repeating the color gradient or whether
+  they all have the same color, corresponding to the respective gradient boundary color.
+  
+  \image html QCPColorGradient-periodic.png
+  
+  As shown in the image above, gradients that have the same start and end color are especially
+  suitable for a periodic gradient mapping, since they produce smooth color transitions throughout
+  the color map. A preset that has this property is \ref gpHues.
+  
+  In practice, using periodic color gradients makes sense when the data corresponds to a periodic
+  dimension, such as an angle or a phase. If this is not the case, the color encoding might become
+  ambiguous, because multiple different data values are shown as the same color.
+*/
+void QCPColorGradient::setPeriodic(bool enabled)
+{
+  mPeriodic = enabled;
+}
+
+/*!
+  This method is used to quickly convert a \a data array to colors. The colors will be output in
+  the array \a scanLine. Both \a data and \a scanLine must have the length \a n when passed to this
+  function. The data range that shall be used for mapping the data value to the gradient is passed
+  in \a range. \a logarithmic indicates whether the data values shall be mapped to colors
+  logarithmically.
+  
+  if \a data actually contains 2D-data linearized via <tt>[row*columnCount + column]</tt>, you can
+  set \a dataIndexFactor to <tt>columnCount</tt> to convert a column instead of a row of the data
+  array, in \a scanLine. \a scanLine will remain a regular (1D) array. This works because \a data
+  is addressed <tt>data[i*dataIndexFactor]</tt>.
+*/
+void QCPColorGradient::colorize(const double *data, const QCPRange &range, QRgb *scanLine, int n, int dataIndexFactor, bool logarithmic)
+{
+  // If you change something here, make sure to also adapt ::color()
+  if (!data)
+  {
+    qDebug() << Q_FUNC_INFO << "null pointer given as data";
+    return;
+  }
+  if (!scanLine)
+  {
+    qDebug() << Q_FUNC_INFO << "null pointer given as scanLine";
+    return;
+  }
+  if (mColorBufferInvalidated)
+    updateColorBuffer();
+  
+  if (!logarithmic)
+  {
+    const double posToIndexFactor = (mLevelCount-1)/range.size();
+    if (mPeriodic)
+    {
+      for (int i=0; i<n; ++i)
+      {
+        int index = (int)((data[dataIndexFactor*i]-range.lower)*posToIndexFactor) % mLevelCount;
+        if (index < 0)
+          index += mLevelCount;
+        scanLine[i] = mColorBuffer.at(index);
+      }
+    } else
+    {
+      for (int i=0; i<n; ++i)
+      {
+        int index = (data[dataIndexFactor*i]-range.lower)*posToIndexFactor;
+        if (index < 0)
+          index = 0;
+        else if (index >= mLevelCount)
+          index = mLevelCount-1;
+        scanLine[i] = mColorBuffer.at(index);
+      }
+    }
+  } else // logarithmic == true
+  {
+    if (mPeriodic)
+    {
+      for (int i=0; i<n; ++i)
+      {
+        int index = (int)(qLn(data[dataIndexFactor*i]/range.lower)/qLn(range.upper/range.lower)*(mLevelCount-1)) % mLevelCount;
+        if (index < 0)
+          index += mLevelCount;
+        scanLine[i] = mColorBuffer.at(index);
+      }
+    } else
+    {
+      for (int i=0; i<n; ++i)
+      {
+        int index = qLn(data[dataIndexFactor*i]/range.lower)/qLn(range.upper/range.lower)*(mLevelCount-1);
+        if (index < 0)
+          index = 0;
+        else if (index >= mLevelCount)
+          index = mLevelCount-1;
+        scanLine[i] = mColorBuffer.at(index);
+      }
+    }
+  }
+}
+
+/*! \internal
+  
+  This method is used to colorize a single data value given in \a position, to colors. The data
+  range that shall be used for mapping the data value to the gradient is passed in \a range. \a
+  logarithmic indicates whether the data value shall be mapped to a color logarithmically.
+  
+  If an entire array of data values shall be converted, rather use \ref colorize, for better
+  performance.
+*/
+QRgb QCPColorGradient::color(double position, const QCPRange &range, bool logarithmic)
+{
+  // If you change something here, make sure to also adapt ::colorize()
+  if (mColorBufferInvalidated)
+    updateColorBuffer();
+  int index = 0;
+  if (!logarithmic)
+    index = (position-range.lower)*(mLevelCount-1)/range.size();
+  else
+    index = qLn(position/range.lower)/qLn(range.upper/range.lower)*(mLevelCount-1);
+  if (mPeriodic)
+  {
+    index = index % mLevelCount;
+    if (index < 0)
+      index += mLevelCount;
+  } else
+  {
+    if (index < 0)
+      index = 0;
+    else if (index >= mLevelCount)
+      index = mLevelCount-1;
+  }
+  return mColorBuffer.at(index);
+}
+
+/*!
+  Clears the current color stops and loads the specified \a preset. A preset consists of predefined
+  color stops and the corresponding color interpolation method.
+  
+  The available presets are:
+  \image html QCPColorGradient.png
+*/
+void QCPColorGradient::loadPreset(GradientPreset preset)
+{
+  clearColorStops();
+  switch (preset)
+  {
+    case gpGrayscale:
+      setColorInterpolation(ciRGB);
+      setColorStopAt(0, Qt::black);
+      setColorStopAt(1, Qt::white);
+      break;
+    case gpHot:
+      setColorInterpolation(ciRGB);
+      setColorStopAt(0, QColor(50, 0, 0));
+      setColorStopAt(0.2, QColor(180, 10, 0));
+      setColorStopAt(0.4, QColor(245, 50, 0));
+      setColorStopAt(0.6, QColor(255, 150, 10));
+      setColorStopAt(0.8, QColor(255, 255, 50));
+      setColorStopAt(1, QColor(255, 255, 255));
+      break;
+    case gpCold:
+      setColorInterpolation(ciRGB);
+      setColorStopAt(0, QColor(0, 0, 50));
+      setColorStopAt(0.2, QColor(0, 10, 180));
+      setColorStopAt(0.4, QColor(0, 50, 245));
+      setColorStopAt(0.6, QColor(10, 150, 255));
+      setColorStopAt(0.8, QColor(50, 255, 255));
+      setColorStopAt(1, QColor(255, 255, 255));
+      break;
+    case gpNight:
+      setColorInterpolation(ciHSV);
+      setColorStopAt(0, QColor(10, 20, 30));
+      setColorStopAt(1, QColor(250, 255, 250));
+      break;
+    case gpCandy:
+      setColorInterpolation(ciHSV);
+      setColorStopAt(0, QColor(0, 0, 255));
+      setColorStopAt(1, QColor(255, 250, 250));
+      break;
+    case gpGeography:
+      setColorInterpolation(ciRGB);
+      setColorStopAt(0, QColor(70, 170, 210));
+      setColorStopAt(0.20, QColor(90, 160, 180));
+      setColorStopAt(0.25, QColor(45, 130, 175));
+      setColorStopAt(0.30, QColor(100, 140, 125));
+      setColorStopAt(0.5, QColor(100, 140, 100));
+      setColorStopAt(0.6, QColor(130, 145, 120));
+      setColorStopAt(0.7, QColor(140, 130, 120));
+      setColorStopAt(0.9, QColor(180, 190, 190));
+      setColorStopAt(1, QColor(210, 210, 230));
+      break;
+    case gpIon:
+      setColorInterpolation(ciHSV);
+      setColorStopAt(0, QColor(50, 10, 10));
+      setColorStopAt(0.45, QColor(0, 0, 255));
+      setColorStopAt(0.8, QColor(0, 255, 255));
+      setColorStopAt(1, QColor(0, 255, 0));
+      break;
+    case gpThermal:
+      setColorInterpolation(ciRGB);
+      setColorStopAt(0, QColor(0, 0, 50));
+      setColorStopAt(0.15, QColor(20, 0, 120));
+      setColorStopAt(0.33, QColor(200, 30, 140));
+      setColorStopAt(0.6, QColor(255, 100, 0));
+      setColorStopAt(0.85, QColor(255, 255, 40));
+      setColorStopAt(1, QColor(255, 255, 255));
+      break;
+    case gpPolar:
+      setColorInterpolation(ciRGB);
+      setColorStopAt(0, QColor(50, 255, 255));
+      setColorStopAt(0.18, QColor(10, 70, 255));
+      setColorStopAt(0.28, QColor(10, 10, 190));
+      setColorStopAt(0.5, QColor(0, 0, 0));
+      setColorStopAt(0.72, QColor(190, 10, 10));
+      setColorStopAt(0.82, QColor(255, 70, 10));
+      setColorStopAt(1, QColor(255, 255, 50));
+      break;
+    case gpSpectrum:
+      setColorInterpolation(ciHSV);
+      setColorStopAt(0, QColor(50, 0, 50));
+      setColorStopAt(0.15, QColor(0, 0, 255));
+      setColorStopAt(0.35, QColor(0, 255, 255));
+      setColorStopAt(0.6, QColor(255, 255, 0));
+      setColorStopAt(0.75, QColor(255, 30, 0));
+      setColorStopAt(1, QColor(50, 0, 0));
+      break;
+    case gpJet:
+      setColorInterpolation(ciRGB);
+      setColorStopAt(0, QColor(0, 0, 100));
+      setColorStopAt(0.15, QColor(0, 50, 255));
+      setColorStopAt(0.35, QColor(0, 255, 255));
+      setColorStopAt(0.65, QColor(255, 255, 0));
+      setColorStopAt(0.85, QColor(255, 30, 0));
+      setColorStopAt(1, QColor(100, 0, 0));
+      break;
+    case gpHues:
+      setColorInterpolation(ciHSV);
+      setColorStopAt(0, QColor(255, 0, 0));
+      setColorStopAt(1.0/3.0, QColor(0, 0, 255));
+      setColorStopAt(2.0/3.0, QColor(0, 255, 0));
+      setColorStopAt(1, QColor(255, 0, 0));
+      break;
+  }
+}
+
+/*!
+  Clears all color stops.
+  
+  \see setColorStops, setColorStopAt
+*/
+void QCPColorGradient::clearColorStops()
+{
+  mColorStops.clear();
+  mColorBufferInvalidated = true;
+}
+
+/*!
+  Returns an inverted gradient. The inverted gradient has all properties as this \ref
+  QCPColorGradient, but the order of the color stops is inverted.
+  
+  \see setColorStops, setColorStopAt
+*/
+QCPColorGradient QCPColorGradient::inverted() const
+{
+  QCPColorGradient result(*this);
+  result.clearColorStops();
+  for (QMap<double, QColor>::const_iterator it=mColorStops.constBegin(); it!=mColorStops.constEnd(); ++it)
+    result.setColorStopAt(1.0-it.key(), it.value());
+  return result;
+}
+
+/*! \internal
+  
+  Updates the internal color buffer which will be used by \ref colorize and \ref color, to quickly
+  convert positions to colors. This is where the interpolation between color stops is calculated.
+*/
+void QCPColorGradient::updateColorBuffer()
+{
+  if (mColorBuffer.size() != mLevelCount)
+    mColorBuffer.resize(mLevelCount);
+  if (mColorStops.size() > 1)
+  {
+    double indexToPosFactor = 1.0/(double)(mLevelCount-1);
+    for (int i=0; i<mLevelCount; ++i)
+    {
+      double position = i*indexToPosFactor;
+      QMap<double, QColor>::const_iterator it = mColorStops.lowerBound(position);
+      if (it == mColorStops.constEnd()) // position is on or after last stop, use color of last stop
+      {
+        mColorBuffer[i] = (it-1).value().rgb();
+      } else if (it == mColorStops.constBegin()) // position is on or before first stop, use color of first stop
+      {
+        mColorBuffer[i] = it.value().rgb();
+      } else // position is in between stops (or on an intermediate stop), interpolate color
+      {
+        QMap<double, QColor>::const_iterator high = it;
+        QMap<double, QColor>::const_iterator low = it-1;
+        double t = (position-low.key())/(high.key()-low.key()); // interpolation factor 0..1
+        switch (mColorInterpolation)
+        {
+          case ciRGB:
+          {
+            mColorBuffer[i] = qRgb((1-t)*low.value().red() + t*high.value().red(),
+                                   (1-t)*low.value().green() + t*high.value().green(),
+                                   (1-t)*low.value().blue() + t*high.value().blue());
+            break;
+          }
+          case ciHSV:
+          {
+            QColor lowHsv = low.value().toHsv();
+            QColor highHsv = high.value().toHsv();
+            double hue = 0;
+            double hueDiff = highHsv.hueF()-lowHsv.hueF();
+            if (hueDiff > 0.5)
+              hue = lowHsv.hueF() - t*(1.0-hueDiff);
+            else if (hueDiff < -0.5)
+              hue = lowHsv.hueF() + t*(1.0+hueDiff);
+            else
+              hue = lowHsv.hueF() + t*hueDiff;
+            if (hue < 0) hue += 1.0;
+            else if (hue >= 1.0) hue -= 1.0;
+            mColorBuffer[i] = QColor::fromHsvF(hue, (1-t)*lowHsv.saturationF() + t*highHsv.saturationF(), (1-t)*lowHsv.valueF() + t*highHsv.valueF()).rgb();
+            break;
+          }
+        }
+      }
+    }
+  } else if (mColorStops.size() == 1)
+  {
+    mColorBuffer.fill(mColorStops.constBegin().value().rgb());
+  } else // mColorStops is empty, fill color buffer with black
+  {
+    mColorBuffer.fill(qRgb(0, 0, 0));
+  }
+  mColorBufferInvalidated = false;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPAxisRect
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPAxisRect
+  \brief Holds multiple axes and arranges them in a rectangular shape.
+  
+  This class represents an axis rect, a rectangular area that is bounded on all sides with an
+  arbitrary number of axes.
+  
+  Initially QCustomPlot has one axis rect, accessible via QCustomPlot::axisRect(). However, the
+  layout system allows to have multiple axis rects, e.g. arranged in a grid layout
+  (QCustomPlot::plotLayout).
+  
+  By default, QCPAxisRect comes with four axes, at bottom, top, left and right. They can be
+  accessed via \ref axis by providing the respective axis type (\ref QCPAxis::AxisType) and index.
+  If you need all axes in the axis rect, use \ref axes. The top and right axes are set to be
+  invisible initially (QCPAxis::setVisible). To add more axes to a side, use \ref addAxis or \ref
+  addAxes. To remove an axis, use \ref removeAxis.
+  
+  The axis rect layerable itself only draws a background pixmap or color, if specified (\ref
+  setBackground). It is placed on the "background" layer initially (see \ref QCPLayer for an
+  explanation of the QCustomPlot layer system). The axes that are held by the axis rect can be
+  placed on other layers, independently of the axis rect.
+  
+  Every axis rect has a child layout of type \ref QCPLayoutInset. It is accessible via \ref
+  insetLayout and can be used to have other layout elements (or even other layouts with multiple
+  elements) hovering inside the axis rect.
+  
+  If an axis rect is clicked and dragged, it processes this by moving certain axis ranges. The
+  behaviour can be controlled with \ref setRangeDrag and \ref setRangeDragAxes. If the mouse wheel
+  is scrolled while the cursor is on the axis rect, certain axes are scaled. This is controllable
+  via \ref setRangeZoom, \ref setRangeZoomAxes and \ref setRangeZoomFactor. These interactions are
+  only enabled if \ref QCustomPlot::setInteractions contains \ref QCP::iRangeDrag and \ref
+  QCP::iRangeZoom.
+  
+  \image html AxisRectSpacingOverview.png
+  <center>Overview of the spacings and paddings that define the geometry of an axis. The dashed
+  line on the far left indicates the viewport/widget border.</center>
+*/
+
+/* start documentation of inline functions */
+
+/*! \fn QCPLayoutInset *QCPAxisRect::insetLayout() const
+  
+  Returns the inset layout of this axis rect. It can be used to place other layout elements (or
+  even layouts with multiple other elements) inside/on top of an axis rect.
+  
+  \see QCPLayoutInset
+*/
+
+/*! \fn int QCPAxisRect::left() const
+  
+  Returns the pixel position of the left border of this axis rect. Margins are not taken into
+  account here, so the returned value is with respect to the inner \ref rect.
+*/
+
+/*! \fn int QCPAxisRect::right() const
+  
+  Returns the pixel position of the right border of this axis rect. Margins are not taken into
+  account here, so the returned value is with respect to the inner \ref rect.
+*/
+
+/*! \fn int QCPAxisRect::top() const
+  
+  Returns the pixel position of the top border of this axis rect. Margins are not taken into
+  account here, so the returned value is with respect to the inner \ref rect.
+*/
+
+/*! \fn int QCPAxisRect::bottom() const
+  
+  Returns the pixel position of the bottom border of this axis rect. Margins are not taken into
+  account here, so the returned value is with respect to the inner \ref rect.
+*/
+
+/*! \fn int QCPAxisRect::width() const
+  
+  Returns the pixel width of this axis rect. Margins are not taken into account here, so the
+  returned value is with respect to the inner \ref rect.
+*/
+
+/*! \fn int QCPAxisRect::height() const
+  
+  Returns the pixel height of this axis rect. Margins are not taken into account here, so the
+  returned value is with respect to the inner \ref rect.
+*/
+
+/*! \fn QSize QCPAxisRect::size() const
+  
+  Returns the pixel size of this axis rect. Margins are not taken into account here, so the
+  returned value is with respect to the inner \ref rect.
+*/
+
+/*! \fn QPoint QCPAxisRect::topLeft() const
+  
+  Returns the top left corner of this axis rect in pixels. Margins are not taken into account here,
+  so the returned value is with respect to the inner \ref rect.
+*/
+
+/*! \fn QPoint QCPAxisRect::topRight() const
+  
+  Returns the top right corner of this axis rect in pixels. Margins are not taken into account
+  here, so the returned value is with respect to the inner \ref rect.
+*/
+
+/*! \fn QPoint QCPAxisRect::bottomLeft() const
+  
+  Returns the bottom left corner of this axis rect in pixels. Margins are not taken into account
+  here, so the returned value is with respect to the inner \ref rect.
+*/
+
+/*! \fn QPoint QCPAxisRect::bottomRight() const
+  
+  Returns the bottom right corner of this axis rect in pixels. Margins are not taken into account
+  here, so the returned value is with respect to the inner \ref rect.
+*/
+
+/*! \fn QPoint QCPAxisRect::center() const
+  
+  Returns the center of this axis rect in pixels. Margins are not taken into account here, so the
+  returned value is with respect to the inner \ref rect.
+*/
+
+/* end documentation of inline functions */
+
+/*!
+  Creates a QCPAxisRect instance and sets default values. An axis is added for each of the four
+  sides, the top and right axes are set invisible initially.
+*/
+QCPAxisRect::QCPAxisRect(QCustomPlot *parentPlot, bool setupDefaultAxes) :
+  QCPLayoutElement(parentPlot),
+  mBackgroundBrush(Qt::NoBrush),
+  mBackgroundScaled(true),
+  mBackgroundScaledMode(Qt::KeepAspectRatioByExpanding),
+  mInsetLayout(new QCPLayoutInset),
+  mRangeDrag(Qt::Horizontal|Qt::Vertical),
+  mRangeZoom(Qt::Horizontal|Qt::Vertical),
+  mRangeZoomFactorHorz(0.85),
+  mRangeZoomFactorVert(0.85),
+  mDragging(false)
+{
+  mInsetLayout->initializeParentPlot(mParentPlot);
+  mInsetLayout->setParentLayerable(this);
+  mInsetLayout->setParent(this);
+  
+  setMinimumSize(50, 50);
+  setMinimumMargins(QMargins(15, 15, 15, 15));
+  mAxes.insert(QCPAxis::atLeft, QList<QCPAxis*>());
+  mAxes.insert(QCPAxis::atRight, QList<QCPAxis*>());
+  mAxes.insert(QCPAxis::atTop, QList<QCPAxis*>());
+  mAxes.insert(QCPAxis::atBottom, QList<QCPAxis*>());
+  
+  if (setupDefaultAxes)
+  {
+    QCPAxis *xAxis = addAxis(QCPAxis::atBottom);
+    QCPAxis *yAxis = addAxis(QCPAxis::atLeft);
+    QCPAxis *xAxis2 = addAxis(QCPAxis::atTop);
+    QCPAxis *yAxis2 = addAxis(QCPAxis::atRight);
+    setRangeDragAxes(xAxis, yAxis);
+    setRangeZoomAxes(xAxis, yAxis);
+    xAxis2->setVisible(false);
+    yAxis2->setVisible(false);
+    xAxis->grid()->setVisible(true);
+    yAxis->grid()->setVisible(true);
+    xAxis2->grid()->setVisible(false);
+    yAxis2->grid()->setVisible(false);
+    xAxis2->grid()->setZeroLinePen(Qt::NoPen);
+    yAxis2->grid()->setZeroLinePen(Qt::NoPen);
+    xAxis2->grid()->setVisible(false);
+    yAxis2->grid()->setVisible(false);
+  }
+}
+
+QCPAxisRect::~QCPAxisRect()
+{
+  delete mInsetLayout;
+  mInsetLayout = 0;
+  
+  QList<QCPAxis*> axesList = axes();
+  for (int i=0; i<axesList.size(); ++i)
+    removeAxis(axesList.at(i));
+}
+
+/*!
+  Returns the number of axes on the axis rect side specified with \a type.
+  
+  \see axis
+*/
+int QCPAxisRect::axisCount(QCPAxis::AxisType type) const
+{
+  return mAxes.value(type).size();
+}
+
+/*!
+  Returns the axis with the given \a index on the axis rect side specified with \a type.
+  
+  \see axisCount, axes
+*/
+QCPAxis *QCPAxisRect::axis(QCPAxis::AxisType type, int index) const
+{
+  QList<QCPAxis*> ax(mAxes.value(type));
+  if (index >= 0 && index < ax.size())
+  {
+    return ax.at(index);
+  } else
+  {
+    qDebug() << Q_FUNC_INFO << "Axis index out of bounds:" << index;
+    return 0;
+  }
+}
+
+/*!
+  Returns all axes on the axis rect sides specified with \a types.
+  
+  \a types may be a single \ref QCPAxis::AxisType or an <tt>or</tt>-combination, to get the axes of
+  multiple sides.
+  
+  \see axis
+*/
+QList<QCPAxis*> QCPAxisRect::axes(QCPAxis::AxisTypes types) const
+{
+  QList<QCPAxis*> result;
+  if (types.testFlag(QCPAxis::atLeft))
+    result << mAxes.value(QCPAxis::atLeft);
+  if (types.testFlag(QCPAxis::atRight))
+    result << mAxes.value(QCPAxis::atRight);
+  if (types.testFlag(QCPAxis::atTop))
+    result << mAxes.value(QCPAxis::atTop);
+  if (types.testFlag(QCPAxis::atBottom))
+    result << mAxes.value(QCPAxis::atBottom);
+  return result;
+}
+
+/*! \overload
+  
+  Returns all axes of this axis rect.
+*/
+QList<QCPAxis*> QCPAxisRect::axes() const
+{
+  QList<QCPAxis*> result;
+  QHashIterator<QCPAxis::AxisType, QList<QCPAxis*> > it(mAxes);
+  while (it.hasNext())
+  {
+    it.next();
+    result << it.value();
+  }
+  return result;
+}
+
+/*!
+  Adds a new axis to the axis rect side specified with \a type, and returns it. If \a axis is 0, a
+  new QCPAxis instance is created internally.
+
+  You may inject QCPAxis instances (or sublasses of QCPAxis) by setting \a axis to an axis that was
+  previously created outside QCustomPlot. It is important to note that QCustomPlot takes ownership
+  of the axis, so you may not delete it afterwards. Further, the \a axis must have been created
+  with this axis rect as parent and with the same axis type as specified in \a type. If this is not
+  the case, a debug output is generated, the axis is not added, and the method returns 0.
+  
+  This method can not be used to move \a axis between axis rects. The same \a axis instance must
+  not be added multiple times to the same or different axis rects.
+  
+  If an axis rect side already contains one or more axes, the lower and upper endings of the new
+  axis (\ref QCPAxis::setLowerEnding, \ref QCPAxis::setUpperEnding) are set to \ref
+  QCPLineEnding::esHalfBar.
+  
+  \see addAxes, setupFullAxesBox
+*/
+QCPAxis *QCPAxisRect::addAxis(QCPAxis::AxisType type, QCPAxis *axis)
+{
+  QCPAxis *newAxis = axis;
+  if (!newAxis)
+  {
+    newAxis = new QCPAxis(this, type);
+  } else // user provided existing axis instance, do some sanity checks
+  {
+    if (newAxis->axisType() != type)
+    {
+      qDebug() << Q_FUNC_INFO << "passed axis has different axis type than specified in type parameter";
+      return 0;
+    }
+    if (newAxis->axisRect() != this)
+    {
+      qDebug() << Q_FUNC_INFO << "passed axis doesn't have this axis rect as parent axis rect";
+      return 0;
+    }
+    if (axes().contains(newAxis))
+    {
+      qDebug() << Q_FUNC_INFO << "passed axis is already owned by this axis rect";
+      return 0;
+    }
+  }
+  if (mAxes[type].size() > 0) // multiple axes on one side, add half-bar axis ending to additional axes with offset
+  {
+    bool invert = (type == QCPAxis::atRight) || (type == QCPAxis::atBottom);
+    newAxis->setLowerEnding(QCPLineEnding(QCPLineEnding::esHalfBar, 6, 10, !invert));
+    newAxis->setUpperEnding(QCPLineEnding(QCPLineEnding::esHalfBar, 6, 10, invert));
+  }
+  mAxes[type].append(newAxis);
+  return newAxis;
+}
+
+/*!
+  Adds a new axis with \ref addAxis to each axis rect side specified in \a types. This may be an
+  <tt>or</tt>-combination of QCPAxis::AxisType, so axes can be added to multiple sides at once.
+  
+  Returns a list of the added axes.
+  
+  \see addAxis, setupFullAxesBox
+*/
+QList<QCPAxis*> QCPAxisRect::addAxes(QCPAxis::AxisTypes types)
+{
+  QList<QCPAxis*> result;
+  if (types.testFlag(QCPAxis::atLeft))
+    result << addAxis(QCPAxis::atLeft);
+  if (types.testFlag(QCPAxis::atRight))
+    result << addAxis(QCPAxis::atRight);
+  if (types.testFlag(QCPAxis::atTop))
+    result << addAxis(QCPAxis::atTop);
+  if (types.testFlag(QCPAxis::atBottom))
+    result << addAxis(QCPAxis::atBottom);
+  return result;
+}
+
+/*!
+  Removes the specified \a axis from the axis rect and deletes it.
+  
+  Returns true on success, i.e. if \a axis was a valid axis in this axis rect.
+  
+  \see addAxis
+*/
+bool QCPAxisRect::removeAxis(QCPAxis *axis)
+{
+  // don't access axis->axisType() to provide safety when axis is an invalid pointer, rather go through all axis containers:
+  QHashIterator<QCPAxis::AxisType, QList<QCPAxis*> > it(mAxes);
+  while (it.hasNext())
+  {
+    it.next();
+    if (it.value().contains(axis))
+    {
+      mAxes[it.key()].removeOne(axis);
+      if (qobject_cast<QCustomPlot*>(parentPlot())) // make sure this isn't called from QObject dtor when QCustomPlot is already destructed (happens when the axis rect is not in any layout and thus QObject-child of QCustomPlot)
+        parentPlot()->axisRemoved(axis);
+      delete axis;
+      return true;
+    }
+  }
+  qDebug() << Q_FUNC_INFO << "Axis isn't in axis rect:" << reinterpret_cast<quintptr>(axis);
+  return false;
+}
+
+/*!
+  Convenience function to create an axis on each side that doesn't have any axes yet and set their
+  visibility to true. Further, the top/right axes are assigned the following properties of the
+  bottom/left axes:
+  
+  \li range (\ref QCPAxis::setRange)
+  \li range reversed (\ref QCPAxis::setRangeReversed)
+  \li scale type (\ref QCPAxis::setScaleType)
+  \li scale log base  (\ref QCPAxis::setScaleLogBase)
+  \li ticks (\ref QCPAxis::setTicks)
+  \li auto (major) tick count (\ref QCPAxis::setAutoTickCount)
+  \li sub tick count (\ref QCPAxis::setSubTickCount)
+  \li auto sub ticks (\ref QCPAxis::setAutoSubTicks)
+  \li tick step (\ref QCPAxis::setTickStep)
+  \li auto tick step (\ref QCPAxis::setAutoTickStep)
+  \li number format (\ref QCPAxis::setNumberFormat)
+  \li number precision (\ref QCPAxis::setNumberPrecision)
+  \li tick label type (\ref QCPAxis::setTickLabelType)
+  \li date time format (\ref QCPAxis::setDateTimeFormat)
+  \li date time spec (\ref QCPAxis::setDateTimeSpec)
+  
+  Tick labels (\ref QCPAxis::setTickLabels) of the right and top axes are set to false.
+
+  If \a connectRanges is true, the \ref QCPAxis::rangeChanged "rangeChanged" signals of the bottom
+  and left axes are connected to the \ref QCPAxis::setRange slots of the top and right axes.
+*/
+void QCPAxisRect::setupFullAxesBox(bool connectRanges)
+{
+  QCPAxis *xAxis, *yAxis, *xAxis2, *yAxis2;
+  if (axisCount(QCPAxis::atBottom) == 0)
+    xAxis = addAxis(QCPAxis::atBottom);
+  else
+    xAxis = axis(QCPAxis::atBottom);
+  
+  if (axisCount(QCPAxis::atLeft) == 0)
+    yAxis = addAxis(QCPAxis::atLeft);
+  else
+    yAxis = axis(QCPAxis::atLeft);
+  
+  if (axisCount(QCPAxis::atTop) == 0)
+    xAxis2 = addAxis(QCPAxis::atTop);
+  else
+    xAxis2 = axis(QCPAxis::atTop);
+  
+  if (axisCount(QCPAxis::atRight) == 0)
+    yAxis2 = addAxis(QCPAxis::atRight);
+  else
+    yAxis2 = axis(QCPAxis::atRight);
+  
+  xAxis->setVisible(true);
+  yAxis->setVisible(true);
+  xAxis2->setVisible(true);
+  yAxis2->setVisible(true);
+  xAxis2->setTickLabels(false);
+  yAxis2->setTickLabels(false);
+  
+  xAxis2->setRange(xAxis->range());
+  xAxis2->setRangeReversed(xAxis->rangeReversed());
+  xAxis2->setScaleType(xAxis->scaleType());
+  xAxis2->setScaleLogBase(xAxis->scaleLogBase());
+  xAxis2->setTicks(xAxis->ticks());
+  xAxis2->setAutoTickCount(xAxis->autoTickCount());
+  xAxis2->setSubTickCount(xAxis->subTickCount());
+  xAxis2->setAutoSubTicks(xAxis->autoSubTicks());
+  xAxis2->setTickStep(xAxis->tickStep());
+  xAxis2->setAutoTickStep(xAxis->autoTickStep());
+  xAxis2->setNumberFormat(xAxis->numberFormat());
+  xAxis2->setNumberPrecision(xAxis->numberPrecision());
+  xAxis2->setTickLabelType(xAxis->tickLabelType());
+  xAxis2->setDateTimeFormat(xAxis->dateTimeFormat());
+  xAxis2->setDateTimeSpec(xAxis->dateTimeSpec());
+
+  yAxis2->setRange(yAxis->range());
+  yAxis2->setRangeReversed(yAxis->rangeReversed());
+  yAxis2->setScaleType(yAxis->scaleType());
+  yAxis2->setScaleLogBase(yAxis->scaleLogBase());
+  yAxis2->setTicks(yAxis->ticks());
+  yAxis2->setAutoTickCount(yAxis->autoTickCount());
+  yAxis2->setSubTickCount(yAxis->subTickCount());
+  yAxis2->setAutoSubTicks(yAxis->autoSubTicks());
+  yAxis2->setTickStep(yAxis->tickStep());
+  yAxis2->setAutoTickStep(yAxis->autoTickStep());
+  yAxis2->setNumberFormat(yAxis->numberFormat());
+  yAxis2->setNumberPrecision(yAxis->numberPrecision());
+  yAxis2->setTickLabelType(yAxis->tickLabelType());
+  yAxis2->setDateTimeFormat(yAxis->dateTimeFormat());
+  yAxis2->setDateTimeSpec(yAxis->dateTimeSpec());
+  
+  if (connectRanges)
+  {
+    connect(xAxis, SIGNAL(rangeChanged(QCPRange)), xAxis2, SLOT(setRange(QCPRange)));
+    connect(yAxis, SIGNAL(rangeChanged(QCPRange)), yAxis2, SLOT(setRange(QCPRange)));
+  }
+}
+
+/*!
+  Returns a list of all the plottables that are associated with this axis rect.
+  
+  A plottable is considered associated with an axis rect if its key or value axis (or both) is in
+  this axis rect.
+  
+  \see graphs, items
+*/
+QList<QCPAbstractPlottable*> QCPAxisRect::plottables() const
+{
+  // Note: don't append all QCPAxis::plottables() into a list, because we might get duplicate entries
+  QList<QCPAbstractPlottable*> result;
+  for (int i=0; i<mParentPlot->mPlottables.size(); ++i)
+  {
+    if (mParentPlot->mPlottables.at(i)->keyAxis()->axisRect() == this ||mParentPlot->mPlottables.at(i)->valueAxis()->axisRect() == this)
+      result.append(mParentPlot->mPlottables.at(i));
+  }
+  return result;
+}
+
+/*!
+  Returns a list of all the graphs that are associated with this axis rect.
+  
+  A graph is considered associated with an axis rect if its key or value axis (or both) is in
+  this axis rect.
+  
+  \see plottables, items
+*/
+QList<QCPGraph*> QCPAxisRect::graphs() const
+{
+  // Note: don't append all QCPAxis::graphs() into a list, because we might get duplicate entries
+  QList<QCPGraph*> result;
+  for (int i=0; i<mParentPlot->mGraphs.size(); ++i)
+  {
+    if (mParentPlot->mGraphs.at(i)->keyAxis()->axisRect() == this || mParentPlot->mGraphs.at(i)->valueAxis()->axisRect() == this)
+      result.append(mParentPlot->mGraphs.at(i));
+  }
+  return result;
+}
+
+/*!
+  Returns a list of all the items that are associated with this axis rect.
+  
+  An item is considered associated with an axis rect if any of its positions has key or value axis
+  set to an axis that is in this axis rect, or if any of its positions has \ref
+  QCPItemPosition::setAxisRect set to the axis rect, or if the clip axis rect (\ref
+  QCPAbstractItem::setClipAxisRect) is set to this axis rect.
+  
+  \see plottables, graphs
+*/
+QList<QCPAbstractItem *> QCPAxisRect::items() const
+{
+  // Note: don't just append all QCPAxis::items() into a list, because we might get duplicate entries
+  //       and miss those items that have this axis rect as clipAxisRect.
+  QList<QCPAbstractItem*> result;
+  for (int itemId=0; itemId<mParentPlot->mItems.size(); ++itemId)
+  {
+    if (mParentPlot->mItems.at(itemId)->clipAxisRect() == this)
+    {
+      result.append(mParentPlot->mItems.at(itemId));
+      continue;
+    }
+    QList<QCPItemPosition*> positions = mParentPlot->mItems.at(itemId)->positions();
+    for (int posId=0; posId<positions.size(); ++posId)
+    {
+      if (positions.at(posId)->axisRect() == this ||
+          positions.at(posId)->keyAxis()->axisRect() == this ||
+          positions.at(posId)->valueAxis()->axisRect() == this)
+      {
+        result.append(mParentPlot->mItems.at(itemId));
+        break;
+      }
+    }
+  }
+  return result;
+}
+
+/*!
+  This method is called automatically upon replot and doesn't need to be called by users of
+  QCPAxisRect.
+  
+  Calls the base class implementation to update the margins (see \ref QCPLayoutElement::update),
+  and finally passes the \ref rect to the inset layout (\ref insetLayout) and calls its
+  QCPInsetLayout::update function.
+*/
+void QCPAxisRect::update(UpdatePhase phase)
+{
+  QCPLayoutElement::update(phase);
+  
+  switch (phase)
+  {
+    case upPreparation:
+    {
+      QList<QCPAxis*> allAxes = axes();
+      for (int i=0; i<allAxes.size(); ++i)
+        allAxes.at(i)->setupTickVectors();
+      break;
+    }
+    case upLayout:
+    {
+      mInsetLayout->setOuterRect(rect());
+      break;
+    }
+    default: break;
+  }
+  
+  // pass update call on to inset layout (doesn't happen automatically, because QCPAxisRect doesn't derive from QCPLayout):
+  mInsetLayout->update(phase);
+}
+
+/* inherits documentation from base class */
+QList<QCPLayoutElement*> QCPAxisRect::elements(bool recursive) const
+{
+  QList<QCPLayoutElement*> result;
+  if (mInsetLayout)
+  {
+    result << mInsetLayout;
+    if (recursive)
+      result << mInsetLayout->elements(recursive);
+  }
+  return result;
+}
+
+/* inherits documentation from base class */
+void QCPAxisRect::applyDefaultAntialiasingHint(QCPPainter *painter) const
+{
+  painter->setAntialiasing(false);
+}
+
+/* inherits documentation from base class */
+void QCPAxisRect::draw(QCPPainter *painter)
+{
+  drawBackground(painter);
+}
+
+/*!
+  Sets \a pm as the axis background pixmap. The axis background pixmap will be drawn inside the
+  axis rect. Since axis rects place themselves on the "background" layer by default, the axis rect
+  backgrounds are usually drawn below everything else.
+
+  For cases where the provided pixmap doesn't have the same size as the axis rect, scaling can be
+  enabled with \ref setBackgroundScaled and the scaling mode (i.e. whether and how the aspect ratio
+  is preserved) can be set with \ref setBackgroundScaledMode. To set all these options in one call,
+  consider using the overloaded version of this function.
+
+  Below the pixmap, the axis rect may be optionally filled with a brush, if specified with \ref
+  setBackground(const QBrush &brush).
+  
+  \see setBackgroundScaled, setBackgroundScaledMode, setBackground(const QBrush &brush)
+*/
+void QCPAxisRect::setBackground(const QPixmap &pm)
+{
+  mBackgroundPixmap = pm;
+  mScaledBackgroundPixmap = QPixmap();
+}
+
+/*! \overload
+  
+  Sets \a brush as the background brush. The axis rect background will be filled with this brush.
+  Since axis rects place themselves on the "background" layer by default, the axis rect backgrounds
+  are usually drawn below everything else.
+
+  The brush will be drawn before (under) any background pixmap, which may be specified with \ref
+  setBackground(const QPixmap &pm).
+
+  To disable drawing of a background brush, set \a brush to Qt::NoBrush.
+  
+  \see setBackground(const QPixmap &pm)
+*/
+void QCPAxisRect::setBackground(const QBrush &brush)
+{
+  mBackgroundBrush = brush;
+}
+
+/*! \overload
+  
+  Allows setting the background pixmap of the axis rect, whether it shall be scaled and how it
+  shall be scaled in one call.
+
+  \see setBackground(const QPixmap &pm), setBackgroundScaled, setBackgroundScaledMode
+*/
+void QCPAxisRect::setBackground(const QPixmap &pm, bool scaled, Qt::AspectRatioMode mode)
+{
+  mBackgroundPixmap = pm;
+  mScaledBackgroundPixmap = QPixmap();
+  mBackgroundScaled = scaled;
+  mBackgroundScaledMode = mode;
+}
+
+/*!
+  Sets whether the axis background pixmap shall be scaled to fit the axis rect or not. If \a scaled
+  is set to true, you may control whether and how the aspect ratio of the original pixmap is
+  preserved with \ref setBackgroundScaledMode.
+  
+  Note that the scaled version of the original pixmap is buffered, so there is no performance
+  penalty on replots. (Except when the axis rect dimensions are changed continuously.)
+  
+  \see setBackground, setBackgroundScaledMode
+*/
+void QCPAxisRect::setBackgroundScaled(bool scaled)
+{
+  mBackgroundScaled = scaled;
+}
+
+/*!
+  If scaling of the axis background pixmap is enabled (\ref setBackgroundScaled), use this function to
+  define whether and how the aspect ratio of the original pixmap passed to \ref setBackground is preserved.
+  \see setBackground, setBackgroundScaled
+*/
+void QCPAxisRect::setBackgroundScaledMode(Qt::AspectRatioMode mode)
+{
+  mBackgroundScaledMode = mode;
+}
+
+/*!
+  Returns the range drag axis of the \a orientation provided.
+  
+  \see setRangeDragAxes
+*/
+QCPAxis *QCPAxisRect::rangeDragAxis(Qt::Orientation orientation)
+{
+  return (orientation == Qt::Horizontal ? mRangeDragHorzAxis.data() : mRangeDragVertAxis.data());
+}
+
+/*!
+  Returns the range zoom axis of the \a orientation provided.
+  
+  \see setRangeZoomAxes
+*/
+QCPAxis *QCPAxisRect::rangeZoomAxis(Qt::Orientation orientation)
+{
+  return (orientation == Qt::Horizontal ? mRangeZoomHorzAxis.data() : mRangeZoomVertAxis.data());
+}
+
+/*!
+  Returns the range zoom factor of the \a orientation provided.
+  
+  \see setRangeZoomFactor
+*/
+double QCPAxisRect::rangeZoomFactor(Qt::Orientation orientation)
+{
+  return (orientation == Qt::Horizontal ? mRangeZoomFactorHorz : mRangeZoomFactorVert);
+}
+
+/*!
+  Sets which axis orientation may be range dragged by the user with mouse interaction.
+  What orientation corresponds to which specific axis can be set with
+  \ref setRangeDragAxes(QCPAxis *horizontal, QCPAxis *vertical). By
+  default, the horizontal axis is the bottom axis (xAxis) and the vertical axis
+  is the left axis (yAxis).
+  
+  To disable range dragging entirely, pass 0 as \a orientations or remove \ref QCP::iRangeDrag from \ref
+  QCustomPlot::setInteractions. To enable range dragging for both directions, pass <tt>Qt::Horizontal |
+  Qt::Vertical</tt> as \a orientations.
+  
+  In addition to setting \a orientations to a non-zero value, make sure \ref QCustomPlot::setInteractions
+  contains \ref QCP::iRangeDrag to enable the range dragging interaction.
+  
+  \see setRangeZoom, setRangeDragAxes, QCustomPlot::setNoAntialiasingOnDrag
+*/
+void QCPAxisRect::setRangeDrag(Qt::Orientations orientations)
+{
+  mRangeDrag = orientations;
+}
+
+/*!
+  Sets which axis orientation may be zoomed by the user with the mouse wheel. What orientation
+  corresponds to which specific axis can be set with \ref setRangeZoomAxes(QCPAxis *horizontal,
+  QCPAxis *vertical). By default, the horizontal axis is the bottom axis (xAxis) and the vertical
+  axis is the left axis (yAxis).
+
+  To disable range zooming entirely, pass 0 as \a orientations or remove \ref QCP::iRangeZoom from \ref
+  QCustomPlot::setInteractions. To enable range zooming for both directions, pass <tt>Qt::Horizontal |
+  Qt::Vertical</tt> as \a orientations.
+  
+  In addition to setting \a orientations to a non-zero value, make sure \ref QCustomPlot::setInteractions
+  contains \ref QCP::iRangeZoom to enable the range zooming interaction.
+  
+  \see setRangeZoomFactor, setRangeZoomAxes, setRangeDrag
+*/
+void QCPAxisRect::setRangeZoom(Qt::Orientations orientations)
+{
+  mRangeZoom = orientations;
+}
+
+/*!
+  Sets the axes whose range will be dragged when \ref setRangeDrag enables mouse range dragging
+  on the QCustomPlot widget.
+  
+  \see setRangeZoomAxes
+*/
+void QCPAxisRect::setRangeDragAxes(QCPAxis *horizontal, QCPAxis *vertical)
+{
+  mRangeDragHorzAxis = horizontal;
+  mRangeDragVertAxis = vertical;
+}
+
+/*!
+  Sets the axes whose range will be zoomed when \ref setRangeZoom enables mouse wheel zooming on the
+  QCustomPlot widget. The two axes can be zoomed with different strengths, when different factors
+  are passed to \ref setRangeZoomFactor(double horizontalFactor, double verticalFactor).
+  
+  \see setRangeDragAxes
+*/
+void QCPAxisRect::setRangeZoomAxes(QCPAxis *horizontal, QCPAxis *vertical)
+{
+  mRangeZoomHorzAxis = horizontal;
+  mRangeZoomVertAxis = vertical;
+}
+
+/*!
+  Sets how strong one rotation step of the mouse wheel zooms, when range zoom was activated with
+  \ref setRangeZoom. The two parameters \a horizontalFactor and \a verticalFactor provide a way to
+  let the horizontal axis zoom at different rates than the vertical axis. Which axis is horizontal
+  and which is vertical, can be set with \ref setRangeZoomAxes.
+
+  When the zoom factor is greater than one, scrolling the mouse wheel backwards (towards the user)
+  will zoom in (make the currently visible range smaller). For zoom factors smaller than one, the
+  same scrolling direction will zoom out.
+*/
+void QCPAxisRect::setRangeZoomFactor(double horizontalFactor, double verticalFactor)
+{
+  mRangeZoomFactorHorz = horizontalFactor;
+  mRangeZoomFactorVert = verticalFactor;
+}
+
+/*! \overload
+  
+  Sets both the horizontal and vertical zoom \a factor.
+*/
+void QCPAxisRect::setRangeZoomFactor(double factor)
+{
+  mRangeZoomFactorHorz = factor;
+  mRangeZoomFactorVert = factor;
+}
+
+/*! \internal
+  
+  Draws the background of this axis rect. It may consist of a background fill (a QBrush) and a
+  pixmap.
+  
+  If a brush was given via \ref setBackground(const QBrush &brush), this function first draws an
+  according filling inside the axis rect with the provided \a painter.
+  
+  Then, if a pixmap was provided via \ref setBackground, this function buffers the scaled version
+  depending on \ref setBackgroundScaled and \ref setBackgroundScaledMode and then draws it inside
+  the axis rect with the provided \a painter. The scaled version is buffered in
+  mScaledBackgroundPixmap to prevent expensive rescaling at every redraw. It is only updated, when
+  the axis rect has changed in a way that requires a rescale of the background pixmap (this is
+  dependant on the \ref setBackgroundScaledMode), or when a differend axis backgroud pixmap was
+  set.
+  
+  \see setBackground, setBackgroundScaled, setBackgroundScaledMode
+*/
+void QCPAxisRect::drawBackground(QCPPainter *painter)
+{
+  // draw background fill:
+  if (mBackgroundBrush != Qt::NoBrush)
+    painter->fillRect(mRect, mBackgroundBrush);
+  
+  // draw background pixmap (on top of fill, if brush specified):
+  if (!mBackgroundPixmap.isNull())
+  {
+    if (mBackgroundScaled)
+    {
+      // check whether mScaledBackground needs to be updated:
+      QSize scaledSize(mBackgroundPixmap.size());
+      scaledSize.scale(mRect.size(), mBackgroundScaledMode);
+      if (mScaledBackgroundPixmap.size() != scaledSize)
+        mScaledBackgroundPixmap = mBackgroundPixmap.scaled(mRect.size(), mBackgroundScaledMode, Qt::SmoothTransformation);
+      painter->drawPixmap(mRect.topLeft()+QPoint(0, -1), mScaledBackgroundPixmap, QRect(0, 0, mRect.width(), mRect.height()) & mScaledBackgroundPixmap.rect());
+    } else
+    {
+      painter->drawPixmap(mRect.topLeft()+QPoint(0, -1), mBackgroundPixmap, QRect(0, 0, mRect.width(), mRect.height()));
+    }
+  }
+}
+
+/*! \internal
+  
+  This function makes sure multiple axes on the side specified with \a type don't collide, but are
+  distributed according to their respective space requirement (QCPAxis::calculateMargin).
+  
+  It does this by setting an appropriate offset (\ref QCPAxis::setOffset) on all axes except the
+  one with index zero.
+  
+  This function is called by \ref calculateAutoMargin.
+*/
+void QCPAxisRect::updateAxesOffset(QCPAxis::AxisType type)
+{
+  const QList<QCPAxis*> axesList = mAxes.value(type);
+  if (axesList.isEmpty())
+    return;
+  
+  bool isFirstVisible = !axesList.first()->visible(); // if the first axis is visible, the second axis (which is where the loop starts) isn't the first visible axis, so initialize with false
+  for (int i=1; i<axesList.size(); ++i)
+  {
+    int offset = axesList.at(i-1)->offset() + axesList.at(i-1)->calculateMargin();
+    if (axesList.at(i)->visible()) // only add inner tick length to offset if this axis is visible and it's not the first visible one (might happen if true first axis is invisible)
+    {
+      if (!isFirstVisible)
+        offset += axesList.at(i)->tickLengthIn();
+      isFirstVisible = false;
+    }
+    axesList.at(i)->setOffset(offset);
+  }
+}
+
+/* inherits documentation from base class */
+int QCPAxisRect::calculateAutoMargin(QCP::MarginSide side)
+{
+  if (!mAutoMargins.testFlag(side))
+    qDebug() << Q_FUNC_INFO << "Called with side that isn't specified as auto margin";
+  
+  updateAxesOffset(QCPAxis::marginSideToAxisType(side));
+  
+  // note: only need to look at the last (outer most) axis to determine the total margin, due to updateAxisOffset call
+  const QList<QCPAxis*> axesList = mAxes.value(QCPAxis::marginSideToAxisType(side));
+  if (axesList.size() > 0)
+    return axesList.last()->offset() + axesList.last()->calculateMargin();
+  else
+    return 0;
+}
+
+/*! \internal
+  
+  Event handler for when a mouse button is pressed on the axis rect. If the left mouse button is
+  pressed, the range dragging interaction is initialized (the actual range manipulation happens in
+  the \ref mouseMoveEvent).
+
+  The mDragging flag is set to true and some anchor points are set that are needed to determine the
+  distance the mouse was dragged in the mouse move/release events later.
+  
+  \see mouseMoveEvent, mouseReleaseEvent
+*/
+void QCPAxisRect::mousePressEvent(QMouseEvent *event)
+{
+  mDragStart = event->pos(); // need this even when not LeftButton is pressed, to determine in releaseEvent whether it was a full click (no position change between press and release)
+  if (event->buttons() & Qt::LeftButton)
+  {
+    mDragging = true;
+    // initialize antialiasing backup in case we start dragging:
+    if (mParentPlot->noAntialiasingOnDrag())
+    {
+      mAADragBackup = mParentPlot->antialiasedElements();
+      mNotAADragBackup = mParentPlot->notAntialiasedElements();
+    }
+    // Mouse range dragging interaction:
+    if (mParentPlot->interactions().testFlag(QCP::iRangeDrag))
+    {
+      if (mRangeDragHorzAxis)
+        mDragStartHorzRange = mRangeDragHorzAxis.data()->range();
+      if (mRangeDragVertAxis)
+        mDragStartVertRange = mRangeDragVertAxis.data()->range();
+    }
+  }
+}
+
+/*! \internal
+  
+  Event handler for when the mouse is moved on the axis rect. If range dragging was activated in a
+  preceding \ref mousePressEvent, the range is moved accordingly.
+  
+  \see mousePressEvent, mouseReleaseEvent
+*/
+void QCPAxisRect::mouseMoveEvent(QMouseEvent *event)
+{
+  // Mouse range dragging interaction:
+  if (mDragging && mParentPlot->interactions().testFlag(QCP::iRangeDrag))
+  {
+    if (mRangeDrag.testFlag(Qt::Horizontal))
+    {
+      if (QCPAxis *rangeDragHorzAxis = mRangeDragHorzAxis.data())
+      {
+        if (rangeDragHorzAxis->mScaleType == QCPAxis::stLinear)
+        {
+          double diff = rangeDragHorzAxis->pixelToCoord(mDragStart.x()) - rangeDragHorzAxis->pixelToCoord(event->pos().x());
+          rangeDragHorzAxis->setRange(mDragStartHorzRange.lower+diff, mDragStartHorzRange.upper+diff);
+        } else if (rangeDragHorzAxis->mScaleType == QCPAxis::stLogarithmic)
+        {
+          double diff = rangeDragHorzAxis->pixelToCoord(mDragStart.x()) / rangeDragHorzAxis->pixelToCoord(event->pos().x());
+          rangeDragHorzAxis->setRange(mDragStartHorzRange.lower*diff, mDragStartHorzRange.upper*diff);
+        }
+      }
+    }
+    if (mRangeDrag.testFlag(Qt::Vertical))
+    {
+      if (QCPAxis *rangeDragVertAxis = mRangeDragVertAxis.data())
+      {
+        if (rangeDragVertAxis->mScaleType == QCPAxis::stLinear)
+        {
+          double diff = rangeDragVertAxis->pixelToCoord(mDragStart.y()) - rangeDragVertAxis->pixelToCoord(event->pos().y());
+          rangeDragVertAxis->setRange(mDragStartVertRange.lower+diff, mDragStartVertRange.upper+diff);
+        } else if (rangeDragVertAxis->mScaleType == QCPAxis::stLogarithmic)
+        {
+          double diff = rangeDragVertAxis->pixelToCoord(mDragStart.y()) / rangeDragVertAxis->pixelToCoord(event->pos().y());
+          rangeDragVertAxis->setRange(mDragStartVertRange.lower*diff, mDragStartVertRange.upper*diff);
+        }
+      }
+    }
+    if (mRangeDrag != 0) // if either vertical or horizontal drag was enabled, do a replot
+    {
+      if (mParentPlot->noAntialiasingOnDrag())
+        mParentPlot->setNotAntialiasedElements(QCP::aeAll);
+      mParentPlot->replot();
+    }
+  }
+}
+
+/* inherits documentation from base class */
+void QCPAxisRect::mouseReleaseEvent(QMouseEvent *event)
+{
+  Q_UNUSED(event)
+  mDragging = false;
+  if (mParentPlot->noAntialiasingOnDrag())
+  {
+    mParentPlot->setAntialiasedElements(mAADragBackup);
+    mParentPlot->setNotAntialiasedElements(mNotAADragBackup);
+  }
+}
+
+/*! \internal
+  
+  Event handler for mouse wheel events. If rangeZoom is Qt::Horizontal, Qt::Vertical or both, the
+  ranges of the axes defined as rangeZoomHorzAxis and rangeZoomVertAxis are scaled. The center of
+  the scaling operation is the current cursor position inside the axis rect. The scaling factor is
+  dependant on the mouse wheel delta (which direction the wheel was rotated) to provide a natural
+  zooming feel. The Strength of the zoom can be controlled via \ref setRangeZoomFactor.
+  
+  Note, that event->delta() is usually +/-120 for single rotation steps. However, if the mouse
+  wheel is turned rapidly, many steps may bunch up to one event, so the event->delta() may then be
+  multiples of 120. This is taken into account here, by calculating \a wheelSteps and using it as
+  exponent of the range zoom factor. This takes care of the wheel direction automatically, by
+  inverting the factor, when the wheel step is negative (f^-1 = 1/f).
+*/
+void QCPAxisRect::wheelEvent(QWheelEvent *event)
+{
+  // Mouse range zooming interaction:
+  if (mParentPlot->interactions().testFlag(QCP::iRangeZoom))
+  {
+    if (mRangeZoom != 0)
+    {
+      double factor;
+      double wheelSteps = event->delta()/120.0; // a single step delta is +/-120 usually
+      if (mRangeZoom.testFlag(Qt::Horizontal))
+      {
+        factor = qPow(mRangeZoomFactorHorz, wheelSteps);
+        if (mRangeZoomHorzAxis.data())
+          mRangeZoomHorzAxis.data()->scaleRange(factor, mRangeZoomHorzAxis.data()->pixelToCoord(event->pos().x()));
+      }
+      if (mRangeZoom.testFlag(Qt::Vertical))
+      {
+        factor = qPow(mRangeZoomFactorVert, wheelSteps);
+        if (mRangeZoomVertAxis.data())
+          mRangeZoomVertAxis.data()->scaleRange(factor, mRangeZoomVertAxis.data()->pixelToCoord(event->pos().y()));
+      }
+      mParentPlot->replot();
+    }
+  }
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPAbstractLegendItem
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPAbstractLegendItem
+  \brief The abstract base class for all entries in a QCPLegend.
+  
+  It defines a very basic interface for entries in a QCPLegend. For representing plottables in the
+  legend, the subclass \ref QCPPlottableLegendItem is more suitable.
+  
+  Only derive directly from this class when you need absolute freedom (e.g. a custom legend entry
+  that's not even associated with a plottable).
+
+  You must implement the following pure virtual functions:
+  \li \ref draw (from QCPLayerable)
+  
+  You inherit the following members you may use:
+  <table>
+    <tr>
+      <td>QCPLegend *\b mParentLegend</td>
+      <td>A pointer to the parent QCPLegend.</td>
+    </tr><tr>
+      <td>QFont \b mFont</td>
+      <td>The generic font of the item. You should use this font for all or at least the most prominent text of the item.</td>
+    </tr>
+  </table>
+*/
+
+/* start of documentation of signals */
+
+/*! \fn void QCPAbstractLegendItem::selectionChanged(bool selected)
+  
+  This signal is emitted when the selection state of this legend item has changed, either by user
+  interaction or by a direct call to \ref setSelected.
+*/
+
+/* end of documentation of signals */
+
+/*!
+  Constructs a QCPAbstractLegendItem and associates it with the QCPLegend \a parent. This does not
+  cause the item to be added to \a parent, so \ref QCPLegend::addItem must be called separately.
+*/
+QCPAbstractLegendItem::QCPAbstractLegendItem(QCPLegend *parent) :
+  QCPLayoutElement(parent->parentPlot()),
+  mParentLegend(parent),
+  mFont(parent->font()),
+  mTextColor(parent->textColor()),
+  mSelectedFont(parent->selectedFont()),
+  mSelectedTextColor(parent->selectedTextColor()),
+  mSelectable(true),
+  mSelected(false)
+{
+  setLayer(QLatin1String("legend"));
+  setMargins(QMargins(8, 2, 8, 2));
+}
+
+/*!
+  Sets the default font of this specific legend item to \a font.
+  
+  \see setTextColor, QCPLegend::setFont
+*/
+void QCPAbstractLegendItem::setFont(const QFont &font)
+{
+  mFont = font;
+}
+
+/*!
+  Sets the default text color of this specific legend item to \a color.
+  
+  \see setFont, QCPLegend::setTextColor
+*/
+void QCPAbstractLegendItem::setTextColor(const QColor &color)
+{
+  mTextColor = color;
+}
+
+/*!
+  When this legend item is selected, \a font is used to draw generic text, instead of the normal
+  font set with \ref setFont.
+  
+  \see setFont, QCPLegend::setSelectedFont
+*/
+void QCPAbstractLegendItem::setSelectedFont(const QFont &font)
+{
+  mSelectedFont = font;
+}
+
+/*!
+  When this legend item is selected, \a color is used to draw generic text, instead of the normal
+  color set with \ref setTextColor.
+  
+  \see setTextColor, QCPLegend::setSelectedTextColor
+*/
+void QCPAbstractLegendItem::setSelectedTextColor(const QColor &color)
+{
+  mSelectedTextColor = color;
+}
+
+/*!
+  Sets whether this specific legend item is selectable.
+  
+  \see setSelectedParts, QCustomPlot::setInteractions
+*/
+void QCPAbstractLegendItem::setSelectable(bool selectable)
+{
+  if (mSelectable != selectable)
+  {
+    mSelectable = selectable;
+    emit selectableChanged(mSelectable);
+  }
+}
+
+/*!
+  Sets whether this specific legend item is selected.
+  
+  It is possible to set the selection state of this item by calling this function directly, even if
+  setSelectable is set to false.
+  
+  \see setSelectableParts, QCustomPlot::setInteractions
+*/
+void QCPAbstractLegendItem::setSelected(bool selected)
+{
+  if (mSelected != selected)
+  {
+    mSelected = selected;
+    emit selectionChanged(mSelected);
+  }
+}
+
+/* inherits documentation from base class */
+double QCPAbstractLegendItem::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  if (!mParentPlot) return -1;
+  if (onlySelectable && (!mSelectable || !mParentLegend->selectableParts().testFlag(QCPLegend::spItems)))
+    return -1;
+  
+  if (mRect.contains(pos.toPoint()))
+    return mParentPlot->selectionTolerance()*0.99;
+  else
+    return -1;
+}
+
+/* inherits documentation from base class */
+void QCPAbstractLegendItem::applyDefaultAntialiasingHint(QCPPainter *painter) const
+{
+  applyAntialiasingHint(painter, mAntialiased, QCP::aeLegendItems);
+}
+
+/* inherits documentation from base class */
+QRect QCPAbstractLegendItem::clipRect() const
+{
+  return mOuterRect;
+}
+
+/* inherits documentation from base class */
+void QCPAbstractLegendItem::selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)
+{
+  Q_UNUSED(event)
+  Q_UNUSED(details)
+  if (mSelectable && mParentLegend->selectableParts().testFlag(QCPLegend::spItems))
+  {
+    bool selBefore = mSelected;
+    setSelected(additive ? !mSelected : true);
+    if (selectionStateChanged)
+      *selectionStateChanged = mSelected != selBefore;
+  }
+}
+
+/* inherits documentation from base class */
+void QCPAbstractLegendItem::deselectEvent(bool *selectionStateChanged)
+{
+  if (mSelectable && mParentLegend->selectableParts().testFlag(QCPLegend::spItems))
+  {
+    bool selBefore = mSelected;
+    setSelected(false);
+    if (selectionStateChanged)
+      *selectionStateChanged = mSelected != selBefore;
+  }
+}
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPPlottableLegendItem
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPPlottableLegendItem
+  \brief A legend item representing a plottable with an icon and the plottable name.
+  
+  This is the standard legend item for plottables. It displays an icon of the plottable next to the
+  plottable name. The icon is drawn by the respective plottable itself (\ref
+  QCPAbstractPlottable::drawLegendIcon), and tries to give an intuitive symbol for the plottable.
+  For example, the QCPGraph draws a centered horizontal line and/or a single scatter point in the
+  middle.
+  
+  Legend items of this type are always associated with one plottable (retrievable via the
+  plottable() function and settable with the constructor). You may change the font of the plottable
+  name with \ref setFont. Icon padding and border pen is taken from the parent QCPLegend, see \ref
+  QCPLegend::setIconBorderPen and \ref QCPLegend::setIconTextPadding.
+
+  The function \ref QCPAbstractPlottable::addToLegend/\ref QCPAbstractPlottable::removeFromLegend
+  creates/removes legend items of this type in the default implementation. However, these functions
+  may be reimplemented such that a different kind of legend item (e.g a direct subclass of
+  QCPAbstractLegendItem) is used for that plottable.
+  
+  Since QCPLegend is based on QCPLayoutGrid, a legend item itself is just a subclass of
+  QCPLayoutElement. While it could be added to a legend (or any other layout) via the normal layout
+  interface, QCPLegend has specialized functions for handling legend items conveniently, see the
+  documentation of \ref QCPLegend.
+*/
+
+/*!
+  Creates a new legend item associated with \a plottable.
+  
+  Once it's created, it can be added to the legend via \ref QCPLegend::addItem.
+  
+  A more convenient way of adding/removing a plottable to/from the legend is via the functions \ref
+  QCPAbstractPlottable::addToLegend and \ref QCPAbstractPlottable::removeFromLegend.
+*/
+QCPPlottableLegendItem::QCPPlottableLegendItem(QCPLegend *parent, QCPAbstractPlottable *plottable) :
+  QCPAbstractLegendItem(parent),
+  mPlottable(plottable)
+{
+}
+
+/*! \internal
+  
+  Returns the pen that shall be used to draw the icon border, taking into account the selection
+  state of this item.
+*/
+QPen QCPPlottableLegendItem::getIconBorderPen() const
+{
+  return mSelected ? mParentLegend->selectedIconBorderPen() : mParentLegend->iconBorderPen();
+}
+
+/*! \internal
+  
+  Returns the text color that shall be used to draw text, taking into account the selection state
+  of this item.
+*/
+QColor QCPPlottableLegendItem::getTextColor() const
+{
+  return mSelected ? mSelectedTextColor : mTextColor;
+}
+
+/*! \internal
+  
+  Returns the font that shall be used to draw text, taking into account the selection state of this
+  item.
+*/
+QFont QCPPlottableLegendItem::getFont() const
+{
+  return mSelected ? mSelectedFont : mFont;
+}
+
+/*! \internal
+  
+  Draws the item with \a painter. The size and position of the drawn legend item is defined by the
+  parent layout (typically a \ref QCPLegend) and the \ref minimumSizeHint and \ref maximumSizeHint
+  of this legend item.
+*/
+void QCPPlottableLegendItem::draw(QCPPainter *painter)
+{
+  if (!mPlottable) return;
+  painter->setFont(getFont());
+  painter->setPen(QPen(getTextColor()));
+  QSizeF iconSize = mParentLegend->iconSize();
+  QRectF textRect = painter->fontMetrics().boundingRect(0, 0, 0, iconSize.height(), Qt::TextDontClip, mPlottable->name());
+  QRectF iconRect(mRect.topLeft(), iconSize);
+  int textHeight = qMax(textRect.height(), iconSize.height());  // if text has smaller height than icon, center text vertically in icon height, else align tops
+  painter->drawText(mRect.x()+iconSize.width()+mParentLegend->iconTextPadding(), mRect.y(), textRect.width(), textHeight, Qt::TextDontClip, mPlottable->name());
+  // draw icon:
+  painter->save();
+  painter->setClipRect(iconRect, Qt::IntersectClip);
+  mPlottable->drawLegendIcon(painter, iconRect);
+  painter->restore();
+  // draw icon border:
+  if (getIconBorderPen().style() != Qt::NoPen)
+  {
+    painter->setPen(getIconBorderPen());
+    painter->setBrush(Qt::NoBrush);
+    painter->drawRect(iconRect);
+  }
+}
+
+/*! \internal
+  
+  Calculates and returns the size of this item. This includes the icon, the text and the padding in
+  between.
+*/
+QSize QCPPlottableLegendItem::minimumSizeHint() const
+{
+  if (!mPlottable) return QSize();
+  QSize result(0, 0);
+  QRect textRect;
+  QFontMetrics fontMetrics(getFont());
+  QSize iconSize = mParentLegend->iconSize();
+  textRect = fontMetrics.boundingRect(0, 0, 0, iconSize.height(), Qt::TextDontClip, mPlottable->name());
+  result.setWidth(iconSize.width() + mParentLegend->iconTextPadding() + textRect.width() + mMargins.left() + mMargins.right());
+  result.setHeight(qMax(textRect.height(), iconSize.height()) + mMargins.top() + mMargins.bottom());
+  return result;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPLegend
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPLegend
+  \brief Manages a legend inside a QCustomPlot.
+
+  A legend is a small box somewhere in the plot which lists plottables with their name and icon.
+  
+  Normally, the legend is populated by calling \ref QCPAbstractPlottable::addToLegend. The
+  respective legend item can be removed with \ref QCPAbstractPlottable::removeFromLegend. However,
+  QCPLegend also offers an interface to add and manipulate legend items directly: \ref item, \ref
+  itemWithPlottable, \ref itemCount, \ref addItem, \ref removeItem, etc.
+  
+  The QCPLegend derives from QCPLayoutGrid and as such can be placed in any position a
+  QCPLayoutElement may be positioned. The legend items are themselves QCPLayoutElements which are
+  placed in the grid layout of the legend. QCPLegend only adds an interface specialized for
+  handling child elements of type QCPAbstractLegendItem, as mentioned above. In principle, any
+  other layout elements may also be added to a legend via the normal \ref QCPLayoutGrid interface.
+  However, the QCPAbstractLegendItem-Interface will ignore those elements (e.g. \ref itemCount will
+  only return the number of items with QCPAbstractLegendItems type).
+
+  By default, every QCustomPlot has one legend (QCustomPlot::legend) which is placed in the inset
+  layout of the main axis rect (\ref QCPAxisRect::insetLayout). To move the legend to another
+  position inside the axis rect, use the methods of the \ref QCPLayoutInset. To move the legend
+  outside of the axis rect, place it anywhere else with the QCPLayout/QCPLayoutElement interface.
+*/
+
+/* start of documentation of signals */
+
+/*! \fn void QCPLegend::selectionChanged(QCPLegend::SelectableParts selection);
+
+  This signal is emitted when the selection state of this legend has changed.
+  
+  \see setSelectedParts, setSelectableParts
+*/
+
+/* end of documentation of signals */
+
+/*!
+  Constructs a new QCPLegend instance with \a parentPlot as the containing plot and default values.
+  
+  Note that by default, QCustomPlot already contains a legend ready to be used as
+  QCustomPlot::legend
+*/
+QCPLegend::QCPLegend()
+{
+  setRowSpacing(0);
+  setColumnSpacing(10);
+  setMargins(QMargins(2, 3, 2, 2));
+  setAntialiased(false);
+  setIconSize(32, 18);
+  
+  setIconTextPadding(7);
+  
+  setSelectableParts(spLegendBox | spItems);
+  setSelectedParts(spNone);
+  
+  setBorderPen(QPen(Qt::black));
+  setSelectedBorderPen(QPen(Qt::blue, 2));
+  setIconBorderPen(Qt::NoPen);
+  setSelectedIconBorderPen(QPen(Qt::blue, 2));
+  setBrush(Qt::white);
+  setSelectedBrush(Qt::white);
+  setTextColor(Qt::black);
+  setSelectedTextColor(Qt::blue);
+}
+
+QCPLegend::~QCPLegend()
+{
+  clearItems();
+  if (qobject_cast<QCustomPlot*>(mParentPlot)) // make sure this isn't called from QObject dtor when QCustomPlot is already destructed (happens when the legend is not in any layout and thus QObject-child of QCustomPlot)
+    mParentPlot->legendRemoved(this);
+}
+
+/* no doc for getter, see setSelectedParts */
+QCPLegend::SelectableParts QCPLegend::selectedParts() const
+{
+  // check whether any legend elements selected, if yes, add spItems to return value
+  bool hasSelectedItems = false;
+  for (int i=0; i<itemCount(); ++i)
+  {
+    if (item(i) && item(i)->selected())
+    {
+      hasSelectedItems = true;
+      break;
+    }
+  }
+  if (hasSelectedItems)
+    return mSelectedParts | spItems;
+  else
+    return mSelectedParts & ~spItems;
+}
+
+/*!
+  Sets the pen, the border of the entire legend is drawn with.
+*/
+void QCPLegend::setBorderPen(const QPen &pen)
+{
+  mBorderPen = pen;
+}
+
+/*!
+  Sets the brush of the legend background.
+*/
+void QCPLegend::setBrush(const QBrush &brush)
+{
+  mBrush = brush;
+}
+
+/*!
+  Sets the default font of legend text. Legend items that draw text (e.g. the name of a graph) will
+  use this font by default. However, a different font can be specified on a per-item-basis by
+  accessing the specific legend item.
+  
+  This function will also set \a font on all already existing legend items.
+  
+  \see QCPAbstractLegendItem::setFont
+*/
+void QCPLegend::setFont(const QFont &font)
+{
+  mFont = font;
+  for (int i=0; i<itemCount(); ++i)
+  {
+    if (item(i))
+      item(i)->setFont(mFont);
+  }
+}
+
+/*!
+  Sets the default color of legend text. Legend items that draw text (e.g. the name of a graph)
+  will use this color by default. However, a different colors can be specified on a per-item-basis
+  by accessing the specific legend item.
+  
+  This function will also set \a color on all already existing legend items.
+  
+  \see QCPAbstractLegendItem::setTextColor
+*/
+void QCPLegend::setTextColor(const QColor &color)
+{
+  mTextColor = color;
+  for (int i=0; i<itemCount(); ++i)
+  {
+    if (item(i))
+      item(i)->setTextColor(color);
+  }
+}
+
+/*!
+  Sets the size of legend icons. Legend items that draw an icon (e.g. a visual
+  representation of the graph) will use this size by default.
+*/
+void QCPLegend::setIconSize(const QSize &size)
+{
+  mIconSize = size;
+}
+
+/*! \overload
+*/
+void QCPLegend::setIconSize(int width, int height)
+{
+  mIconSize.setWidth(width);
+  mIconSize.setHeight(height);
+}
+
+/*!
+  Sets the horizontal space in pixels between the legend icon and the text next to it.
+  Legend items that draw an icon (e.g. a visual representation of the graph) and text (e.g. the
+  name of the graph) will use this space by default.
+*/
+void QCPLegend::setIconTextPadding(int padding)
+{
+  mIconTextPadding = padding;
+}
+
+/*!
+  Sets the pen used to draw a border around each legend icon. Legend items that draw an
+  icon (e.g. a visual representation of the graph) will use this pen by default.
+  
+  If no border is wanted, set this to \a Qt::NoPen.
+*/
+void QCPLegend::setIconBorderPen(const QPen &pen)
+{
+  mIconBorderPen = pen;
+}
+
+/*!
+  Sets whether the user can (de-)select the parts in \a selectable by clicking on the QCustomPlot surface.
+  (When \ref QCustomPlot::setInteractions contains \ref QCP::iSelectLegend.)
+  
+  However, even when \a selectable is set to a value not allowing the selection of a specific part,
+  it is still possible to set the selection of this part manually, by calling \ref setSelectedParts
+  directly.
+  
+  \see SelectablePart, setSelectedParts
+*/
+void QCPLegend::setSelectableParts(const SelectableParts &selectable)
+{
+  if (mSelectableParts != selectable)
+  {
+    mSelectableParts = selectable;
+    emit selectableChanged(mSelectableParts);
+  }
+}
+
+/*!
+  Sets the selected state of the respective legend parts described by \ref SelectablePart. When a part
+  is selected, it uses a different pen/font and brush. If some legend items are selected and \a selected
+  doesn't contain \ref spItems, those items become deselected.
+  
+  The entire selection mechanism is handled automatically when \ref QCustomPlot::setInteractions
+  contains iSelectLegend. You only need to call this function when you wish to change the selection
+  state manually.
+  
+  This function can change the selection state of a part even when \ref setSelectableParts was set to a
+  value that actually excludes the part.
+  
+  emits the \ref selectionChanged signal when \a selected is different from the previous selection state.
+  
+  Note that it doesn't make sense to set the selected state \ref spItems here when it wasn't set
+  before, because there's no way to specify which exact items to newly select. Do this by calling
+  \ref QCPAbstractLegendItem::setSelected directly on the legend item you wish to select.
+  
+  \see SelectablePart, setSelectableParts, selectTest, setSelectedBorderPen, setSelectedIconBorderPen, setSelectedBrush,
+  setSelectedFont
+*/
+void QCPLegend::setSelectedParts(const SelectableParts &selected)
+{
+  SelectableParts newSelected = selected;
+  mSelectedParts = this->selectedParts(); // update mSelectedParts in case item selection changed
+
+  if (mSelectedParts != newSelected)
+  {
+    if (!mSelectedParts.testFlag(spItems) && newSelected.testFlag(spItems)) // attempt to set spItems flag (can't do that)
+    {
+      qDebug() << Q_FUNC_INFO << "spItems flag can not be set, it can only be unset with this function";
+      newSelected &= ~spItems;
+    }
+    if (mSelectedParts.testFlag(spItems) && !newSelected.testFlag(spItems)) // spItems flag was unset, so clear item selection
+    {
+      for (int i=0; i<itemCount(); ++i)
+      {
+        if (item(i))
+          item(i)->setSelected(false);
+      }
+    }
+    mSelectedParts = newSelected;
+    emit selectionChanged(mSelectedParts);
+  }
+}
+
+/*!
+  When the legend box is selected, this pen is used to draw the border instead of the normal pen
+  set via \ref setBorderPen.
+
+  \see setSelectedParts, setSelectableParts, setSelectedBrush
+*/
+void QCPLegend::setSelectedBorderPen(const QPen &pen)
+{
+  mSelectedBorderPen = pen;
+}
+
+/*!
+  Sets the pen legend items will use to draw their icon borders, when they are selected.
+
+  \see setSelectedParts, setSelectableParts, setSelectedFont
+*/
+void QCPLegend::setSelectedIconBorderPen(const QPen &pen)
+{
+  mSelectedIconBorderPen = pen;
+}
+
+/*!
+  When the legend box is selected, this brush is used to draw the legend background instead of the normal brush
+  set via \ref setBrush.
+
+  \see setSelectedParts, setSelectableParts, setSelectedBorderPen
+*/
+void QCPLegend::setSelectedBrush(const QBrush &brush)
+{
+  mSelectedBrush = brush;
+}
+
+/*!
+  Sets the default font that is used by legend items when they are selected.
+  
+  This function will also set \a font on all already existing legend items.
+
+  \see setFont, QCPAbstractLegendItem::setSelectedFont
+*/
+void QCPLegend::setSelectedFont(const QFont &font)
+{
+  mSelectedFont = font;
+  for (int i=0; i<itemCount(); ++i)
+  {
+    if (item(i))
+      item(i)->setSelectedFont(font);
+  }
+}
+
+/*!
+  Sets the default text color that is used by legend items when they are selected.
+  
+  This function will also set \a color on all already existing legend items.
+
+  \see setTextColor, QCPAbstractLegendItem::setSelectedTextColor
+*/
+void QCPLegend::setSelectedTextColor(const QColor &color)
+{
+  mSelectedTextColor = color;
+  for (int i=0; i<itemCount(); ++i)
+  {
+    if (item(i))
+      item(i)->setSelectedTextColor(color);
+  }
+}
+
+/*!
+  Returns the item with index \a i.
+  
+  \see itemCount
+*/
+QCPAbstractLegendItem *QCPLegend::item(int index) const
+{
+  return qobject_cast<QCPAbstractLegendItem*>(elementAt(index));
+}
+
+/*!
+  Returns the QCPPlottableLegendItem which is associated with \a plottable (e.g. a \ref QCPGraph*).
+  If such an item isn't in the legend, returns 0.
+  
+  \see hasItemWithPlottable
+*/
+QCPPlottableLegendItem *QCPLegend::itemWithPlottable(const QCPAbstractPlottable *plottable) const
+{
+  for (int i=0; i<itemCount(); ++i)
+  {
+    if (QCPPlottableLegendItem *pli = qobject_cast<QCPPlottableLegendItem*>(item(i)))
+    {
+      if (pli->plottable() == plottable)
+        return pli;
+    }
+  }
+  return 0;
+}
+
+/*!
+  Returns the number of items currently in the legend.
+  \see item
+*/
+int QCPLegend::itemCount() const
+{
+  return elementCount();
+}
+
+/*!
+  Returns whether the legend contains \a itm.
+*/
+bool QCPLegend::hasItem(QCPAbstractLegendItem *item) const
+{
+  for (int i=0; i<itemCount(); ++i)
+  {
+    if (item == this->item(i))
+        return true;
+  }
+  return false;
+}
+
+/*!
+  Returns whether the legend contains a QCPPlottableLegendItem which is associated with \a plottable (e.g. a \ref QCPGraph*).
+  If such an item isn't in the legend, returns false.
+  
+  \see itemWithPlottable
+*/
+bool QCPLegend::hasItemWithPlottable(const QCPAbstractPlottable *plottable) const
+{
+  return itemWithPlottable(plottable);
+}
+
+/*!
+  Adds \a item to the legend, if it's not present already.
+  
+  Returns true on sucess, i.e. if the item wasn't in the list already and has been successfuly added.
+  
+  The legend takes ownership of the item.
+*/
+bool QCPLegend::addItem(QCPAbstractLegendItem *item)
+{
+  if (!hasItem(item))
+  {
+    return addElement(rowCount(), 0, item);
+  } else
+    return false;
+}
+
+/*!
+  Removes the item with index \a index from the legend.
+
+  Returns true, if successful.
+  
+  \see itemCount, clearItems
+*/
+bool QCPLegend::removeItem(int index)
+{
+  if (QCPAbstractLegendItem *ali = item(index))
+  {
+    bool success = remove(ali);
+    simplify();
+    return success;
+  } else
+    return false;
+}
+
+/*! \overload
+  
+  Removes \a item from the legend.
+
+  Returns true, if successful.
+  
+  \see clearItems
+*/
+bool QCPLegend::removeItem(QCPAbstractLegendItem *item)
+{
+  bool success = remove(item);
+  simplify();
+  return success;
+}
+
+/*!
+  Removes all items from the legend.
+*/
+void QCPLegend::clearItems()
+{
+  for (int i=itemCount()-1; i>=0; --i)
+    removeItem(i);
+}
+
+/*!
+  Returns the legend items that are currently selected. If no items are selected,
+  the list is empty.
+  
+  \see QCPAbstractLegendItem::setSelected, setSelectable
+*/
+QList<QCPAbstractLegendItem *> QCPLegend::selectedItems() const
+{
+  QList<QCPAbstractLegendItem*> result;
+  for (int i=0; i<itemCount(); ++i)
+  {
+    if (QCPAbstractLegendItem *ali = item(i))
+    {
+      if (ali->selected())
+        result.append(ali);
+    }
+  }
+  return result;
+}
+
+/*! \internal
+
+  A convenience function to easily set the QPainter::Antialiased hint on the provided \a painter
+  before drawing main legend elements.
+
+  This is the antialiasing state the painter passed to the \ref draw method is in by default.
+  
+  This function takes into account the local setting of the antialiasing flag as well as the
+  overrides set with \ref QCustomPlot::setAntialiasedElements and \ref
+  QCustomPlot::setNotAntialiasedElements.
+  
+  \see setAntialiased
+*/
+void QCPLegend::applyDefaultAntialiasingHint(QCPPainter *painter) const
+{
+  applyAntialiasingHint(painter, mAntialiased, QCP::aeLegend);
+}
+
+/*! \internal
+  
+  Returns the pen used to paint the border of the legend, taking into account the selection state
+  of the legend box.
+*/
+QPen QCPLegend::getBorderPen() const
+{
+  return mSelectedParts.testFlag(spLegendBox) ? mSelectedBorderPen : mBorderPen;
+}
+
+/*! \internal
+  
+  Returns the brush used to paint the background of the legend, taking into account the selection
+  state of the legend box.
+*/
+QBrush QCPLegend::getBrush() const
+{
+  return mSelectedParts.testFlag(spLegendBox) ? mSelectedBrush : mBrush;
+}
+
+/*! \internal
+  
+  Draws the legend box with the provided \a painter. The individual legend items are layerables
+  themselves, thus are drawn independently.
+*/
+void QCPLegend::draw(QCPPainter *painter)
+{
+  // draw background rect:
+  painter->setBrush(getBrush());
+  painter->setPen(getBorderPen());
+  painter->drawRect(mOuterRect);
+}
+
+/* inherits documentation from base class */
+double QCPLegend::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  if (!mParentPlot) return -1;
+  if (onlySelectable && !mSelectableParts.testFlag(spLegendBox))
+    return -1;
+  
+  if (mOuterRect.contains(pos.toPoint()))
+  {
+    if (details) details->setValue(spLegendBox);
+    return mParentPlot->selectionTolerance()*0.99;
+  }
+  return -1;
+}
+
+/* inherits documentation from base class */
+void QCPLegend::selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)
+{
+  Q_UNUSED(event)
+  mSelectedParts = selectedParts(); // in case item selection has changed
+  if (details.value<SelectablePart>() == spLegendBox && mSelectableParts.testFlag(spLegendBox))
+  {
+    SelectableParts selBefore = mSelectedParts;
+    setSelectedParts(additive ? mSelectedParts^spLegendBox : mSelectedParts|spLegendBox); // no need to unset spItems in !additive case, because they will be deselected by QCustomPlot (they're normal QCPLayerables with own deselectEvent)
+    if (selectionStateChanged)
+      *selectionStateChanged = mSelectedParts != selBefore;
+  }
+}
+
+/* inherits documentation from base class */
+void QCPLegend::deselectEvent(bool *selectionStateChanged)
+{
+  mSelectedParts = selectedParts(); // in case item selection has changed
+  if (mSelectableParts.testFlag(spLegendBox))
+  {
+    SelectableParts selBefore = mSelectedParts;
+    setSelectedParts(selectedParts() & ~spLegendBox);
+    if (selectionStateChanged)
+      *selectionStateChanged = mSelectedParts != selBefore;
+  }
+}
+
+/* inherits documentation from base class */
+QCP::Interaction QCPLegend::selectionCategory() const
+{
+  return QCP::iSelectLegend;
+}
+
+/* inherits documentation from base class */
+QCP::Interaction QCPAbstractLegendItem::selectionCategory() const
+{
+  return QCP::iSelectLegend;
+}
+
+/* inherits documentation from base class */
+void QCPLegend::parentPlotInitialized(QCustomPlot *parentPlot)
+{
+  Q_UNUSED(parentPlot)
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPPlotTitle
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPPlotTitle
+  \brief A layout element displaying a plot title text
+  
+  The text may be specified with \ref setText, theformatting can be controlled with \ref setFont
+  and \ref setTextColor.
+  
+  A plot title can be added as follows:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpplottitle-creation
+  
+  Since a plot title is a common requirement, QCustomPlot offers specialized selection signals for
+  easy interaction with QCPPlotTitle. If a layout element of type QCPPlotTitle is clicked, the
+  signal \ref QCustomPlot::titleClick is emitted. A double click emits the \ref
+  QCustomPlot::titleDoubleClick signal.
+*/
+
+/* start documentation of signals */
+
+/*! \fn void QCPPlotTitle::selectionChanged(bool selected)
+  
+  This signal is emitted when the selection state has changed to \a selected, either by user
+  interaction or by a direct call to \ref setSelected.
+  
+  \see setSelected, setSelectable
+*/
+
+/* end documentation of signals */
+
+/*!
+  Creates a new QCPPlotTitle instance and sets default values. The initial text is empty (\ref setText).
+  
+  To set the title text in the constructor, rather use \ref QCPPlotTitle(QCustomPlot *parentPlot, const QString &text).
+*/
+QCPPlotTitle::QCPPlotTitle(QCustomPlot *parentPlot) :
+  QCPLayoutElement(parentPlot),
+  mFont(QFont(QLatin1String("sans serif"), 13*1.5, QFont::Bold)),
+  mTextColor(Qt::black),
+  mSelectedFont(QFont(QLatin1String("sans serif"), 13*1.6, QFont::Bold)),
+  mSelectedTextColor(Qt::blue),
+  mSelectable(false),
+  mSelected(false)
+{
+  if (parentPlot)
+  {
+    setLayer(parentPlot->currentLayer());
+    mFont = QFont(parentPlot->font().family(), parentPlot->font().pointSize()*1.5, QFont::Bold);
+    mSelectedFont = QFont(parentPlot->font().family(), parentPlot->font().pointSize()*1.6, QFont::Bold);
+  }
+  setMargins(QMargins(5, 5, 5, 0));
+}
+
+/*! \overload
+  
+  Creates a new QCPPlotTitle instance and sets default values. The initial text is set to \a text.
+*/
+QCPPlotTitle::QCPPlotTitle(QCustomPlot *parentPlot, const QString &text) :
+  QCPLayoutElement(parentPlot),
+  mText(text),
+  mFont(QFont(parentPlot->font().family(), parentPlot->font().pointSize()*1.5, QFont::Bold)),
+  mTextColor(Qt::black),
+  mSelectedFont(QFont(parentPlot->font().family(), parentPlot->font().pointSize()*1.6, QFont::Bold)),
+  mSelectedTextColor(Qt::blue),
+  mSelectable(false),
+  mSelected(false)
+{
+  setLayer(QLatin1String("axes"));
+  setMargins(QMargins(5, 5, 5, 0));
+}
+
+/*!
+  Sets the text that will be displayed to \a text. Multiple lines can be created by insertion of "\n".
+  
+  \see setFont, setTextColor
+*/
+void QCPPlotTitle::setText(const QString &text)
+{
+  mText = text;
+}
+
+/*!
+  Sets the \a font of the title text.
+  
+  \see setTextColor, setSelectedFont
+*/
+void QCPPlotTitle::setFont(const QFont &font)
+{
+  mFont = font;
+}
+
+/*!
+  Sets the \a color of the title text.
+  
+  \see setFont, setSelectedTextColor
+*/
+void QCPPlotTitle::setTextColor(const QColor &color)
+{
+  mTextColor = color;
+}
+
+/*!
+  Sets the \a font of the title text that will be used if the plot title is selected (\ref setSelected).
+  
+  \see setFont
+*/
+void QCPPlotTitle::setSelectedFont(const QFont &font)
+{
+  mSelectedFont = font;
+}
+
+/*!
+  Sets the \a color of the title text that will be used if the plot title is selected (\ref setSelected).
+  
+  \see setTextColor
+*/
+void QCPPlotTitle::setSelectedTextColor(const QColor &color)
+{
+  mSelectedTextColor = color;
+}
+
+/*!
+  Sets whether the user may select this plot title to \a selectable.
+
+  Note that even when \a selectable is set to <tt>false</tt>, the selection state may be changed
+  programmatically via \ref setSelected.
+*/
+void QCPPlotTitle::setSelectable(bool selectable)
+{
+  if (mSelectable != selectable)
+  {
+    mSelectable = selectable;
+    emit selectableChanged(mSelectable);
+  }
+}
+
+/*!
+  Sets the selection state of this plot title to \a selected. If the selection has changed, \ref
+  selectionChanged is emitted.
+  
+  Note that this function can change the selection state independently of the current \ref
+  setSelectable state.
+*/
+void QCPPlotTitle::setSelected(bool selected)
+{
+  if (mSelected != selected)
+  {
+    mSelected = selected;
+    emit selectionChanged(mSelected);
+  }
+}
+
+/* inherits documentation from base class */
+void QCPPlotTitle::applyDefaultAntialiasingHint(QCPPainter *painter) const
+{
+  applyAntialiasingHint(painter, mAntialiased, QCP::aeNone);
+}
+
+/* inherits documentation from base class */
+void QCPPlotTitle::draw(QCPPainter *painter)
+{
+  painter->setFont(mainFont());
+  painter->setPen(QPen(mainTextColor()));
+  painter->drawText(mRect, Qt::AlignCenter, mText, &mTextBoundingRect);
+}
+
+/* inherits documentation from base class */
+QSize QCPPlotTitle::minimumSizeHint() const
+{
+  QFontMetrics metrics(mFont);
+  QSize result = metrics.boundingRect(0, 0, 0, 0, Qt::AlignCenter, mText).size();
+  result.rwidth() += mMargins.left() + mMargins.right();
+  result.rheight() += mMargins.top() + mMargins.bottom();
+  return result;
+}
+
+/* inherits documentation from base class */
+QSize QCPPlotTitle::maximumSizeHint() const
+{
+  QFontMetrics metrics(mFont);
+  QSize result = metrics.boundingRect(0, 0, 0, 0, Qt::AlignCenter, mText).size();
+  result.rheight() += mMargins.top() + mMargins.bottom();
+  result.setWidth(QWIDGETSIZE_MAX);
+  return result;
+}
+
+/* inherits documentation from base class */
+void QCPPlotTitle::selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)
+{
+  Q_UNUSED(event)
+  Q_UNUSED(details)
+  if (mSelectable)
+  {
+    bool selBefore = mSelected;
+    setSelected(additive ? !mSelected : true);
+    if (selectionStateChanged)
+      *selectionStateChanged = mSelected != selBefore;
+  }
+}
+
+/* inherits documentation from base class */
+void QCPPlotTitle::deselectEvent(bool *selectionStateChanged)
+{
+  if (mSelectable)
+  {
+    bool selBefore = mSelected;
+    setSelected(false);
+    if (selectionStateChanged)
+      *selectionStateChanged = mSelected != selBefore;
+  }
+}
+
+/* inherits documentation from base class */
+double QCPPlotTitle::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  if (onlySelectable && !mSelectable)
+    return -1;
+  
+  if (mTextBoundingRect.contains(pos.toPoint()))
+    return mParentPlot->selectionTolerance()*0.99;
+  else
+    return -1;
+}
+
+/*! \internal
+  
+  Returns the main font to be used. This is mSelectedFont if \ref setSelected is set to
+  <tt>true</tt>, else mFont is returned.
+*/
+QFont QCPPlotTitle::mainFont() const
+{
+  return mSelected ? mSelectedFont : mFont;
+}
+
+/*! \internal
+  
+  Returns the main color to be used. This is mSelectedTextColor if \ref setSelected is set to
+  <tt>true</tt>, else mTextColor is returned.
+*/
+QColor QCPPlotTitle::mainTextColor() const
+{
+  return mSelected ? mSelectedTextColor : mTextColor;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPColorScale
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPColorScale
+  \brief A color scale for use with color coding data such as QCPColorMap
+  
+  This layout element can be placed on the plot to correlate a color gradient with data values. It
+  is usually used in combination with one or multiple \ref QCPColorMap "QCPColorMaps".
+
+  \image html QCPColorScale.png
+  
+  The color scale can be either horizontal or vertical, as shown in the image above. The
+  orientation and the side where the numbers appear is controlled with \ref setType.
+  
+  Use \ref QCPColorMap::setColorScale to connect a color map with a color scale. Once they are
+  connected, they share their gradient, data range and data scale type (\ref setGradient, \ref
+  setDataRange, \ref setDataScaleType). Multiple color maps may be associated with a single color
+  scale, to make them all synchronize these properties.
+  
+  To have finer control over the number display and axis behaviour, you can directly access the
+  \ref axis. See the documentation of QCPAxis for details about configuring axes. For example, if
+  you want to change the number of automatically generated ticks, call
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpcolorscale-autotickcount
+  
+  Placing a color scale next to the main axis rect works like with any other layout element:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpcolorscale-creation
+  In this case we have placed it to the right of the default axis rect, so it wasn't necessary to
+  call \ref setType, since \ref QCPAxis::atRight is already the default. The text next to the color
+  scale can be set with \ref setLabel.
+  
+  For optimum appearance (like in the image above), it may be desirable to line up the axis rect and
+  the borders of the color scale. Use a \ref QCPMarginGroup to achieve this:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpcolorscale-margingroup
+  
+  Color scales are initialized with a non-zero minimum top and bottom margin (\ref
+  setMinimumMargins), because vertical color scales are most common and the minimum top/bottom
+  margin makes sure it keeps some distance to the top/bottom widget border. So if you change to a
+  horizontal color scale by setting \ref setType to \ref QCPAxis::atBottom or \ref QCPAxis::atTop, you
+  might want to also change the minimum margins accordingly, e.g. <tt>setMinimumMargins(QMargins(6, 0, 6, 0))</tt>.
+*/
+
+/* start documentation of inline functions */
+
+/*! \fn QCPAxis *QCPColorScale::axis() const
+  
+  Returns the internal \ref QCPAxis instance of this color scale. You can access it to alter the
+  appearance and behaviour of the axis. \ref QCPColorScale duplicates some properties in its
+  interface for convenience. Those are \ref setDataRange (\ref QCPAxis::setRange), \ref
+  setDataScaleType (\ref QCPAxis::setScaleType), and the method \ref setLabel (\ref
+  QCPAxis::setLabel). As they each are connected, it does not matter whether you use the method on
+  the QCPColorScale or on its QCPAxis.
+  
+  If the type of the color scale is changed with \ref setType, the axis returned by this method
+  will change, too, to either the left, right, bottom or top axis, depending on which type was set.
+*/
+
+/* end documentation of signals */
+/* start documentation of signals */
+
+/*! \fn void QCPColorScale::dataRangeChanged(QCPRange newRange);
+  
+  This signal is emitted when the data range changes.
+  
+  \see setDataRange
+*/
+
+/*! \fn void QCPColorScale::dataScaleTypeChanged(QCPAxis::ScaleType scaleType);
+  
+  This signal is emitted when the data scale type changes.
+  
+  \see setDataScaleType
+*/
+
+/*! \fn void QCPColorScale::gradientChanged(QCPColorGradient newGradient);
+  
+  This signal is emitted when the gradient changes.
+  
+  \see setGradient
+*/
+
+/* end documentation of signals */
+
+/*!
+  Constructs a new QCPColorScale.
+*/
+QCPColorScale::QCPColorScale(QCustomPlot *parentPlot) :
+  QCPLayoutElement(parentPlot),
+  mType(QCPAxis::atTop), // set to atTop such that setType(QCPAxis::atRight) below doesn't skip work because it thinks it's already atRight
+  mDataScaleType(QCPAxis::stLinear),
+  mBarWidth(20),
+  mAxisRect(new QCPColorScaleAxisRectPrivate(this))
+{
+  setMinimumMargins(QMargins(0, 6, 0, 6)); // for default right color scale types, keep some room at bottom and top (important if no margin group is used)
+  setType(QCPAxis::atRight);
+  setDataRange(QCPRange(0, 6));
+}
+
+QCPColorScale::~QCPColorScale()
+{
+  delete mAxisRect;
+}
+
+/* undocumented getter */
+QString QCPColorScale::label() const
+{
+  if (!mColorAxis)
+  {
+    qDebug() << Q_FUNC_INFO << "internal color axis undefined";
+    return QString();
+  }
+  
+  return mColorAxis.data()->label();
+}
+
+/* undocumented getter */
+bool QCPColorScale::rangeDrag() const
+{
+  if (!mAxisRect)
+  {
+    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
+    return false;
+  }
+  
+  return mAxisRect.data()->rangeDrag().testFlag(QCPAxis::orientation(mType)) &&
+      mAxisRect.data()->rangeDragAxis(QCPAxis::orientation(mType)) &&
+      mAxisRect.data()->rangeDragAxis(QCPAxis::orientation(mType))->orientation() == QCPAxis::orientation(mType);
+}
+
+/* undocumented getter */
+bool QCPColorScale::rangeZoom() const
+{
+  if (!mAxisRect)
+  {
+    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
+    return false;
+  }
+  
+  return mAxisRect.data()->rangeZoom().testFlag(QCPAxis::orientation(mType)) &&
+      mAxisRect.data()->rangeZoomAxis(QCPAxis::orientation(mType)) &&
+      mAxisRect.data()->rangeZoomAxis(QCPAxis::orientation(mType))->orientation() == QCPAxis::orientation(mType);
+}
+
+/*!
+  Sets at which side of the color scale the axis is placed, and thus also its orientation.
+  
+  Note that after setting \a type to a different value, the axis returned by \ref axis() will
+  be a different one. The new axis will adopt the following properties from the previous axis: The
+  range, scale type, log base and label.
+*/
+void QCPColorScale::setType(QCPAxis::AxisType type)
+{
+  if (!mAxisRect)
+  {
+    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
+    return;
+  }
+  if (mType != type)
+  {
+    mType = type;
+    QCPRange rangeTransfer(0, 6);
+    double logBaseTransfer = 10;
+    QString labelTransfer;
+    // revert some settings on old axis:
+    if (mColorAxis)
+    {
+      rangeTransfer = mColorAxis.data()->range();
+      labelTransfer = mColorAxis.data()->label();
+      logBaseTransfer = mColorAxis.data()->scaleLogBase();
+      mColorAxis.data()->setLabel(QString());
+      disconnect(mColorAxis.data(), SIGNAL(rangeChanged(QCPRange)), this, SLOT(setDataRange(QCPRange)));
+      disconnect(mColorAxis.data(), SIGNAL(scaleTypeChanged(QCPAxis::ScaleType)), this, SLOT(setDataScaleType(QCPAxis::ScaleType)));
+    }
+    QList<QCPAxis::AxisType> allAxisTypes = QList<QCPAxis::AxisType>() << QCPAxis::atLeft << QCPAxis::atRight << QCPAxis::atBottom << QCPAxis::atTop;
+    foreach (QCPAxis::AxisType atype, allAxisTypes)
+    {
+      mAxisRect.data()->axis(atype)->setTicks(atype == mType);
+      mAxisRect.data()->axis(atype)->setTickLabels(atype== mType);
+    }
+    // set new mColorAxis pointer:
+    mColorAxis = mAxisRect.data()->axis(mType);
+    // transfer settings to new axis:
+    mColorAxis.data()->setRange(rangeTransfer); // transfer range of old axis to new one (necessary if axis changes from vertical to horizontal or vice versa)
+    mColorAxis.data()->setLabel(labelTransfer);
+    mColorAxis.data()->setScaleLogBase(logBaseTransfer); // scaleType is synchronized among axes in realtime via signals (connected in QCPColorScale ctor), so we only need to take care of log base here
+    connect(mColorAxis.data(), SIGNAL(rangeChanged(QCPRange)), this, SLOT(setDataRange(QCPRange)));
+    connect(mColorAxis.data(), SIGNAL(scaleTypeChanged(QCPAxis::ScaleType)), this, SLOT(setDataScaleType(QCPAxis::ScaleType)));
+    mAxisRect.data()->setRangeDragAxes(QCPAxis::orientation(mType) == Qt::Horizontal ? mColorAxis.data() : 0,
+                                       QCPAxis::orientation(mType) == Qt::Vertical ? mColorAxis.data() : 0);
+  }
+}
+
+/*!
+  Sets the range spanned by the color gradient and that is shown by the axis in the color scale.
+  
+  It is equivalent to calling QCPColorMap::setDataRange on any of the connected color maps. It is
+  also equivalent to directly accessing the \ref axis and setting its range with \ref
+  QCPAxis::setRange.
+  
+  \see setDataScaleType, setGradient, rescaleDataRange
+*/
+void QCPColorScale::setDataRange(const QCPRange &dataRange)
+{
+  if (mDataRange.lower != dataRange.lower || mDataRange.upper != dataRange.upper)
+  {
+    mDataRange = dataRange;
+    if (mColorAxis)
+      mColorAxis.data()->setRange(mDataRange);
+    emit dataRangeChanged(mDataRange);
+  }
+}
+
+/*!
+  Sets the scale type of the color scale, i.e. whether values are linearly associated with colors
+  or logarithmically.
+  
+  It is equivalent to calling QCPColorMap::setDataScaleType on any of the connected color maps. It is
+  also equivalent to directly accessing the \ref axis and setting its scale type with \ref
+  QCPAxis::setScaleType.
+  
+  \see setDataRange, setGradient
+*/
+void QCPColorScale::setDataScaleType(QCPAxis::ScaleType scaleType)
+{
+  if (mDataScaleType != scaleType)
+  {
+    mDataScaleType = scaleType;
+    if (mColorAxis)
+      mColorAxis.data()->setScaleType(mDataScaleType);
+    if (mDataScaleType == QCPAxis::stLogarithmic)
+      setDataRange(mDataRange.sanitizedForLogScale());
+    emit dataScaleTypeChanged(mDataScaleType);
+  }
+}
+
+/*!
+  Sets the color gradient that will be used to represent data values.
+  
+  It is equivalent to calling QCPColorMap::setGradient on any of the connected color maps.
+  
+  \see setDataRange, setDataScaleType
+*/
+void QCPColorScale::setGradient(const QCPColorGradient &gradient)
+{
+  if (mGradient != gradient)
+  {
+    mGradient = gradient;
+    if (mAxisRect)
+      mAxisRect.data()->mGradientImageInvalidated = true;
+    emit gradientChanged(mGradient);
+  }
+}
+
+/*!
+  Sets the axis label of the color scale. This is equivalent to calling \ref QCPAxis::setLabel on
+  the internal \ref axis.
+*/
+void QCPColorScale::setLabel(const QString &str)
+{
+  if (!mColorAxis)
+  {
+    qDebug() << Q_FUNC_INFO << "internal color axis undefined";
+    return;
+  }
+  
+  mColorAxis.data()->setLabel(str);
+}
+
+/*!
+  Sets the width (or height, for horizontal color scales) the bar where the gradient is displayed
+  will have.
+*/
+void QCPColorScale::setBarWidth(int width)
+{
+  mBarWidth = width;
+}
+
+/*!
+  Sets whether the user can drag the data range (\ref setDataRange).
+  
+  Note that \ref QCP::iRangeDrag must be in the QCustomPlot's interactions (\ref
+  QCustomPlot::setInteractions) to allow range dragging.
+*/
+void QCPColorScale::setRangeDrag(bool enabled)
+{
+  if (!mAxisRect)
+  {
+    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
+    return;
+  }
+  
+  if (enabled)
+    mAxisRect.data()->setRangeDrag(QCPAxis::orientation(mType));
+  else
+    mAxisRect.data()->setRangeDrag(0);
+}
+
+/*!
+  Sets whether the user can zoom the data range (\ref setDataRange) by scrolling the mouse wheel.
+  
+  Note that \ref QCP::iRangeZoom must be in the QCustomPlot's interactions (\ref
+  QCustomPlot::setInteractions) to allow range dragging.
+*/
+void QCPColorScale::setRangeZoom(bool enabled)
+{
+  if (!mAxisRect)
+  {
+    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
+    return;
+  }
+  
+  if (enabled)
+    mAxisRect.data()->setRangeZoom(QCPAxis::orientation(mType));
+  else
+    mAxisRect.data()->setRangeZoom(0);
+}
+
+/*!
+  Returns a list of all the color maps associated with this color scale.
+*/
+QList<QCPColorMap*> QCPColorScale::colorMaps() const
+{
+  QList<QCPColorMap*> result;
+  for (int i=0; i<mParentPlot->plottableCount(); ++i)
+  {
+    if (QCPColorMap *cm = qobject_cast<QCPColorMap*>(mParentPlot->plottable(i)))
+      if (cm->colorScale() == this)
+        result.append(cm);
+  }
+  return result;
+}
+
+/*!
+  Changes the data range such that all color maps associated with this color scale are fully mapped
+  to the gradient in the data dimension.
+  
+  \see setDataRange
+*/
+void QCPColorScale::rescaleDataRange(bool onlyVisibleMaps)
+{
+  QList<QCPColorMap*> maps = colorMaps();
+  QCPRange newRange;
+  bool haveRange = false;
+  int sign = 0; // TODO: should change this to QCPAbstractPlottable::SignDomain later (currently is protected, maybe move to QCP namespace)
+  if (mDataScaleType == QCPAxis::stLogarithmic)
+    sign = (mDataRange.upper < 0 ? -1 : 1);
+  for (int i=0; i<maps.size(); ++i)
+  {
+    if (!maps.at(i)->realVisibility() && onlyVisibleMaps)
+      continue;
+    QCPRange mapRange;
+    if (maps.at(i)->colorScale() == this)
+    {
+      bool currentFoundRange = true;
+      mapRange = maps.at(i)->data()->dataBounds();
+      if (sign == 1)
+      {
+        if (mapRange.lower <= 0 && mapRange.upper > 0)
+          mapRange.lower = mapRange.upper*1e-3;
+        else if (mapRange.lower <= 0 && mapRange.upper <= 0)
+          currentFoundRange = false;
+      } else if (sign == -1)
+      {
+        if (mapRange.upper >= 0 && mapRange.lower < 0)
+          mapRange.upper = mapRange.lower*1e-3;
+        else if (mapRange.upper >= 0 && mapRange.lower >= 0)
+          currentFoundRange = false;
+      }
+      if (currentFoundRange)
+      {
+        if (!haveRange)
+          newRange = mapRange;
+        else
+          newRange.expand(mapRange);
+        haveRange = true;
+      }
+    }
+  }
+  if (haveRange)
+  {
+    if (!QCPRange::validRange(newRange)) // likely due to range being zero (plottable has only constant data in this dimension), shift current range to at least center the data
+    {
+      double center = (newRange.lower+newRange.upper)*0.5; // upper and lower should be equal anyway, but just to make sure, incase validRange returned false for other reason
+      if (mDataScaleType == QCPAxis::stLinear)
+      {
+        newRange.lower = center-mDataRange.size()/2.0;
+        newRange.upper = center+mDataRange.size()/2.0;
+      } else // mScaleType == stLogarithmic
+      {
+        newRange.lower = center/qSqrt(mDataRange.upper/mDataRange.lower);
+        newRange.upper = center*qSqrt(mDataRange.upper/mDataRange.lower);
+      }
+    }
+    setDataRange(newRange);
+  }
+}
+
+/* inherits documentation from base class */
+void QCPColorScale::update(UpdatePhase phase)
+{
+  QCPLayoutElement::update(phase);
+  if (!mAxisRect)
+  {
+    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
+    return;
+  }
+  
+  mAxisRect.data()->update(phase);
+  
+  switch (phase)
+  {
+    case upMargins:
+    {
+      if (mType == QCPAxis::atBottom || mType == QCPAxis::atTop)
+      {
+        setMaximumSize(QWIDGETSIZE_MAX, mBarWidth+mAxisRect.data()->margins().top()+mAxisRect.data()->margins().bottom()+margins().top()+margins().bottom());
+        setMinimumSize(0,               mBarWidth+mAxisRect.data()->margins().top()+mAxisRect.data()->margins().bottom()+margins().top()+margins().bottom());
+      } else
+      {
+        setMaximumSize(mBarWidth+mAxisRect.data()->margins().left()+mAxisRect.data()->margins().right()+margins().left()+margins().right(), QWIDGETSIZE_MAX);
+        setMinimumSize(mBarWidth+mAxisRect.data()->margins().left()+mAxisRect.data()->margins().right()+margins().left()+margins().right(), 0);
+      }
+      break;
+    }
+    case upLayout:
+    {
+      mAxisRect.data()->setOuterRect(rect());
+      break;
+    }
+    default: break;
+  }
+}
+
+/* inherits documentation from base class */
+void QCPColorScale::applyDefaultAntialiasingHint(QCPPainter *painter) const
+{
+  painter->setAntialiasing(false);
+}
+
+/* inherits documentation from base class */
+void QCPColorScale::mousePressEvent(QMouseEvent *event)
+{
+  if (!mAxisRect)
+  {
+    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
+    return;
+  }
+  mAxisRect.data()->mousePressEvent(event);
+}
+
+/* inherits documentation from base class */
+void QCPColorScale::mouseMoveEvent(QMouseEvent *event)
+{
+  if (!mAxisRect)
+  {
+    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
+    return;
+  }
+  mAxisRect.data()->mouseMoveEvent(event);
+}
+
+/* inherits documentation from base class */
+void QCPColorScale::mouseReleaseEvent(QMouseEvent *event)
+{
+  if (!mAxisRect)
+  {
+    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
+    return;
+  }
+  mAxisRect.data()->mouseReleaseEvent(event);
+}
+
+/* inherits documentation from base class */
+void QCPColorScale::wheelEvent(QWheelEvent *event)
+{
+  if (!mAxisRect)
+  {
+    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
+    return;
+  }
+  mAxisRect.data()->wheelEvent(event);
+}
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPColorScaleAxisRectPrivate
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPColorScaleAxisRectPrivate
+
+  \internal
+  \brief An axis rect subclass for use in a QCPColorScale
+  
+  This is a private class and not part of the public QCustomPlot interface.
+  
+  It provides the axis rect functionality for the QCPColorScale class.
+*/
+
+
+/*!
+  Creates a new instance, as a child of \a parentColorScale.
+*/
+QCPColorScaleAxisRectPrivate::QCPColorScaleAxisRectPrivate(QCPColorScale *parentColorScale) :
+  QCPAxisRect(parentColorScale->parentPlot(), true),
+  mParentColorScale(parentColorScale),
+  mGradientImageInvalidated(true)
+{
+  setParentLayerable(parentColorScale);
+  setMinimumMargins(QMargins(0, 0, 0, 0));
+  QList<QCPAxis::AxisType> allAxisTypes = QList<QCPAxis::AxisType>() << QCPAxis::atBottom << QCPAxis::atTop << QCPAxis::atLeft << QCPAxis::atRight;
+  foreach (QCPAxis::AxisType type, allAxisTypes)
+  {
+    axis(type)->setVisible(true);
+    axis(type)->grid()->setVisible(false);
+    axis(type)->setPadding(0);
+    connect(axis(type), SIGNAL(selectionChanged(QCPAxis::SelectableParts)), this, SLOT(axisSelectionChanged(QCPAxis::SelectableParts)));
+    connect(axis(type), SIGNAL(selectableChanged(QCPAxis::SelectableParts)), this, SLOT(axisSelectableChanged(QCPAxis::SelectableParts)));
+  }
+
+  connect(axis(QCPAxis::atLeft), SIGNAL(rangeChanged(QCPRange)), axis(QCPAxis::atRight), SLOT(setRange(QCPRange)));
+  connect(axis(QCPAxis::atRight), SIGNAL(rangeChanged(QCPRange)), axis(QCPAxis::atLeft), SLOT(setRange(QCPRange)));
+  connect(axis(QCPAxis::atBottom), SIGNAL(rangeChanged(QCPRange)), axis(QCPAxis::atTop), SLOT(setRange(QCPRange)));
+  connect(axis(QCPAxis::atTop), SIGNAL(rangeChanged(QCPRange)), axis(QCPAxis::atBottom), SLOT(setRange(QCPRange)));
+  connect(axis(QCPAxis::atLeft), SIGNAL(scaleTypeChanged(QCPAxis::ScaleType)), axis(QCPAxis::atRight), SLOT(setScaleType(QCPAxis::ScaleType)));
+  connect(axis(QCPAxis::atRight), SIGNAL(scaleTypeChanged(QCPAxis::ScaleType)), axis(QCPAxis::atLeft), SLOT(setScaleType(QCPAxis::ScaleType)));
+  connect(axis(QCPAxis::atBottom), SIGNAL(scaleTypeChanged(QCPAxis::ScaleType)), axis(QCPAxis::atTop), SLOT(setScaleType(QCPAxis::ScaleType)));
+  connect(axis(QCPAxis::atTop), SIGNAL(scaleTypeChanged(QCPAxis::ScaleType)), axis(QCPAxis::atBottom), SLOT(setScaleType(QCPAxis::ScaleType)));
+  
+  // make layer transfers of color scale transfer to axis rect and axes
+  // the axes must be set after axis rect, such that they appear above color gradient drawn by axis rect:
+  connect(parentColorScale, SIGNAL(layerChanged(QCPLayer*)), this, SLOT(setLayer(QCPLayer*)));
+  foreach (QCPAxis::AxisType type, allAxisTypes)
+    connect(parentColorScale, SIGNAL(layerChanged(QCPLayer*)), axis(type), SLOT(setLayer(QCPLayer*)));
+}
+
+/*! \internal
+  Updates the color gradient image if necessary, by calling \ref updateGradientImage, then draws
+  it. Then the axes are drawn by calling the \ref QCPAxisRect::draw base class implementation.
+*/
+void QCPColorScaleAxisRectPrivate::draw(QCPPainter *painter)
+{
+  if (mGradientImageInvalidated)
+    updateGradientImage();
+  
+  bool mirrorHorz = false;
+  bool mirrorVert = false;
+  if (mParentColorScale->mColorAxis)
+  {
+    mirrorHorz = mParentColorScale->mColorAxis.data()->rangeReversed() && (mParentColorScale->type() == QCPAxis::atBottom || mParentColorScale->type() == QCPAxis::atTop);
+    mirrorVert = mParentColorScale->mColorAxis.data()->rangeReversed() && (mParentColorScale->type() == QCPAxis::atLeft || mParentColorScale->type() == QCPAxis::atRight);
+  }
+  
+  painter->drawImage(rect().adjusted(0, -1, 0, -1), mGradientImage.mirrored(mirrorHorz, mirrorVert));
+  QCPAxisRect::draw(painter);
+}
+
+/*! \internal
+
+  Uses the current gradient of the parent \ref QCPColorScale (specified in the constructor) to
+  generate a gradient image. This gradient image will be used in the \ref draw method.
+*/
+void QCPColorScaleAxisRectPrivate::updateGradientImage()
+{
+  if (rect().isEmpty())
+    return;
+  
+  int n = mParentColorScale->mGradient.levelCount();
+  int w, h;
+  QVector<double> data(n);
+  for (int i=0; i<n; ++i)
+    data[i] = i;
+  if (mParentColorScale->mType == QCPAxis::atBottom || mParentColorScale->mType == QCPAxis::atTop)
+  {
+    w = n;
+    h = rect().height();
+    mGradientImage = QImage(w, h, QImage::Format_RGB32);
+    QVector<QRgb*> pixels;
+    for (int y=0; y<h; ++y)
+      pixels.append(reinterpret_cast<QRgb*>(mGradientImage.scanLine(y)));
+    mParentColorScale->mGradient.colorize(data.constData(), QCPRange(0, n-1), pixels.first(), n);
+    for (int y=1; y<h; ++y)
+      memcpy(pixels.at(y), pixels.first(), n*sizeof(QRgb));
+  } else
+  {
+    w = rect().width();
+    h = n;
+    mGradientImage = QImage(w, h, QImage::Format_RGB32);
+    for (int y=0; y<h; ++y)
+    {
+      QRgb *pixels = reinterpret_cast<QRgb*>(mGradientImage.scanLine(y));
+      const QRgb lineColor = mParentColorScale->mGradient.color(data[h-1-y], QCPRange(0, n-1));
+      for (int x=0; x<w; ++x)
+        pixels[x] = lineColor;
+    }
+  }
+  mGradientImageInvalidated = false;
+}
+
+/*! \internal
+
+  This slot is connected to the selectionChanged signals of the four axes in the constructor. It
+  synchronizes the selection state of the axes.
+*/
+void QCPColorScaleAxisRectPrivate::axisSelectionChanged(QCPAxis::SelectableParts selectedParts)
+{
+  // axis bases of four axes shall always (de-)selected synchronously:
+  QList<QCPAxis::AxisType> allAxisTypes = QList<QCPAxis::AxisType>() << QCPAxis::atBottom << QCPAxis::atTop << QCPAxis::atLeft << QCPAxis::atRight;
+  foreach (QCPAxis::AxisType type, allAxisTypes)
+  {
+    if (QCPAxis *senderAxis = qobject_cast<QCPAxis*>(sender()))
+      if (senderAxis->axisType() == type)
+        continue;
+    
+    if (axis(type)->selectableParts().testFlag(QCPAxis::spAxis))
+    {
+      if (selectedParts.testFlag(QCPAxis::spAxis))
+        axis(type)->setSelectedParts(axis(type)->selectedParts() | QCPAxis::spAxis);
+      else
+        axis(type)->setSelectedParts(axis(type)->selectedParts() & ~QCPAxis::spAxis);
+    }
+  }
+}
+
+/*! \internal
+
+  This slot is connected to the selectableChanged signals of the four axes in the constructor. It
+  synchronizes the selectability of the axes.
+*/
+void QCPColorScaleAxisRectPrivate::axisSelectableChanged(QCPAxis::SelectableParts selectableParts)
+{
+  // synchronize axis base selectability:
+  QList<QCPAxis::AxisType> allAxisTypes = QList<QCPAxis::AxisType>() << QCPAxis::atBottom << QCPAxis::atTop << QCPAxis::atLeft << QCPAxis::atRight;
+  foreach (QCPAxis::AxisType type, allAxisTypes)
+  {
+    if (QCPAxis *senderAxis = qobject_cast<QCPAxis*>(sender()))
+      if (senderAxis->axisType() == type)
+        continue;
+    
+    if (axis(type)->selectableParts().testFlag(QCPAxis::spAxis))
+    {
+      if (selectableParts.testFlag(QCPAxis::spAxis))
+        axis(type)->setSelectableParts(axis(type)->selectableParts() | QCPAxis::spAxis);
+      else
+        axis(type)->setSelectableParts(axis(type)->selectableParts() & ~QCPAxis::spAxis);
+    }
+  }
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPData
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPData
+  \brief Holds the data of one single data point for QCPGraph.
+  
+  The container for storing multiple data points is \ref QCPDataMap.
+  
+  The stored data is:
+  \li \a key: coordinate on the key axis of this data point
+  \li \a value: coordinate on the value axis of this data point
+  \li \a keyErrorMinus: negative error in the key dimension (for error bars)
+  \li \a keyErrorPlus: positive error in the key dimension (for error bars)
+  \li \a valueErrorMinus: negative error in the value dimension (for error bars)
+  \li \a valueErrorPlus: positive error in the value dimension (for error bars)
+  
+  \see QCPDataMap
+*/
+
+/*!
+  Constructs a data point with key, value and all errors set to zero.
+*/
+QCPData::QCPData() :
+  key(0),
+  value(0),
+  keyErrorPlus(0),
+  keyErrorMinus(0),
+  valueErrorPlus(0),
+  valueErrorMinus(0)
+{
+}
+
+/*!
+  Constructs a data point with the specified \a key and \a value. All errors are set to zero.
+*/
+QCPData::QCPData(double key, double value) :
+  key(key),
+  value(value),
+  keyErrorPlus(0),
+  keyErrorMinus(0),
+  valueErrorPlus(0),
+  valueErrorMinus(0)
+{
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPGraph
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPGraph
+  \brief A plottable representing a graph in a plot.
+
+  \image html QCPGraph.png
+  
+  Usually you create new graphs by calling QCustomPlot::addGraph. The resulting instance can be
+  accessed via QCustomPlot::graph.
+
+  To plot data, assign it with the \ref setData or \ref addData functions. Alternatively, you can
+  also access and modify the graph's data via the \ref data method, which returns a pointer to the
+  internal \ref QCPDataMap.
+  
+  Graphs are used to display single-valued data. Single-valued means that there should only be one
+  data point per unique key coordinate. In other words, the graph can't have \a loops. If you do
+  want to plot non-single-valued curves, rather use the QCPCurve plottable.
+  
+  Gaps in the graph line can be created by adding data points with NaN as value
+  (<tt>qQNaN()</tt> or <tt>std::numeric_limits<double>::quiet_NaN()</tt>) in between the two data points that shall be
+  separated.
+  
+  \section appearance Changing the appearance
+  
+  The appearance of the graph is mainly determined by the line style, scatter style, brush and pen
+  of the graph (\ref setLineStyle, \ref setScatterStyle, \ref setBrush, \ref setPen).
+  
+  \subsection filling Filling under or between graphs
+  
+  QCPGraph knows two types of fills: Normal graph fills towards the zero-value-line parallel to
+  the key axis of the graph, and fills between two graphs, called channel fills. To enable a fill,
+  just set a brush with \ref setBrush which is neither Qt::NoBrush nor fully transparent.
+  
+  By default, a normal fill towards the zero-value-line will be drawn. To set up a channel fill
+  between this graph and another one, call \ref setChannelFillGraph with the other graph as
+  parameter.
+
+  \see QCustomPlot::addGraph, QCustomPlot::graph
+*/
+
+/* start of documentation of inline functions */
+
+/*! \fn QCPDataMap *QCPGraph::data() const
+  
+  Returns a pointer to the internal data storage of type \ref QCPDataMap. You may use it to
+  directly manipulate the data, which may be more convenient and faster than using the regular \ref
+  setData or \ref addData methods, in certain situations.
+*/
+
+/* end of documentation of inline functions */
+
+/*!
+  Constructs a graph which uses \a keyAxis as its key axis ("x") and \a valueAxis as its value
+  axis ("y"). \a keyAxis and \a valueAxis must reside in the same QCustomPlot instance and not have
+  the same orientation. If either of these restrictions is violated, a corresponding message is
+  printed to the debug output (qDebug), the construction is not aborted, though.
+  
+  The constructed QCPGraph can be added to the plot with QCustomPlot::addPlottable, QCustomPlot
+  then takes ownership of the graph.
+  
+  To directly create a graph inside a plot, you can also use the simpler QCustomPlot::addGraph function.
+*/
+QCPGraph::QCPGraph(QCPAxis *keyAxis, QCPAxis *valueAxis) :
+  QCPAbstractPlottable(keyAxis, valueAxis)
+{
+  mData = new QCPDataMap;
+  
+  setPen(QPen(Qt::blue, 0));
+  setErrorPen(QPen(Qt::black));
+  setBrush(Qt::NoBrush);
+  setSelectedPen(QPen(QColor(80, 80, 255), 2.5));
+  setSelectedBrush(Qt::NoBrush);
+  
+  setLineStyle(lsLine);
+  setErrorType(etNone);
+  setErrorBarSize(6);
+  setErrorBarSkipSymbol(true);
+  setChannelFillGraph(0);
+  setAdaptiveSampling(true);
+}
+
+QCPGraph::~QCPGraph()
+{
+  delete mData;
+}
+
+/*!
+  Replaces the current data with the provided \a data.
+  
+  If \a copy is set to true, data points in \a data will only be copied. if false, the graph
+  takes ownership of the passed data and replaces the internal data pointer with it. This is
+  significantly faster than copying for large datasets.
+  
+  Alternatively, you can also access and modify the graph's data via the \ref data method, which
+  returns a pointer to the internal \ref QCPDataMap.
+*/
+void QCPGraph::setData(QCPDataMap *data, bool copy)
+{
+  if (mData == data)
+  {
+    qDebug() << Q_FUNC_INFO << "The data pointer is already in (and owned by) this plottable" << reinterpret_cast<quintptr>(data);
+    return;
+  }
+  if (copy)
+  {
+    *mData = *data;
+  } else
+  {
+    delete mData;
+    mData = data;
+  }
+}
+
+/*! \overload
+  
+  Replaces the current data with the provided points in \a key and \a value pairs. The provided
+  vectors should have equal length. Else, the number of added points will be the size of the
+  smallest vector.
+*/
+void QCPGraph::setData(const QVector<double> &key, const QVector<double> &value)
+{
+  mData->clear();
+  int n = key.size();
+  n = qMin(n, value.size());
+  QCPData newData;
+  for (int i=0; i<n; ++i)
+  {
+    newData.key = key[i];
+    newData.value = value[i];
+    mData->insertMulti(newData.key, newData);
+  }
+}
+
+/*!
+  Replaces the current data with the provided points in \a key and \a value pairs. Additionally the
+  symmetrical value error of the data points are set to the values in \a valueError.
+  For error bars to show appropriately, see \ref setErrorType.
+  The provided vectors should have equal length. Else, the number of added points will be the size of the
+  smallest vector.
+  
+  For asymmetrical errors (plus different from minus), see the overloaded version of this function.
+*/
+void QCPGraph::setDataValueError(const QVector<double> &key, const QVector<double> &value, const QVector<double> &valueError)
+{
+  mData->clear();
+  int n = key.size();
+  n = qMin(n, value.size());
+  n = qMin(n, valueError.size());
+  QCPData newData;
+  for (int i=0; i<n; ++i)
+  {
+    newData.key = key[i];
+    newData.value = value[i];
+    newData.valueErrorMinus = valueError[i];
+    newData.valueErrorPlus = valueError[i];
+    mData->insertMulti(key[i], newData);
+  }
+}
+
+/*!
+  \overload
+  Replaces the current data with the provided points in \a key and \a value pairs. Additionally the
+  negative value error of the data points are set to the values in \a valueErrorMinus, the positive
+  value error to \a valueErrorPlus.
+  For error bars to show appropriately, see \ref setErrorType.
+  The provided vectors should have equal length. Else, the number of added points will be the size of the
+  smallest vector.
+*/
+void QCPGraph::setDataValueError(const QVector<double> &key, const QVector<double> &value, const QVector<double> &valueErrorMinus, const QVector<double> &valueErrorPlus)
+{
+  mData->clear();
+  int n = key.size();
+  n = qMin(n, value.size());
+  n = qMin(n, valueErrorMinus.size());
+  n = qMin(n, valueErrorPlus.size());
+  QCPData newData;
+  for (int i=0; i<n; ++i)
+  {
+    newData.key = key[i];
+    newData.value = value[i];
+    newData.valueErrorMinus = valueErrorMinus[i];
+    newData.valueErrorPlus = valueErrorPlus[i];
+    mData->insertMulti(key[i], newData);
+  }
+}
+
+/*!
+  Replaces the current data with the provided points in \a key and \a value pairs. Additionally the
+  symmetrical key error of the data points are set to the values in \a keyError.
+  For error bars to show appropriately, see \ref setErrorType.
+  The provided vectors should have equal length. Else, the number of added points will be the size of the
+  smallest vector.
+  
+  For asymmetrical errors (plus different from minus), see the overloaded version of this function.
+*/
+void QCPGraph::setDataKeyError(const QVector<double> &key, const QVector<double> &value, const QVector<double> &keyError)
+{
+  mData->clear();
+  int n = key.size();
+  n = qMin(n, value.size());
+  n = qMin(n, keyError.size());
+  QCPData newData;
+  for (int i=0; i<n; ++i)
+  {
+    newData.key = key[i];
+    newData.value = value[i];
+    newData.keyErrorMinus = keyError[i];
+    newData.keyErrorPlus = keyError[i];
+    mData->insertMulti(key[i], newData);
+  }
+}
+
+/*!
+  \overload
+  Replaces the current data with the provided points in \a key and \a value pairs. Additionally the
+  negative key error of the data points are set to the values in \a keyErrorMinus, the positive
+  key error to \a keyErrorPlus.
+  For error bars to show appropriately, see \ref setErrorType.
+  The provided vectors should have equal length. Else, the number of added points will be the size of the
+  smallest vector.
+*/
+void QCPGraph::setDataKeyError(const QVector<double> &key, const QVector<double> &value, const QVector<double> &keyErrorMinus, const QVector<double> &keyErrorPlus)
+{
+  mData->clear();
+  int n = key.size();
+  n = qMin(n, value.size());
+  n = qMin(n, keyErrorMinus.size());
+  n = qMin(n, keyErrorPlus.size());
+  QCPData newData;
+  for (int i=0; i<n; ++i)
+  {
+    newData.key = key[i];
+    newData.value = value[i];
+    newData.keyErrorMinus = keyErrorMinus[i];
+    newData.keyErrorPlus = keyErrorPlus[i];
+    mData->insertMulti(key[i], newData);
+  }
+}
+
+/*!
+  Replaces the current data with the provided points in \a key and \a value pairs. Additionally the
+  symmetrical key and value errors of the data points are set to the values in \a keyError and \a valueError.
+  For error bars to show appropriately, see \ref setErrorType.
+  The provided vectors should have equal length. Else, the number of added points will be the size of the
+  smallest vector.
+  
+  For asymmetrical errors (plus different from minus), see the overloaded version of this function.
+*/
+void QCPGraph::setDataBothError(const QVector<double> &key, const QVector<double> &value, const QVector<double> &keyError, const QVector<double> &valueError)
+{
+  mData->clear();
+  int n = key.size();
+  n = qMin(n, value.size());
+  n = qMin(n, valueError.size());
+  n = qMin(n, keyError.size());
+  QCPData newData;
+  for (int i=0; i<n; ++i)
+  {
+    newData.key = key[i];
+    newData.value = value[i];
+    newData.keyErrorMinus = keyError[i];
+    newData.keyErrorPlus = keyError[i];
+    newData.valueErrorMinus = valueError[i];
+    newData.valueErrorPlus = valueError[i];
+    mData->insertMulti(key[i], newData);
+  }
+}
+
+/*!
+  \overload
+  Replaces the current data with the provided points in \a key and \a value pairs. Additionally the
+  negative key and value errors of the data points are set to the values in \a keyErrorMinus and \a valueErrorMinus. The positive
+  key and value errors are set to the values in \a keyErrorPlus \a valueErrorPlus.
+  For error bars to show appropriately, see \ref setErrorType.
+  The provided vectors should have equal length. Else, the number of added points will be the size of the
+  smallest vector.
+*/
+void QCPGraph::setDataBothError(const QVector<double> &key, const QVector<double> &value, const QVector<double> &keyErrorMinus, const QVector<double> &keyErrorPlus, const QVector<double> &valueErrorMinus, const QVector<double> &valueErrorPlus)
+{
+  mData->clear();
+  int n = key.size();
+  n = qMin(n, value.size());
+  n = qMin(n, valueErrorMinus.size());
+  n = qMin(n, valueErrorPlus.size());
+  n = qMin(n, keyErrorMinus.size());
+  n = qMin(n, keyErrorPlus.size());
+  QCPData newData;
+  for (int i=0; i<n; ++i)
+  {
+    newData.key = key[i];
+    newData.value = value[i];
+    newData.keyErrorMinus = keyErrorMinus[i];
+    newData.keyErrorPlus = keyErrorPlus[i];
+    newData.valueErrorMinus = valueErrorMinus[i];
+    newData.valueErrorPlus = valueErrorPlus[i];
+    mData->insertMulti(key[i], newData);
+  }
+}
+
+
+/*!
+  Sets how the single data points are connected in the plot. For scatter-only plots, set \a ls to
+  \ref lsNone and \ref setScatterStyle to the desired scatter style.
+  
+  \see setScatterStyle
+*/
+void QCPGraph::setLineStyle(LineStyle ls)
+{
+  mLineStyle = ls;
+}
+
+/*!
+  Sets the visual appearance of single data points in the plot. If set to \ref QCPScatterStyle::ssNone, no scatter points
+  are drawn (e.g. for line-only-plots with appropriate line style).
+  
+  \see QCPScatterStyle, setLineStyle
+*/
+void QCPGraph::setScatterStyle(const QCPScatterStyle &style)
+{
+  mScatterStyle = style;
+}
+
+/*!
+  Sets which kind of error bars (Key Error, Value Error or both) should be drawn on each data
+  point. If you set \a errorType to something other than \ref etNone, make sure to actually pass
+  error data via the specific setData functions along with the data points (e.g. \ref
+  setDataValueError, \ref setDataKeyError, \ref setDataBothError).
+
+  \see ErrorType
+*/
+void QCPGraph::setErrorType(ErrorType errorType)
+{
+  mErrorType = errorType;
+}
+
+/*!
+  Sets the pen with which the error bars will be drawn.
+  \see setErrorBarSize, setErrorType
+*/
+void QCPGraph::setErrorPen(const QPen &pen)
+{
+  mErrorPen = pen;
+}
+
+/*!
+  Sets the width of the handles at both ends of an error bar in pixels.
+*/
+void QCPGraph::setErrorBarSize(double size)
+{
+  mErrorBarSize = size;
+}
+
+/*!
+  If \a enabled is set to true, the error bar will not be drawn as a solid line under the scatter symbol but
+  leave some free space around the symbol.
+  
+  This feature uses the current scatter size (\ref QCPScatterStyle::setSize) to determine the size
+  of the area to leave blank. So when drawing Pixmaps as scatter points (\ref
+  QCPScatterStyle::ssPixmap), the scatter size must be set manually to a value corresponding to the
+  size of the Pixmap, if the error bars should leave gaps to its boundaries.
+  
+  \ref setErrorType, setErrorBarSize, setScatterStyle
+*/
+void QCPGraph::setErrorBarSkipSymbol(bool enabled)
+{
+  mErrorBarSkipSymbol = enabled;
+}
+
+/*!
+  Sets the target graph for filling the area between this graph and \a targetGraph with the current
+  brush (\ref setBrush).
+  
+  When \a targetGraph is set to 0, a normal graph fill to the zero-value-line will be shown. To
+  disable any filling, set the brush to Qt::NoBrush.
+
+  \see setBrush
+*/
+void QCPGraph::setChannelFillGraph(QCPGraph *targetGraph)
+{
+  // prevent setting channel target to this graph itself:
+  if (targetGraph == this)
+  {
+    qDebug() << Q_FUNC_INFO << "targetGraph is this graph itself";
+    mChannelFillGraph = 0;
+    return;
+  }
+  // prevent setting channel target to a graph not in the plot:
+  if (targetGraph && targetGraph->mParentPlot != mParentPlot)
+  {
+    qDebug() << Q_FUNC_INFO << "targetGraph not in same plot";
+    mChannelFillGraph = 0;
+    return;
+  }
+  
+  mChannelFillGraph = targetGraph;
+}
+
+/*!
+  Sets whether adaptive sampling shall be used when plotting this graph. QCustomPlot's adaptive
+  sampling technique can drastically improve the replot performance for graphs with a larger number
+  of points (e.g. above 10,000), without notably changing the appearance of the graph.
+  
+  By default, adaptive sampling is enabled. Even if enabled, QCustomPlot decides whether adaptive
+  sampling shall actually be used on a per-graph basis. So leaving adaptive sampling enabled has no
+  disadvantage in almost all cases.
+  
+  \image html adaptive-sampling-line.png "A line plot of 500,000 points without and with adaptive sampling"
+  
+  As can be seen, line plots experience no visual degradation from adaptive sampling. Outliers are
+  reproduced reliably, as well as the overall shape of the data set. The replot time reduces
+  dramatically though. This allows QCustomPlot to display large amounts of data in realtime.
+  
+  \image html adaptive-sampling-scatter.png "A scatter plot of 100,000 points without and with adaptive sampling"
+  
+  Care must be taken when using high-density scatter plots in combination with adaptive sampling.
+  The adaptive sampling algorithm treats scatter plots more carefully than line plots which still
+  gives a significant reduction of replot times, but not quite as much as for line plots. This is
+  because scatter plots inherently need more data points to be preserved in order to still resemble
+  the original, non-adaptive-sampling plot. As shown above, the results still aren't quite
+  identical, as banding occurs for the outer data points. This is in fact intentional, such that
+  the boundaries of the data cloud stay visible to the viewer. How strong the banding appears,
+  depends on the point density, i.e. the number of points in the plot.
+  
+  For some situations with scatter plots it might thus be desirable to manually turn adaptive
+  sampling off. For example, when saving the plot to disk. This can be achieved by setting \a
+  enabled to false before issuing a command like \ref QCustomPlot::savePng, and setting \a enabled
+  back to true afterwards.
+*/
+void QCPGraph::setAdaptiveSampling(bool enabled)
+{
+  mAdaptiveSampling = enabled;
+}
+
+/*!
+  Adds the provided data points in \a dataMap to the current data.
+  
+  Alternatively, you can also access and modify the graph's data via the \ref data method, which
+  returns a pointer to the internal \ref QCPDataMap.
+  
+  \see removeData
+*/
+void QCPGraph::addData(const QCPDataMap &dataMap)
+{
+  mData->unite(dataMap);
+}
+
+/*! \overload
+  Adds the provided single data point in \a data to the current data.
+  
+  Alternatively, you can also access and modify the graph's data via the \ref data method, which
+  returns a pointer to the internal \ref QCPDataMap.
+  
+  \see removeData
+*/
+void QCPGraph::addData(const QCPData &data)
+{
+  mData->insertMulti(data.key, data);
+}
+
+/*! \overload
+  Adds the provided single data point as \a key and \a value pair to the current data.
+  
+  Alternatively, you can also access and modify the graph's data via the \ref data method, which
+  returns a pointer to the internal \ref QCPDataMap.
+  
+  \see removeData
+*/
+void QCPGraph::addData(double key, double value)
+{
+  QCPData newData;
+  newData.key = key;
+  newData.value = value;
+  mData->insertMulti(newData.key, newData);
+}
+
+/*! \overload
+  Adds the provided data points as \a key and \a value pairs to the current data.
+  
+  Alternatively, you can also access and modify the graph's data via the \ref data method, which
+  returns a pointer to the internal \ref QCPDataMap.
+  
+  \see removeData
+*/
+void QCPGraph::addData(const QVector<double> &keys, const QVector<double> &values)
+{
+  int n = qMin(keys.size(), values.size());
+  QCPData newData;
+  for (int i=0; i<n; ++i)
+  {
+    newData.key = keys[i];
+    newData.value = values[i];
+    mData->insertMulti(newData.key, newData);
+  }
+}
+
+/*!
+  Removes all data points with keys smaller than \a key.
+  \see addData, clearData
+*/
+void QCPGraph::removeDataBefore(double key)
+{
+  QCPDataMap::iterator it = mData->begin();
+  while (it != mData->end() && it.key() < key)
+    it = mData->erase(it);
+}
+
+/*!
+  Removes all data points with keys greater than \a key.
+  \see addData, clearData
+*/
+void QCPGraph::removeDataAfter(double key)
+{
+  if (mData->isEmpty()) return;
+  QCPDataMap::iterator it = mData->upperBound(key);
+  while (it != mData->end())
+    it = mData->erase(it);
+}
+
+/*!
+  Removes all data points with keys between \a fromKey and \a toKey.
+  if \a fromKey is greater or equal to \a toKey, the function does nothing. To remove
+  a single data point with known key, use \ref removeData(double key).
+  
+  \see addData, clearData
+*/
+void QCPGraph::removeData(double fromKey, double toKey)
+{
+  if (fromKey >= toKey || mData->isEmpty()) return;
+  QCPDataMap::iterator it = mData->upperBound(fromKey);
+  QCPDataMap::iterator itEnd = mData->upperBound(toKey);
+  while (it != itEnd)
+    it = mData->erase(it);
+}
+
+/*! \overload
+  
+  Removes a single data point at \a key. If the position is not known with absolute precision,
+  consider using \ref removeData(double fromKey, double toKey) with a small fuzziness interval around
+  the suspected position, depeding on the precision with which the key is known.
+
+  \see addData, clearData
+*/
+void QCPGraph::removeData(double key)
+{
+  mData->remove(key);
+}
+
+/*!
+  Removes all data points.
+  \see removeData, removeDataAfter, removeDataBefore
+*/
+void QCPGraph::clearData()
+{
+  mData->clear();
+}
+
+/* inherits documentation from base class */
+double QCPGraph::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  if ((onlySelectable && !mSelectable) || mData->isEmpty())
+    return -1;
+  if (!mKeyAxis || !mValueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return -1; }
+  
+  if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))
+    return pointDistance(pos);
+  else
+    return -1;
+}
+
+/*! \overload
+  
+  Allows to define whether error bars are taken into consideration when determining the new axis
+  range.
+  
+  \see rescaleKeyAxis, rescaleValueAxis, QCPAbstractPlottable::rescaleAxes, QCustomPlot::rescaleAxes
+*/
+void QCPGraph::rescaleAxes(bool onlyEnlarge, bool includeErrorBars) const
+{
+  rescaleKeyAxis(onlyEnlarge, includeErrorBars);
+  rescaleValueAxis(onlyEnlarge, includeErrorBars);
+}
+
+/*! \overload
+  
+  Allows to define whether error bars (of kind \ref QCPGraph::etKey) are taken into consideration
+  when determining the new axis range.
+  
+  \see rescaleAxes, QCPAbstractPlottable::rescaleKeyAxis
+*/
+void QCPGraph::rescaleKeyAxis(bool onlyEnlarge, bool includeErrorBars) const
+{
+  // this code is a copy of QCPAbstractPlottable::rescaleKeyAxis with the only change
+  // that getKeyRange is passed the includeErrorBars value.
+  if (mData->isEmpty()) return;
+  
+  QCPAxis *keyAxis = mKeyAxis.data();
+  if (!keyAxis) { qDebug() << Q_FUNC_INFO << "invalid key axis"; return; }
+
+  SignDomain signDomain = sdBoth;
+  if (keyAxis->scaleType() == QCPAxis::stLogarithmic)
+    signDomain = (keyAxis->range().upper < 0 ? sdNegative : sdPositive);
+  
+  bool foundRange;
+  QCPRange newRange = getKeyRange(foundRange, signDomain, includeErrorBars);
+  
+  if (foundRange)
+  {
+    if (onlyEnlarge)
+    {
+      if (keyAxis->range().lower < newRange.lower)
+        newRange.lower = keyAxis->range().lower;
+      if (keyAxis->range().upper > newRange.upper)
+        newRange.upper = keyAxis->range().upper;
+    }
+    keyAxis->setRange(newRange);
+  }
+}
+
+/*! \overload
+  
+  Allows to define whether error bars (of kind \ref QCPGraph::etValue) are taken into consideration
+  when determining the new axis range.
+  
+  \see rescaleAxes, QCPAbstractPlottable::rescaleValueAxis
+*/
+void QCPGraph::rescaleValueAxis(bool onlyEnlarge, bool includeErrorBars) const
+{
+  // this code is a copy of QCPAbstractPlottable::rescaleValueAxis with the only change
+  // is that getValueRange is passed the includeErrorBars value.
+  if (mData->isEmpty()) return;
+  
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!valueAxis) { qDebug() << Q_FUNC_INFO << "invalid value axis"; return; }
+
+  SignDomain signDomain = sdBoth;
+  if (valueAxis->scaleType() == QCPAxis::stLogarithmic)
+    signDomain = (valueAxis->range().upper < 0 ? sdNegative : sdPositive);
+  
+  bool foundRange;
+  QCPRange newRange = getValueRange(foundRange, signDomain, includeErrorBars);
+  
+  if (foundRange)
+  {
+    if (onlyEnlarge)
+    {
+      if (valueAxis->range().lower < newRange.lower)
+        newRange.lower = valueAxis->range().lower;
+      if (valueAxis->range().upper > newRange.upper)
+        newRange.upper = valueAxis->range().upper;
+    }
+    valueAxis->setRange(newRange);
+  }
+}
+
+/* inherits documentation from base class */
+void QCPGraph::draw(QCPPainter *painter)
+{
+  if (!mKeyAxis || !mValueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
+  if (mKeyAxis.data()->range().size() <= 0 || mData->isEmpty()) return;
+  if (mLineStyle == lsNone && mScatterStyle.isNone()) return;
+  
+  // allocate line and (if necessary) point vectors:
+  QVector<QPointF> *lineData = new QVector<QPointF>;
+  QVector<QCPData> *scatterData = 0;
+  if (!mScatterStyle.isNone())
+    scatterData = new QVector<QCPData>;
+  
+  // fill vectors with data appropriate to plot style:
+  getPlotData(lineData, scatterData);
+  
+  // check data validity if flag set:
+#ifdef QCUSTOMPLOT_CHECK_DATA
+  QCPDataMap::const_iterator it;
+  for (it = mData->constBegin(); it != mData->constEnd(); ++it)
+  {
+    if (QCP::isInvalidData(it.value().key, it.value().value) ||
+        QCP::isInvalidData(it.value().keyErrorPlus, it.value().keyErrorMinus) ||
+        QCP::isInvalidData(it.value().valueErrorPlus, it.value().valueErrorPlus))
+      qDebug() << Q_FUNC_INFO << "Data point at" << it.key() << "invalid." << "Plottable name:" << name();
+  }
+#endif
+
+  // draw fill of graph:
+  if (mLineStyle != lsNone)
+    drawFill(painter, lineData);
+  
+  // draw line:
+  if (mLineStyle == lsImpulse)
+    drawImpulsePlot(painter, lineData);
+  else if (mLineStyle != lsNone)
+    drawLinePlot(painter, lineData); // also step plots can be drawn as a line plot
+  
+  // draw scatters:
+  if (scatterData)
+    drawScatterPlot(painter, scatterData);
+  
+  // free allocated line and point vectors:
+  delete lineData;
+  if (scatterData)
+    delete scatterData;
+}
+
+/* inherits documentation from base class */
+void QCPGraph::drawLegendIcon(QCPPainter *painter, const QRectF &rect) const
+{
+  // draw fill:
+  if (mBrush.style() != Qt::NoBrush)
+  {
+    applyFillAntialiasingHint(painter);
+    painter->fillRect(QRectF(rect.left(), rect.top()+rect.height()/2.0, rect.width(), rect.height()/3.0), mBrush);
+  }
+  // draw line vertically centered:
+  if (mLineStyle != lsNone)
+  {
+    applyDefaultAntialiasingHint(painter);
+    painter->setPen(mPen);
+    painter->drawLine(QLineF(rect.left(), rect.top()+rect.height()/2.0, rect.right()+5, rect.top()+rect.height()/2.0)); // +5 on x2 else last segment is missing from dashed/dotted pens
+  }
+  // draw scatter symbol:
+  if (!mScatterStyle.isNone())
+  {
+    applyScattersAntialiasingHint(painter);
+    // scale scatter pixmap if it's too large to fit in legend icon rect:
+    if (mScatterStyle.shape() == QCPScatterStyle::ssPixmap && (mScatterStyle.pixmap().size().width() > rect.width() || mScatterStyle.pixmap().size().height() > rect.height()))
+    {
+      QCPScatterStyle scaledStyle(mScatterStyle);
+      scaledStyle.setPixmap(scaledStyle.pixmap().scaled(rect.size().toSize(), Qt::KeepAspectRatio, Qt::SmoothTransformation));
+      scaledStyle.applyTo(painter, mPen);
+      scaledStyle.drawShape(painter, QRectF(rect).center());
+    } else
+    {
+      mScatterStyle.applyTo(painter, mPen);
+      mScatterStyle.drawShape(painter, QRectF(rect).center());
+    }
+  }
+}
+
+/*! \internal
+
+  This function branches out to the line style specific "get(...)PlotData" functions, according to
+  the line style of the graph.
+  
+  \a lineData will be filled with raw points that will be drawn with the according draw functions,
+  e.g. \ref drawLinePlot and \ref drawImpulsePlot. These aren't necessarily the original data
+  points, since for step plots for example, additional points are needed for drawing lines that
+  make up steps. If the line style of the graph is \ref lsNone, the \a lineData vector will be left
+  untouched.
+  
+  \a scatterData will be filled with the original data points so \ref drawScatterPlot can draw the
+  scatter symbols accordingly. If no scatters need to be drawn, i.e. the scatter style's shape is
+  \ref QCPScatterStyle::ssNone, pass 0 as \a scatterData, and this step will be skipped.
+  
+  \see getScatterPlotData, getLinePlotData, getStepLeftPlotData, getStepRightPlotData,
+  getStepCenterPlotData, getImpulsePlotData
+*/
+void QCPGraph::getPlotData(QVector<QPointF> *lineData, QVector<QCPData> *scatterData) const
+{
+  switch(mLineStyle)
+  {
+    case lsNone: getScatterPlotData(scatterData); break;
+    case lsLine: getLinePlotData(lineData, scatterData); break;
+    case lsStepLeft: getStepLeftPlotData(lineData, scatterData); break;
+    case lsStepRight: getStepRightPlotData(lineData, scatterData); break;
+    case lsStepCenter: getStepCenterPlotData(lineData, scatterData); break;
+    case lsImpulse: getImpulsePlotData(lineData, scatterData); break;
+  }
+}
+
+/*! \internal
+  
+  If line style is \ref lsNone and the scatter style's shape is not \ref QCPScatterStyle::ssNone,
+  this function serves at providing the visible data points in \a scatterData, so the \ref
+  drawScatterPlot function can draw the scatter points accordingly.
+  
+  If line style is not \ref lsNone, this function is not called and the data for the scatter points
+  are (if needed) calculated inside the corresponding other "get(...)PlotData" functions.
+  
+  \see drawScatterPlot
+*/
+void QCPGraph::getScatterPlotData(QVector<QCPData> *scatterData) const
+{
+  getPreparedData(0, scatterData);
+}
+
+/*! \internal
+  
+  Places the raw data points needed for a normal linearly connected graph in \a linePixelData.
+
+  As for all plot data retrieval functions, \a scatterData just contains all unaltered data (scatter)
+  points that are visible for drawing scatter points, if necessary. If drawing scatter points is
+  disabled (i.e. the scatter style's shape is \ref QCPScatterStyle::ssNone), pass 0 as \a
+  scatterData, and the function will skip filling the vector.
+  
+  \see drawLinePlot
+*/
+void QCPGraph::getLinePlotData(QVector<QPointF> *linePixelData, QVector<QCPData> *scatterData) const
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
+  if (!linePixelData) { qDebug() << Q_FUNC_INFO << "null pointer passed as linePixelData"; return; }
+  
+  QVector<QCPData> lineData;
+  getPreparedData(&lineData, scatterData);
+  linePixelData->reserve(lineData.size()+2); // added 2 to reserve memory for lower/upper fill base points that might be needed for fill
+  linePixelData->resize(lineData.size());
+  
+  // transform lineData points to pixels:
+  if (keyAxis->orientation() == Qt::Vertical)
+  {
+    for (int i=0; i<lineData.size(); ++i)
+    {
+      (*linePixelData)[i].setX(valueAxis->coordToPixel(lineData.at(i).value));
+      (*linePixelData)[i].setY(keyAxis->coordToPixel(lineData.at(i).key));
+    }
+  } else // key axis is horizontal
+  {
+    for (int i=0; i<lineData.size(); ++i)
+    {
+      (*linePixelData)[i].setX(keyAxis->coordToPixel(lineData.at(i).key));
+      (*linePixelData)[i].setY(valueAxis->coordToPixel(lineData.at(i).value));
+    }
+  }
+}
+
+/*!
+  \internal
+  Places the raw data points needed for a step plot with left oriented steps in \a lineData.
+
+  As for all plot data retrieval functions, \a scatterData just contains all unaltered data (scatter)
+  points that are visible for drawing scatter points, if necessary. If drawing scatter points is
+  disabled (i.e. the scatter style's shape is \ref QCPScatterStyle::ssNone), pass 0 as \a
+  scatterData, and the function will skip filling the vector.
+  
+  \see drawLinePlot
+*/
+void QCPGraph::getStepLeftPlotData(QVector<QPointF> *linePixelData, QVector<QCPData> *scatterData) const
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
+  if (!linePixelData) { qDebug() << Q_FUNC_INFO << "null pointer passed as lineData"; return; }
+  
+  QVector<QCPData> lineData;
+  getPreparedData(&lineData, scatterData);
+  linePixelData->reserve(lineData.size()*2+2); // added 2 to reserve memory for lower/upper fill base points that might be needed for fill
+  linePixelData->resize(lineData.size()*2);
+  
+  // calculate steps from lineData and transform to pixel coordinates:
+  if (keyAxis->orientation() == Qt::Vertical)
+  {
+    double lastValue = valueAxis->coordToPixel(lineData.first().value);
+    double key;
+    for (int i=0; i<lineData.size(); ++i)
+    {
+      key = keyAxis->coordToPixel(lineData.at(i).key);
+      (*linePixelData)[i*2+0].setX(lastValue);
+      (*linePixelData)[i*2+0].setY(key);
+      lastValue = valueAxis->coordToPixel(lineData.at(i).value);
+      (*linePixelData)[i*2+1].setX(lastValue);
+      (*linePixelData)[i*2+1].setY(key);
+    }
+  } else // key axis is horizontal
+  {
+    double lastValue = valueAxis->coordToPixel(lineData.first().value);
+    double key;
+    for (int i=0; i<lineData.size(); ++i)
+    {
+      key = keyAxis->coordToPixel(lineData.at(i).key);
+      (*linePixelData)[i*2+0].setX(key);
+      (*linePixelData)[i*2+0].setY(lastValue);
+      lastValue = valueAxis->coordToPixel(lineData.at(i).value);
+      (*linePixelData)[i*2+1].setX(key);
+      (*linePixelData)[i*2+1].setY(lastValue);
+    }
+  }
+}
+
+/*!
+  \internal
+  Places the raw data points needed for a step plot with right oriented steps in \a lineData.
+
+  As for all plot data retrieval functions, \a scatterData just contains all unaltered data (scatter)
+  points that are visible for drawing scatter points, if necessary. If drawing scatter points is
+  disabled (i.e. the scatter style's shape is \ref QCPScatterStyle::ssNone), pass 0 as \a
+  scatterData, and the function will skip filling the vector.
+  
+  \see drawLinePlot
+*/
+void QCPGraph::getStepRightPlotData(QVector<QPointF> *linePixelData, QVector<QCPData> *scatterData) const
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
+  if (!linePixelData) { qDebug() << Q_FUNC_INFO << "null pointer passed as lineData"; return; }
+  
+  QVector<QCPData> lineData;
+  getPreparedData(&lineData, scatterData);
+  linePixelData->reserve(lineData.size()*2+2); // added 2 to reserve memory for lower/upper fill base points that might be needed for fill
+  linePixelData->resize(lineData.size()*2);
+  
+  // calculate steps from lineData and transform to pixel coordinates:
+  if (keyAxis->orientation() == Qt::Vertical)
+  {
+    double lastKey = keyAxis->coordToPixel(lineData.first().key);
+    double value;
+    for (int i=0; i<lineData.size(); ++i)
+    {
+      value = valueAxis->coordToPixel(lineData.at(i).value);
+      (*linePixelData)[i*2+0].setX(value);
+      (*linePixelData)[i*2+0].setY(lastKey);
+      lastKey = keyAxis->coordToPixel(lineData.at(i).key);
+      (*linePixelData)[i*2+1].setX(value);
+      (*linePixelData)[i*2+1].setY(lastKey);
+    }
+  } else // key axis is horizontal
+  {
+    double lastKey = keyAxis->coordToPixel(lineData.first().key);
+    double value;
+    for (int i=0; i<lineData.size(); ++i)
+    {
+      value = valueAxis->coordToPixel(lineData.at(i).value);
+      (*linePixelData)[i*2+0].setX(lastKey);
+      (*linePixelData)[i*2+0].setY(value);
+      lastKey = keyAxis->coordToPixel(lineData.at(i).key);
+      (*linePixelData)[i*2+1].setX(lastKey);
+      (*linePixelData)[i*2+1].setY(value);
+    }
+  }
+}
+
+/*!
+  \internal
+  Places the raw data points needed for a step plot with centered steps in \a lineData.
+
+  As for all plot data retrieval functions, \a scatterData just contains all unaltered data (scatter)
+  points that are visible for drawing scatter points, if necessary. If drawing scatter points is
+  disabled (i.e. the scatter style's shape is \ref QCPScatterStyle::ssNone), pass 0 as \a
+  scatterData, and the function will skip filling the vector.
+  
+  \see drawLinePlot
+*/
+void QCPGraph::getStepCenterPlotData(QVector<QPointF> *linePixelData, QVector<QCPData> *scatterData) const
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
+  if (!linePixelData) { qDebug() << Q_FUNC_INFO << "null pointer passed as lineData"; return; }
+  
+  QVector<QCPData> lineData;
+  getPreparedData(&lineData, scatterData);
+  linePixelData->reserve(lineData.size()*2+2); // added 2 to reserve memory for lower/upper fill base points that might be needed for fill
+  linePixelData->resize(lineData.size()*2);
+  // calculate steps from lineData and transform to pixel coordinates:
+  if (keyAxis->orientation() == Qt::Vertical)
+  {
+    double lastKey = keyAxis->coordToPixel(lineData.first().key);
+    double lastValue = valueAxis->coordToPixel(lineData.first().value);
+    double key;
+    (*linePixelData)[0].setX(lastValue);
+    (*linePixelData)[0].setY(lastKey);
+    for (int i=1; i<lineData.size(); ++i)
+    {
+      key = (keyAxis->coordToPixel(lineData.at(i).key)+lastKey)*0.5;
+      (*linePixelData)[i*2-1].setX(lastValue);
+      (*linePixelData)[i*2-1].setY(key);
+      lastValue = valueAxis->coordToPixel(lineData.at(i).value);
+      lastKey = keyAxis->coordToPixel(lineData.at(i).key);
+      (*linePixelData)[i*2+0].setX(lastValue);
+      (*linePixelData)[i*2+0].setY(key);
+    }
+    (*linePixelData)[lineData.size()*2-1].setX(lastValue);
+    (*linePixelData)[lineData.size()*2-1].setY(lastKey);
+  } else // key axis is horizontal
+  {
+    double lastKey = keyAxis->coordToPixel(lineData.first().key);
+    double lastValue = valueAxis->coordToPixel(lineData.first().value);
+    double key;
+    (*linePixelData)[0].setX(lastKey);
+    (*linePixelData)[0].setY(lastValue);
+    for (int i=1; i<lineData.size(); ++i)
+    {
+      key = (keyAxis->coordToPixel(lineData.at(i).key)+lastKey)*0.5;
+      (*linePixelData)[i*2-1].setX(key);
+      (*linePixelData)[i*2-1].setY(lastValue);
+      lastValue = valueAxis->coordToPixel(lineData.at(i).value);
+      lastKey = keyAxis->coordToPixel(lineData.at(i).key);
+      (*linePixelData)[i*2+0].setX(key);
+      (*linePixelData)[i*2+0].setY(lastValue);
+    }
+    (*linePixelData)[lineData.size()*2-1].setX(lastKey);
+    (*linePixelData)[lineData.size()*2-1].setY(lastValue);
+  }
+
+}
+
+/*!
+  \internal
+  Places the raw data points needed for an impulse plot in \a lineData.
+
+  As for all plot data retrieval functions, \a scatterData just contains all unaltered data (scatter)
+  points that are visible for drawing scatter points, if necessary. If drawing scatter points is
+  disabled (i.e. the scatter style's shape is \ref QCPScatterStyle::ssNone), pass 0 as \a
+  scatterData, and the function will skip filling the vector.
+  
+  \see drawImpulsePlot
+*/
+void QCPGraph::getImpulsePlotData(QVector<QPointF> *linePixelData, QVector<QCPData> *scatterData) const
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
+  if (!linePixelData) { qDebug() << Q_FUNC_INFO << "null pointer passed as linePixelData"; return; }
+  
+  QVector<QCPData> lineData;
+  getPreparedData(&lineData, scatterData);
+  linePixelData->resize(lineData.size()*2); // no need to reserve 2 extra points because impulse plot has no fill
+  
+  // transform lineData points to pixels:
+  if (keyAxis->orientation() == Qt::Vertical)
+  {
+    double zeroPointX = valueAxis->coordToPixel(0);
+    double key;
+    for (int i=0; i<lineData.size(); ++i)
+    {
+      key = keyAxis->coordToPixel(lineData.at(i).key);
+      (*linePixelData)[i*2+0].setX(zeroPointX);
+      (*linePixelData)[i*2+0].setY(key);
+      (*linePixelData)[i*2+1].setX(valueAxis->coordToPixel(lineData.at(i).value));
+      (*linePixelData)[i*2+1].setY(key);
+    }
+  } else // key axis is horizontal
+  {
+    double zeroPointY = valueAxis->coordToPixel(0);
+    double key;
+    for (int i=0; i<lineData.size(); ++i)
+    {
+      key = keyAxis->coordToPixel(lineData.at(i).key);
+      (*linePixelData)[i*2+0].setX(key);
+      (*linePixelData)[i*2+0].setY(zeroPointY);
+      (*linePixelData)[i*2+1].setX(key);
+      (*linePixelData)[i*2+1].setY(valueAxis->coordToPixel(lineData.at(i).value));
+    }
+  }
+}
+
+/*! \internal
+  
+  Draws the fill of the graph with the specified brush.
+
+  If the fill is a normal fill towards the zero-value-line, only the \a lineData is required (and
+  two extra points at the zero-value-line, which are added by \ref addFillBasePoints and removed by
+  \ref removeFillBasePoints after the fill drawing is done).
+  
+  If the fill is a channel fill between this QCPGraph and another QCPGraph (mChannelFillGraph), the
+  more complex polygon is calculated with the \ref getChannelFillPolygon function.
+  
+  \see drawLinePlot
+*/
+void QCPGraph::drawFill(QCPPainter *painter, QVector<QPointF> *lineData) const
+{
+  if (mLineStyle == lsImpulse) return; // fill doesn't make sense for impulse plot
+  if (mainBrush().style() == Qt::NoBrush || mainBrush().color().alpha() == 0) return;
+  
+  applyFillAntialiasingHint(painter);
+  if (!mChannelFillGraph)
+  {
+    // draw base fill under graph, fill goes all the way to the zero-value-line:
+    addFillBasePoints(lineData);
+    painter->setPen(Qt::NoPen);
+    painter->setBrush(mainBrush());
+    painter->drawPolygon(QPolygonF(*lineData));
+    removeFillBasePoints(lineData);
+  } else
+  {
+    // draw channel fill between this graph and mChannelFillGraph:
+    painter->setPen(Qt::NoPen);
+    painter->setBrush(mainBrush());
+    painter->drawPolygon(getChannelFillPolygon(lineData));
+  }
+}
+
+/*! \internal
+  
+  Draws scatter symbols at every data point passed in \a scatterData. scatter symbols are independent
+  of the line style and are always drawn if the scatter style's shape is not \ref
+  QCPScatterStyle::ssNone. Hence, the \a scatterData vector is outputted by all "get(...)PlotData"
+  functions, together with the (line style dependent) line data.
+  
+  \see drawLinePlot, drawImpulsePlot
+*/
+void QCPGraph::drawScatterPlot(QCPPainter *painter, QVector<QCPData> *scatterData) const
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
+  
+  // draw error bars:
+  if (mErrorType != etNone)
+  {
+    applyErrorBarsAntialiasingHint(painter);
+    painter->setPen(mErrorPen);
+    if (keyAxis->orientation() == Qt::Vertical)
+    {
+      for (int i=0; i<scatterData->size(); ++i)
+        drawError(painter, valueAxis->coordToPixel(scatterData->at(i).value), keyAxis->coordToPixel(scatterData->at(i).key), scatterData->at(i));
+    } else
+    {
+      for (int i=0; i<scatterData->size(); ++i)
+        drawError(painter, keyAxis->coordToPixel(scatterData->at(i).key), valueAxis->coordToPixel(scatterData->at(i).value), scatterData->at(i));
+    }
+  }
+  
+  // draw scatter point symbols:
+  applyScattersAntialiasingHint(painter);
+  mScatterStyle.applyTo(painter, mPen);
+  if (keyAxis->orientation() == Qt::Vertical)
+  {
+    for (int i=0; i<scatterData->size(); ++i)
+      if (!qIsNaN(scatterData->at(i).value))
+        mScatterStyle.drawShape(painter, valueAxis->coordToPixel(scatterData->at(i).value), keyAxis->coordToPixel(scatterData->at(i).key));
+  } else
+  {
+    for (int i=0; i<scatterData->size(); ++i)
+      if (!qIsNaN(scatterData->at(i).value))
+        mScatterStyle.drawShape(painter, keyAxis->coordToPixel(scatterData->at(i).key), valueAxis->coordToPixel(scatterData->at(i).value));
+  }
+}
+
+/*!  \internal
+  
+  Draws line graphs from the provided data. It connects all points in \a lineData, which was
+  created by one of the "get(...)PlotData" functions for line styles that require simple line
+  connections between the point vector they create. These are for example \ref getLinePlotData,
+  \ref getStepLeftPlotData, \ref getStepRightPlotData and \ref getStepCenterPlotData.
+  
+  \see drawScatterPlot, drawImpulsePlot
+*/
+void QCPGraph::drawLinePlot(QCPPainter *painter, QVector<QPointF> *lineData) const
+{
+  // draw line of graph:
+  if (mainPen().style() != Qt::NoPen && mainPen().color().alpha() != 0)
+  {
+    applyDefaultAntialiasingHint(painter);
+    painter->setPen(mainPen());
+    painter->setBrush(Qt::NoBrush);
+    
+    /* Draws polyline in batches, currently not used:
+    int p = 0;
+    while (p < lineData->size())
+    {
+      int batch = qMin(25, lineData->size()-p);
+      if (p != 0)
+      {
+        ++batch;
+        --p; // to draw the connection lines between two batches
+      }
+      painter->drawPolyline(lineData->constData()+p, batch);
+      p += batch;
+    }
+    */
+    
+    // if drawing solid line and not in PDF, use much faster line drawing instead of polyline:
+    if (mParentPlot->plottingHints().testFlag(QCP::phFastPolylines) &&
+        painter->pen().style() == Qt::SolidLine &&
+        !painter->modes().testFlag(QCPPainter::pmVectorized) &&
+        !painter->modes().testFlag(QCPPainter::pmNoCaching))
+    {
+      int i = 0;
+      bool lastIsNan = false;
+      const int lineDataSize = lineData->size();
+      while (i < lineDataSize && (qIsNaN(lineData->at(i).y()) || qIsNaN(lineData->at(i).x()))) // make sure first point is not NaN
+        ++i;
+      ++i; // because drawing works in 1 point retrospect
+      while (i < lineDataSize)
+      {
+        if (!qIsNaN(lineData->at(i).y()) && !qIsNaN(lineData->at(i).x())) // NaNs create a gap in the line
+        {
+          if (!lastIsNan)
+            painter->drawLine(lineData->at(i-1), lineData->at(i));
+          else
+            lastIsNan = false;
+        } else
+          lastIsNan = true;
+        ++i;
+      }
+    } else
+    {
+      int segmentStart = 0;
+      int i = 0;
+      const int lineDataSize = lineData->size();
+      while (i < lineDataSize)
+     {
+        if (qIsNaN(lineData->at(i).y()) || qIsNaN(lineData->at(i).x()) || qIsInf(lineData->at(i).y())) // NaNs create a gap in the line. Also filter Infs which make drawPolyline block
+        {
+          painter->drawPolyline(lineData->constData()+segmentStart, i-segmentStart); // i, because we don't want to include the current NaN point
+          segmentStart = i+1;
+        }
+        ++i;
+      }
+      // draw last segment:
+      painter->drawPolyline(lineData->constData()+segmentStart, lineDataSize-segmentStart);
+    }
+  }
+}
+
+/*! \internal
+  
+  Draws impulses from the provided data, i.e. it connects all line pairs in \a lineData, which was
+  created by \ref getImpulsePlotData.
+  
+  \see drawScatterPlot, drawLinePlot
+*/
+void QCPGraph::drawImpulsePlot(QCPPainter *painter, QVector<QPointF> *lineData) const
+{
+  // draw impulses:
+  if (mainPen().style() != Qt::NoPen && mainPen().color().alpha() != 0)
+  {
+    applyDefaultAntialiasingHint(painter);
+    QPen pen = mainPen();
+    pen.setCapStyle(Qt::FlatCap); // so impulse line doesn't reach beyond zero-line
+    painter->setPen(pen);
+    painter->setBrush(Qt::NoBrush);
+    painter->drawLines(*lineData);
+  }
+}
+
+/*! \internal
+  
+  Returns the \a lineData and \a scatterData that need to be plotted for this graph taking into
+  consideration the current axis ranges and, if \ref setAdaptiveSampling is enabled, local point
+  densities.
+  
+  0 may be passed as \a lineData or \a scatterData to indicate that the respective dataset isn't
+  needed. For example, if the scatter style (\ref setScatterStyle) is \ref QCPScatterStyle::ssNone, \a
+  scatterData should be 0 to prevent unnecessary calculations.
+  
+  This method is used by the various "get(...)PlotData" methods to get the basic working set of data.
+*/
+void QCPGraph::getPreparedData(QVector<QCPData> *lineData, QVector<QCPData> *scatterData) const
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
+  // get visible data range:
+  QCPDataMap::const_iterator lower, upper; // note that upper is the actual upper point, and not 1 step after the upper point
+  getVisibleDataBounds(lower, upper);
+  if (lower == mData->constEnd() || upper == mData->constEnd())
+    return;
+  
+  // count points in visible range, taking into account that we only need to count to the limit maxCount if using adaptive sampling:
+  int maxCount = std::numeric_limits<int>::max();
+  if (mAdaptiveSampling)
+  {
+    int keyPixelSpan = qAbs(keyAxis->coordToPixel(lower.key())-keyAxis->coordToPixel(upper.key()));
+    maxCount = 2*keyPixelSpan+2;
+  }
+  int dataCount = countDataInBounds(lower, upper, maxCount);
+  
+  if (mAdaptiveSampling && dataCount >= maxCount) // use adaptive sampling only if there are at least two points per pixel on average
+  {
+    if (lineData)
+    {
+      QCPDataMap::const_iterator it = lower;
+      QCPDataMap::const_iterator upperEnd = upper+1;
+      double minValue = it.value().value;
+      double maxValue = it.value().value;
+      QCPDataMap::const_iterator currentIntervalFirstPoint = it;
+      int reversedFactor = keyAxis->rangeReversed() != (keyAxis->orientation()==Qt::Vertical) ? -1 : 1; // is used to calculate keyEpsilon pixel into the correct direction
+      int reversedRound = keyAxis->rangeReversed() != (keyAxis->orientation()==Qt::Vertical) ? 1 : 0; // is used to switch between floor (normal) and ceil (reversed) rounding of currentIntervalStartKey
+      double currentIntervalStartKey = keyAxis->pixelToCoord((int)(keyAxis->coordToPixel(lower.key())+reversedRound));
+      double lastIntervalEndKey = currentIntervalStartKey;
+      double keyEpsilon = qAbs(currentIntervalStartKey-keyAxis->pixelToCoord(keyAxis->coordToPixel(currentIntervalStartKey)+1.0*reversedFactor)); // interval of one pixel on screen when mapped to plot key coordinates
+      bool keyEpsilonVariable = keyAxis->scaleType() == QCPAxis::stLogarithmic; // indicates whether keyEpsilon needs to be updated after every interval (for log axes)
+      int intervalDataCount = 1;
+      ++it; // advance iterator to second data point because adaptive sampling works in 1 point retrospect
+      while (it != upperEnd)
+      {
+        if (it.key() < currentIntervalStartKey+keyEpsilon) // data point is still within same pixel, so skip it and expand value span of this cluster if necessary
+        {
+          if (it.value().value < minValue)
+            minValue = it.value().value;
+          else if (it.value().value > maxValue)
+            maxValue = it.value().value;
+          ++intervalDataCount;
+        } else // new pixel interval started
+        {
+          if (intervalDataCount >= 2) // last pixel had multiple data points, consolidate them to a cluster
+          {
+            if (lastIntervalEndKey < currentIntervalStartKey-keyEpsilon) // last point is further away, so first point of this cluster must be at a real data point
+              lineData->append(QCPData(currentIntervalStartKey+keyEpsilon*0.2, currentIntervalFirstPoint.value().value));
+            lineData->append(QCPData(currentIntervalStartKey+keyEpsilon*0.25, minValue));
+            lineData->append(QCPData(currentIntervalStartKey+keyEpsilon*0.75, maxValue));
+            if (it.key() > currentIntervalStartKey+keyEpsilon*2) // new pixel started further away from previous cluster, so make sure the last point of the cluster is at a real data point
+              lineData->append(QCPData(currentIntervalStartKey+keyEpsilon*0.8, (it-1).value().value));
+          } else
+            lineData->append(QCPData(currentIntervalFirstPoint.key(), currentIntervalFirstPoint.value().value));
+          lastIntervalEndKey = (it-1).value().key;
+          minValue = it.value().value;
+          maxValue = it.value().value;
+          currentIntervalFirstPoint = it;
+          currentIntervalStartKey = keyAxis->pixelToCoord((int)(keyAxis->coordToPixel(it.key())+reversedRound));
+          if (keyEpsilonVariable)
+            keyEpsilon = qAbs(currentIntervalStartKey-keyAxis->pixelToCoord(keyAxis->coordToPixel(currentIntervalStartKey)+1.0*reversedFactor));
+          intervalDataCount = 1;
+        }
+        ++it;
+      }
+      // handle last interval:
+      if (intervalDataCount >= 2) // last pixel had multiple data points, consolidate them to a cluster
+      {
+        if (lastIntervalEndKey < currentIntervalStartKey-keyEpsilon) // last point wasn't a cluster, so first point of this cluster must be at a real data point
+          lineData->append(QCPData(currentIntervalStartKey+keyEpsilon*0.2, currentIntervalFirstPoint.value().value));
+        lineData->append(QCPData(currentIntervalStartKey+keyEpsilon*0.25, minValue));
+        lineData->append(QCPData(currentIntervalStartKey+keyEpsilon*0.75, maxValue));
+      } else
+        lineData->append(QCPData(currentIntervalFirstPoint.key(), currentIntervalFirstPoint.value().value));
+    }
+    
+    if (scatterData)
+    {
+      double valueMaxRange = valueAxis->range().upper;
+      double valueMinRange = valueAxis->range().lower;
+      QCPDataMap::const_iterator it = lower;
+      QCPDataMap::const_iterator upperEnd = upper+1;
+      double minValue = it.value().value;
+      double maxValue = it.value().value;
+      QCPDataMap::const_iterator minValueIt = it;
+      QCPDataMap::const_iterator maxValueIt = it;
+      QCPDataMap::const_iterator currentIntervalStart = it;
+      int reversedFactor = keyAxis->rangeReversed() ? -1 : 1; // is used to calculate keyEpsilon pixel into the correct direction
+      int reversedRound = keyAxis->rangeReversed() ? 1 : 0; // is used to switch between floor (normal) and ceil (reversed) rounding of currentIntervalStartKey
+      double currentIntervalStartKey = keyAxis->pixelToCoord((int)(keyAxis->coordToPixel(lower.key())+reversedRound));
+      double keyEpsilon = qAbs(currentIntervalStartKey-keyAxis->pixelToCoord(keyAxis->coordToPixel(currentIntervalStartKey)+1.0*reversedFactor)); // interval of one pixel on screen when mapped to plot key coordinates
+      bool keyEpsilonVariable = keyAxis->scaleType() == QCPAxis::stLogarithmic; // indicates whether keyEpsilon needs to be updated after every interval (for log axes)
+      int intervalDataCount = 1;
+      ++it; // advance iterator to second data point because adaptive sampling works in 1 point retrospect
+      while (it != upperEnd)
+      {
+        if (it.key() < currentIntervalStartKey+keyEpsilon) // data point is still within same pixel, so skip it and expand value span of this pixel if necessary
+        {
+          if (it.value().value < minValue && it.value().value > valueMinRange && it.value().value < valueMaxRange)
+          {
+            minValue = it.value().value;
+            minValueIt = it;
+          } else if (it.value().value > maxValue && it.value().value > valueMinRange && it.value().value < valueMaxRange)
+          {
+            maxValue = it.value().value;
+            maxValueIt = it;
+          }
+          ++intervalDataCount;
+        } else // new pixel started
+        {
+          if (intervalDataCount >= 2) // last pixel had multiple data points, consolidate them
+          {
+            // determine value pixel span and add as many points in interval to maintain certain vertical data density (this is specific to scatter plot):
+            double valuePixelSpan = qAbs(valueAxis->coordToPixel(minValue)-valueAxis->coordToPixel(maxValue));
+            int dataModulo = qMax(1, qRound(intervalDataCount/(valuePixelSpan/4.0))); // approximately every 4 value pixels one data point on average
+            QCPDataMap::const_iterator intervalIt = currentIntervalStart;
+            int c = 0;
+            while (intervalIt != it)
+            {
+              if ((c % dataModulo == 0 || intervalIt == minValueIt || intervalIt == maxValueIt) && intervalIt.value().value > valueMinRange && intervalIt.value().value < valueMaxRange)
+                scatterData->append(intervalIt.value());
+              ++c;
+              ++intervalIt;
+            }
+          } else if (currentIntervalStart.value().value > valueMinRange && currentIntervalStart.value().value < valueMaxRange)
+            scatterData->append(currentIntervalStart.value());
+          minValue = it.value().value;
+          maxValue = it.value().value;
+          currentIntervalStart = it;
+          currentIntervalStartKey = keyAxis->pixelToCoord((int)(keyAxis->coordToPixel(it.key())+reversedRound));
+          if (keyEpsilonVariable)
+            keyEpsilon = qAbs(currentIntervalStartKey-keyAxis->pixelToCoord(keyAxis->coordToPixel(currentIntervalStartKey)+1.0*reversedFactor));
+          intervalDataCount = 1;
+        }
+        ++it;
+      }
+      // handle last interval:
+      if (intervalDataCount >= 2) // last pixel had multiple data points, consolidate them
+      {
+        // determine value pixel span and add as many points in interval to maintain certain vertical data density (this is specific to scatter plot):
+        double valuePixelSpan = qAbs(valueAxis->coordToPixel(minValue)-valueAxis->coordToPixel(maxValue));
+        int dataModulo = qMax(1, qRound(intervalDataCount/(valuePixelSpan/4.0))); // approximately every 4 value pixels one data point on average
+        QCPDataMap::const_iterator intervalIt = currentIntervalStart;
+        int c = 0;
+        while (intervalIt != it)
+        {
+          if ((c % dataModulo == 0 || intervalIt == minValueIt || intervalIt == maxValueIt) && intervalIt.value().value > valueMinRange && intervalIt.value().value < valueMaxRange)
+            scatterData->append(intervalIt.value());
+          ++c;
+          ++intervalIt;
+        }
+      } else if (currentIntervalStart.value().value > valueMinRange && currentIntervalStart.value().value < valueMaxRange)
+        scatterData->append(currentIntervalStart.value());
+    }
+  } else // don't use adaptive sampling algorithm, transfer points one-to-one from the map into the output parameters
+  {
+    QVector<QCPData> *dataVector = 0;
+    if (lineData)
+      dataVector = lineData;
+    else if (scatterData)
+      dataVector = scatterData;
+    if (dataVector)
+    {
+      QCPDataMap::const_iterator it = lower;
+      QCPDataMap::const_iterator upperEnd = upper+1;
+      dataVector->reserve(dataCount+2); // +2 for possible fill end points
+      while (it != upperEnd)
+      {
+        dataVector->append(it.value());
+        ++it;
+      }
+    }
+    if (lineData && scatterData)
+      *scatterData = *dataVector;
+  }
+}
+
+/*!  \internal
+  
+  called by the scatter drawing function (\ref drawScatterPlot) to draw the error bars on one data
+  point. \a x and \a y pixel positions of the data point are passed since they are already known in
+  pixel coordinates in the drawing function, so we save some extra coordToPixel transforms here. \a
+  data is therefore only used for the errors, not key and value.
+*/
+void QCPGraph::drawError(QCPPainter *painter, double x, double y, const QCPData &data) const
+{
+  if (qIsNaN(data.value))
+    return;
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
+  
+  double a, b; // positions of error bar bounds in pixels
+  double barWidthHalf = mErrorBarSize*0.5;
+  double skipSymbolMargin = mScatterStyle.size(); // pixels left blank per side, when mErrorBarSkipSymbol is true
+
+  if (keyAxis->orientation() == Qt::Vertical)
+  {
+    // draw key error vertically and value error horizontally
+    if (mErrorType == etKey || mErrorType == etBoth)
+    {
+      a = keyAxis->coordToPixel(data.key-data.keyErrorMinus);
+      b = keyAxis->coordToPixel(data.key+data.keyErrorPlus);
+      if (keyAxis->rangeReversed())
+        qSwap(a,b);
+      // draw spine:
+      if (mErrorBarSkipSymbol)
+      {
+        if (a-y > skipSymbolMargin) // don't draw spine if error is so small it's within skipSymbolmargin
+          painter->drawLine(QLineF(x, a, x, y+skipSymbolMargin));
+        if (y-b > skipSymbolMargin)
+          painter->drawLine(QLineF(x, y-skipSymbolMargin, x, b));
+      } else
+        painter->drawLine(QLineF(x, a, x, b));
+      // draw handles:
+      painter->drawLine(QLineF(x-barWidthHalf, a, x+barWidthHalf, a));
+      painter->drawLine(QLineF(x-barWidthHalf, b, x+barWidthHalf, b));
+    }
+    if (mErrorType == etValue || mErrorType == etBoth)
+    {
+      a = valueAxis->coordToPixel(data.value-data.valueErrorMinus);
+      b = valueAxis->coordToPixel(data.value+data.valueErrorPlus);
+      if (valueAxis->rangeReversed())
+        qSwap(a,b);
+      // draw spine:
+      if (mErrorBarSkipSymbol)
+      {
+        if (x-a > skipSymbolMargin) // don't draw spine if error is so small it's within skipSymbolmargin
+          painter->drawLine(QLineF(a, y, x-skipSymbolMargin, y));
+        if (b-x > skipSymbolMargin)
+          painter->drawLine(QLineF(x+skipSymbolMargin, y, b, y));
+      } else
+        painter->drawLine(QLineF(a, y, b, y));
+      // draw handles:
+      painter->drawLine(QLineF(a, y-barWidthHalf, a, y+barWidthHalf));
+      painter->drawLine(QLineF(b, y-barWidthHalf, b, y+barWidthHalf));
+    }
+  } else // mKeyAxis->orientation() is Qt::Horizontal
+  {
+    // draw value error vertically and key error horizontally
+    if (mErrorType == etKey || mErrorType == etBoth)
+    {
+      a = keyAxis->coordToPixel(data.key-data.keyErrorMinus);
+      b = keyAxis->coordToPixel(data.key+data.keyErrorPlus);
+      if (keyAxis->rangeReversed())
+        qSwap(a,b);
+      // draw spine:
+      if (mErrorBarSkipSymbol)
+      {
+        if (x-a > skipSymbolMargin) // don't draw spine if error is so small it's within skipSymbolmargin
+          painter->drawLine(QLineF(a, y, x-skipSymbolMargin, y));
+        if (b-x > skipSymbolMargin)
+          painter->drawLine(QLineF(x+skipSymbolMargin, y, b, y));
+      } else
+        painter->drawLine(QLineF(a, y, b, y));
+      // draw handles:
+      painter->drawLine(QLineF(a, y-barWidthHalf, a, y+barWidthHalf));
+      painter->drawLine(QLineF(b, y-barWidthHalf, b, y+barWidthHalf));
+    }
+    if (mErrorType == etValue || mErrorType == etBoth)
+    {
+      a = valueAxis->coordToPixel(data.value-data.valueErrorMinus);
+      b = valueAxis->coordToPixel(data.value+data.valueErrorPlus);
+      if (valueAxis->rangeReversed())
+        qSwap(a,b);
+      // draw spine:
+      if (mErrorBarSkipSymbol)
+      {
+        if (a-y > skipSymbolMargin) // don't draw spine if error is so small it's within skipSymbolmargin
+          painter->drawLine(QLineF(x, a, x, y+skipSymbolMargin));
+        if (y-b > skipSymbolMargin)
+          painter->drawLine(QLineF(x, y-skipSymbolMargin, x, b));
+      } else
+        painter->drawLine(QLineF(x, a, x, b));
+      // draw handles:
+      painter->drawLine(QLineF(x-barWidthHalf, a, x+barWidthHalf, a));
+      painter->drawLine(QLineF(x-barWidthHalf, b, x+barWidthHalf, b));
+    }
+  }
+}
+
+/*!  \internal
+  
+  called by \ref getPreparedData to determine which data (key) range is visible at the current key
+  axis range setting, so only that needs to be processed.
+  
+  \a lower returns an iterator to the lowest data point that needs to be taken into account when
+  plotting. Note that in order to get a clean plot all the way to the edge of the axis rect, \a
+  lower may still be just outside the visible range.
+  
+  \a upper returns an iterator to the highest data point. Same as before, \a upper may also lie
+  just outside of the visible range.
+  
+  if the graph contains no data, both \a lower and \a upper point to constEnd.
+*/
+void QCPGraph::getVisibleDataBounds(QCPDataMap::const_iterator &lower, QCPDataMap::const_iterator &upper) const
+{
+  if (!mKeyAxis) { qDebug() << Q_FUNC_INFO << "invalid key axis"; return; }
+  if (mData->isEmpty())
+  {
+    lower = mData->constEnd();
+    upper = mData->constEnd();
+    return;
+  }
+  
+  // get visible data range as QMap iterators
+  QCPDataMap::const_iterator lbound = mData->lowerBound(mKeyAxis.data()->range().lower);
+  QCPDataMap::const_iterator ubound = mData->upperBound(mKeyAxis.data()->range().upper);
+  bool lowoutlier = lbound != mData->constBegin(); // indicates whether there exist points below axis range
+  bool highoutlier = ubound != mData->constEnd(); // indicates whether there exist points above axis range
+  
+  lower = (lowoutlier ? lbound-1 : lbound); // data point range that will be actually drawn
+  upper = (highoutlier ? ubound : ubound-1); // data point range that will be actually drawn
+}
+
+/*!  \internal
+  
+  Counts the number of data points between \a lower and \a upper (including them), up to a maximum
+  of \a maxCount.
+  
+  This function is used by \ref getPreparedData to determine whether adaptive sampling shall be
+  used (if enabled via \ref setAdaptiveSampling) or not. This is also why counting of data points
+  only needs to be done until \a maxCount is reached, which should be set to the number of data
+  points at which adaptive sampling sets in.
+*/
+int QCPGraph::countDataInBounds(const QCPDataMap::const_iterator &lower, const QCPDataMap::const_iterator &upper, int maxCount) const
+{
+  if (upper == mData->constEnd() && lower == mData->constEnd())
+    return 0;
+  QCPDataMap::const_iterator it = lower;
+  int count = 1;
+  while (it != upper && count < maxCount)
+  {
+    ++it;
+    ++count;
+  }
+  return count;
+}
+
+/*! \internal
+  
+  The line data vector generated by e.g. getLinePlotData contains only the line that connects the
+  data points. If the graph needs to be filled, two additional points need to be added at the
+  value-zero-line in the lower and upper key positions of the graph. This function calculates these
+  points and adds them to the end of \a lineData. Since the fill is typically drawn before the line
+  stroke, these added points need to be removed again after the fill is done, with the
+  removeFillBasePoints function.
+  
+  The expanding of \a lineData by two points will not cause unnecessary memory reallocations,
+  because the data vector generation functions (getLinePlotData etc.) reserve two extra points when
+  they allocate memory for \a lineData.
+  
+  \see removeFillBasePoints, lowerFillBasePoint, upperFillBasePoint
+*/
+void QCPGraph::addFillBasePoints(QVector<QPointF> *lineData) const
+{
+  if (!mKeyAxis) { qDebug() << Q_FUNC_INFO << "invalid key axis"; return; }
+  if (!lineData) { qDebug() << Q_FUNC_INFO << "passed null as lineData"; return; }
+  if (lineData->isEmpty()) return;
+  
+  // append points that close the polygon fill at the key axis:
+  if (mKeyAxis.data()->orientation() == Qt::Vertical)
+  {
+    *lineData << upperFillBasePoint(lineData->last().y());
+    *lineData << lowerFillBasePoint(lineData->first().y());
+  } else
+  {
+    *lineData << upperFillBasePoint(lineData->last().x());
+    *lineData << lowerFillBasePoint(lineData->first().x());
+  }
+}
+
+/*! \internal
+  
+  removes the two points from \a lineData that were added by \ref addFillBasePoints.
+  
+  \see addFillBasePoints, lowerFillBasePoint, upperFillBasePoint
+*/
+void QCPGraph::removeFillBasePoints(QVector<QPointF> *lineData) const
+{
+  if (!lineData) { qDebug() << Q_FUNC_INFO << "passed null as lineData"; return; }
+  if (lineData->isEmpty()) return;
+  
+  lineData->remove(lineData->size()-2, 2);
+}
+
+/*! \internal
+  
+  called by \ref addFillBasePoints to conveniently assign the point which closes the fill polygon
+  on the lower side of the zero-value-line parallel to the key axis. The logarithmic axis scale
+  case is a bit special, since the zero-value-line in pixel coordinates is in positive or negative
+  infinity. So this case is handled separately by just closing the fill polygon on the axis which
+  lies in the direction towards the zero value.
+  
+  \a lowerKey will be the the key (in pixels) of the returned point. Depending on whether the key
+  axis is horizontal or vertical, \a lowerKey will end up as the x or y value of the returned
+  point, respectively.
+  
+  \see upperFillBasePoint, addFillBasePoints
+*/
+QPointF QCPGraph::lowerFillBasePoint(double lowerKey) const
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPointF(); }
+  
+  QPointF point;
+  if (valueAxis->scaleType() == QCPAxis::stLinear)
+  {
+    if (keyAxis->axisType() == QCPAxis::atLeft)
+    {
+      point.setX(valueAxis->coordToPixel(0));
+      point.setY(lowerKey);
+    } else if (keyAxis->axisType() == QCPAxis::atRight)
+    {
+      point.setX(valueAxis->coordToPixel(0));
+      point.setY(lowerKey);
+    } else if (keyAxis->axisType() == QCPAxis::atTop)
+    {
+      point.setX(lowerKey);
+      point.setY(valueAxis->coordToPixel(0));
+    } else if (keyAxis->axisType() == QCPAxis::atBottom)
+    {
+      point.setX(lowerKey);
+      point.setY(valueAxis->coordToPixel(0));
+    }
+  } else // valueAxis->mScaleType == QCPAxis::stLogarithmic
+  {
+    // In logarithmic scaling we can't just draw to value zero so we just fill all the way
+    // to the axis which is in the direction towards zero
+    if (keyAxis->orientation() == Qt::Vertical)
+    {
+      if ((valueAxis->range().upper < 0 && !valueAxis->rangeReversed()) ||
+          (valueAxis->range().upper > 0 && valueAxis->rangeReversed())) // if range is negative, zero is on opposite side of key axis
+        point.setX(keyAxis->axisRect()->right());
+      else
+        point.setX(keyAxis->axisRect()->left());
+      point.setY(lowerKey);
+    } else if (keyAxis->axisType() == QCPAxis::atTop || keyAxis->axisType() == QCPAxis::atBottom)
+    {
+      point.setX(lowerKey);
+      if ((valueAxis->range().upper < 0 && !valueAxis->rangeReversed()) ||
+          (valueAxis->range().upper > 0 && valueAxis->rangeReversed())) // if range is negative, zero is on opposite side of key axis
+        point.setY(keyAxis->axisRect()->top());
+      else
+        point.setY(keyAxis->axisRect()->bottom());
+    }
+  }
+  return point;
+}
+
+/*! \internal
+  
+  called by \ref addFillBasePoints to conveniently assign the point which closes the fill
+  polygon on the upper side of the zero-value-line parallel to the key axis. The logarithmic axis
+  scale case is a bit special, since the zero-value-line in pixel coordinates is in positive or
+  negative infinity. So this case is handled separately by just closing the fill polygon on the
+  axis which lies in the direction towards the zero value.
+
+  \a upperKey will be the the key (in pixels) of the returned point. Depending on whether the key
+  axis is horizontal or vertical, \a upperKey will end up as the x or y value of the returned
+  point, respectively.
+  
+  \see lowerFillBasePoint, addFillBasePoints
+*/
+QPointF QCPGraph::upperFillBasePoint(double upperKey) const
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPointF(); }
+  
+  QPointF point;
+  if (valueAxis->scaleType() == QCPAxis::stLinear)
+  {
+    if (keyAxis->axisType() == QCPAxis::atLeft)
+    {
+      point.setX(valueAxis->coordToPixel(0));
+      point.setY(upperKey);
+    } else if (keyAxis->axisType() == QCPAxis::atRight)
+    {
+      point.setX(valueAxis->coordToPixel(0));
+      point.setY(upperKey);
+    } else if (keyAxis->axisType() == QCPAxis::atTop)
+    {
+      point.setX(upperKey);
+      point.setY(valueAxis->coordToPixel(0));
+    } else if (keyAxis->axisType() == QCPAxis::atBottom)
+    {
+      point.setX(upperKey);
+      point.setY(valueAxis->coordToPixel(0));
+    }
+  } else // valueAxis->mScaleType == QCPAxis::stLogarithmic
+  {
+    // In logarithmic scaling we can't just draw to value 0 so we just fill all the way
+    // to the axis which is in the direction towards 0
+    if (keyAxis->orientation() == Qt::Vertical)
+    {
+      if ((valueAxis->range().upper < 0 && !valueAxis->rangeReversed()) ||
+          (valueAxis->range().upper > 0 && valueAxis->rangeReversed())) // if range is negative, zero is on opposite side of key axis
+        point.setX(keyAxis->axisRect()->right());
+      else
+        point.setX(keyAxis->axisRect()->left());
+      point.setY(upperKey);
+    } else if (keyAxis->axisType() == QCPAxis::atTop || keyAxis->axisType() == QCPAxis::atBottom)
+    {
+      point.setX(upperKey);
+      if ((valueAxis->range().upper < 0 && !valueAxis->rangeReversed()) ||
+          (valueAxis->range().upper > 0 && valueAxis->rangeReversed())) // if range is negative, zero is on opposite side of key axis
+        point.setY(keyAxis->axisRect()->top());
+      else
+        point.setY(keyAxis->axisRect()->bottom());
+    }
+  }
+  return point;
+}
+
+/*! \internal
+  
+  Generates the polygon needed for drawing channel fills between this graph (data passed via \a
+  lineData) and the graph specified by mChannelFillGraph (data generated by calling its \ref
+  getPlotData function). May return an empty polygon if the key ranges have no overlap or fill
+  target graph and this graph don't have same orientation (i.e. both key axes horizontal or both
+  key axes vertical). For increased performance (due to implicit sharing), keep the returned
+  QPolygonF const.
+*/
+const QPolygonF QCPGraph::getChannelFillPolygon(const QVector<QPointF> *lineData) const
+{
+  if (!mChannelFillGraph)
+    return QPolygonF();
+  
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPolygonF(); }
+  if (!mChannelFillGraph.data()->mKeyAxis) { qDebug() << Q_FUNC_INFO << "channel fill target key axis invalid"; return QPolygonF(); }
+  
+  if (mChannelFillGraph.data()->mKeyAxis.data()->orientation() != keyAxis->orientation())
+    return QPolygonF(); // don't have same axis orientation, can't fill that (Note: if keyAxis fits, valueAxis will fit too, because it's always orthogonal to keyAxis)
+  
+  if (lineData->isEmpty()) return QPolygonF();
+  QVector<QPointF> otherData;
+  mChannelFillGraph.data()->getPlotData(&otherData, 0);
+  if (otherData.isEmpty()) return QPolygonF();
+  QVector<QPointF> thisData;
+  thisData.reserve(lineData->size()+otherData.size()); // because we will join both vectors at end of this function
+  for (int i=0; i<lineData->size(); ++i) // don't use the vector<<(vector),  it squeezes internally, which ruins the performance tuning with reserve()
+    thisData << lineData->at(i);
+  
+  // pointers to be able to swap them, depending which data range needs cropping:
+  QVector<QPointF> *staticData = &thisData;
+  QVector<QPointF> *croppedData = &otherData;
+  
+  // crop both vectors to ranges in which the keys overlap (which coord is key, depends on axisType):
+  if (keyAxis->orientation() == Qt::Horizontal)
+  {
+    // x is key
+    // if an axis range is reversed, the data point keys will be descending. Reverse them, since following algorithm assumes ascending keys:
+    if (staticData->first().x() > staticData->last().x())
+    {
+      int size = staticData->size();
+      for (int i=0; i<size/2; ++i)
+        qSwap((*staticData)[i], (*staticData)[size-1-i]);
+    }
+    if (croppedData->first().x() > croppedData->last().x())
+    {
+      int size = croppedData->size();
+      for (int i=0; i<size/2; ++i)
+        qSwap((*croppedData)[i], (*croppedData)[size-1-i]);
+    }
+    // crop lower bound:
+    if (staticData->first().x() < croppedData->first().x()) // other one must be cropped
+      qSwap(staticData, croppedData);
+    int lowBound = findIndexBelowX(croppedData, staticData->first().x());
+    if (lowBound == -1) return QPolygonF(); // key ranges have no overlap
+    croppedData->remove(0, lowBound);
+    // set lowest point of cropped data to fit exactly key position of first static data
+    // point via linear interpolation:
+    if (croppedData->size() < 2) return QPolygonF(); // need at least two points for interpolation
+    double slope;
+    if (croppedData->at(1).x()-croppedData->at(0).x() != 0)
+      slope = (croppedData->at(1).y()-croppedData->at(0).y())/(croppedData->at(1).x()-croppedData->at(0).x());
+    else
+      slope = 0;
+    (*croppedData)[0].setY(croppedData->at(0).y()+slope*(staticData->first().x()-croppedData->at(0).x()));
+    (*croppedData)[0].setX(staticData->first().x());
+    
+    // crop upper bound:
+    if (staticData->last().x() > croppedData->last().x()) // other one must be cropped
+      qSwap(staticData, croppedData);
+    int highBound = findIndexAboveX(croppedData, staticData->last().x());
+    if (highBound == -1) return QPolygonF(); // key ranges have no overlap
+    croppedData->remove(highBound+1, croppedData->size()-(highBound+1));
+    // set highest point of cropped data to fit exactly key position of last static data
+    // point via linear interpolation:
+    if (croppedData->size() < 2) return QPolygonF(); // need at least two points for interpolation
+    int li = croppedData->size()-1; // last index
+    if (croppedData->at(li).x()-croppedData->at(li-1).x() != 0)
+      slope = (croppedData->at(li).y()-croppedData->at(li-1).y())/(croppedData->at(li).x()-croppedData->at(li-1).x());
+    else
+      slope = 0;
+    (*croppedData)[li].setY(croppedData->at(li-1).y()+slope*(staticData->last().x()-croppedData->at(li-1).x()));
+    (*croppedData)[li].setX(staticData->last().x());
+  } else // mKeyAxis->orientation() == Qt::Vertical
+  {
+    // y is key
+    // similar to "x is key" but switched x,y. Further, lower/upper meaning is inverted compared to x,
+    // because in pixel coordinates, y increases from top to bottom, not bottom to top like data coordinate.
+    // if an axis range is reversed, the data point keys will be descending. Reverse them, since following algorithm assumes ascending keys:
+    if (staticData->first().y() < staticData->last().y())
+    {
+      int size = staticData->size();
+      for (int i=0; i<size/2; ++i)
+        qSwap((*staticData)[i], (*staticData)[size-1-i]);
+    }
+    if (croppedData->first().y() < croppedData->last().y())
+    {
+      int size = croppedData->size();
+      for (int i=0; i<size/2; ++i)
+        qSwap((*croppedData)[i], (*croppedData)[size-1-i]);
+    }
+    // crop lower bound:
+    if (staticData->first().y() > croppedData->first().y()) // other one must be cropped
+      qSwap(staticData, croppedData);
+    int lowBound = findIndexAboveY(croppedData, staticData->first().y());
+    if (lowBound == -1) return QPolygonF(); // key ranges have no overlap
+    croppedData->remove(0, lowBound);
+    // set lowest point of cropped data to fit exactly key position of first static data
+    // point via linear interpolation:
+    if (croppedData->size() < 2) return QPolygonF(); // need at least two points for interpolation
+    double slope;
+    if (croppedData->at(1).y()-croppedData->at(0).y() != 0) // avoid division by zero in step plots
+      slope = (croppedData->at(1).x()-croppedData->at(0).x())/(croppedData->at(1).y()-croppedData->at(0).y());
+    else
+      slope = 0;
+    (*croppedData)[0].setX(croppedData->at(0).x()+slope*(staticData->first().y()-croppedData->at(0).y()));
+    (*croppedData)[0].setY(staticData->first().y());
+    
+    // crop upper bound:
+    if (staticData->last().y() < croppedData->last().y()) // other one must be cropped
+      qSwap(staticData, croppedData);
+    int highBound = findIndexBelowY(croppedData, staticData->last().y());
+    if (highBound == -1) return QPolygonF(); // key ranges have no overlap
+    croppedData->remove(highBound+1, croppedData->size()-(highBound+1));
+    // set highest point of cropped data to fit exactly key position of last static data
+    // point via linear interpolation:
+    if (croppedData->size() < 2) return QPolygonF(); // need at least two points for interpolation
+    int li = croppedData->size()-1; // last index
+    if (croppedData->at(li).y()-croppedData->at(li-1).y() != 0) // avoid division by zero in step plots
+      slope = (croppedData->at(li).x()-croppedData->at(li-1).x())/(croppedData->at(li).y()-croppedData->at(li-1).y());
+    else
+      slope = 0;
+    (*croppedData)[li].setX(croppedData->at(li-1).x()+slope*(staticData->last().y()-croppedData->at(li-1).y()));
+    (*croppedData)[li].setY(staticData->last().y());
+  }
+  
+  // return joined:
+  for (int i=otherData.size()-1; i>=0; --i) // insert reversed, otherwise the polygon will be twisted
+    thisData << otherData.at(i);
+  return QPolygonF(thisData);
+}
+
+/*! \internal
+  
+  Finds the smallest index of \a data, whose points x value is just above \a x. Assumes x values in
+  \a data points are ordered ascending, as is the case when plotting with horizontal key axis.
+
+  Used to calculate the channel fill polygon, see \ref getChannelFillPolygon.
+*/
+int QCPGraph::findIndexAboveX(const QVector<QPointF> *data, double x) const
+{
+  for (int i=data->size()-1; i>=0; --i)
+  {
+    if (data->at(i).x() < x)
+    {
+      if (i<data->size()-1)
+        return i+1;
+      else
+        return data->size()-1;
+    }
+  }
+  return -1;
+}
+
+/*! \internal
+  
+  Finds the highest index of \a data, whose points x value is just below \a x. Assumes x values in
+  \a data points are ordered ascending, as is the case when plotting with horizontal key axis.
+  
+  Used to calculate the channel fill polygon, see \ref getChannelFillPolygon.
+*/
+int QCPGraph::findIndexBelowX(const QVector<QPointF> *data, double x) const
+{
+  for (int i=0; i<data->size(); ++i)
+  {
+    if (data->at(i).x() > x)
+    {
+      if (i>0)
+        return i-1;
+      else
+        return 0;
+    }
+  }
+  return -1;
+}
+
+/*! \internal
+  
+  Finds the smallest index of \a data, whose points y value is just above \a y. Assumes y values in
+  \a data points are ordered descending, as is the case when plotting with vertical key axis.
+  
+  Used to calculate the channel fill polygon, see \ref getChannelFillPolygon.
+*/
+int QCPGraph::findIndexAboveY(const QVector<QPointF> *data, double y) const
+{
+  for (int i=0; i<data->size(); ++i)
+  {
+    if (data->at(i).y() < y)
+    {
+      if (i>0)
+        return i-1;
+      else
+        return 0;
+    }
+  }
+  return -1;
+}
+
+/*! \internal
+  
+  Calculates the (minimum) distance (in pixels) the graph's representation has from the given \a
+  pixelPoint in pixels. This is used to determine whether the graph was clicked or not, e.g. in
+  \ref selectTest.
+  
+  If either the graph has no data or if the line style is \ref lsNone and the scatter style's shape
+  is \ref QCPScatterStyle::ssNone (i.e. there is no visual representation of the graph), returns -1.0.
+*/
+double QCPGraph::pointDistance(const QPointF &pixelPoint) const
+{
+  if (mData->isEmpty())
+    return -1.0;
+  if (mLineStyle == lsNone && mScatterStyle.isNone())
+    return -1.0;
+  
+  // calculate minimum distances to graph representation:
+  if (mLineStyle == lsNone)
+  {
+    // no line displayed, only calculate distance to scatter points:
+    QVector<QCPData> scatterData;
+    getScatterPlotData(&scatterData);
+    if (scatterData.size() > 0)
+    {
+      double minDistSqr = std::numeric_limits<double>::max();
+      for (int i=0; i<scatterData.size(); ++i)
+      {
+        double currentDistSqr = QVector2D(coordsToPixels(scatterData.at(i).key, scatterData.at(i).value)-pixelPoint).lengthSquared();
+        if (currentDistSqr < minDistSqr)
+          minDistSqr = currentDistSqr;
+      }
+      return qSqrt(minDistSqr);
+    } else // no data available in view to calculate distance to
+      return -1.0;
+  } else
+  {
+    // line displayed, calculate distance to line segments:
+    QVector<QPointF> lineData;
+    getPlotData(&lineData, 0); // unlike with getScatterPlotData we get pixel coordinates here
+    if (lineData.size() > 1) // at least one line segment, compare distance to line segments
+    {
+      double minDistSqr = std::numeric_limits<double>::max();
+      if (mLineStyle == lsImpulse)
+      {
+        // impulse plot differs from other line styles in that the lineData points are only pairwise connected:
+        for (int i=0; i<lineData.size()-1; i+=2) // iterate pairs
+        {
+          double currentDistSqr = distSqrToLine(lineData.at(i), lineData.at(i+1), pixelPoint);
+          if (currentDistSqr < minDistSqr)
+            minDistSqr = currentDistSqr;
+        }
+      } else
+      {
+        // all other line plots (line and step) connect points directly:
+        for (int i=0; i<lineData.size()-1; ++i)
+        {
+          double currentDistSqr = distSqrToLine(lineData.at(i), lineData.at(i+1), pixelPoint);
+          if (currentDistSqr < minDistSqr)
+            minDistSqr = currentDistSqr;
+        }
+      }
+      return qSqrt(minDistSqr);
+    } else if (lineData.size() > 0) // only single data point, calculate distance to that point
+    {
+      return QVector2D(lineData.at(0)-pixelPoint).length();
+    } else // no data available in view to calculate distance to
+      return -1.0;
+  }
+}
+
+/*! \internal
+  
+  Finds the highest index of \a data, whose points y value is just below \a y. Assumes y values in
+  \a data points are ordered descending, as is the case when plotting with vertical key axis (since
+  keys are ordered ascending).
+
+  Used to calculate the channel fill polygon, see \ref getChannelFillPolygon.
+*/
+int QCPGraph::findIndexBelowY(const QVector<QPointF> *data, double y) const
+{
+  for (int i=data->size()-1; i>=0; --i)
+  {
+    if (data->at(i).y() > y)
+    {
+      if (i<data->size()-1)
+        return i+1;
+      else
+        return data->size()-1;
+    }
+  }
+  return -1;
+}
+
+/* inherits documentation from base class */
+QCPRange QCPGraph::getKeyRange(bool &foundRange, SignDomain inSignDomain) const
+{
+  // just call the specialized version which takes an additional argument whether error bars
+  // should also be taken into consideration for range calculation. We set this to true here.
+  return getKeyRange(foundRange, inSignDomain, true);
+}
+
+/* inherits documentation from base class */
+QCPRange QCPGraph::getValueRange(bool &foundRange, SignDomain inSignDomain) const
+{
+  // just call the specialized version which takes an additional argument whether error bars
+  // should also be taken into consideration for range calculation. We set this to true here.
+  return getValueRange(foundRange, inSignDomain, true);
+}
+
+/*! \overload
+  
+  Allows to specify whether the error bars should be included in the range calculation.
+  
+  \see getKeyRange(bool &foundRange, SignDomain inSignDomain)
+*/
+QCPRange QCPGraph::getKeyRange(bool &foundRange, SignDomain inSignDomain, bool includeErrors) const
+{
+  QCPRange range;
+  bool haveLower = false;
+  bool haveUpper = false;
+  
+  double current, currentErrorMinus, currentErrorPlus;
+  
+  if (inSignDomain == sdBoth) // range may be anywhere
+  {
+    QCPDataMap::const_iterator it = mData->constBegin();
+    while (it != mData->constEnd())
+    {
+      if (!qIsNaN(it.value().value))
+      {
+        current = it.value().key;
+        currentErrorMinus = (includeErrors ? it.value().keyErrorMinus : 0);
+        currentErrorPlus = (includeErrors ? it.value().keyErrorPlus : 0);
+        if (current-currentErrorMinus < range.lower || !haveLower)
+        {
+          range.lower = current-currentErrorMinus;
+          haveLower = true;
+        }
+        if (current+currentErrorPlus > range.upper || !haveUpper)
+        {
+          range.upper = current+currentErrorPlus;
+          haveUpper = true;
+        }
+      }
+      ++it;
+    }
+  } else if (inSignDomain == sdNegative) // range may only be in the negative sign domain
+  {
+    QCPDataMap::const_iterator it = mData->constBegin();
+    while (it != mData->constEnd())
+    {
+      if (!qIsNaN(it.value().value))
+      {
+        current = it.value().key;
+        currentErrorMinus = (includeErrors ? it.value().keyErrorMinus : 0);
+        currentErrorPlus = (includeErrors ? it.value().keyErrorPlus : 0);
+        if ((current-currentErrorMinus < range.lower || !haveLower) && current-currentErrorMinus < 0)
+        {
+          range.lower = current-currentErrorMinus;
+          haveLower = true;
+        }
+        if ((current+currentErrorPlus > range.upper || !haveUpper) && current+currentErrorPlus < 0)
+        {
+          range.upper = current+currentErrorPlus;
+          haveUpper = true;
+        }
+        if (includeErrors) // in case point is in valid sign domain but errobars stretch beyond it, we still want to geht that point.
+        {
+          if ((current < range.lower || !haveLower) && current < 0)
+          {
+            range.lower = current;
+            haveLower = true;
+          }
+          if ((current > range.upper || !haveUpper) && current < 0)
+          {
+            range.upper = current;
+            haveUpper = true;
+          }
+        }
+      }
+      ++it;
+    }
+  } else if (inSignDomain == sdPositive) // range may only be in the positive sign domain
+  {
+    QCPDataMap::const_iterator it = mData->constBegin();
+    while (it != mData->constEnd())
+    {
+      if (!qIsNaN(it.value().value))
+      {
+        current = it.value().key;
+        currentErrorMinus = (includeErrors ? it.value().keyErrorMinus : 0);
+        currentErrorPlus = (includeErrors ? it.value().keyErrorPlus : 0);
+        if ((current-currentErrorMinus < range.lower || !haveLower) && current-currentErrorMinus > 0)
+        {
+          range.lower = current-currentErrorMinus;
+          haveLower = true;
+        }
+        if ((current+currentErrorPlus > range.upper || !haveUpper) && current+currentErrorPlus > 0)
+        {
+          range.upper = current+currentErrorPlus;
+          haveUpper = true;
+        }
+        if (includeErrors) // in case point is in valid sign domain but errobars stretch beyond it, we still want to get that point.
+        {
+          if ((current < range.lower || !haveLower) && current > 0)
+          {
+            range.lower = current;
+            haveLower = true;
+          }
+          if ((current > range.upper || !haveUpper) && current > 0)
+          {
+            range.upper = current;
+            haveUpper = true;
+          }
+        }
+      }
+      ++it;
+    }
+  }
+  
+  foundRange = haveLower && haveUpper;
+  return range;
+}
+
+/*! \overload
+  
+  Allows to specify whether the error bars should be included in the range calculation.
+  
+  \see getValueRange(bool &foundRange, SignDomain inSignDomain)
+*/
+QCPRange QCPGraph::getValueRange(bool &foundRange, SignDomain inSignDomain, bool includeErrors) const
+{
+  QCPRange range;
+  bool haveLower = false;
+  bool haveUpper = false;
+  
+  double current, currentErrorMinus, currentErrorPlus;
+  
+  if (inSignDomain == sdBoth) // range may be anywhere
+  {
+    QCPDataMap::const_iterator it = mData->constBegin();
+    while (it != mData->constEnd())
+    {
+      current = it.value().value;
+      if (!qIsNaN(current))
+      {
+        currentErrorMinus = (includeErrors ? it.value().valueErrorMinus : 0);
+        currentErrorPlus = (includeErrors ? it.value().valueErrorPlus : 0);
+        if (current-currentErrorMinus < range.lower || !haveLower)
+        {
+          range.lower = current-currentErrorMinus;
+          haveLower = true;
+        }
+        if (current+currentErrorPlus > range.upper || !haveUpper)
+        {
+          range.upper = current+currentErrorPlus;
+          haveUpper = true;
+        }
+      }
+      ++it;
+    }
+  } else if (inSignDomain == sdNegative) // range may only be in the negative sign domain
+  {
+    QCPDataMap::const_iterator it = mData->constBegin();
+    while (it != mData->constEnd())
+    {
+      current = it.value().value;
+      if (!qIsNaN(current))
+      {
+        currentErrorMinus = (includeErrors ? it.value().valueErrorMinus : 0);
+        currentErrorPlus = (includeErrors ? it.value().valueErrorPlus : 0);
+        if ((current-currentErrorMinus < range.lower || !haveLower) && current-currentErrorMinus < 0)
+        {
+          range.lower = current-currentErrorMinus;
+          haveLower = true;
+        }
+        if ((current+currentErrorPlus > range.upper || !haveUpper) && current+currentErrorPlus < 0)
+        {
+          range.upper = current+currentErrorPlus;
+          haveUpper = true;
+        }
+        if (includeErrors) // in case point is in valid sign domain but errobars stretch beyond it, we still want to get that point.
+        {
+          if ((current < range.lower || !haveLower) && current < 0)
+          {
+            range.lower = current;
+            haveLower = true;
+          }
+          if ((current > range.upper || !haveUpper) && current < 0)
+          {
+            range.upper = current;
+            haveUpper = true;
+          }
+        }
+      }
+      ++it;
+    }
+  } else if (inSignDomain == sdPositive) // range may only be in the positive sign domain
+  {
+    QCPDataMap::const_iterator it = mData->constBegin();
+    while (it != mData->constEnd())
+    {
+      current = it.value().value;
+      if (!qIsNaN(current))
+      {
+        currentErrorMinus = (includeErrors ? it.value().valueErrorMinus : 0);
+        currentErrorPlus = (includeErrors ? it.value().valueErrorPlus : 0);
+        if ((current-currentErrorMinus < range.lower || !haveLower) && current-currentErrorMinus > 0)
+        {
+          range.lower = current-currentErrorMinus;
+          haveLower = true;
+        }
+        if ((current+currentErrorPlus > range.upper || !haveUpper) && current+currentErrorPlus > 0)
+        {
+          range.upper = current+currentErrorPlus;
+          haveUpper = true;
+        }
+        if (includeErrors) // in case point is in valid sign domain but errobars stretch beyond it, we still want to geht that point.
+        {
+          if ((current < range.lower || !haveLower) && current > 0)
+          {
+            range.lower = current;
+            haveLower = true;
+          }
+          if ((current > range.upper || !haveUpper) && current > 0)
+          {
+            range.upper = current;
+            haveUpper = true;
+          }
+        }
+      }
+      ++it;
+    }
+  }
+  
+  foundRange = haveLower && haveUpper;
+  return range;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPCurveData
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPCurveData
+  \brief Holds the data of one single data point for QCPCurve.
+  
+  The container for storing multiple data points is \ref QCPCurveDataMap.
+  
+  The stored data is:
+  \li \a t: the free parameter of the curve at this curve point (cp. the mathematical vector <em>(x(t), y(t))</em>)
+  \li \a key: coordinate on the key axis of this curve point
+  \li \a value: coordinate on the value axis of this curve point
+  
+  \see QCPCurveDataMap
+*/
+
+/*!
+  Constructs a curve data point with t, key and value set to zero.
+*/
+QCPCurveData::QCPCurveData() :
+  t(0),
+  key(0),
+  value(0)
+{
+}
+
+/*!
+  Constructs a curve data point with the specified \a t, \a key and \a value.
+*/
+QCPCurveData::QCPCurveData(double t, double key, double value) :
+  t(t),
+  key(key),
+  value(value)
+{
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPCurve
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPCurve
+  \brief A plottable representing a parametric curve in a plot.
+  
+  \image html QCPCurve.png
+  
+  Unlike QCPGraph, plottables of this type may have multiple points with the same key coordinate,
+  so their visual representation can have \a loops. This is realized by introducing a third
+  coordinate \a t, which defines the order of the points described by the other two coordinates \a
+  x and \a y.
+
+  To plot data, assign it with the \ref setData or \ref addData functions.
+  
+  Gaps in the curve can be created by adding data points with NaN as key and value
+  (<tt>qQNaN()</tt> or <tt>std::numeric_limits<double>::quiet_NaN()</tt>) in between the two data points that shall be
+  separated.
+  
+  \section appearance Changing the appearance
+  
+  The appearance of the curve is determined by the pen and the brush (\ref setPen, \ref setBrush).
+  \section usage Usage
+  
+  Like all data representing objects in QCustomPlot, the QCPCurve is a plottable (QCPAbstractPlottable). So
+  the plottable-interface of QCustomPlot applies (QCustomPlot::plottable, QCustomPlot::addPlottable, QCustomPlot::removePlottable, etc.)
+  
+  Usually, you first create an instance and add it to the customPlot:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpcurve-creation-1
+  and then modify the properties of the newly created plottable, e.g.:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpcurve-creation-2
+*/
+
+/*!
+  Constructs a curve which uses \a keyAxis as its key axis ("x") and \a valueAxis as its value
+  axis ("y"). \a keyAxis and \a valueAxis must reside in the same QCustomPlot instance and not have
+  the same orientation. If either of these restrictions is violated, a corresponding message is
+  printed to the debug output (qDebug), the construction is not aborted, though.
+  
+  The constructed QCPCurve can be added to the plot with QCustomPlot::addPlottable, QCustomPlot
+  then takes ownership of the graph.
+*/
+QCPCurve::QCPCurve(QCPAxis *keyAxis, QCPAxis *valueAxis) :
+  QCPAbstractPlottable(keyAxis, valueAxis)
+{
+  mData = new QCPCurveDataMap;
+  mPen.setColor(Qt::blue);
+  mPen.setStyle(Qt::SolidLine);
+  mBrush.setColor(Qt::blue);
+  mBrush.setStyle(Qt::NoBrush);
+  mSelectedPen = mPen;
+  mSelectedPen.setWidthF(2.5);
+  mSelectedPen.setColor(QColor(80, 80, 255)); // lighter than Qt::blue of mPen
+  mSelectedBrush = mBrush;
+  
+  setScatterStyle(QCPScatterStyle());
+  setLineStyle(lsLine);
+}
+
+QCPCurve::~QCPCurve()
+{
+  delete mData;
+}
+
+/*!
+  Replaces the current data with the provided \a data.
+  
+  If \a copy is set to true, data points in \a data will only be copied. if false, the plottable
+  takes ownership of the passed data and replaces the internal data pointer with it. This is
+  significantly faster than copying for large datasets.
+*/
+void QCPCurve::setData(QCPCurveDataMap *data, bool copy)
+{
+  if (mData == data)
+  {
+    qDebug() << Q_FUNC_INFO << "The data pointer is already in (and owned by) this plottable" << reinterpret_cast<quintptr>(data);
+    return;
+  }
+  if (copy)
+  {
+    *mData = *data;
+  } else
+  {
+    delete mData;
+    mData = data;
+  }
+}
+
+/*! \overload
+  
+  Replaces the current data with the provided points in \a t, \a key and \a value tuples. The
+  provided vectors should have equal length. Else, the number of added points will be the size of
+  the smallest vector.
+*/
+void QCPCurve::setData(const QVector<double> &t, const QVector<double> &key, const QVector<double> &value)
+{
+  mData->clear();
+  int n = t.size();
+  n = qMin(n, key.size());
+  n = qMin(n, value.size());
+  QCPCurveData newData;
+  for (int i=0; i<n; ++i)
+  {
+    newData.t = t[i];
+    newData.key = key[i];
+    newData.value = value[i];
+    mData->insertMulti(newData.t, newData);
+  }
+}
+
+/*! \overload
+  
+  Replaces the current data with the provided \a key and \a value pairs. The t parameter
+  of each data point will be set to the integer index of the respective key/value pair.
+*/
+void QCPCurve::setData(const QVector<double> &key, const QVector<double> &value)
+{
+  mData->clear();
+  int n = key.size();
+  n = qMin(n, value.size());
+  QCPCurveData newData;
+  for (int i=0; i<n; ++i)
+  {
+    newData.t = i; // no t vector given, so we assign t the index of the key/value pair
+    newData.key = key[i];
+    newData.value = value[i];
+    mData->insertMulti(newData.t, newData);
+  }
+}
+
+/*!
+  Sets the visual appearance of single data points in the plot. If set to \ref
+  QCPScatterStyle::ssNone, no scatter points are drawn (e.g. for line-only plots with appropriate
+  line style).
+  
+  \see QCPScatterStyle, setLineStyle
+*/
+void QCPCurve::setScatterStyle(const QCPScatterStyle &style)
+{
+  mScatterStyle = style;
+}
+
+/*!
+  Sets how the single data points are connected in the plot or how they are represented visually
+  apart from the scatter symbol. For scatter-only plots, set \a style to \ref lsNone and \ref
+  setScatterStyle to the desired scatter style.
+  
+  \see setScatterStyle
+*/
+void QCPCurve::setLineStyle(QCPCurve::LineStyle style)
+{
+  mLineStyle = style;
+}
+
+/*!
+  Adds the provided data points in \a dataMap to the current data.
+  \see removeData
+*/
+void QCPCurve::addData(const QCPCurveDataMap &dataMap)
+{
+  mData->unite(dataMap);
+}
+
+/*! \overload
+  Adds the provided single data point in \a data to the current data.
+  \see removeData
+*/
+void QCPCurve::addData(const QCPCurveData &data)
+{
+  mData->insertMulti(data.t, data);
+}
+
+/*! \overload
+  Adds the provided single data point as \a t, \a key and \a value tuple to the current data
+  \see removeData
+*/
+void QCPCurve::addData(double t, double key, double value)
+{
+  QCPCurveData newData;
+  newData.t = t;
+  newData.key = key;
+  newData.value = value;
+  mData->insertMulti(newData.t, newData);
+}
+
+/*! \overload
+  
+  Adds the provided single data point as \a key and \a value pair to the current data The t
+  parameter of the data point is set to the t of the last data point plus 1. If there is no last
+  data point, t will be set to 0.
+  
+  \see removeData
+*/
+void QCPCurve::addData(double key, double value)
+{
+  QCPCurveData newData;
+  if (!mData->isEmpty())
+    newData.t = (mData->constEnd()-1).key()+1;
+  else
+    newData.t = 0;
+  newData.key = key;
+  newData.value = value;
+  mData->insertMulti(newData.t, newData);
+}
+
+/*! \overload
+  Adds the provided data points as \a t, \a key and \a value tuples to the current data.
+  \see removeData
+*/
+void QCPCurve::addData(const QVector<double> &ts, const QVector<double> &keys, const QVector<double> &values)
+{
+  int n = ts.size();
+  n = qMin(n, keys.size());
+  n = qMin(n, values.size());
+  QCPCurveData newData;
+  for (int i=0; i<n; ++i)
+  {
+    newData.t = ts[i];
+    newData.key = keys[i];
+    newData.value = values[i];
+    mData->insertMulti(newData.t, newData);
+  }
+}
+
+/*!
+  Removes all data points with curve parameter t smaller than \a t.
+  \see addData, clearData
+*/
+void QCPCurve::removeDataBefore(double t)
+{
+  QCPCurveDataMap::iterator it = mData->begin();
+  while (it != mData->end() && it.key() < t)
+    it = mData->erase(it);
+}
+
+/*!
+  Removes all data points with curve parameter t greater than \a t.
+  \see addData, clearData
+*/
+void QCPCurve::removeDataAfter(double t)
+{
+  if (mData->isEmpty()) return;
+  QCPCurveDataMap::iterator it = mData->upperBound(t);
+  while (it != mData->end())
+    it = mData->erase(it);
+}
+
+/*!
+  Removes all data points with curve parameter t between \a fromt and \a tot. if \a fromt is
+  greater or equal to \a tot, the function does nothing. To remove a single data point with known
+  t, use \ref removeData(double t).
+  
+  \see addData, clearData
+*/
+void QCPCurve::removeData(double fromt, double tot)
+{
+  if (fromt >= tot || mData->isEmpty()) return;
+  QCPCurveDataMap::iterator it = mData->upperBound(fromt);
+  QCPCurveDataMap::iterator itEnd = mData->upperBound(tot);
+  while (it != itEnd)
+    it = mData->erase(it);
+}
+
+/*! \overload
+  
+  Removes a single data point at curve parameter \a t. If the position is not known with absolute
+  precision, consider using \ref removeData(double fromt, double tot) with a small fuzziness
+  interval around the suspected position, depeding on the precision with which the curve parameter
+  is known.
+  
+  \see addData, clearData
+*/
+void QCPCurve::removeData(double t)
+{
+  mData->remove(t);
+}
+
+/*!
+  Removes all data points.
+  \see removeData, removeDataAfter, removeDataBefore
+*/
+void QCPCurve::clearData()
+{
+  mData->clear();
+}
+
+/* inherits documentation from base class */
+double QCPCurve::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  if ((onlySelectable && !mSelectable) || mData->isEmpty())
+    return -1;
+  if (!mKeyAxis || !mValueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return -1; }
+  
+  if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))
+    return pointDistance(pos);
+  else
+    return -1;
+}
+
+/* inherits documentation from base class */
+void QCPCurve::draw(QCPPainter *painter)
+{
+  if (mData->isEmpty()) return;
+  
+  // allocate line vector:
+  QVector<QPointF> *lineData = new QVector<QPointF>;
+  
+  // fill with curve data:
+  getCurveData(lineData);
+  
+  // check data validity if flag set:
+#ifdef QCUSTOMPLOT_CHECK_DATA
+  QCPCurveDataMap::const_iterator it;
+  for (it = mData->constBegin(); it != mData->constEnd(); ++it)
+  {
+    if (QCP::isInvalidData(it.value().t) ||
+        QCP::isInvalidData(it.value().key, it.value().value))
+      qDebug() << Q_FUNC_INFO << "Data point at" << it.key() << "invalid." << "Plottable name:" << name();
+  }
+#endif
+  
+  // draw curve fill:
+  if (mainBrush().style() != Qt::NoBrush && mainBrush().color().alpha() != 0)
+  {
+    applyFillAntialiasingHint(painter);
+    painter->setPen(Qt::NoPen);
+    painter->setBrush(mainBrush());
+    painter->drawPolygon(QPolygonF(*lineData));
+  }
+  
+  // draw curve line:
+  if (mLineStyle != lsNone && mainPen().style() != Qt::NoPen && mainPen().color().alpha() != 0)
+  {
+    applyDefaultAntialiasingHint(painter);
+    painter->setPen(mainPen());
+    painter->setBrush(Qt::NoBrush);
+    // if drawing solid line and not in PDF, use much faster line drawing instead of polyline:
+    if (mParentPlot->plottingHints().testFlag(QCP::phFastPolylines) &&
+        painter->pen().style() == Qt::SolidLine &&
+        !painter->modes().testFlag(QCPPainter::pmVectorized) &&
+        !painter->modes().testFlag(QCPPainter::pmNoCaching))
+    {
+      int i = 0;
+      bool lastIsNan = false;
+      const int lineDataSize = lineData->size();
+      while (i < lineDataSize && (qIsNaN(lineData->at(i).y()) || qIsNaN(lineData->at(i).x()))) // make sure first point is not NaN
+        ++i;
+      ++i; // because drawing works in 1 point retrospect
+      while (i < lineDataSize)
+      {
+        if (!qIsNaN(lineData->at(i).y()) && !qIsNaN(lineData->at(i).x())) // NaNs create a gap in the line
+        {
+          if (!lastIsNan)
+            painter->drawLine(lineData->at(i-1), lineData->at(i));
+          else
+            lastIsNan = false;
+        } else
+          lastIsNan = true;
+        ++i;
+      }
+    } else
+    {
+      int segmentStart = 0;
+      int i = 0;
+      const int lineDataSize = lineData->size();
+      while (i < lineDataSize)
+      {
+        if (qIsNaN(lineData->at(i).y()) || qIsNaN(lineData->at(i).x())) // NaNs create a gap in the line
+        {
+          painter->drawPolyline(lineData->constData()+segmentStart, i-segmentStart); // i, because we don't want to include the current NaN point
+          segmentStart = i+1;
+        }
+        ++i;
+      }
+      // draw last segment:
+      painter->drawPolyline(lineData->constData()+segmentStart, lineDataSize-segmentStart);
+    }
+  }
+  
+  // draw scatters:
+  if (!mScatterStyle.isNone())
+    drawScatterPlot(painter, lineData);
+  
+  // free allocated line data:
+  delete lineData;
+}
+
+/* inherits documentation from base class */
+void QCPCurve::drawLegendIcon(QCPPainter *painter, const QRectF &rect) const
+{
+  // draw fill:
+  if (mBrush.style() != Qt::NoBrush)
+  {
+    applyFillAntialiasingHint(painter);
+    painter->fillRect(QRectF(rect.left(), rect.top()+rect.height()/2.0, rect.width(), rect.height()/3.0), mBrush);
+  }
+  // draw line vertically centered:
+  if (mLineStyle != lsNone)
+  {
+    applyDefaultAntialiasingHint(painter);
+    painter->setPen(mPen);
+    painter->drawLine(QLineF(rect.left(), rect.top()+rect.height()/2.0, rect.right()+5, rect.top()+rect.height()/2.0)); // +5 on x2 else last segment is missing from dashed/dotted pens
+  }
+  // draw scatter symbol:
+  if (!mScatterStyle.isNone())
+  {
+    applyScattersAntialiasingHint(painter);
+    // scale scatter pixmap if it's too large to fit in legend icon rect:
+    if (mScatterStyle.shape() == QCPScatterStyle::ssPixmap && (mScatterStyle.pixmap().size().width() > rect.width() || mScatterStyle.pixmap().size().height() > rect.height()))
+    {
+      QCPScatterStyle scaledStyle(mScatterStyle);
+      scaledStyle.setPixmap(scaledStyle.pixmap().scaled(rect.size().toSize(), Qt::KeepAspectRatio, Qt::SmoothTransformation));
+      scaledStyle.applyTo(painter, mPen);
+      scaledStyle.drawShape(painter, QRectF(rect).center());
+    } else
+    {
+      mScatterStyle.applyTo(painter, mPen);
+      mScatterStyle.drawShape(painter, QRectF(rect).center());
+    }
+  }
+}
+
+/*! \internal
+  
+  Draws scatter symbols at every data point passed in \a pointData. scatter symbols are independent of
+  the line style and are always drawn if scatter shape is not \ref QCPScatterStyle::ssNone.
+*/
+void QCPCurve::drawScatterPlot(QCPPainter *painter, const QVector<QPointF> *pointData) const
+{
+  // draw scatter point symbols:
+  applyScattersAntialiasingHint(painter);
+  mScatterStyle.applyTo(painter, mPen);
+  for (int i=0; i<pointData->size(); ++i)
+    if (!qIsNaN(pointData->at(i).x()) && !qIsNaN(pointData->at(i).y()))
+      mScatterStyle.drawShape(painter,  pointData->at(i));
+}
+
+/*! \internal
+  
+  called by QCPCurve::draw to generate a point vector (in pixel coordinates) which represents the
+  line of the curve.
+
+  Line segments that aren't visible in the current axis rect are handled in an optimized way. They
+  are projected onto a rectangle slightly larger than the visible axis rect and simplified
+  regarding point count. The algorithm makes sure to preserve appearance of lines and fills inside
+  the visible axis rect by generating new temporary points on the outer rect if necessary.
+  
+  Methods that are also involved in the algorithm are: \ref getRegion, \ref getOptimizedPoint, \ref
+  getOptimizedCornerPoints \ref mayTraverse, \ref getTraverse, \ref getTraverseCornerPoints.
+*/
+void QCPCurve::getCurveData(QVector<QPointF> *lineData) const
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
+  
+  // add margins to rect to compensate for stroke width
+  double strokeMargin = qMax(qreal(1.0), qreal(mainPen().widthF()*0.75)); // stroke radius + 50% safety
+  if (!mScatterStyle.isNone())
+    strokeMargin = qMax(strokeMargin, mScatterStyle.size());
+  double rectLeft = keyAxis->pixelToCoord(keyAxis->coordToPixel(keyAxis->range().lower)-strokeMargin*((keyAxis->orientation()==Qt::Vertical)!=keyAxis->rangeReversed()?-1:1));
+  double rectRight = keyAxis->pixelToCoord(keyAxis->coordToPixel(keyAxis->range().upper)+strokeMargin*((keyAxis->orientation()==Qt::Vertical)!=keyAxis->rangeReversed()?-1:1));
+  double rectBottom = valueAxis->pixelToCoord(valueAxis->coordToPixel(valueAxis->range().lower)+strokeMargin*((valueAxis->orientation()==Qt::Horizontal)!=valueAxis->rangeReversed()?-1:1));
+  double rectTop = valueAxis->pixelToCoord(valueAxis->coordToPixel(valueAxis->range().upper)-strokeMargin*((valueAxis->orientation()==Qt::Horizontal)!=valueAxis->rangeReversed()?-1:1));
+  int currentRegion;
+  QCPCurveDataMap::const_iterator it = mData->constBegin();
+  QCPCurveDataMap::const_iterator prevIt = mData->constEnd()-1;
+  int prevRegion = getRegion(prevIt.value().key, prevIt.value().value, rectLeft, rectTop, rectRight, rectBottom);
+  QVector<QPointF> trailingPoints; // points that must be applied after all other points (are generated only when handling first point to get virtual segment between last and first point right)
+  while (it != mData->constEnd())
+  {
+    currentRegion = getRegion(it.value().key, it.value().value, rectLeft, rectTop, rectRight, rectBottom);
+    if (currentRegion != prevRegion) // changed region, possibly need to add some optimized edge points or original points if entering R
+    {
+      if (currentRegion != 5) // segment doesn't end in R, so it's a candidate for removal
+      {
+        QPointF crossA, crossB;
+        if (prevRegion == 5) // we're coming from R, so add this point optimized
+        {
+          lineData->append(getOptimizedPoint(currentRegion, it.value().key, it.value().value, prevIt.value().key, prevIt.value().value, rectLeft, rectTop, rectRight, rectBottom));
+          // in the situations 5->1/7/9/3 the segment may leave R and directly cross through two outer regions. In these cases we need to add an additional corner point
+          *lineData << getOptimizedCornerPoints(prevRegion, currentRegion, prevIt.value().key, prevIt.value().value, it.value().key, it.value().value, rectLeft, rectTop, rectRight, rectBottom);
+        } else if (mayTraverse(prevRegion, currentRegion) &&
+                   getTraverse(prevIt.value().key, prevIt.value().value, it.value().key, it.value().value, rectLeft, rectTop, rectRight, rectBottom, crossA, crossB))
+        {
+          // add the two cross points optimized if segment crosses R and if segment isn't virtual zeroth segment between last and first curve point:
+          QVector<QPointF> beforeTraverseCornerPoints, afterTraverseCornerPoints;
+          getTraverseCornerPoints(prevRegion, currentRegion, rectLeft, rectTop, rectRight, rectBottom, beforeTraverseCornerPoints, afterTraverseCornerPoints);
+          if (it != mData->constBegin())
+          {
+            *lineData << beforeTraverseCornerPoints;
+            lineData->append(crossA);
+            lineData->append(crossB);
+            *lineData << afterTraverseCornerPoints;
+          } else
+          {
+            lineData->append(crossB);
+            *lineData << afterTraverseCornerPoints;
+            trailingPoints << beforeTraverseCornerPoints << crossA ;
+          }
+        } else // doesn't cross R, line is just moving around in outside regions, so only need to add optimized point(s) at the boundary corner(s)
+        {
+          *lineData << getOptimizedCornerPoints(prevRegion, currentRegion, prevIt.value().key, prevIt.value().value, it.value().key, it.value().value, rectLeft, rectTop, rectRight, rectBottom);
+        }
+      } else // segment does end in R, so we add previous point optimized and this point at original position
+      {
+        if (it == mData->constBegin()) // it is first point in curve and prevIt is last one. So save optimized point for adding it to the lineData in the end
+          trailingPoints << getOptimizedPoint(prevRegion, prevIt.value().key, prevIt.value().value, it.value().key, it.value().value, rectLeft, rectTop, rectRight, rectBottom);
+        else
+          lineData->append(getOptimizedPoint(prevRegion, prevIt.value().key, prevIt.value().value, it.value().key, it.value().value, rectLeft, rectTop, rectRight, rectBottom));
+        lineData->append(coordsToPixels(it.value().key, it.value().value));
+      }
+    } else // region didn't change
+    {
+      if (currentRegion == 5) // still in R, keep adding original points
+      {
+        lineData->append(coordsToPixels(it.value().key, it.value().value));
+      } else // still outside R, no need to add anything
+      {
+        // see how this is not doing anything? That's the main optimization...
+      }
+    }
+    prevIt = it;
+    prevRegion = currentRegion;
+    ++it;
+  }
+  *lineData << trailingPoints;
+}
+
+/*! \internal
+  
+  This function is part of the curve optimization algorithm of \ref getCurveData.
+  
+  It returns the region of the given point (\a x, \a y) with respect to a rectangle defined by \a
+  rectLeft, \a rectTop, \a rectRight, and \a rectBottom.
+  
+  The regions are enumerated from top to bottom and left to right:
+  
+  <table style="width:10em; text-align:center">
+    <tr><td>1</td><td>4</td><td>7</td></tr>
+    <tr><td>2</td><td style="border:1px solid black">5</td><td>8</td></tr>
+    <tr><td>3</td><td>6</td><td>9</td></tr>
+  </table>
+  
+  With the rectangle being region 5, and the outer regions extending infinitely outwards. In the
+  curve optimization algorithm, region 5 is considered to be the visible portion of the plot.
+*/
+int QCPCurve::getRegion(double x, double y, double rectLeft, double rectTop, double rectRight, double rectBottom) const
+{
+  if (x < rectLeft) // region 123
+  {
+    if (y > rectTop)
+      return 1;
+    else if (y < rectBottom)
+      return 3;
+    else
+      return 2;
+  } else if (x > rectRight) // region 789
+  {
+    if (y > rectTop)
+      return 7;
+    else if (y < rectBottom)
+      return 9;
+    else
+      return 8;
+  } else // region 456
+  {
+    if (y > rectTop)
+      return 4;
+    else if (y < rectBottom)
+      return 6;
+    else
+      return 5;
+  }
+}
+
+/*! \internal
+  
+  This function is part of the curve optimization algorithm of \ref getCurveData.
+  
+  This method is used in case the current segment passes from inside the visible rect (region 5,
+  see \ref getRegion) to any of the outer regions (\a otherRegion). The current segment is given by
+  the line connecting (\a key, \a value) with (\a otherKey, \a otherValue).
+  
+  It returns the intersection point of the segment with the border of region 5.
+  
+  For this function it doesn't matter whether (\a key, \a value) is the point inside region 5 or
+  whether it's (\a otherKey, \a otherValue), i.e. whether the segment is coming from region 5 or
+  leaving it. It is important though that \a otherRegion correctly identifies the other region not
+  equal to 5.
+*/
+QPointF QCPCurve::getOptimizedPoint(int otherRegion, double otherKey, double otherValue, double key, double value, double rectLeft, double rectTop, double rectRight, double rectBottom) const
+{
+  double intersectKey = rectLeft; // initial value is just fail-safe
+  double intersectValue = rectTop; // initial value is just fail-safe
+  switch (otherRegion)
+  {
+    case 1: // top and left edge
+    {
+      intersectValue = rectTop;
+      intersectKey = otherKey + (key-otherKey)/(value-otherValue)*(intersectValue-otherValue);
+      if (intersectKey < rectLeft || intersectKey > rectRight) // doesn't intersect, so must intersect other:
+      {
+        intersectKey = rectLeft;
+        intersectValue = otherValue + (value-otherValue)/(key-otherKey)*(intersectKey-otherKey);
+      }
+      break;
+    }
+    case 2: // left edge
+    {
+      intersectKey = rectLeft;
+      intersectValue = otherValue + (value-otherValue)/(key-otherKey)*(intersectKey-otherKey);
+      break;
+    }
+    case 3: // bottom and left edge
+    {
+      intersectValue = rectBottom;
+      intersectKey = otherKey + (key-otherKey)/(value-otherValue)*(intersectValue-otherValue);
+      if (intersectKey < rectLeft || intersectKey > rectRight) // doesn't intersect, so must intersect other:
+      {
+        intersectKey = rectLeft;
+        intersectValue = otherValue + (value-otherValue)/(key-otherKey)*(intersectKey-otherKey);
+      }
+      break;
+    }
+    case 4: // top edge
+    {
+      intersectValue = rectTop;
+      intersectKey = otherKey + (key-otherKey)/(value-otherValue)*(intersectValue-otherValue);
+      break;
+    }
+    case 5:
+    {
+      break; // case 5 shouldn't happen for this function but we add it anyway to prevent potential discontinuity in branch table
+    }
+    case 6: // bottom edge
+    {
+      intersectValue = rectBottom;
+      intersectKey = otherKey + (key-otherKey)/(value-otherValue)*(intersectValue-otherValue);
+      break;
+    }
+    case 7: // top and right edge
+    {
+      intersectValue = rectTop;
+      intersectKey = otherKey + (key-otherKey)/(value-otherValue)*(intersectValue-otherValue);
+      if (intersectKey < rectLeft || intersectKey > rectRight) // doesn't intersect, so must intersect other:
+      {
+        intersectKey = rectRight;
+        intersectValue = otherValue + (value-otherValue)/(key-otherKey)*(intersectKey-otherKey);
+      }
+      break;
+    }
+    case 8: // right edge
+    {
+      intersectKey = rectRight;
+      intersectValue = otherValue + (value-otherValue)/(key-otherKey)*(intersectKey-otherKey);
+      break;
+    }
+    case 9: // bottom and right edge
+    {
+      intersectValue = rectBottom;
+      intersectKey = otherKey + (key-otherKey)/(value-otherValue)*(intersectValue-otherValue);
+      if (intersectKey < rectLeft || intersectKey > rectRight) // doesn't intersect, so must intersect other:
+      {
+        intersectKey = rectRight;
+        intersectValue = otherValue + (value-otherValue)/(key-otherKey)*(intersectKey-otherKey);
+      }
+      break;
+    }
+  }
+  return coordsToPixels(intersectKey, intersectValue);
+}
+
+/*! \internal
+  
+  This function is part of the curve optimization algorithm of \ref getCurveData.
+  
+  In situations where a single segment skips over multiple regions it might become necessary to add
+  extra points at the corners of region 5 (see \ref getRegion) such that the optimized segment
+  doesn't unintentionally cut through the visible area of the axis rect and create plot artifacts.
+  This method provides these points that must be added, assuming the original segment doesn't
+  start, end, or traverse region 5. (Corner points where region 5 is traversed are calculated by
+  \ref getTraverseCornerPoints.)
+  
+  For example, consider a segment which directly goes from region 4 to 2 but originally is far out
+  to the top left such that it doesn't cross region 5. Naively optimizing these points by
+  projecting them on the top and left borders of region 5 will create a segment that surely crosses
+  5, creating a visual artifact in the plot. This method prevents this by providing extra points at
+  the top left corner, making the optimized curve correctly pass from region 4 to 1 to 2 without
+  traversing 5.
+*/
+QVector<QPointF> QCPCurve::getOptimizedCornerPoints(int prevRegion, int currentRegion, double prevKey, double prevValue, double key, double value, double rectLeft, double rectTop, double rectRight, double rectBottom) const
+{
+  QVector<QPointF> result;
+  switch (prevRegion)
+  {
+    case 1:
+    {
+      switch (currentRegion)
+      {
+        case 2: { result << coordsToPixels(rectLeft, rectTop); break; }
+        case 4: { result << coordsToPixels(rectLeft, rectTop); break; }
+        case 3: { result << coordsToPixels(rectLeft, rectTop) << coordsToPixels(rectLeft, rectBottom); break; }
+        case 7: { result << coordsToPixels(rectLeft, rectTop) << coordsToPixels(rectRight, rectTop); break; }
+        case 6: { result << coordsToPixels(rectLeft, rectTop) << coordsToPixels(rectLeft, rectBottom); result.append(result.last()); break; }
+        case 8: { result << coordsToPixels(rectLeft, rectTop) << coordsToPixels(rectRight, rectTop); result.append(result.last()); break; }
+        case 9: { // in this case we need another distinction of cases: segment may pass below or above rect, requiring either bottom right or top left corner points
+          if ((value-prevValue)/(key-prevKey)*(rectLeft-key)+value < rectBottom) // segment passes below R
+          { result << coordsToPixels(rectLeft, rectTop) << coordsToPixels(rectLeft, rectBottom); result.append(result.last()); result << coordsToPixels(rectRight, rectBottom); }
+          else
+          { result << coordsToPixels(rectLeft, rectTop) << coordsToPixels(rectRight, rectTop); result.append(result.last()); result << coordsToPixels(rectRight, rectBottom); }
+          break;
+        }
+      }
+      break;
+    }
+    case 2:
+    {
+      switch (currentRegion)
+      {
+        case 1: { result << coordsToPixels(rectLeft, rectTop); break; }
+        case 3: { result << coordsToPixels(rectLeft, rectBottom); break; }
+        case 4: { result << coordsToPixels(rectLeft, rectTop); result.append(result.last()); break; }
+        case 6: { result << coordsToPixels(rectLeft, rectBottom); result.append(result.last()); break; }
+        case 7: { result << coordsToPixels(rectLeft, rectTop); result.append(result.last()); result << coordsToPixels(rectRight, rectTop); break; }
+        case 9: { result << coordsToPixels(rectLeft, rectBottom); result.append(result.last()); result << coordsToPixels(rectRight, rectBottom); break; }
+      }
+      break;
+    }
+    case 3:
+    {
+      switch (currentRegion)
+      {
+        case 2: { result << coordsToPixels(rectLeft, rectBottom); break; }
+        case 6: { result << coordsToPixels(rectLeft, rectBottom); break; }
+        case 1: { result << coordsToPixels(rectLeft, rectBottom) << coordsToPixels(rectLeft, rectTop); break; }
+        case 9: { result << coordsToPixels(rectLeft, rectBottom) << coordsToPixels(rectRight, rectBottom); break; }
+        case 4: { result << coordsToPixels(rectLeft, rectBottom) << coordsToPixels(rectLeft, rectTop); result.append(result.last()); break; }
+        case 8: { result << coordsToPixels(rectLeft, rectBottom) << coordsToPixels(rectRight, rectBottom); result.append(result.last()); break; }
+        case 7: { // in this case we need another distinction of cases: segment may pass below or above rect, requiring either bottom right or top left corner points
+          if ((value-prevValue)/(key-prevKey)*(rectRight-key)+value < rectBottom) // segment passes below R
+          { result << coordsToPixels(rectLeft, rectBottom) << coordsToPixels(rectRight, rectBottom); result.append(result.last()); result << coordsToPixels(rectRight, rectTop); }
+          else
+          { result << coordsToPixels(rectLeft, rectBottom) << coordsToPixels(rectLeft, rectTop); result.append(result.last()); result << coordsToPixels(rectRight, rectTop); }
+          break;
+        }
+      }
+      break;
+    }
+    case 4:
+    {
+      switch (currentRegion)
+      {
+        case 1: { result << coordsToPixels(rectLeft, rectTop); break; }
+        case 7: { result << coordsToPixels(rectRight, rectTop); break; }
+        case 2: { result << coordsToPixels(rectLeft, rectTop); result.append(result.last()); break; }
+        case 8: { result << coordsToPixels(rectRight, rectTop); result.append(result.last()); break; }
+        case 3: { result << coordsToPixels(rectLeft, rectTop); result.append(result.last()); result << coordsToPixels(rectLeft, rectBottom); break; }
+        case 9: { result << coordsToPixels(rectRight, rectTop); result.append(result.last()); result << coordsToPixels(rectRight, rectBottom); break; }
+      }
+      break;
+    }
+    case 5:
+    {
+      switch (currentRegion)
+      {
+        case 1: { result << coordsToPixels(rectLeft, rectTop); break; }
+        case 7: { result << coordsToPixels(rectRight, rectTop); break; }
+        case 9: { result << coordsToPixels(rectRight, rectBottom); break; }
+        case 3: { result << coordsToPixels(rectLeft, rectBottom); break; }
+      }
+      break;
+    }
+    case 6:
+    {
+      switch (currentRegion)
+      {
+        case 3: { result << coordsToPixels(rectLeft, rectBottom); break; }
+        case 9: { result << coordsToPixels(rectRight, rectBottom); break; }
+        case 2: { result << coordsToPixels(rectLeft, rectBottom); result.append(result.last()); break; }
+        case 8: { result << coordsToPixels(rectRight, rectBottom); result.append(result.last()); break; }
+        case 1: { result << coordsToPixels(rectLeft, rectBottom); result.append(result.last()); result << coordsToPixels(rectLeft, rectTop); break; }
+        case 7: { result << coordsToPixels(rectRight, rectBottom); result.append(result.last()); result << coordsToPixels(rectRight, rectTop); break; }
+      }
+      break;
+    }
+    case 7:
+    {
+      switch (currentRegion)
+      {
+        case 4: { result << coordsToPixels(rectRight, rectTop); break; }
+        case 8: { result << coordsToPixels(rectRight, rectTop); break; }
+        case 1: { result << coordsToPixels(rectRight, rectTop) << coordsToPixels(rectLeft, rectTop); break; }
+        case 9: { result << coordsToPixels(rectRight, rectTop) << coordsToPixels(rectRight, rectBottom); break; }
+        case 2: { result << coordsToPixels(rectRight, rectTop) << coordsToPixels(rectLeft, rectTop); result.append(result.last()); break; }
+        case 6: { result << coordsToPixels(rectRight, rectTop) << coordsToPixels(rectRight, rectBottom); result.append(result.last()); break; }
+        case 3: { // in this case we need another distinction of cases: segment may pass below or above rect, requiring either bottom right or top left corner points
+          if ((value-prevValue)/(key-prevKey)*(rectRight-key)+value < rectBottom) // segment passes below R
+          { result << coordsToPixels(rectRight, rectTop) << coordsToPixels(rectRight, rectBottom); result.append(result.last()); result << coordsToPixels(rectLeft, rectBottom); }
+          else
+          { result << coordsToPixels(rectRight, rectTop) << coordsToPixels(rectLeft, rectTop); result.append(result.last()); result << coordsToPixels(rectLeft, rectBottom); }
+          break;
+        }
+      }
+      break;
+    }
+    case 8:
+    {
+      switch (currentRegion)
+      {
+        case 7: { result << coordsToPixels(rectRight, rectTop); break; }
+        case 9: { result << coordsToPixels(rectRight, rectBottom); break; }
+        case 4: { result << coordsToPixels(rectRight, rectTop); result.append(result.last()); break; }
+        case 6: { result << coordsToPixels(rectRight, rectBottom); result.append(result.last()); break; }
+        case 1: { result << coordsToPixels(rectRight, rectTop); result.append(result.last()); result << coordsToPixels(rectLeft, rectTop); break; }
+        case 3: { result << coordsToPixels(rectRight, rectBottom); result.append(result.last()); result << coordsToPixels(rectLeft, rectBottom); break; }
+      }
+      break;
+    }
+    case 9:
+    {
+      switch (currentRegion)
+      {
+        case 6: { result << coordsToPixels(rectRight, rectBottom); break; }
+        case 8: { result << coordsToPixels(rectRight, rectBottom); break; }
+        case 3: { result << coordsToPixels(rectRight, rectBottom) << coordsToPixels(rectLeft, rectBottom); break; }
+        case 7: { result << coordsToPixels(rectRight, rectBottom) << coordsToPixels(rectRight, rectTop); break; }
+        case 2: { result << coordsToPixels(rectRight, rectBottom) << coordsToPixels(rectLeft, rectBottom); result.append(result.last()); break; }
+        case 4: { result << coordsToPixels(rectRight, rectBottom) << coordsToPixels(rectRight, rectTop); result.append(result.last()); break; }
+        case 1: { // in this case we need another distinction of cases: segment may pass below or above rect, requiring either bottom right or top left corner points
+          if ((value-prevValue)/(key-prevKey)*(rectLeft-key)+value < rectBottom) // segment passes below R
+          { result << coordsToPixels(rectRight, rectBottom) << coordsToPixels(rectLeft, rectBottom); result.append(result.last()); result << coordsToPixels(rectLeft, rectTop); }
+          else
+          { result << coordsToPixels(rectRight, rectBottom) << coordsToPixels(rectRight, rectTop); result.append(result.last()); result << coordsToPixels(rectLeft, rectTop); }
+          break;
+        }
+      }
+      break;
+    }
+  }
+  return result;
+}
+
+/*! \internal
+  
+  This function is part of the curve optimization algorithm of \ref getCurveData.
+  
+  This method returns whether a segment going from \a prevRegion to \a currentRegion (see \ref
+  getRegion) may traverse the visible region 5. This function assumes that neither \a prevRegion
+  nor \a currentRegion is 5 itself.
+  
+  If this method returns false, the segment for sure doesn't pass region 5. If it returns true, the
+  segment may or may not pass region 5 and a more fine-grained calculation must be used (\ref
+  getTraverse).
+*/
+bool QCPCurve::mayTraverse(int prevRegion, int currentRegion) const
+{
+  switch (prevRegion)
+  {
+    case 1:
+    {
+      switch (currentRegion)
+      {
+        case 4:
+        case 7:
+        case 2:
+        case 3: return false;
+        default: return true;
+      }
+    }
+    case 2:
+    {
+      switch (currentRegion)
+      {
+        case 1:
+        case 3: return false;
+        default: return true;
+      }
+    }
+    case 3:
+    {
+      switch (currentRegion)
+      {
+        case 1:
+        case 2:
+        case 6:
+        case 9: return false;
+        default: return true;
+      }
+    }
+    case 4:
+    {
+      switch (currentRegion)
+      {
+        case 1:
+        case 7: return false;
+        default: return true;
+      }
+    }
+    case 5: return false; // should never occur
+    case 6:
+    {
+      switch (currentRegion)
+      {
+        case 3:
+        case 9: return false;
+        default: return true;
+      }
+    }
+    case 7:
+    {
+      switch (currentRegion)
+      {
+        case 1:
+        case 4:
+        case 8:
+        case 9: return false;
+        default: return true;
+      }
+    }
+    case 8:
+    {
+      switch (currentRegion)
+      {
+        case 7:
+        case 9: return false;
+        default: return true;
+      }
+    }
+    case 9:
+    {
+      switch (currentRegion)
+      {
+        case 3:
+        case 6:
+        case 8:
+        case 7: return false;
+        default: return true;
+      }
+    }
+    default: return true;
+  }
+}
+
+
+/*! \internal
+  
+  This function is part of the curve optimization algorithm of \ref getCurveData.
+  
+  This method assumes that the \ref mayTraverse test has returned true, so there is a chance the
+  segment defined by (\a prevKey, \a prevValue) and (\a key, \a value) goes through the visible
+  region 5.
+  
+  The return value of this method indicates whether the segment actually traverses region 5 or not.
+  
+  If the segment traverses 5, the output parameters \a crossA and \a crossB indicate the entry and
+  exit points of region 5. They will become the optimized points for that segment.
+*/
+bool QCPCurve::getTraverse(double prevKey, double prevValue, double key, double value, double rectLeft, double rectTop, double rectRight, double rectBottom, QPointF &crossA, QPointF &crossB) const
+{
+  QList<QPointF> intersections; // x of QPointF corresponds to key and y to value
+  if (qFuzzyIsNull(key-prevKey)) // line is parallel to value axis
+  {
+    // due to region filter in mayTraverseR(), if line is parallel to value or key axis, R is traversed here
+    intersections.append(QPointF(key, rectBottom)); // direction will be taken care of at end of method
+    intersections.append(QPointF(key, rectTop));
+  } else if (qFuzzyIsNull(value-prevValue)) // line is parallel to key axis
+  {
+    // due to region filter in mayTraverseR(), if line is parallel to value or key axis, R is traversed here
+    intersections.append(QPointF(rectLeft, value)); // direction will be taken care of at end of method
+    intersections.append(QPointF(rectRight, value));
+  } else // line is skewed
+  {
+    double gamma;
+    double keyPerValue = (key-prevKey)/(value-prevValue);
+    // check top of rect:
+    gamma = prevKey + (rectTop-prevValue)*keyPerValue;
+    if (gamma >= rectLeft && gamma <= rectRight)
+      intersections.append(QPointF(gamma, rectTop));
+    // check bottom of rect:
+    gamma = prevKey + (rectBottom-prevValue)*keyPerValue;
+    if (gamma >= rectLeft && gamma <= rectRight)
+      intersections.append(QPointF(gamma, rectBottom));
+    double valuePerKey = 1.0/keyPerValue;
+    // check left of rect:
+    gamma = prevValue + (rectLeft-prevKey)*valuePerKey;
+    if (gamma >= rectBottom && gamma <= rectTop)
+      intersections.append(QPointF(rectLeft, gamma));
+    // check right of rect:
+    gamma = prevValue + (rectRight-prevKey)*valuePerKey;
+    if (gamma >= rectBottom && gamma <= rectTop)
+      intersections.append(QPointF(rectRight, gamma));
+  }
+  
+  // handle cases where found points isn't exactly 2:
+  if (intersections.size() > 2)
+  {
+    // line probably goes through corner of rect, and we got duplicate points there. single out the point pair with greatest distance in between:
+    double distSqrMax = 0;
+    QPointF pv1, pv2;
+    for (int i=0; i<intersections.size()-1; ++i)
+    {
+      for (int k=i+1; k<intersections.size(); ++k)
+      {
+        QPointF distPoint = intersections.at(i)-intersections.at(k);
+        double distSqr = distPoint.x()*distPoint.x()+distPoint.y()+distPoint.y();
+        if (distSqr > distSqrMax)
+        {
+          pv1 = intersections.at(i);
+          pv2 = intersections.at(k);
+          distSqrMax = distSqr;
+        }
+      }
+    }
+    intersections = QList<QPointF>() << pv1 << pv2;
+  } else if (intersections.size() != 2)
+  {
+    // one or even zero points found (shouldn't happen unless line perfectly tangent to corner), no need to draw segment
+    return false;
+  }
+  
+  // possibly re-sort points so optimized point segment has same direction as original segment:
+  if ((key-prevKey)*(intersections.at(1).x()-intersections.at(0).x()) + (value-prevValue)*(intersections.at(1).y()-intersections.at(0).y()) < 0) // scalar product of both segments < 0 -> opposite direction
+    intersections.move(0, 1);
+  crossA = coordsToPixels(intersections.at(0).x(), intersections.at(0).y());
+  crossB = coordsToPixels(intersections.at(1).x(), intersections.at(1).y());
+  return true;
+}
+
+/*! \internal
+  
+  This function is part of the curve optimization algorithm of \ref getCurveData.
+  
+  This method assumes that the \ref getTraverse test has returned true, so the segment definitely
+  traverses the visible region 5 when going from \a prevRegion to \a currentRegion.
+  
+  In certain situations it is not sufficient to merely generate the entry and exit points of the
+  segment into/out of region 5, as \ref getTraverse provides. It may happen that a single segment, in
+  addition to traversing region 5, skips another region outside of region 5, which makes it
+  necessary to add an optimized corner point there (very similar to the job \ref
+  getOptimizedCornerPoints does for segments that are completely in outside regions and don't
+  traverse 5).
+  
+  As an example, consider a segment going from region 1 to region 6, traversing the lower left
+  corner of region 5. In this configuration, the segment additionally crosses the border between
+  region 1 and 2 before entering region 5. This makes it necessary to add an additional point in
+  the top left corner, before adding the optimized traverse points. So in this case, the output
+  parameter \a beforeTraverse will contain the top left corner point, and \a afterTraverse will be
+  empty.
+  
+  In some cases, such as when going from region 1 to 9, it may even be necessary to add additional
+  corner points before and after the traverse. Then both \a beforeTraverse and \a afterTraverse
+  return the respective corner points.
+*/
+void QCPCurve::getTraverseCornerPoints(int prevRegion, int currentRegion, double rectLeft, double rectTop, double rectRight, double rectBottom, QVector<QPointF> &beforeTraverse, QVector<QPointF> &afterTraverse) const
+{
+  switch (prevRegion)
+  {
+    case 1:
+    {
+      switch (currentRegion)
+      {
+        case 6: { beforeTraverse << coordsToPixels(rectLeft, rectTop); break; }
+        case 9: { beforeTraverse << coordsToPixels(rectLeft, rectTop); afterTraverse << coordsToPixels(rectRight, rectBottom); break; }
+        case 8: { beforeTraverse << coordsToPixels(rectLeft, rectTop); break; }
+      }
+      break;
+    }
+    case 2:
+    {
+      switch (currentRegion)
+      {
+        case 7: { afterTraverse << coordsToPixels(rectRight, rectTop); break; }
+        case 9: { afterTraverse << coordsToPixels(rectRight, rectBottom); break; }
+      }
+      break;
+    }
+    case 3:
+    {
+      switch (currentRegion)
+      {
+        case 4: { beforeTraverse << coordsToPixels(rectLeft, rectBottom); break; }
+        case 7: { beforeTraverse << coordsToPixels(rectLeft, rectBottom); afterTraverse << coordsToPixels(rectRight, rectTop); break; }
+        case 8: { beforeTraverse << coordsToPixels(rectLeft, rectBottom); break; }
+      }
+      break;
+    }
+    case 4:
+    {
+      switch (currentRegion)
+      {
+        case 3: { afterTraverse << coordsToPixels(rectLeft, rectBottom); break; }
+        case 9: { afterTraverse << coordsToPixels(rectRight, rectBottom); break; }
+      }
+      break;
+    }
+    case 5: { break; } // shouldn't happen because this method only handles full traverses
+    case 6:
+    {
+      switch (currentRegion)
+      {
+        case 1: { afterTraverse << coordsToPixels(rectLeft, rectTop); break; }
+        case 7: { afterTraverse << coordsToPixels(rectRight, rectTop); break; }
+      }
+      break;
+    }
+    case 7:
+    {
+      switch (currentRegion)
+      {
+        case 2: { beforeTraverse << coordsToPixels(rectRight, rectTop); break; }
+        case 3: { beforeTraverse << coordsToPixels(rectRight, rectTop); afterTraverse << coordsToPixels(rectLeft, rectBottom); break; }
+        case 6: { beforeTraverse << coordsToPixels(rectRight, rectTop); break; }
+      }
+      break;
+    }
+    case 8:
+    {
+      switch (currentRegion)
+      {
+        case 1: { afterTraverse << coordsToPixels(rectLeft, rectTop); break; }
+        case 3: { afterTraverse << coordsToPixels(rectLeft, rectBottom); break; }
+      }
+      break;
+    }
+    case 9:
+    {
+      switch (currentRegion)
+      {
+        case 2: { beforeTraverse << coordsToPixels(rectRight, rectBottom); break; }
+        case 1: { beforeTraverse << coordsToPixels(rectRight, rectBottom); afterTraverse << coordsToPixels(rectLeft, rectTop); break; }
+        case 4: { beforeTraverse << coordsToPixels(rectRight, rectBottom); break; }
+      }
+      break;
+    }
+  }
+}
+
+/*! \internal
+  
+  Calculates the (minimum) distance (in pixels) the curve's representation has from the given \a
+  pixelPoint in pixels. This is used to determine whether the curve was clicked or not, e.g. in
+  \ref selectTest.
+*/
+double QCPCurve::pointDistance(const QPointF &pixelPoint) const
+{
+  if (mData->isEmpty())
+  {
+    qDebug() << Q_FUNC_INFO << "requested point distance on curve" << mName << "without data";
+    return 500;
+  }
+  if (mData->size() == 1)
+  {
+    QPointF dataPoint = coordsToPixels(mData->constBegin().key(), mData->constBegin().value().value);
+    return QVector2D(dataPoint-pixelPoint).length();
+  }
+  
+  // calculate minimum distance to line segments:
+  QVector<QPointF> *lineData = new QVector<QPointF>;
+  getCurveData(lineData);
+  double minDistSqr = std::numeric_limits<double>::max();
+  for (int i=0; i<lineData->size()-1; ++i)
+  {
+    double currentDistSqr = distSqrToLine(lineData->at(i), lineData->at(i+1), pixelPoint);
+    if (currentDistSqr < minDistSqr)
+      minDistSqr = currentDistSqr;
+  }
+  delete lineData;
+  return qSqrt(minDistSqr);
+}
+
+/* inherits documentation from base class */
+QCPRange QCPCurve::getKeyRange(bool &foundRange, SignDomain inSignDomain) const
+{
+  QCPRange range;
+  bool haveLower = false;
+  bool haveUpper = false;
+  
+  double current;
+  
+  QCPCurveDataMap::const_iterator it = mData->constBegin();
+  while (it != mData->constEnd())
+  {
+    current = it.value().key;
+    if (!qIsNaN(current) && !qIsNaN(it.value().value))
+    {
+      if (inSignDomain == sdBoth || (inSignDomain == sdNegative && current < 0) || (inSignDomain == sdPositive && current > 0))
+      {
+        if (current < range.lower || !haveLower)
+        {
+          range.lower = current;
+          haveLower = true;
+        }
+        if (current > range.upper || !haveUpper)
+        {
+          range.upper = current;
+          haveUpper = true;
+        }
+      }
+    }
+    ++it;
+  }
+  
+  foundRange = haveLower && haveUpper;
+  return range;
+}
+
+/* inherits documentation from base class */
+QCPRange QCPCurve::getValueRange(bool &foundRange, SignDomain inSignDomain) const
+{
+  QCPRange range;
+  bool haveLower = false;
+  bool haveUpper = false;
+  
+  double current;
+  
+  QCPCurveDataMap::const_iterator it = mData->constBegin();
+  while (it != mData->constEnd())
+  {
+    current = it.value().value;
+    if (!qIsNaN(current) && !qIsNaN(it.value().key))
+    {
+      if (inSignDomain == sdBoth || (inSignDomain == sdNegative && current < 0) || (inSignDomain == sdPositive && current > 0))
+      {
+        if (current < range.lower || !haveLower)
+        {
+          range.lower = current;
+          haveLower = true;
+        }
+        if (current > range.upper || !haveUpper)
+        {
+          range.upper = current;
+          haveUpper = true;
+        }
+      }
+    }
+    ++it;
+  }
+  
+  foundRange = haveLower && haveUpper;
+  return range;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPBarsGroup
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPBarsGroup
+  \brief Groups multiple QCPBars together so they appear side by side
+  
+  \image html QCPBarsGroup.png
+  
+  When showing multiple QCPBars in one plot which have bars at identical keys, it may be desirable
+  to have them appearing next to each other at each key. This is what adding the respective QCPBars
+  plottables to a QCPBarsGroup achieves. (An alternative approach is to stack them on top of each
+  other, see \ref QCPBars::moveAbove.)
+  
+  \section qcpbarsgroup-usage Usage
+  
+  To add a QCPBars plottable to the group, create a new group and then add the respective bars
+  intances:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpbarsgroup-creation
+  Alternatively to appending to the group like shown above, you can also set the group on the
+  QCPBars plottable via \ref QCPBars::setBarsGroup.
+  
+  The spacing between the bars can be configured via \ref setSpacingType and \ref setSpacing. The
+  bars in this group appear in the plot in the order they were appended. To insert a bars plottable
+  at a certain index position, or to reposition a bars plottable which is already in the group, use
+  \ref insert.
+  
+  To remove specific bars from the group, use either \ref remove or call \ref
+  QCPBars::setBarsGroup "QCPBars::setBarsGroup(0)" on the respective bars plottable.
+  
+  To clear the entire group, call \ref clear, or simply delete the group.
+  
+  \section qcpbarsgroup-example Example
+  
+  The image above is generated with the following code:
+  \snippet documentation/doc-image-generator/mainwindow.cpp qcpbarsgroup-example
+*/
+
+/* start of documentation of inline functions */
+
+/*! \fn QList<QCPBars*> QCPBarsGroup::bars() const
+  
+  Returns all bars currently in this group.
+  
+  \see bars(int index)
+*/
+
+/*! \fn int QCPBarsGroup::size() const
+  
+  Returns the number of QCPBars plottables that are part of this group.
+  
+*/
+
+/*! \fn bool QCPBarsGroup::isEmpty() const
+  
+  Returns whether this bars group is empty.
+  
+  \see size
+*/
+
+/*! \fn bool QCPBarsGroup::contains(QCPBars *bars)
+  
+  Returns whether the specified \a bars plottable is part of this group.
+  
+*/
+
+/* end of documentation of inline functions */
+
+/*!
+  Constructs a new bars group for the specified QCustomPlot instance.
+*/
+QCPBarsGroup::QCPBarsGroup(QCustomPlot *parentPlot) :
+  QObject(parentPlot),
+  mParentPlot(parentPlot),
+  mSpacingType(stAbsolute),
+  mSpacing(4)
+{
+}
+
+QCPBarsGroup::~QCPBarsGroup()
+{
+  clear();
+}
+
+/*!
+  Sets how the spacing between adjacent bars is interpreted. See \ref SpacingType.
+  
+  The actual spacing can then be specified with \ref setSpacing.
+
+  \see setSpacing
+*/
+void QCPBarsGroup::setSpacingType(SpacingType spacingType)
+{
+  mSpacingType = spacingType;
+}
+
+/*!
+  Sets the spacing between adjacent bars. What the number passed as \a spacing actually means, is
+  defined by the current \ref SpacingType, which can be set with \ref setSpacingType.
+
+  \see setSpacingType
+*/
+void QCPBarsGroup::setSpacing(double spacing)
+{
+  mSpacing = spacing;
+}
+
+/*!
+  Returns the QCPBars instance with the specified \a index in this group. If no such QCPBars
+  exists, returns 0.
+
+  \see bars(), size
+*/
+QCPBars *QCPBarsGroup::bars(int index) const
+{
+  if (index >= 0 && index < mBars.size())
+  {
+    return mBars.at(index);
+  } else
+  {
+    qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;
+    return 0;
+  }
+}
+
+/*!
+  Removes all QCPBars plottables from this group.
+
+  \see isEmpty
+*/
+void QCPBarsGroup::clear()
+{
+  foreach (QCPBars *bars, mBars) // since foreach takes a copy, removing bars in the loop is okay
+    bars->setBarsGroup(0); // removes itself via removeBars
+}
+
+/*!
+  Adds the specified \a bars plottable to this group. Alternatively, you can also use \ref
+  QCPBars::setBarsGroup on the \a bars instance.
+
+  \see insert, remove
+*/
+void QCPBarsGroup::append(QCPBars *bars)
+{
+  if (!bars)
+  {
+    qDebug() << Q_FUNC_INFO << "bars is 0";
+    return;
+  }
+    
+  if (!mBars.contains(bars))
+    bars->setBarsGroup(this);
+  else
+    qDebug() << Q_FUNC_INFO << "bars plottable is already in this bars group:" << reinterpret_cast<quintptr>(bars);
+}
+
+/*!
+  Inserts the specified \a bars plottable into this group at the specified index position \a i.
+  This gives you full control over the ordering of the bars.
+  
+  \a bars may already be part of this group. In that case, \a bars is just moved to the new index
+  position.
+
+  \see append, remove
+*/
+void QCPBarsGroup::insert(int i, QCPBars *bars)
+{
+  if (!bars)
+  {
+    qDebug() << Q_FUNC_INFO << "bars is 0";
+    return;
+  }
+  
+  // first append to bars list normally:
+  if (!mBars.contains(bars))
+    bars->setBarsGroup(this);
+  // then move to according position:
+  mBars.move(mBars.indexOf(bars), qBound(0, i, mBars.size()-1));
+}
+
+/*!
+  Removes the specified \a bars plottable from this group.
+  
+  \see contains, clear
+*/
+void QCPBarsGroup::remove(QCPBars *bars)
+{
+  if (!bars)
+  {
+    qDebug() << Q_FUNC_INFO << "bars is 0";
+    return;
+  }
+  
+  if (mBars.contains(bars))
+    bars->setBarsGroup(0);
+  else
+    qDebug() << Q_FUNC_INFO << "bars plottable is not in this bars group:" << reinterpret_cast<quintptr>(bars);
+}
+
+/*! \internal
+  
+  Adds the specified \a bars to the internal mBars list of bars. This method does not change the
+  barsGroup property on \a bars.
+  
+  \see unregisterBars
+*/
+void QCPBarsGroup::registerBars(QCPBars *bars)
+{
+  if (!mBars.contains(bars))
+    mBars.append(bars);
+}
+
+/*! \internal
+  
+  Removes the specified \a bars from the internal mBars list of bars. This method does not change
+  the barsGroup property on \a bars.
+  
+  \see registerBars
+*/
+void QCPBarsGroup::unregisterBars(QCPBars *bars)
+{
+  mBars.removeOne(bars);
+}
+
+/*! \internal
+  
+  Returns the pixel offset in the key dimension the specified \a bars plottable should have at the
+  given key coordinate \a keyCoord. The offset is relative to the pixel position of the key
+  coordinate \a keyCoord.
+*/
+double QCPBarsGroup::keyPixelOffset(const QCPBars *bars, double keyCoord)
+{
+  // find list of all base bars in case some mBars are stacked:
+  QList<const QCPBars*> baseBars;
+  foreach (const QCPBars *b, mBars)
+  {
+    while (b->barBelow())
+      b = b->barBelow();
+    if (!baseBars.contains(b))
+      baseBars.append(b);
+  }
+  // find base bar this "bars" is stacked on:
+  const QCPBars *thisBase = bars;
+  while (thisBase->barBelow())
+    thisBase = thisBase->barBelow();
+  
+  // determine key pixel offset of this base bars considering all other base bars in this barsgroup:
+  double result = 0;
+  int index = baseBars.indexOf(thisBase);
+  if (index >= 0)
+  {
+    int startIndex;
+    double lowerPixelWidth, upperPixelWidth;
+    if (baseBars.size() % 2 == 1 && index == (baseBars.size()-1)/2) // is center bar (int division on purpose)
+    {
+      return result;
+    } else if (index < (baseBars.size()-1)/2.0) // bar is to the left of center
+    {
+      if (baseBars.size() % 2 == 0) // even number of bars
+      {
+        startIndex = baseBars.size()/2-1;
+        result -= getPixelSpacing(baseBars.at(startIndex), keyCoord)*0.5; // half of middle spacing
+      } else // uneven number of bars
+      {
+        startIndex = (baseBars.size()-1)/2-1;
+        baseBars.at((baseBars.size()-1)/2)->getPixelWidth(keyCoord, lowerPixelWidth, upperPixelWidth);
+        result -= qAbs(upperPixelWidth-lowerPixelWidth)*0.5; // half of center bar
+        result -= getPixelSpacing(baseBars.at((baseBars.size()-1)/2), keyCoord); // center bar spacing
+      }
+      for (int i=startIndex; i>index; --i) // add widths and spacings of bars in between center and our bars
+      {
+        baseBars.at(i)->getPixelWidth(keyCoord, lowerPixelWidth, upperPixelWidth);
+        result -= qAbs(upperPixelWidth-lowerPixelWidth);
+        result -= getPixelSpacing(baseBars.at(i), keyCoord);
+      }
+      // finally half of our bars width:
+      baseBars.at(index)->getPixelWidth(keyCoord, lowerPixelWidth, upperPixelWidth);
+      result -= qAbs(upperPixelWidth-lowerPixelWidth)*0.5;
+    } else // bar is to the right of center
+    {
+      if (baseBars.size() % 2 == 0) // even number of bars
+      {
+        startIndex = baseBars.size()/2;
+        result += getPixelSpacing(baseBars.at(startIndex), keyCoord)*0.5; // half of middle spacing
+      } else // uneven number of bars
+      {
+        startIndex = (baseBars.size()-1)/2+1;
+        baseBars.at((baseBars.size()-1)/2)->getPixelWidth(keyCoord, lowerPixelWidth, upperPixelWidth);
+        result += qAbs(upperPixelWidth-lowerPixelWidth)*0.5; // half of center bar
+        result += getPixelSpacing(baseBars.at((baseBars.size()-1)/2), keyCoord); // center bar spacing
+      }
+      for (int i=startIndex; i<index; ++i) // add widths and spacings of bars in between center and our bars
+      {
+        baseBars.at(i)->getPixelWidth(keyCoord, lowerPixelWidth, upperPixelWidth);
+        result += qAbs(upperPixelWidth-lowerPixelWidth);
+        result += getPixelSpacing(baseBars.at(i), keyCoord);
+      }
+      // finally half of our bars width:
+      baseBars.at(index)->getPixelWidth(keyCoord, lowerPixelWidth, upperPixelWidth);
+      result += qAbs(upperPixelWidth-lowerPixelWidth)*0.5;
+    }
+  }
+  return result;
+}
+
+/*! \internal
+  
+  Returns the spacing in pixels which is between this \a bars and the following one, both at the
+  key coordinate \a keyCoord.
+  
+  \note Typically the returned value doesn't depend on \a bars or \a keyCoord. \a bars is only
+  needed to get acces to the key axis transformation and axis rect for the modes \ref
+  stAxisRectRatio and \ref stPlotCoords. The \a keyCoord is only relevant for spacings given in
+  \ref stPlotCoords on a logarithmic axis.
+*/
+double QCPBarsGroup::getPixelSpacing(const QCPBars *bars, double keyCoord)
+{
+  switch (mSpacingType)
+  {
+    case stAbsolute:
+    {
+      return mSpacing;
+    }
+    case stAxisRectRatio:
+    {
+      if (bars->keyAxis()->orientation() == Qt::Horizontal)
+        return bars->keyAxis()->axisRect()->width()*mSpacing;
+      else
+        return bars->keyAxis()->axisRect()->height()*mSpacing;
+    }
+    case stPlotCoords:
+    {
+      double keyPixel = bars->keyAxis()->coordToPixel(keyCoord);
+      return bars->keyAxis()->coordToPixel(keyCoord+mSpacing)-keyPixel;
+    }
+  }
+  return 0;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPBarData
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPBarData
+  \brief Holds the data of one single data point (one bar) for QCPBars.
+  
+  The container for storing multiple data points is \ref QCPBarDataMap.
+  
+  The stored data is:
+  \li \a key: coordinate on the key axis of this bar
+  \li \a value: height coordinate on the value axis of this bar
+  
+  \see QCPBarDataaMap
+*/
+
+/*!
+  Constructs a bar data point with key and value set to zero.
+*/
+QCPBarData::QCPBarData() :
+  key(0),
+  value(0)
+{
+}
+
+/*!
+  Constructs a bar data point with the specified \a key and \a value.
+*/
+QCPBarData::QCPBarData(double key, double value) :
+  key(key),
+  value(value)
+{
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPBars
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPBars
+  \brief A plottable representing a bar chart in a plot.
+
+  \image html QCPBars.png
+  
+  To plot data, assign it with the \ref setData or \ref addData functions.
+  
+  \section appearance Changing the appearance
+  
+  The appearance of the bars is determined by the pen and the brush (\ref setPen, \ref setBrush).
+  The width of the individual bars can be controlled with \ref setWidthType and \ref setWidth.
+  
+  Bar charts are stackable. This means, two QCPBars plottables can be placed on top of each other
+  (see \ref QCPBars::moveAbove). So when two bars are at the same key position, they will appear
+  stacked.
+  
+  If you would like to group multiple QCPBars plottables together so they appear side by side as
+  shown below, use QCPBarsGroup.
+  
+  \image html QCPBarsGroup.png
+  
+  \section usage Usage
+  
+  Like all data representing objects in QCustomPlot, the QCPBars is a plottable
+  (QCPAbstractPlottable). So the plottable-interface of QCustomPlot applies
+  (QCustomPlot::plottable, QCustomPlot::addPlottable, QCustomPlot::removePlottable, etc.)
+  
+  Usually, you first create an instance:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpbars-creation-1
+  add it to the customPlot with QCustomPlot::addPlottable:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpbars-creation-2
+  and then modify the properties of the newly created plottable, e.g.:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpbars-creation-3
+*/
+
+/* start of documentation of inline functions */
+
+/*! \fn QCPBars *QCPBars::barBelow() const
+  Returns the bars plottable that is directly below this bars plottable.
+  If there is no such plottable, returns 0.
+  
+  \see barAbove, moveBelow, moveAbove
+*/
+
+/*! \fn QCPBars *QCPBars::barAbove() const
+  Returns the bars plottable that is directly above this bars plottable.
+  If there is no such plottable, returns 0.
+  
+  \see barBelow, moveBelow, moveAbove
+*/
+
+/* end of documentation of inline functions */
+
+/*!
+  Constructs a bar chart which uses \a keyAxis as its key axis ("x") and \a valueAxis as its value
+  axis ("y"). \a keyAxis and \a valueAxis must reside in the same QCustomPlot instance and not have
+  the same orientation. If either of these restrictions is violated, a corresponding message is
+  printed to the debug output (qDebug), the construction is not aborted, though.
+  
+  The constructed QCPBars can be added to the plot with QCustomPlot::addPlottable, QCustomPlot
+  then takes ownership of the bar chart.
+*/
+QCPBars::QCPBars(QCPAxis *keyAxis, QCPAxis *valueAxis) :
+  QCPAbstractPlottable(keyAxis, valueAxis),
+  mData(new QCPBarDataMap),
+  mWidth(0.75),
+  mWidthType(wtPlotCoords),
+  mBarsGroup(0),
+  mBaseValue(0)
+{
+  // modify inherited properties from abstract plottable:
+  mPen.setColor(Qt::blue);
+  mPen.setStyle(Qt::SolidLine);
+  mBrush.setColor(QColor(40, 50, 255, 30));
+  mBrush.setStyle(Qt::SolidPattern);
+  mSelectedPen = mPen;
+  mSelectedPen.setWidthF(2.5);
+  mSelectedPen.setColor(QColor(80, 80, 255)); // lighter than Qt::blue of mPen
+  mSelectedBrush = mBrush;
+}
+
+QCPBars::~QCPBars()
+{
+  setBarsGroup(0);
+  if (mBarBelow || mBarAbove)
+    connectBars(mBarBelow.data(), mBarAbove.data()); // take this bar out of any stacking
+  delete mData;
+}
+
+/*!
+  Sets the width of the bars.
+
+  How the number passed as \a width is interpreted (e.g. screen pixels, plot coordinates,...),
+  depends on the currently set width type, see \ref setWidthType and \ref WidthType.
+*/
+void QCPBars::setWidth(double width)
+{
+  mWidth = width;
+}
+
+/*!
+  Sets how the width of the bars is defined. See the documentation of \ref WidthType for an
+  explanation of the possible values for \a widthType.
+  
+  The default value is \ref wtPlotCoords.
+  
+  \see setWidth
+*/
+void QCPBars::setWidthType(QCPBars::WidthType widthType)
+{
+  mWidthType = widthType;
+}
+
+/*!
+  Sets to which QCPBarsGroup this QCPBars instance belongs to. Alternatively, you can also use \ref
+  QCPBarsGroup::append.
+  
+  To remove this QCPBars from any group, set \a barsGroup to 0.
+*/
+void QCPBars::setBarsGroup(QCPBarsGroup *barsGroup)
+{
+  // deregister at old group:
+  if (mBarsGroup)
+    mBarsGroup->unregisterBars(this);
+  mBarsGroup = barsGroup;
+  // register at new group:
+  if (mBarsGroup)
+    mBarsGroup->registerBars(this);
+}
+
+/*!
+  Sets the base value of this bars plottable.
+
+  The base value defines where on the value coordinate the bars start. How far the bars extend from
+  the base value is given by their individual value data. For example, if the base value is set to
+  1, a bar with data value 2 will have its lowest point at value coordinate 1 and highest point at
+  3.
+  
+  For stacked bars, only the base value of the bottom-most QCPBars has meaning.
+  
+  The default base value is 0.
+*/
+void QCPBars::setBaseValue(double baseValue)
+{
+  mBaseValue = baseValue;
+}
+
+/*!
+  Replaces the current data with the provided \a data.
+  
+  If \a copy is set to true, data points in \a data will only be copied. if false, the plottable
+  takes ownership of the passed data and replaces the internal data pointer with it. This is
+  significantly faster than copying for large datasets.
+*/
+void QCPBars::setData(QCPBarDataMap *data, bool copy)
+{
+  if (mData == data)
+  {
+    qDebug() << Q_FUNC_INFO << "The data pointer is already in (and owned by) this plottable" << reinterpret_cast<quintptr>(data);
+    return;
+  }
+  if (copy)
+  {
+    *mData = *data;
+  } else
+  {
+    delete mData;
+    mData = data;
+  }
+}
+
+/*! \overload
+  
+  Replaces the current data with the provided points in \a key and \a value tuples. The
+  provided vectors should have equal length. Else, the number of added points will be the size of
+  the smallest vector.
+*/
+void QCPBars::setData(const QVector<double> &key, const QVector<double> &value)
+{
+  mData->clear();
+  int n = key.size();
+  n = qMin(n, value.size());
+  QCPBarData newData;
+  for (int i=0; i<n; ++i)
+  {
+    newData.key = key[i];
+    newData.value = value[i];
+    mData->insertMulti(newData.key, newData);
+  }
+}
+
+/*!
+  Moves this bars plottable below \a bars. In other words, the bars of this plottable will appear
+  below the bars of \a bars. The move target \a bars must use the same key and value axis as this
+  plottable.
+  
+  Inserting into and removing from existing bar stacking is handled gracefully. If \a bars already
+  has a bars object below itself, this bars object is inserted between the two. If this bars object
+  is already between two other bars, the two other bars will be stacked on top of each other after
+  the operation.
+  
+  To remove this bars plottable from any stacking, set \a bars to 0.
+  
+  \see moveBelow, barAbove, barBelow
+*/
+void QCPBars::moveBelow(QCPBars *bars)
+{
+  if (bars == this) return;
+  if (bars && (bars->keyAxis() != mKeyAxis.data() || bars->valueAxis() != mValueAxis.data()))
+  {
+    qDebug() << Q_FUNC_INFO << "passed QCPBars* doesn't have same key and value axis as this QCPBars";
+    return;
+  }
+  // remove from stacking:
+  connectBars(mBarBelow.data(), mBarAbove.data()); // Note: also works if one (or both) of them is 0
+  // if new bar given, insert this bar below it:
+  if (bars)
+  {
+    if (bars->mBarBelow)
+      connectBars(bars->mBarBelow.data(), this);
+    connectBars(this, bars);
+  }
+}
+
+/*!
+  Moves this bars plottable above \a bars. In other words, the bars of this plottable will appear
+  above the bars of \a bars. The move target \a bars must use the same key and value axis as this
+  plottable.
+  
+  Inserting into and removing from existing bar stacking is handled gracefully. If \a bars already
+  has a bars object above itself, this bars object is inserted between the two. If this bars object
+  is already between two other bars, the two other bars will be stacked on top of each other after
+  the operation.
+  
+  To remove this bars plottable from any stacking, set \a bars to 0.
+  
+  \see moveBelow, barBelow, barAbove
+*/
+void QCPBars::moveAbove(QCPBars *bars)
+{
+  if (bars == this) return;
+  if (bars && (bars->keyAxis() != mKeyAxis.data() || bars->valueAxis() != mValueAxis.data()))
+  {
+    qDebug() << Q_FUNC_INFO << "passed QCPBars* doesn't have same key and value axis as this QCPBars";
+    return;
+  }
+  // remove from stacking:
+  connectBars(mBarBelow.data(), mBarAbove.data()); // Note: also works if one (or both) of them is 0
+  // if new bar given, insert this bar above it:
+  if (bars)
+  {
+    if (bars->mBarAbove)
+      connectBars(this, bars->mBarAbove.data());
+    connectBars(bars, this);
+  }
+}
+
+/*!
+  Adds the provided data points in \a dataMap to the current data.
+  \see removeData
+*/
+void QCPBars::addData(const QCPBarDataMap &dataMap)
+{
+  mData->unite(dataMap);
+}
+
+/*! \overload
+  Adds the provided single data point in \a data to the current data.
+  \see removeData
+*/
+void QCPBars::addData(const QCPBarData &data)
+{
+  mData->insertMulti(data.key, data);
+}
+
+/*! \overload
+  Adds the provided single data point as \a key and \a value tuple to the current data
+  \see removeData
+*/
+void QCPBars::addData(double key, double value)
+{
+  QCPBarData newData;
+  newData.key = key;
+  newData.value = value;
+  mData->insertMulti(newData.key, newData);
+}
+
+/*! \overload
+  Adds the provided data points as \a key and \a value tuples to the current data.
+  \see removeData
+*/
+void QCPBars::addData(const QVector<double> &keys, const QVector<double> &values)
+{
+  int n = keys.size();
+  n = qMin(n, values.size());
+  QCPBarData newData;
+  for (int i=0; i<n; ++i)
+  {
+    newData.key = keys[i];
+    newData.value = values[i];
+    mData->insertMulti(newData.key, newData);
+  }
+}
+
+/*!
+  Removes all data points with key smaller than \a key.
+  \see addData, clearData
+*/
+void QCPBars::removeDataBefore(double key)
+{
+  QCPBarDataMap::iterator it = mData->begin();
+  while (it != mData->end() && it.key() < key)
+    it = mData->erase(it);
+}
+
+/*!
+  Removes all data points with key greater than \a key.
+  \see addData, clearData
+*/
+void QCPBars::removeDataAfter(double key)
+{
+  if (mData->isEmpty()) return;
+  QCPBarDataMap::iterator it = mData->upperBound(key);
+  while (it != mData->end())
+    it = mData->erase(it);
+}
+
+/*!
+  Removes all data points with key between \a fromKey and \a toKey. if \a fromKey is
+  greater or equal to \a toKey, the function does nothing. To remove a single data point with known
+  key, use \ref removeData(double key).
+  
+  \see addData, clearData
+*/
+void QCPBars::removeData(double fromKey, double toKey)
+{
+  if (fromKey >= toKey || mData->isEmpty()) return;
+  QCPBarDataMap::iterator it = mData->upperBound(fromKey);
+  QCPBarDataMap::iterator itEnd = mData->upperBound(toKey);
+  while (it != itEnd)
+    it = mData->erase(it);
+}
+
+/*! \overload
+  
+  Removes a single data point at \a key. If the position is not known with absolute precision,
+  consider using \ref removeData(double fromKey, double toKey) with a small fuzziness interval
+  around the suspected position, depeding on the precision with which the key is known.
+  
+  \see addData, clearData
+*/
+void QCPBars::removeData(double key)
+{
+  mData->remove(key);
+}
+
+/*!
+  Removes all data points.
+  \see removeData, removeDataAfter, removeDataBefore
+*/
+void QCPBars::clearData()
+{
+  mData->clear();
+}
+
+/* inherits documentation from base class */
+double QCPBars::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  if (onlySelectable && !mSelectable)
+    return -1;
+  if (!mKeyAxis || !mValueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return -1; }
+  
+  if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))
+  {
+    QCPBarDataMap::ConstIterator it;
+    for (it = mData->constBegin(); it != mData->constEnd(); ++it)
+    {
+      if (getBarPolygon(it.value().key, it.value().value).boundingRect().contains(pos))
+        return mParentPlot->selectionTolerance()*0.99;
+    }
+  }
+  return -1;
+}
+
+/* inherits documentation from base class */
+void QCPBars::draw(QCPPainter *painter)
+{
+  if (!mKeyAxis || !mValueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
+  if (mData->isEmpty()) return;
+  
+  QCPBarDataMap::const_iterator it, lower, upperEnd;
+  getVisibleDataBounds(lower, upperEnd);
+  for (it = lower; it != upperEnd; ++it)
+  {
+    // check data validity if flag set:
+#ifdef QCUSTOMPLOT_CHECK_DATA
+    if (QCP::isInvalidData(it.value().key, it.value().value))
+      qDebug() << Q_FUNC_INFO << "Data point at" << it.key() << "of drawn range invalid." << "Plottable name:" << name();
+#endif
+    QPolygonF barPolygon = getBarPolygon(it.key(), it.value().value);
+    // draw bar fill:
+    if (mainBrush().style() != Qt::NoBrush && mainBrush().color().alpha() != 0)
+    {
+      applyFillAntialiasingHint(painter);
+      painter->setPen(Qt::NoPen);
+      painter->setBrush(mainBrush());
+      painter->drawPolygon(barPolygon);
+    }
+    // draw bar line:
+    if (mainPen().style() != Qt::NoPen && mainPen().color().alpha() != 0)
+    {
+      applyDefaultAntialiasingHint(painter);
+      painter->setPen(mainPen());
+      painter->setBrush(Qt::NoBrush);
+      painter->drawPolyline(barPolygon);
+    }
+  }
+}
+
+/* inherits documentation from base class */
+void QCPBars::drawLegendIcon(QCPPainter *painter, const QRectF &rect) const
+{
+  // draw filled rect:
+  applyDefaultAntialiasingHint(painter);
+  painter->setBrush(mBrush);
+  painter->setPen(mPen);
+  QRectF r = QRectF(0, 0, rect.width()*0.67, rect.height()*0.67);
+  r.moveCenter(rect.center());
+  painter->drawRect(r);
+}
+
+/*!  \internal
+  
+  called by \ref draw to determine which data (key) range is visible at the current key axis range
+  setting, so only that needs to be processed. It also takes into account the bar width.
+  
+  \a lower returns an iterator to the lowest data point that needs to be taken into account when
+  plotting. Note that in order to get a clean plot all the way to the edge of the axis rect, \a
+  lower may still be just outside the visible range.
+  
+  \a upperEnd returns an iterator one higher than the highest visible data point. Same as before, \a
+  upperEnd may also lie just outside of the visible range.
+  
+  if the bars plottable contains no data, both \a lower and \a upperEnd point to constEnd.
+*/
+void QCPBars::getVisibleDataBounds(QCPBarDataMap::const_iterator &lower, QCPBarDataMap::const_iterator &upperEnd) const
+{
+  if (!mKeyAxis) { qDebug() << Q_FUNC_INFO << "invalid key axis"; return; }
+  if (mData->isEmpty())
+  {
+    lower = mData->constEnd();
+    upperEnd = mData->constEnd();
+    return;
+  }
+  
+  // get visible data range as QMap iterators
+  lower = mData->lowerBound(mKeyAxis.data()->range().lower);
+  upperEnd = mData->upperBound(mKeyAxis.data()->range().upper);
+  double lowerPixelBound = mKeyAxis.data()->coordToPixel(mKeyAxis.data()->range().lower);
+  double upperPixelBound = mKeyAxis.data()->coordToPixel(mKeyAxis.data()->range().upper);
+  bool isVisible = false;
+  // walk left from lbound to find lower bar that actually is completely outside visible pixel range:
+  QCPBarDataMap::const_iterator it = lower;
+  while (it != mData->constBegin())
+  {
+    --it;
+    QRectF barBounds = getBarPolygon(it.value().key, it.value().value).boundingRect();
+    if (mKeyAxis.data()->orientation() == Qt::Horizontal)
+      isVisible = ((!mKeyAxis.data()->rangeReversed() && barBounds.right() >= lowerPixelBound) || (mKeyAxis.data()->rangeReversed() && barBounds.left() <= lowerPixelBound));
+    else // keyaxis is vertical
+      isVisible = ((!mKeyAxis.data()->rangeReversed() && barBounds.top() <= lowerPixelBound) || (mKeyAxis.data()->rangeReversed() && barBounds.bottom() >= lowerPixelBound));
+    if (isVisible)
+      lower = it;
+    else
+      break;
+  }
+  // walk right from ubound to find upper bar that actually is completely outside visible pixel range:
+  it = upperEnd;
+  while (it != mData->constEnd())
+  {
+    QRectF barBounds = getBarPolygon(upperEnd.value().key, upperEnd.value().value).boundingRect();
+    if (mKeyAxis.data()->orientation() == Qt::Horizontal)
+      isVisible = ((!mKeyAxis.data()->rangeReversed() && barBounds.left() <= upperPixelBound) || (mKeyAxis.data()->rangeReversed() && barBounds.right() >= upperPixelBound));
+    else // keyaxis is vertical
+      isVisible = ((!mKeyAxis.data()->rangeReversed() && barBounds.bottom() >= upperPixelBound) || (mKeyAxis.data()->rangeReversed() && barBounds.top() <= upperPixelBound));
+    if (isVisible)
+      upperEnd = it+1;
+    else
+      break;
+    ++it;
+  }
+}
+
+/*! \internal
+  
+  Returns the polygon of a single bar with \a key and \a value. The Polygon is open at the bottom
+  and shifted according to the bar stacking (see \ref moveAbove) and base value (see \ref
+  setBaseValue).
+*/
+QPolygonF QCPBars::getBarPolygon(double key, double value) const
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPolygonF(); }
+  
+  QPolygonF result;
+  double lowerPixelWidth, upperPixelWidth;
+  getPixelWidth(key, lowerPixelWidth, upperPixelWidth);
+  double base = getStackedBaseValue(key, value >= 0);
+  double basePixel = valueAxis->coordToPixel(base);
+  double valuePixel = valueAxis->coordToPixel(base+value);
+  double keyPixel = keyAxis->coordToPixel(key);
+  if (mBarsGroup)
+    keyPixel += mBarsGroup->keyPixelOffset(this, key);
+  if (keyAxis->orientation() == Qt::Horizontal)
+  {
+    result << QPointF(keyPixel+lowerPixelWidth, basePixel);
+    result << QPointF(keyPixel+lowerPixelWidth, valuePixel);
+    result << QPointF(keyPixel+upperPixelWidth, valuePixel);
+    result << QPointF(keyPixel+upperPixelWidth, basePixel);
+  } else
+  {
+    result << QPointF(basePixel, keyPixel+lowerPixelWidth);
+    result << QPointF(valuePixel, keyPixel+lowerPixelWidth);
+    result << QPointF(valuePixel, keyPixel+upperPixelWidth);
+    result << QPointF(basePixel, keyPixel+upperPixelWidth);
+  }
+  return result;
+}
+
+/*! \internal
+  
+  This function is used to determine the width of the bar at coordinate \a key, according to the
+  specified width (\ref setWidth) and width type (\ref setWidthType).
+  
+  The output parameters \a lower and \a upper return the number of pixels the bar extends to lower
+  and higher keys, relative to the \a key coordinate (so with a non-reversed horizontal axis, \a
+  lower is negative and \a upper positive).
+*/
+void QCPBars::getPixelWidth(double key, double &lower, double &upper) const
+{
+  switch (mWidthType)
+  {
+    case wtAbsolute:
+    {
+      upper = mWidth*0.5;
+      lower = -upper;
+      if (mKeyAxis && (mKeyAxis.data()->rangeReversed() ^ (mKeyAxis.data()->orientation() == Qt::Vertical)))
+        qSwap(lower, upper);
+      break;
+    }
+    case wtAxisRectRatio:
+    {
+      if (mKeyAxis && mKeyAxis.data()->axisRect())
+      {
+        if (mKeyAxis.data()->orientation() == Qt::Horizontal)
+          upper = mKeyAxis.data()->axisRect()->width()*mWidth*0.5;
+        else
+          upper = mKeyAxis.data()->axisRect()->height()*mWidth*0.5;
+        lower = -upper;
+        if (mKeyAxis && (mKeyAxis.data()->rangeReversed() ^ (mKeyAxis.data()->orientation() == Qt::Vertical)))
+          qSwap(lower, upper);
+      } else
+        qDebug() << Q_FUNC_INFO << "No key axis or axis rect defined";
+      break;
+    }
+    case wtPlotCoords:
+    {
+      if (mKeyAxis)
+      {
+        double keyPixel = mKeyAxis.data()->coordToPixel(key);
+        upper = mKeyAxis.data()->coordToPixel(key+mWidth*0.5)-keyPixel;
+        lower = mKeyAxis.data()->coordToPixel(key-mWidth*0.5)-keyPixel;
+        // no need to qSwap(lower, higher) when range reversed, because higher/lower are gained by
+        // coordinate transform which includes range direction
+      } else
+        qDebug() << Q_FUNC_INFO << "No key axis defined";
+      break;
+    }
+  }
+}
+
+/*! \internal
+  
+  This function is called to find at which value to start drawing the base of a bar at \a key, when
+  it is stacked on top of another QCPBars (e.g. with \ref moveAbove).
+  
+  positive and negative bars are separated per stack (positive are stacked above baseValue upwards,
+  negative are stacked below baseValue downwards). This can be indicated with \a positive. So if the
+  bar for which we need the base value is negative, set \a positive to false.
+*/
+double QCPBars::getStackedBaseValue(double key, bool positive) const
+{
+  if (mBarBelow)
+  {
+    double max = 0; // don't use mBaseValue here because only base value of bottom-most bar has meaning in a bar stack
+    // find bars of mBarBelow that are approximately at key and find largest one:
+    double epsilon = qAbs(key)*1e-6; // should be safe even when changed to use float at some point
+    if (key == 0)
+      epsilon = 1e-6;
+    QCPBarDataMap::const_iterator it = mBarBelow.data()->mData->lowerBound(key-epsilon);
+    QCPBarDataMap::const_iterator itEnd = mBarBelow.data()->mData->upperBound(key+epsilon);
+    while (it != itEnd)
+    {
+      if ((positive && it.value().value > max) ||
+          (!positive && it.value().value < max))
+        max = it.value().value;
+      ++it;
+    }
+    // recurse down the bar-stack to find the total height:
+    return max + mBarBelow.data()->getStackedBaseValue(key, positive);
+  } else
+    return mBaseValue;
+}
+
+/*! \internal
+
+  Connects \a below and \a above to each other via their mBarAbove/mBarBelow properties. The bar(s)
+  currently above lower and below upper will become disconnected to lower/upper.
+  
+  If lower is zero, upper will be disconnected at the bottom.
+  If upper is zero, lower will be disconnected at the top.
+*/
+void QCPBars::connectBars(QCPBars *lower, QCPBars *upper)
+{
+  if (!lower && !upper) return;
+  
+  if (!lower) // disconnect upper at bottom
+  {
+    // disconnect old bar below upper:
+    if (upper->mBarBelow && upper->mBarBelow.data()->mBarAbove.data() == upper)
+      upper->mBarBelow.data()->mBarAbove = 0;
+    upper->mBarBelow = 0;
+  } else if (!upper) // disconnect lower at top
+  {
+    // disconnect old bar above lower:
+    if (lower->mBarAbove && lower->mBarAbove.data()->mBarBelow.data() == lower)
+      lower->mBarAbove.data()->mBarBelow = 0;
+    lower->mBarAbove = 0;
+  } else // connect lower and upper
+  {
+    // disconnect old bar above lower:
+    if (lower->mBarAbove && lower->mBarAbove.data()->mBarBelow.data() == lower)
+      lower->mBarAbove.data()->mBarBelow = 0;
+    // disconnect old bar below upper:
+    if (upper->mBarBelow && upper->mBarBelow.data()->mBarAbove.data() == upper)
+      upper->mBarBelow.data()->mBarAbove = 0;
+    lower->mBarAbove = upper;
+    upper->mBarBelow = lower;
+  }
+}
+
+/* inherits documentation from base class */
+QCPRange QCPBars::getKeyRange(bool &foundRange, SignDomain inSignDomain) const
+{
+  QCPRange range;
+  bool haveLower = false;
+  bool haveUpper = false;
+  
+  double current;
+  QCPBarDataMap::const_iterator it = mData->constBegin();
+  while (it != mData->constEnd())
+  {
+    current = it.value().key;
+    if (inSignDomain == sdBoth || (inSignDomain == sdNegative && current < 0) || (inSignDomain == sdPositive && current > 0))
+    {
+      if (current < range.lower || !haveLower)
+      {
+        range.lower = current;
+        haveLower = true;
+      }
+      if (current > range.upper || !haveUpper)
+      {
+        range.upper = current;
+        haveUpper = true;
+      }
+    }
+    ++it;
+  }
+  // determine exact range of bars by including bar width and barsgroup offset:
+  if (haveLower && mKeyAxis)
+  {
+    double lowerPixelWidth, upperPixelWidth, keyPixel;
+    getPixelWidth(range.lower, lowerPixelWidth, upperPixelWidth);
+    keyPixel = mKeyAxis.data()->coordToPixel(range.lower) + lowerPixelWidth;
+    if (mBarsGroup)
+      keyPixel += mBarsGroup->keyPixelOffset(this, range.lower);
+    range.lower = mKeyAxis.data()->pixelToCoord(keyPixel);
+  }
+  if (haveUpper && mKeyAxis)
+  {
+    double lowerPixelWidth, upperPixelWidth, keyPixel;
+    getPixelWidth(range.upper, lowerPixelWidth, upperPixelWidth);
+    keyPixel = mKeyAxis.data()->coordToPixel(range.upper) + upperPixelWidth;
+    if (mBarsGroup)
+      keyPixel += mBarsGroup->keyPixelOffset(this, range.upper);
+    range.upper = mKeyAxis.data()->pixelToCoord(keyPixel);
+  }
+  foundRange = haveLower && haveUpper;
+  return range;
+}
+
+/* inherits documentation from base class */
+QCPRange QCPBars::getValueRange(bool &foundRange, SignDomain inSignDomain) const
+{
+  QCPRange range;
+  range.lower = mBaseValue;
+  range.upper = mBaseValue;
+  bool haveLower = true; // set to true, because baseValue should always be visible in bar charts
+  bool haveUpper = true; // set to true, because baseValue should always be visible in bar charts
+  double current;
+  
+  QCPBarDataMap::const_iterator it = mData->constBegin();
+  while (it != mData->constEnd())
+  {
+    current = it.value().value + getStackedBaseValue(it.value().key, it.value().value >= 0);
+    if (inSignDomain == sdBoth || (inSignDomain == sdNegative && current < 0) || (inSignDomain == sdPositive && current > 0))
+    {
+      if (current < range.lower || !haveLower)
+      {
+        range.lower = current;
+        haveLower = true;
+      }
+      if (current > range.upper || !haveUpper)
+      {
+        range.upper = current;
+        haveUpper = true;
+      }
+    }
+    ++it;
+  }
+  
+  foundRange = true; // return true because bar charts always have the 0-line visible
+  return range;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPStatisticalBox
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPStatisticalBox
+  \brief A plottable representing a single statistical box in a plot.
+
+  \image html QCPStatisticalBox.png
+  
+  To plot data, assign it with the individual parameter functions or use \ref setData to set all
+  parameters at once. The individual functions are:
+  \li \ref setMinimum
+  \li \ref setLowerQuartile
+  \li \ref setMedian
+  \li \ref setUpperQuartile
+  \li \ref setMaximum
+  
+  Additionally you can define a list of outliers, drawn as scatter datapoints:
+  \li \ref setOutliers
+  
+  \section appearance Changing the appearance
+  
+  The appearance of the box itself is controlled via \ref setPen and \ref setBrush. You may change
+  the width of the box with \ref setWidth in plot coordinates (not pixels).
+
+  Analog functions exist for the minimum/maximum-whiskers: \ref setWhiskerPen, \ref
+  setWhiskerBarPen, \ref setWhiskerWidth. The whisker width is the width of the bar at the top
+  (maximum) and bottom (minimum).
+  
+  The median indicator line has its own pen, \ref setMedianPen.
+  
+  If the whisker backbone pen is changed, make sure to set the capStyle to Qt::FlatCap. Else, the
+  backbone line might exceed the whisker bars by a few pixels due to the pen cap being not
+  perfectly flat.
+  
+  The Outlier data points are drawn as normal scatter points. Their look can be controlled with
+  \ref setOutlierStyle
+  
+  \section usage Usage
+  
+  Like all data representing objects in QCustomPlot, the QCPStatisticalBox is a plottable.
+  Usually, you first create an instance and add it to the customPlot:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpstatisticalbox-creation-1
+  and then modify the properties of the newly created plottable, e.g.:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpstatisticalbox-creation-2
+*/
+
+/*!
+  Constructs a statistical box which uses \a keyAxis as its key axis ("x") and \a valueAxis as its
+  value axis ("y"). \a keyAxis and \a valueAxis must reside in the same QCustomPlot instance and
+  not have the same orientation. If either of these restrictions is violated, a corresponding
+  message is printed to the debug output (qDebug), the construction is not aborted, though.
+  
+  The constructed statistical box can be added to the plot with QCustomPlot::addPlottable,
+  QCustomPlot then takes ownership of the statistical box.
+*/
+QCPStatisticalBox::QCPStatisticalBox(QCPAxis *keyAxis, QCPAxis *valueAxis) :
+  QCPAbstractPlottable(keyAxis, valueAxis),
+  mKey(0),
+  mMinimum(0),
+  mLowerQuartile(0),
+  mMedian(0),
+  mUpperQuartile(0),
+  mMaximum(0)
+{
+  setOutlierStyle(QCPScatterStyle(QCPScatterStyle::ssCircle, Qt::blue, 6));
+  setWhiskerWidth(0.2);
+  setWidth(0.5);
+  
+  setPen(QPen(Qt::black));
+  setSelectedPen(QPen(Qt::blue, 2.5));
+  setMedianPen(QPen(Qt::black, 3, Qt::SolidLine, Qt::FlatCap));
+  setWhiskerPen(QPen(Qt::black, 0, Qt::DashLine, Qt::FlatCap));
+  setWhiskerBarPen(QPen(Qt::black));
+  setBrush(Qt::NoBrush);
+  setSelectedBrush(Qt::NoBrush);
+}
+
+/*!
+  Sets the key coordinate of the statistical box.
+*/
+void QCPStatisticalBox::setKey(double key)
+{
+  mKey = key;
+}
+
+/*!
+  Sets the parameter "minimum" of the statistical box plot. This is the position of the lower
+  whisker, typically the minimum measurement of the sample that's not considered an outlier.
+  
+  \see setMaximum, setWhiskerPen, setWhiskerBarPen, setWhiskerWidth
+*/
+void QCPStatisticalBox::setMinimum(double value)
+{
+  mMinimum = value;
+}
+
+/*!
+  Sets the parameter "lower Quartile" of the statistical box plot. This is the lower end of the
+  box. The lower and the upper quartiles are the two statistical quartiles around the median of the
+  sample, they contain 50% of the sample data.
+  
+  \see setUpperQuartile, setPen, setBrush, setWidth
+*/
+void QCPStatisticalBox::setLowerQuartile(double value)
+{
+  mLowerQuartile = value;
+}
+
+/*!
+  Sets the parameter "median" of the statistical box plot. This is the value of the median mark
+  inside the quartile box. The median separates the sample data in half (50% of the sample data is
+  below/above the median).
+  
+  \see setMedianPen
+*/
+void QCPStatisticalBox::setMedian(double value)
+{
+  mMedian = value;
+}
+
+/*!
+  Sets the parameter "upper Quartile" of the statistical box plot. This is the upper end of the
+  box. The lower and the upper quartiles are the two statistical quartiles around the median of the
+  sample, they contain 50% of the sample data.
+  
+  \see setLowerQuartile, setPen, setBrush, setWidth
+*/
+void QCPStatisticalBox::setUpperQuartile(double value)
+{
+  mUpperQuartile = value;
+}
+
+/*!
+  Sets the parameter "maximum" of the statistical box plot. This is the position of the upper
+  whisker, typically the maximum measurement of the sample that's not considered an outlier.
+  
+  \see setMinimum, setWhiskerPen, setWhiskerBarPen, setWhiskerWidth
+*/
+void QCPStatisticalBox::setMaximum(double value)
+{
+  mMaximum = value;
+}
+
+/*!
+  Sets a vector of outlier values that will be drawn as scatters. Any data points in the sample
+  that are not within the whiskers (\ref setMinimum, \ref setMaximum) should be considered outliers
+  and displayed as such.
+  
+  \see setOutlierStyle
+*/
+void QCPStatisticalBox::setOutliers(const QVector<double> &values)
+{
+  mOutliers = values;
+}
+
+/*!
+  Sets all parameters of the statistical box plot at once.
+  
+  \see setKey, setMinimum, setLowerQuartile, setMedian, setUpperQuartile, setMaximum
+*/
+void QCPStatisticalBox::setData(double key, double minimum, double lowerQuartile, double median, double upperQuartile, double maximum)
+{
+  setKey(key);
+  setMinimum(minimum);
+  setLowerQuartile(lowerQuartile);
+  setMedian(median);
+  setUpperQuartile(upperQuartile);
+  setMaximum(maximum);
+}
+
+/*!
+  Sets the width of the box in key coordinates.
+  
+  \see setWhiskerWidth
+*/
+void QCPStatisticalBox::setWidth(double width)
+{
+  mWidth = width;
+}
+
+/*!
+  Sets the width of the whiskers (\ref setMinimum, \ref setMaximum) in key coordinates.
+  
+  \see setWidth
+*/
+void QCPStatisticalBox::setWhiskerWidth(double width)
+{
+  mWhiskerWidth = width;
+}
+
+/*!
+  Sets the pen used for drawing the whisker backbone (That's the line parallel to the value axis).
+  
+  Make sure to set the \a pen capStyle to Qt::FlatCap to prevent the whisker backbone from reaching
+  a few pixels past the whisker bars, when using a non-zero pen width.
+  
+  \see setWhiskerBarPen
+*/
+void QCPStatisticalBox::setWhiskerPen(const QPen &pen)
+{
+  mWhiskerPen = pen;
+}
+
+/*!
+  Sets the pen used for drawing the whisker bars (Those are the lines parallel to the key axis at
+  each end of the whisker backbone).
+  
+  \see setWhiskerPen
+*/
+void QCPStatisticalBox::setWhiskerBarPen(const QPen &pen)
+{
+  mWhiskerBarPen = pen;
+}
+
+/*!
+  Sets the pen used for drawing the median indicator line inside the statistical box.
+*/
+void QCPStatisticalBox::setMedianPen(const QPen &pen)
+{
+  mMedianPen = pen;
+}
+
+/*!
+  Sets the appearance of the outlier data points.
+  
+  \see setOutliers
+*/
+void QCPStatisticalBox::setOutlierStyle(const QCPScatterStyle &style)
+{
+  mOutlierStyle = style;
+}
+
+/* inherits documentation from base class */
+void QCPStatisticalBox::clearData()
+{
+  setOutliers(QVector<double>());
+  setKey(0);
+  setMinimum(0);
+  setLowerQuartile(0);
+  setMedian(0);
+  setUpperQuartile(0);
+  setMaximum(0);
+}
+
+/* inherits documentation from base class */
+double QCPStatisticalBox::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  if (onlySelectable && !mSelectable)
+    return -1;
+  if (!mKeyAxis || !mValueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return -1; }
+  
+  if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))
+  {
+    double posKey, posValue;
+    pixelsToCoords(pos, posKey, posValue);
+    // quartile box:
+    QCPRange keyRange(mKey-mWidth*0.5, mKey+mWidth*0.5);
+    QCPRange valueRange(mLowerQuartile, mUpperQuartile);
+    if (keyRange.contains(posKey) && valueRange.contains(posValue))
+      return mParentPlot->selectionTolerance()*0.99;
+    
+    // min/max whiskers:
+    if (QCPRange(mMinimum, mMaximum).contains(posValue))
+      return qAbs(mKeyAxis.data()->coordToPixel(mKey)-mKeyAxis.data()->coordToPixel(posKey));
+  }
+  return -1;
+}
+
+/* inherits documentation from base class */
+void QCPStatisticalBox::draw(QCPPainter *painter)
+{
+  if (!mKeyAxis || !mValueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
+
+  // check data validity if flag set:
+#ifdef QCUSTOMPLOT_CHECK_DATA
+  if (QCP::isInvalidData(mKey, mMedian) ||
+      QCP::isInvalidData(mLowerQuartile, mUpperQuartile) ||
+      QCP::isInvalidData(mMinimum, mMaximum))
+    qDebug() << Q_FUNC_INFO << "Data point at" << mKey << "of drawn range has invalid data." << "Plottable name:" << name();
+  for (int i=0; i<mOutliers.size(); ++i)
+    if (QCP::isInvalidData(mOutliers.at(i)))
+      qDebug() << Q_FUNC_INFO << "Data point outlier at" << mKey << "of drawn range invalid." << "Plottable name:" << name();
+#endif
+  
+  QRectF quartileBox;
+  drawQuartileBox(painter, &quartileBox);
+  
+  painter->save();
+  painter->setClipRect(quartileBox, Qt::IntersectClip);
+  drawMedian(painter);
+  painter->restore();
+  
+  drawWhiskers(painter);
+  drawOutliers(painter);
+}
+
+/* inherits documentation from base class */
+void QCPStatisticalBox::drawLegendIcon(QCPPainter *painter, const QRectF &rect) const
+{
+  // draw filled rect:
+  applyDefaultAntialiasingHint(painter);
+  painter->setPen(mPen);
+  painter->setBrush(mBrush);
+  QRectF r = QRectF(0, 0, rect.width()*0.67, rect.height()*0.67);
+  r.moveCenter(rect.center());
+  painter->drawRect(r);
+}
+
+/*! \internal
+  
+  Draws the quartile box. \a box is an output parameter that returns the quartile box (in pixel
+  coordinates) which is used to set the clip rect of the painter before calling \ref drawMedian (so
+  the median doesn't draw outside the quartile box).
+*/
+void QCPStatisticalBox::drawQuartileBox(QCPPainter *painter, QRectF *quartileBox) const
+{
+  QRectF box;
+  box.setTopLeft(coordsToPixels(mKey-mWidth*0.5, mUpperQuartile));
+  box.setBottomRight(coordsToPixels(mKey+mWidth*0.5, mLowerQuartile));
+  applyDefaultAntialiasingHint(painter);
+  painter->setPen(mainPen());
+  painter->setBrush(mainBrush());
+  painter->drawRect(box);
+  if (quartileBox)
+    *quartileBox = box;
+}
+
+/*! \internal
+  
+  Draws the median line inside the quartile box.
+*/
+void QCPStatisticalBox::drawMedian(QCPPainter *painter) const
+{
+  QLineF medianLine;
+  medianLine.setP1(coordsToPixels(mKey-mWidth*0.5, mMedian));
+  medianLine.setP2(coordsToPixels(mKey+mWidth*0.5, mMedian));
+  applyDefaultAntialiasingHint(painter);
+  painter->setPen(mMedianPen);
+  painter->drawLine(medianLine);
+}
+
+/*! \internal
+  
+  Draws both whisker backbones and bars.
+*/
+void QCPStatisticalBox::drawWhiskers(QCPPainter *painter) const
+{
+  QLineF backboneMin, backboneMax, barMin, barMax;
+  backboneMax.setPoints(coordsToPixels(mKey, mUpperQuartile), coordsToPixels(mKey, mMaximum));
+  backboneMin.setPoints(coordsToPixels(mKey, mLowerQuartile), coordsToPixels(mKey, mMinimum));
+  barMax.setPoints(coordsToPixels(mKey-mWhiskerWidth*0.5, mMaximum), coordsToPixels(mKey+mWhiskerWidth*0.5, mMaximum));
+  barMin.setPoints(coordsToPixels(mKey-mWhiskerWidth*0.5, mMinimum), coordsToPixels(mKey+mWhiskerWidth*0.5, mMinimum));
+  applyErrorBarsAntialiasingHint(painter);
+  painter->setPen(mWhiskerPen);
+  painter->drawLine(backboneMin);
+  painter->drawLine(backboneMax);
+  painter->setPen(mWhiskerBarPen);
+  painter->drawLine(barMin);
+  painter->drawLine(barMax);
+}
+
+/*! \internal
+  
+  Draws the outlier scatter points.
+*/
+void QCPStatisticalBox::drawOutliers(QCPPainter *painter) const
+{
+  applyScattersAntialiasingHint(painter);
+  mOutlierStyle.applyTo(painter, mPen);
+  for (int i=0; i<mOutliers.size(); ++i)
+    mOutlierStyle.drawShape(painter, coordsToPixels(mKey, mOutliers.at(i)));
+}
+
+/* inherits documentation from base class */
+QCPRange QCPStatisticalBox::getKeyRange(bool &foundRange, SignDomain inSignDomain) const
+{
+  foundRange = true;
+  if (inSignDomain == sdBoth)
+  {
+    return QCPRange(mKey-mWidth*0.5, mKey+mWidth*0.5);
+  } else if (inSignDomain == sdNegative)
+  {
+    if (mKey+mWidth*0.5 < 0)
+      return QCPRange(mKey-mWidth*0.5, mKey+mWidth*0.5);
+    else if (mKey < 0)
+      return QCPRange(mKey-mWidth*0.5, mKey);
+    else
+    {
+      foundRange = false;
+      return QCPRange();
+    }
+  } else if (inSignDomain == sdPositive)
+  {
+    if (mKey-mWidth*0.5 > 0)
+      return QCPRange(mKey-mWidth*0.5, mKey+mWidth*0.5);
+    else if (mKey > 0)
+      return QCPRange(mKey, mKey+mWidth*0.5);
+    else
+    {
+      foundRange = false;
+      return QCPRange();
+    }
+  }
+  foundRange = false;
+  return QCPRange();
+}
+
+/* inherits documentation from base class */
+QCPRange QCPStatisticalBox::getValueRange(bool &foundRange, SignDomain inSignDomain) const
+{
+  QVector<double> values; // values that must be considered (i.e. all outliers and the five box-parameters)
+  values.reserve(mOutliers.size() + 5);
+  values << mMaximum << mUpperQuartile << mMedian << mLowerQuartile << mMinimum;
+  values << mOutliers;
+  // go through values and find the ones in legal range:
+  bool haveUpper = false;
+  bool haveLower = false;
+  double upper = 0;
+  double lower = 0;
+  for (int i=0; i<values.size(); ++i)
+  {
+    if ((inSignDomain == sdNegative && values.at(i) < 0) ||
+        (inSignDomain == sdPositive && values.at(i) > 0) ||
+        (inSignDomain == sdBoth))
+    {
+      if (values.at(i) > upper || !haveUpper)
+      {
+        upper = values.at(i);
+        haveUpper = true;
+      }
+      if (values.at(i) < lower || !haveLower)
+      {
+        lower = values.at(i);
+        haveLower = true;
+      }
+    }
+  }
+  // return the bounds if we found some sensible values:
+  if (haveLower && haveUpper)
+  {
+    foundRange = true;
+    return QCPRange(lower, upper);
+  } else // might happen if all values are in other sign domain
+  {
+    foundRange = false;
+    return QCPRange();
+  }
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPColorMapData
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPColorMapData
+  \brief Holds the two-dimensional data of a QCPColorMap plottable.
+  
+  This class is a data storage for \ref QCPColorMap. It holds a two-dimensional array, which \ref
+  QCPColorMap then displays as a 2D image in the plot, where the array values are represented by a
+  color, depending on the value.
+  
+  The size of the array can be controlled via \ref setSize (or \ref setKeySize, \ref setValueSize).
+  Which plot coordinates these cells correspond to can be configured with \ref setRange (or \ref
+  setKeyRange, \ref setValueRange).
+  
+  The data cells can be accessed in two ways: They can be directly addressed by an integer index
+  with \ref setCell. This is the fastest method. Alternatively, they can be addressed by their plot
+  coordinate with \ref setData. plot coordinate to cell index transformations and vice versa are
+  provided by the functions \ref coordToCell and \ref cellToCoord.
+  
+  This class also buffers the minimum and maximum values that are in the data set, to provide
+  QCPColorMap::rescaleDataRange with the necessary information quickly. Setting a cell to a value
+  that is greater than the current maximum increases this maximum to the new value. However,
+  setting the cell that currently holds the maximum value to a smaller value doesn't decrease the
+  maximum again, because finding the true new maximum would require going through the entire data
+  array, which might be time consuming. The same holds for the data minimum. This functionality is
+  given by \ref recalculateDataBounds, such that you can decide when it is sensible to find the
+  true current minimum and maximum. The method QCPColorMap::rescaleDataRange offers a convenience
+  parameter \a recalculateDataBounds which may be set to true to automatically call \ref
+  recalculateDataBounds internally.
+*/
+
+/* start of documentation of inline functions */
+
+/*! \fn bool QCPColorMapData::isEmpty() const
+  
+  Returns whether this instance carries no data. This is equivalent to having a size where at least
+  one of the dimensions is 0 (see \ref setSize).
+*/
+
+/* end of documentation of inline functions */
+
+/*!
+  Constructs a new QCPColorMapData instance. The instance has \a keySize cells in the key direction
+  and \a valueSize cells in the value direction. These cells will be displayed by the \ref QCPColorMap
+  at the coordinates \a keyRange and \a valueRange.
+  
+  \see setSize, setKeySize, setValueSize, setRange, setKeyRange, setValueRange
+*/
+QCPColorMapData::QCPColorMapData(int keySize, int valueSize, const QCPRange &keyRange, const QCPRange &valueRange) :
+  mKeySize(0),
+  mValueSize(0),
+  mKeyRange(keyRange),
+  mValueRange(valueRange),
+  mIsEmpty(true),
+  mData(0),
+  mDataModified(true)
+{
+  setSize(keySize, valueSize);
+  fill(0);
+}
+
+QCPColorMapData::~QCPColorMapData()
+{
+  if (mData)
+    delete[] mData;
+}
+
+/*!
+  Constructs a new QCPColorMapData instance copying the data and range of \a other.
+*/
+QCPColorMapData::QCPColorMapData(const QCPColorMapData &other) :
+  mKeySize(0),
+  mValueSize(0),
+  mIsEmpty(true),
+  mData(0),
+  mDataModified(true)
+{
+  *this = other;
+}
+
+/*!
+  Overwrites this color map data instance with the data stored in \a other.
+*/
+QCPColorMapData &QCPColorMapData::operator=(const QCPColorMapData &other)
+{
+  if (&other != this)
+  {
+    const int keySize = other.keySize();
+    const int valueSize = other.valueSize();
+    setSize(keySize, valueSize);
+    setRange(other.keyRange(), other.valueRange());
+    if (!mIsEmpty)
+      memcpy(mData, other.mData, sizeof(mData[0])*keySize*valueSize);
+    mDataBounds = other.mDataBounds;
+    mDataModified = true;
+  }
+  return *this;
+}
+
+/* undocumented getter */
+double QCPColorMapData::data(double key, double value)
+{
+  int keyCell = (key-mKeyRange.lower)/(mKeyRange.upper-mKeyRange.lower)*(mKeySize-1)+0.5;
+  int valueCell = (value-mValueRange.lower)/(mValueRange.upper-mValueRange.lower)*(mValueSize-1)+0.5;
+  if (keyCell >= 0 && keyCell < mKeySize && valueCell >= 0 && valueCell < mValueSize)
+    return mData[valueCell*mKeySize + keyCell];
+  else
+    return 0;
+}
+
+/* undocumented getter */
+double QCPColorMapData::cell(int keyIndex, int valueIndex)
+{
+  if (keyIndex >= 0 && keyIndex < mKeySize && valueIndex >= 0 && valueIndex < mValueSize)
+    return mData[valueIndex*mKeySize + keyIndex];
+  else
+    return 0;
+}
+
+/*!
+  Resizes the data array to have \a keySize cells in the key dimension and \a valueSize cells in
+  the value dimension.
+
+  The current data is discarded and the map cells are set to 0, unless the map had already the
+  requested size.
+  
+  Setting at least one of \a keySize or \a valueSize to zero frees the internal data array and \ref
+  isEmpty returns true.
+
+  \see setRange, setKeySize, setValueSize
+*/
+void QCPColorMapData::setSize(int keySize, int valueSize)
+{
+  if (keySize != mKeySize || valueSize != mValueSize)
+  {
+    mKeySize = keySize;
+    mValueSize = valueSize;
+    if (mData)
+      delete[] mData;
+    mIsEmpty = mKeySize == 0 || mValueSize == 0;
+    if (!mIsEmpty)
+    {
+#ifdef __EXCEPTIONS
+      try { // 2D arrays get memory intensive fast. So if the allocation fails, at least output debug message
+#endif
+      mData = new double[mKeySize*mValueSize];
+#ifdef __EXCEPTIONS
+      } catch (...) { mData = 0; }
+#endif
+      if (mData)
+        fill(0);
+      else
+        qDebug() << Q_FUNC_INFO << "out of memory for data dimensions "<< mKeySize << "*" << mValueSize;
+    } else
+      mData = 0;
+    mDataModified = true;
+  }
+}
+
+/*!
+  Resizes the data array to have \a keySize cells in the key dimension.
+
+  The current data is discarded and the map cells are set to 0, unless the map had already the
+  requested size.
+  
+  Setting \a keySize to zero frees the internal data array and \ref isEmpty returns true.
+
+  \see setKeyRange, setSize, setValueSize
+*/
+void QCPColorMapData::setKeySize(int keySize)
+{
+  setSize(keySize, mValueSize);
+}
+
+/*!
+  Resizes the data array to have \a valueSize cells in the value dimension.
+
+  The current data is discarded and the map cells are set to 0, unless the map had already the
+  requested size.
+  
+  Setting \a valueSize to zero frees the internal data array and \ref isEmpty returns true.
+
+  \see setValueRange, setSize, setKeySize
+*/
+void QCPColorMapData::setValueSize(int valueSize)
+{
+  setSize(mKeySize, valueSize);
+}
+
+/*!
+  Sets the coordinate ranges the data shall be distributed over. This defines the rectangular area
+  covered by the color map in plot coordinates.
+  
+  The outer cells will be centered on the range boundaries given to this function. For example, if
+  the key size (\ref setKeySize) is 3 and \a keyRange is set to <tt>QCPRange(2, 3)</tt> there will
+  be cells centered on the key coordinates 2, 2.5 and 3.
+ 
+  \see setSize
+*/
+void QCPColorMapData::setRange(const QCPRange &keyRange, const QCPRange &valueRange)
+{
+  setKeyRange(keyRange);
+  setValueRange(valueRange);
+}
+
+/*!
+  Sets the coordinate range the data shall be distributed over in the key dimension. Together with
+  the value range, This defines the rectangular area covered by the color map in plot coordinates.
+  
+  The outer cells will be centered on the range boundaries given to this function. For example, if
+  the key size (\ref setKeySize) is 3 and \a keyRange is set to <tt>QCPRange(2, 3)</tt> there will
+  be cells centered on the key coordinates 2, 2.5 and 3.
+ 
+  \see setRange, setValueRange, setSize
+*/
+void QCPColorMapData::setKeyRange(const QCPRange &keyRange)
+{
+  mKeyRange = keyRange;
+}
+
+/*!
+  Sets the coordinate range the data shall be distributed over in the value dimension. Together with
+  the key range, This defines the rectangular area covered by the color map in plot coordinates.
+  
+  The outer cells will be centered on the range boundaries given to this function. For example, if
+  the value size (\ref setValueSize) is 3 and \a valueRange is set to <tt>QCPRange(2, 3)</tt> there
+  will be cells centered on the value coordinates 2, 2.5 and 3.
+ 
+  \see setRange, setKeyRange, setSize
+*/
+void QCPColorMapData::setValueRange(const QCPRange &valueRange)
+{
+  mValueRange = valueRange;
+}
+
+/*!
+  Sets the data of the cell, which lies at the plot coordinates given by \a key and \a value, to \a
+  z.
+  
+  \note The QCPColorMap always displays the data at equal key/value intervals, even if the key or
+  value axis is set to a logarithmic scaling. If you want to use QCPColorMap with logarithmic axes,
+  you shouldn't use the \ref QCPColorMapData::setData method as it uses a linear transformation to
+  determine the cell index. Rather directly access the cell index with \ref
+  QCPColorMapData::setCell.
+ 
+  \see setCell, setRange
+*/
+void QCPColorMapData::setData(double key, double value, double z)
+{
+  int keyCell = (key-mKeyRange.lower)/(mKeyRange.upper-mKeyRange.lower)*(mKeySize-1)+0.5;
+  int valueCell = (value-mValueRange.lower)/(mValueRange.upper-mValueRange.lower)*(mValueSize-1)+0.5;
+  if (keyCell >= 0 && keyCell < mKeySize && valueCell >= 0 && valueCell < mValueSize)
+  {
+    mData[valueCell*mKeySize + keyCell] = z;
+    if (z < mDataBounds.lower)
+      mDataBounds.lower = z;
+    if (z > mDataBounds.upper)
+      mDataBounds.upper = z;
+     mDataModified = true;
+  }
+}
+
+/*!
+  Sets the data of the cell with indices \a keyIndex and \a valueIndex to \a z. The indices
+  enumerate the cells starting from zero, up to the map's size-1 in the respective dimension (see
+  \ref setSize).
+  
+  In the standard plot configuration (horizontal key axis and vertical value axis, both not
+  range-reversed), the cell with indices (0, 0) is in the bottom left corner and the cell with
+  indices (keySize-1, valueSize-1) is in the top right corner of the color map.
+  
+  \see setData, setSize
+*/
+void QCPColorMapData::setCell(int keyIndex, int valueIndex, double z)
+{
+  if (keyIndex >= 0 && keyIndex < mKeySize && valueIndex >= 0 && valueIndex < mValueSize)
+  {
+    mData[valueIndex*mKeySize + keyIndex] = z;
+    if (z < mDataBounds.lower)
+      mDataBounds.lower = z;
+    if (z > mDataBounds.upper)
+      mDataBounds.upper = z;
+     mDataModified = true;
+  }
+}
+
+/*!
+  Goes through the data and updates the buffered minimum and maximum data values.
+  
+  Calling this method is only advised if you are about to call \ref QCPColorMap::rescaleDataRange
+  and can not guarantee that the cells holding the maximum or minimum data haven't been overwritten
+  with a smaller or larger value respectively, since the buffered maximum/minimum values have been
+  updated the last time. Why this is the case is explained in the class description (\ref
+  QCPColorMapData).
+  
+  Note that the method \ref QCPColorMap::rescaleDataRange provides a parameter \a
+  recalculateDataBounds for convenience. Setting this to true will call this method for you, before
+  doing the rescale.
+*/
+void QCPColorMapData::recalculateDataBounds()
+{
+  if (mKeySize > 0 && mValueSize > 0)
+  {
+    double minHeight = mData[0];
+    double maxHeight = mData[0];
+    const int dataCount = mValueSize*mKeySize;
+    for (int i=0; i<dataCount; ++i)
+    {
+      if (mData[i] > maxHeight)
+        maxHeight = mData[i];
+      if (mData[i] < minHeight)
+        minHeight = mData[i];
+    }
+    mDataBounds.lower = minHeight;
+    mDataBounds.upper = maxHeight;
+  }
+}
+
+/*!
+  Frees the internal data memory.
+  
+  This is equivalent to calling \ref setSize "setSize(0, 0)".
+*/
+void QCPColorMapData::clear()
+{
+  setSize(0, 0);
+}
+
+/*!
+  Sets all cells to the value \a z.
+*/
+void QCPColorMapData::fill(double z)
+{
+  const int dataCount = mValueSize*mKeySize;
+  for (int i=0; i<dataCount; ++i)
+    mData[i] = z;
+  mDataBounds = QCPRange(z, z);
+  mDataModified = true;
+}
+
+/*!
+  Transforms plot coordinates given by \a key and \a value to cell indices of this QCPColorMapData
+  instance. The resulting cell indices are returned via the output parameters \a keyIndex and \a
+  valueIndex.
+  
+  The retrieved key/value cell indices can then be used for example with \ref setCell.
+  
+  If you are only interested in a key or value index, you may pass 0 as \a valueIndex or \a
+  keyIndex.
+  
+  \note The QCPColorMap always displays the data at equal key/value intervals, even if the key or
+  value axis is set to a logarithmic scaling. If you want to use QCPColorMap with logarithmic axes,
+  you shouldn't use the \ref QCPColorMapData::coordToCell method as it uses a linear transformation to
+  determine the cell index.
+  
+  \see cellToCoord, QCPAxis::coordToPixel
+*/
+void QCPColorMapData::coordToCell(double key, double value, int *keyIndex, int *valueIndex) const
+{
+  if (keyIndex)
+    *keyIndex = (key-mKeyRange.lower)/(mKeyRange.upper-mKeyRange.lower)*(mKeySize-1)+0.5;
+  if (valueIndex)
+    *valueIndex = (value-mValueRange.lower)/(mValueRange.upper-mValueRange.lower)*(mValueSize-1)+0.5;
+}
+
+/*!
+  Transforms cell indices given by \a keyIndex and \a valueIndex to cell indices of this QCPColorMapData
+  instance. The resulting coordinates are returned via the output parameters \a key and \a
+  value.
+  
+  If you are only interested in a key or value coordinate, you may pass 0 as \a key or \a
+  value.
+  
+  \note The QCPColorMap always displays the data at equal key/value intervals, even if the key or
+  value axis is set to a logarithmic scaling. If you want to use QCPColorMap with logarithmic axes,
+  you shouldn't use the \ref QCPColorMapData::cellToCoord method as it uses a linear transformation to
+  determine the cell index.
+  
+  \see coordToCell, QCPAxis::pixelToCoord
+*/
+void QCPColorMapData::cellToCoord(int keyIndex, int valueIndex, double *key, double *value) const
+{
+  if (key)
+    *key = keyIndex/(double)(mKeySize-1)*(mKeyRange.upper-mKeyRange.lower)+mKeyRange.lower;
+  if (value)
+    *value = valueIndex/(double)(mValueSize-1)*(mValueRange.upper-mValueRange.lower)+mValueRange.lower;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPColorMap
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPColorMap
+  \brief A plottable representing a two-dimensional color map in a plot.
+
+  \image html QCPColorMap.png
+  
+  The data is stored in the class \ref QCPColorMapData, which can be accessed via the data()
+  method.
+  
+  A color map has three dimensions to represent a data point: The \a key dimension, the \a value
+  dimension and the \a data dimension. As with other plottables such as graphs, \a key and \a value
+  correspond to two orthogonal axes on the QCustomPlot surface that you specify in the QCPColorMap
+  constructor. The \a data dimension however is encoded as the color of the point at (\a key, \a
+  value).
+
+  Set the number of points (or \a cells) in the key/value dimension via \ref
+  QCPColorMapData::setSize. The plot coordinate range over which these points will be displayed is
+  specified via \ref QCPColorMapData::setRange. The first cell will be centered on the lower range
+  boundary and the last cell will be centered on the upper range boundary. The data can be set by
+  either accessing the cells directly with QCPColorMapData::setCell or by addressing the cells via
+  their plot coordinates with \ref QCPColorMapData::setData. If possible, you should prefer
+  setCell, since it doesn't need to do any coordinate transformation and thus performs a bit
+  better.
+  
+  The cell with index (0, 0) is at the bottom left, if the color map uses normal (i.e. not reversed)
+  key and value axes.
+  
+  To show the user which colors correspond to which \a data values, a \ref QCPColorScale is
+  typically placed to the right of the axis rect. See the documentation there for details on how to
+  add and use a color scale.
+  
+  \section appearance Changing the appearance
+  
+  The central part of the appearance is the color gradient, which can be specified via \ref
+  setGradient. See the documentation of \ref QCPColorGradient for details on configuring a color
+  gradient.
+  
+  The \a data range that is mapped to the colors of the gradient can be specified with \ref
+  setDataRange. To make the data range encompass the whole data set minimum to maximum, call \ref
+  rescaleDataRange.
+  
+  \section usage Usage
+  
+  Like all data representing objects in QCustomPlot, the QCPColorMap is a plottable
+  (QCPAbstractPlottable). So the plottable-interface of QCustomPlot applies
+  (QCustomPlot::plottable, QCustomPlot::addPlottable, QCustomPlot::removePlottable, etc.)
+  
+  Usually, you first create an instance and add it to the customPlot:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpcolormap-creation-1
+  and then modify the properties of the newly created color map, e.g.:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpcolormap-creation-2
+  
+  \note The QCPColorMap always displays the data at equal key/value intervals, even if the key or
+  value axis is set to a logarithmic scaling. If you want to use QCPColorMap with logarithmic axes,
+  you shouldn't use the \ref QCPColorMapData::setData method as it uses a linear transformation to
+  determine the cell index. Rather directly access the cell index with \ref
+  QCPColorMapData::setCell.
+*/
+
+/* start documentation of inline functions */
+
+/*! \fn QCPColorMapData *QCPColorMap::data() const
+  
+  Returns a pointer to the internal data storage of type \ref QCPColorMapData. Access this to
+  modify data points (cells) and the color map key/value range.
+  
+  \see setData
+*/
+
+/* end documentation of inline functions */
+
+/* start documentation of signals */
+
+/*! \fn void QCPColorMap::dataRangeChanged(QCPRange newRange);
+  
+  This signal is emitted when the data range changes.
+  
+  \see setDataRange
+*/
+
+/*! \fn void QCPColorMap::dataScaleTypeChanged(QCPAxis::ScaleType scaleType);
+  
+  This signal is emitted when the data scale type changes.
+  
+  \see setDataScaleType
+*/
+
+/*! \fn void QCPColorMap::gradientChanged(QCPColorGradient newGradient);
+  
+  This signal is emitted when the gradient changes.
+  
+  \see setGradient
+*/
+
+/* end documentation of signals */
+
+/*!
+  Constructs a color map with the specified \a keyAxis and \a valueAxis.
+  
+  The constructed QCPColorMap can be added to the plot with QCustomPlot::addPlottable, QCustomPlot
+  then takes ownership of the color map.
+*/
+QCPColorMap::QCPColorMap(QCPAxis *keyAxis, QCPAxis *valueAxis) :
+  QCPAbstractPlottable(keyAxis, valueAxis),
+  mDataScaleType(QCPAxis::stLinear),
+  mMapData(new QCPColorMapData(10, 10, QCPRange(0, 5), QCPRange(0, 5))),
+  mInterpolate(true),
+  mTightBoundary(false),
+  mMapImageInvalidated(true)
+{
+}
+
+QCPColorMap::~QCPColorMap()
+{
+  delete mMapData;
+}
+
+/*!
+  Replaces the current \ref data with the provided \a data.
+  
+  If \a copy is set to true, the \a data object will only be copied. if false, the color map
+  takes ownership of the passed data and replaces the internal data pointer with it. This is
+  significantly faster than copying for large datasets.
+*/
+void QCPColorMap::setData(QCPColorMapData *data, bool copy)
+{
+  if (mMapData == data)
+  {
+    qDebug() << Q_FUNC_INFO << "The data pointer is already in (and owned by) this plottable" << reinterpret_cast<quintptr>(data);
+    return;
+  }
+  if (copy)
+  {
+    *mMapData = *data;
+  } else
+  {
+    delete mMapData;
+    mMapData = data;
+  }
+  mMapImageInvalidated = true;
+}
+
+/*!
+  Sets the data range of this color map to \a dataRange. The data range defines which data values
+  are mapped to the color gradient.
+  
+  To make the data range span the full range of the data set, use \ref rescaleDataRange.
+  
+  \see QCPColorScale::setDataRange
+*/
+void QCPColorMap::setDataRange(const QCPRange &dataRange)
+{
+  if (!QCPRange::validRange(dataRange)) return;
+  if (mDataRange.lower != dataRange.lower || mDataRange.upper != dataRange.upper)
+  {
+    if (mDataScaleType == QCPAxis::stLogarithmic)
+      mDataRange = dataRange.sanitizedForLogScale();
+    else
+      mDataRange = dataRange.sanitizedForLinScale();
+    mMapImageInvalidated = true;
+    emit dataRangeChanged(mDataRange);
+  }
+}
+
+/*!
+  Sets whether the data is correlated with the color gradient linearly or logarithmically.
+  
+  \see QCPColorScale::setDataScaleType
+*/
+void QCPColorMap::setDataScaleType(QCPAxis::ScaleType scaleType)
+{
+  if (mDataScaleType != scaleType)
+  {
+    mDataScaleType = scaleType;
+    mMapImageInvalidated = true;
+    emit dataScaleTypeChanged(mDataScaleType);
+    if (mDataScaleType == QCPAxis::stLogarithmic)
+      setDataRange(mDataRange.sanitizedForLogScale());
+  }
+}
+
+/*!
+  Sets the color gradient that is used to represent the data. For more details on how to create an
+  own gradient or use one of the preset gradients, see \ref QCPColorGradient.
+  
+  The colors defined by the gradient will be used to represent data values in the currently set
+  data range, see \ref setDataRange. Data points that are outside this data range will either be
+  colored uniformly with the respective gradient boundary color, or the gradient will repeat,
+  depending on \ref QCPColorGradient::setPeriodic.
+  
+  \see QCPColorScale::setGradient
+*/
+void QCPColorMap::setGradient(const QCPColorGradient &gradient)
+{
+  if (mGradient != gradient)
+  {
+    mGradient = gradient;
+    mMapImageInvalidated = true;
+    emit gradientChanged(mGradient);
+  }
+}
+
+/*!
+  Sets whether the color map image shall use bicubic interpolation when displaying the color map
+  shrinked or expanded, and not at a 1:1 pixel-to-data scale.
+  
+  \image html QCPColorMap-interpolate.png "A 10*10 color map, with interpolation and without interpolation enabled"
+*/
+void QCPColorMap::setInterpolate(bool enabled)
+{
+  mInterpolate = enabled;
+  mMapImageInvalidated = true; // because oversampling factors might need to change
+}
+
+/*!
+  Sets whether the outer most data rows and columns are clipped to the specified key and value
+  range (see \ref QCPColorMapData::setKeyRange, \ref QCPColorMapData::setValueRange).
+  
+  if \a enabled is set to false, the data points at the border of the color map are drawn with the
+  same width and height as all other data points. Since the data points are represented by
+  rectangles of one color centered on the data coordinate, this means that the shown color map
+  extends by half a data point over the specified key/value range in each direction.
+  
+  \image html QCPColorMap-tightboundary.png "A color map, with tight boundary enabled and disabled"
+*/
+void QCPColorMap::setTightBoundary(bool enabled)
+{
+  mTightBoundary = enabled;
+}
+
+/*!
+  Associates the color scale \a colorScale with this color map.
+  
+  This means that both the color scale and the color map synchronize their gradient, data range and
+  data scale type (\ref setGradient, \ref setDataRange, \ref setDataScaleType). Multiple color maps
+  can be associated with one single color scale. This causes the color maps to also synchronize
+  those properties, via the mutual color scale.
+  
+  This function causes the color map to adopt the current color gradient, data range and data scale
+  type of \a colorScale. After this call, you may change these properties at either the color map
+  or the color scale, and the setting will be applied to both.
+  
+  Pass 0 as \a colorScale to disconnect the color scale from this color map again.
+*/
+void QCPColorMap::setColorScale(QCPColorScale *colorScale)
+{
+  if (mColorScale) // unconnect signals from old color scale
+  {
+    disconnect(this, SIGNAL(dataRangeChanged(QCPRange)), mColorScale.data(), SLOT(setDataRange(QCPRange)));
+    disconnect(this, SIGNAL(dataScaleTypeChanged(QCPAxis::ScaleType)), mColorScale.data(), SLOT(setDataScaleType(QCPAxis::ScaleType)));
+    disconnect(this, SIGNAL(gradientChanged(QCPColorGradient)), mColorScale.data(), SLOT(setGradient(QCPColorGradient)));
+    disconnect(mColorScale.data(), SIGNAL(dataRangeChanged(QCPRange)), this, SLOT(setDataRange(QCPRange)));
+    disconnect(mColorScale.data(), SIGNAL(gradientChanged(QCPColorGradient)), this, SLOT(setGradient(QCPColorGradient)));
+    disconnect(mColorScale.data(), SIGNAL(dataScaleTypeChanged(QCPAxis::ScaleType)), this, SLOT(setDataScaleType(QCPAxis::ScaleType)));
+  }
+  mColorScale = colorScale;
+  if (mColorScale) // connect signals to new color scale
+  {
+    setGradient(mColorScale.data()->gradient());
+    setDataRange(mColorScale.data()->dataRange());
+    setDataScaleType(mColorScale.data()->dataScaleType());
+    connect(this, SIGNAL(dataRangeChanged(QCPRange)), mColorScale.data(), SLOT(setDataRange(QCPRange)));
+    connect(this, SIGNAL(dataScaleTypeChanged(QCPAxis::ScaleType)), mColorScale.data(), SLOT(setDataScaleType(QCPAxis::ScaleType)));
+    connect(this, SIGNAL(gradientChanged(QCPColorGradient)), mColorScale.data(), SLOT(setGradient(QCPColorGradient)));
+    connect(mColorScale.data(), SIGNAL(dataRangeChanged(QCPRange)), this, SLOT(setDataRange(QCPRange)));
+    connect(mColorScale.data(), SIGNAL(gradientChanged(QCPColorGradient)), this, SLOT(setGradient(QCPColorGradient)));
+    connect(mColorScale.data(), SIGNAL(dataScaleTypeChanged(QCPAxis::ScaleType)), this, SLOT(setDataScaleType(QCPAxis::ScaleType)));
+  }
+}
+
+/*!
+  Sets the data range (\ref setDataRange) to span the minimum and maximum values that occur in the
+  current data set. This corresponds to the \ref rescaleKeyAxis or \ref rescaleValueAxis methods,
+  only for the third data dimension of the color map.
+  
+  The minimum and maximum values of the data set are buffered in the internal QCPColorMapData
+  instance (\ref data). As data is updated via its \ref QCPColorMapData::setCell or \ref
+  QCPColorMapData::setData, the buffered minimum and maximum values are updated, too. For
+  performance reasons, however, they are only updated in an expanding fashion. So the buffered
+  maximum can only increase and the buffered minimum can only decrease. In consequence, changes to
+  the data that actually lower the maximum of the data set (by overwriting the cell holding the
+  current maximum with a smaller value), aren't recognized and the buffered maximum overestimates
+  the true maximum of the data set. The same happens for the buffered minimum. To recalculate the
+  true minimum and maximum by explicitly looking at each cell, the method
+  QCPColorMapData::recalculateDataBounds can be used. For convenience, setting the parameter \a
+  recalculateDataBounds calls this method before setting the data range to the buffered minimum and
+  maximum.
+  
+  \see setDataRange
+*/
+void QCPColorMap::rescaleDataRange(bool recalculateDataBounds)
+{
+  if (recalculateDataBounds)
+    mMapData->recalculateDataBounds();
+  setDataRange(mMapData->dataBounds());
+}
+
+/*!
+  Takes the current appearance of the color map and updates the legend icon, which is used to
+  represent this color map in the legend (see \ref QCPLegend).
+  
+  The \a transformMode specifies whether the rescaling is done by a faster, low quality image
+  scaling algorithm (Qt::FastTransformation) or by a slower, higher quality algorithm
+  (Qt::SmoothTransformation).
+  
+  The current color map appearance is scaled down to \a thumbSize. Ideally, this should be equal to
+  the size of the legend icon (see \ref QCPLegend::setIconSize). If it isn't exactly the configured
+  legend icon size, the thumb will be rescaled during drawing of the legend item.
+  
+  \see setDataRange
+*/
+void QCPColorMap::updateLegendIcon(Qt::TransformationMode transformMode, const QSize &thumbSize)
+{
+  if (mMapImage.isNull() && !data()->isEmpty())
+    updateMapImage(); // try to update map image if it's null (happens if no draw has happened yet)
+  
+  if (!mMapImage.isNull()) // might still be null, e.g. if data is empty, so check here again
+  {
+    bool mirrorX = (keyAxis()->orientation() == Qt::Horizontal ? keyAxis() : valueAxis())->rangeReversed();
+    bool mirrorY = (valueAxis()->orientation() == Qt::Vertical ? valueAxis() : keyAxis())->rangeReversed();
+    mLegendIcon = QPixmap::fromImage(mMapImage.mirrored(mirrorX, mirrorY)).scaled(thumbSize, Qt::KeepAspectRatio, transformMode);
+  }
+}
+
+/*!
+  Clears the colormap data by calling \ref QCPColorMapData::clear() on the internal data. This also
+  resizes the map to 0x0 cells.
+*/
+void QCPColorMap::clearData()
+{
+  mMapData->clear();
+}
+
+/* inherits documentation from base class */
+double QCPColorMap::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  if (onlySelectable && !mSelectable)
+    return -1;
+  if (!mKeyAxis || !mValueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return -1; }
+  
+  if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))
+  {
+    double posKey, posValue;
+    pixelsToCoords(pos, posKey, posValue);
+    if (mMapData->keyRange().contains(posKey) && mMapData->valueRange().contains(posValue))
+      return mParentPlot->selectionTolerance()*0.99;
+  }
+  return -1;
+}
+
+/*! \internal
+  
+  Updates the internal map image buffer by going through the internal \ref QCPColorMapData and
+  turning the data values into color pixels with \ref QCPColorGradient::colorize.
+  
+  This method is called by \ref QCPColorMap::draw if either the data has been modified or the map image
+  has been invalidated for a different reason (e.g. a change of the data range with \ref
+  setDataRange).
+  
+  If the map cell count is low, the image created will be oversampled in order to avoid a
+  QPainter::drawImage bug which makes inner pixel boundaries jitter when stretch-drawing images
+  without smooth transform enabled. Accordingly, oversampling isn't performed if \ref
+  setInterpolate is true.
+*/
+void QCPColorMap::updateMapImage()
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  if (!keyAxis) return;
+  if (mMapData->isEmpty()) return;
+  
+  const int keySize = mMapData->keySize();
+  const int valueSize = mMapData->valueSize();
+  int keyOversamplingFactor = mInterpolate ? 1 : (int)(1.0+100.0/(double)keySize); // make mMapImage have at least size 100, factor becomes 1 if size > 200 or interpolation is on
+  int valueOversamplingFactor = mInterpolate ? 1 : (int)(1.0+100.0/(double)valueSize); // make mMapImage have at least size 100, factor becomes 1 if size > 200 or interpolation is on
+  
+  // resize mMapImage to correct dimensions including possible oversampling factors, according to key/value axes orientation:
+  if (keyAxis->orientation() == Qt::Horizontal && (mMapImage.width() != keySize*keyOversamplingFactor || mMapImage.height() != valueSize*valueOversamplingFactor))
+    mMapImage = QImage(QSize(keySize*keyOversamplingFactor, valueSize*valueOversamplingFactor), QImage::Format_RGB32);
+  else if (keyAxis->orientation() == Qt::Vertical && (mMapImage.width() != valueSize*valueOversamplingFactor || mMapImage.height() != keySize*keyOversamplingFactor))
+    mMapImage = QImage(QSize(valueSize*valueOversamplingFactor, keySize*keyOversamplingFactor), QImage::Format_RGB32);
+  
+  QImage *localMapImage = &mMapImage; // this is the image on which the colorization operates. Either the final mMapImage, or if we need oversampling, mUndersampledMapImage
+  if (keyOversamplingFactor > 1 || valueOversamplingFactor > 1)
+  {
+    // resize undersampled map image to actual key/value cell sizes:
+    if (keyAxis->orientation() == Qt::Horizontal && (mUndersampledMapImage.width() != keySize || mUndersampledMapImage.height() != valueSize))
+      mUndersampledMapImage = QImage(QSize(keySize, valueSize), QImage::Format_RGB32);
+    else if (keyAxis->orientation() == Qt::Vertical && (mUndersampledMapImage.width() != valueSize || mUndersampledMapImage.height() != keySize))
+      mUndersampledMapImage = QImage(QSize(valueSize, keySize), QImage::Format_RGB32);
+    localMapImage = &mUndersampledMapImage; // make the colorization run on the undersampled image
+  } else if (!mUndersampledMapImage.isNull())
+    mUndersampledMapImage = QImage(); // don't need oversampling mechanism anymore (map size has changed) but mUndersampledMapImage still has nonzero size, free it
+  
+  const double *rawData = mMapData->mData;
+  if (keyAxis->orientation() == Qt::Horizontal)
+  {
+    const int lineCount = valueSize;
+    const int rowCount = keySize;
+    for (int line=0; line<lineCount; ++line)
+    {
+      QRgb* pixels = reinterpret_cast<QRgb*>(localMapImage->scanLine(lineCount-1-line)); // invert scanline index because QImage counts scanlines from top, but our vertical index counts from bottom (mathematical coordinate system)
+      mGradient.colorize(rawData+line*rowCount, mDataRange, pixels, rowCount, 1, mDataScaleType==QCPAxis::stLogarithmic);
+    }
+  } else // keyAxis->orientation() == Qt::Vertical
+  {
+    const int lineCount = keySize;
+    const int rowCount = valueSize;
+    for (int line=0; line<lineCount; ++line)
+    {
+      QRgb* pixels = reinterpret_cast<QRgb*>(localMapImage->scanLine(lineCount-1-line)); // invert scanline index because QImage counts scanlines from top, but our vertical index counts from bottom (mathematical coordinate system)
+      mGradient.colorize(rawData+line, mDataRange, pixels, rowCount, lineCount, mDataScaleType==QCPAxis::stLogarithmic);
+    }
+  }
+  
+  if (keyOversamplingFactor > 1 || valueOversamplingFactor > 1)
+  {
+    if (keyAxis->orientation() == Qt::Horizontal)
+      mMapImage = mUndersampledMapImage.scaled(keySize*keyOversamplingFactor, valueSize*valueOversamplingFactor, Qt::IgnoreAspectRatio, Qt::FastTransformation);
+    else
+      mMapImage = mUndersampledMapImage.scaled(valueSize*valueOversamplingFactor, keySize*keyOversamplingFactor, Qt::IgnoreAspectRatio, Qt::FastTransformation);
+  }
+  mMapData->mDataModified = false;
+  mMapImageInvalidated = false;
+}
+
+/* inherits documentation from base class */
+void QCPColorMap::draw(QCPPainter *painter)
+{
+  if (mMapData->isEmpty()) return;
+  if (!mKeyAxis || !mValueAxis) return;
+  applyDefaultAntialiasingHint(painter);
+  
+  if (mMapData->mDataModified || mMapImageInvalidated)
+    updateMapImage();
+  
+  // use buffer if painting vectorized (PDF):
+  bool useBuffer = painter->modes().testFlag(QCPPainter::pmVectorized);
+  QCPPainter *localPainter = painter; // will be redirected to paint on mapBuffer if painting vectorized
+  QRectF mapBufferTarget; // the rect in absolute widget coordinates where the visible map portion/buffer will end up in
+  QPixmap mapBuffer;
+  double mapBufferPixelRatio = 3; // factor by which DPI is increased in embedded bitmaps
+  if (useBuffer)
+  {
+    mapBufferTarget = painter->clipRegion().boundingRect();
+    mapBuffer = QPixmap((mapBufferTarget.size()*mapBufferPixelRatio).toSize());
+    mapBuffer.fill(Qt::transparent);
+    localPainter = new QCPPainter(&mapBuffer);
+    localPainter->scale(mapBufferPixelRatio, mapBufferPixelRatio);
+    localPainter->translate(-mapBufferTarget.topLeft());
+  }
+  
+  QRectF imageRect = QRectF(coordsToPixels(mMapData->keyRange().lower, mMapData->valueRange().lower),
+                            coordsToPixels(mMapData->keyRange().upper, mMapData->valueRange().upper)).normalized();
+  // extend imageRect to contain outer halves/quarters of bordering/cornering pixels (cells are centered on map range boundary):
+  double halfCellWidth = 0; // in pixels
+  double halfCellHeight = 0; // in pixels
+  if (keyAxis()->orientation() == Qt::Horizontal)
+  {
+    if (mMapData->keySize() > 1)
+      halfCellWidth = 0.5*imageRect.width()/(double)(mMapData->keySize()-1);
+    if (mMapData->valueSize() > 1)
+      halfCellHeight = 0.5*imageRect.height()/(double)(mMapData->valueSize()-1);
+  } else // keyAxis orientation is Qt::Vertical
+  {
+    if (mMapData->keySize() > 1)
+      halfCellHeight = 0.5*imageRect.height()/(double)(mMapData->keySize()-1);
+    if (mMapData->valueSize() > 1)
+      halfCellWidth = 0.5*imageRect.width()/(double)(mMapData->valueSize()-1);
+  }
+  imageRect.adjust(-halfCellWidth, -halfCellHeight, halfCellWidth, halfCellHeight);
+  bool mirrorX = (keyAxis()->orientation() == Qt::Horizontal ? keyAxis() : valueAxis())->rangeReversed();
+  bool mirrorY = (valueAxis()->orientation() == Qt::Vertical ? valueAxis() : keyAxis())->rangeReversed();
+  bool smoothBackup = localPainter->renderHints().testFlag(QPainter::SmoothPixmapTransform);
+  localPainter->setRenderHint(QPainter::SmoothPixmapTransform, mInterpolate);
+  QRegion clipBackup;
+  if (mTightBoundary)
+  {
+    clipBackup = localPainter->clipRegion();
+    QRectF tightClipRect = QRectF(coordsToPixels(mMapData->keyRange().lower, mMapData->valueRange().lower),
+                                  coordsToPixels(mMapData->keyRange().upper, mMapData->valueRange().upper)).normalized();
+    localPainter->setClipRect(tightClipRect, Qt::IntersectClip);
+  }
+  localPainter->drawImage(imageRect, mMapImage.mirrored(mirrorX, mirrorY));
+  if (mTightBoundary)
+    localPainter->setClipRegion(clipBackup);
+  localPainter->setRenderHint(QPainter::SmoothPixmapTransform, smoothBackup);
+  
+  if (useBuffer) // localPainter painted to mapBuffer, so now draw buffer with original painter
+  {
+    delete localPainter;
+    painter->drawPixmap(mapBufferTarget.toRect(), mapBuffer);
+  }
+}
+
+/* inherits documentation from base class */
+void QCPColorMap::drawLegendIcon(QCPPainter *painter, const QRectF &rect) const
+{
+  applyDefaultAntialiasingHint(painter);
+  // draw map thumbnail:
+  if (!mLegendIcon.isNull())
+  {
+    QPixmap scaledIcon = mLegendIcon.scaled(rect.size().toSize(), Qt::KeepAspectRatio, Qt::FastTransformation);
+    QRectF iconRect = QRectF(0, 0, scaledIcon.width(), scaledIcon.height());
+    iconRect.moveCenter(rect.center());
+    painter->drawPixmap(iconRect.topLeft(), scaledIcon);
+  }
+  /*
+  // draw frame:
+  painter->setBrush(Qt::NoBrush);
+  painter->setPen(Qt::black);
+  painter->drawRect(rect.adjusted(1, 1, 0, 0));
+  */
+}
+
+/* inherits documentation from base class */
+QCPRange QCPColorMap::getKeyRange(bool &foundRange, SignDomain inSignDomain) const
+{
+  foundRange = true;
+  QCPRange result = mMapData->keyRange();
+  result.normalize();
+  if (inSignDomain == QCPAbstractPlottable::sdPositive)
+  {
+    if (result.lower <= 0 && result.upper > 0)
+      result.lower = result.upper*1e-3;
+    else if (result.lower <= 0 && result.upper <= 0)
+      foundRange = false;
+  } else if (inSignDomain == QCPAbstractPlottable::sdNegative)
+  {
+    if (result.upper >= 0 && result.lower < 0)
+      result.upper = result.lower*1e-3;
+    else if (result.upper >= 0 && result.lower >= 0)
+      foundRange = false;
+  }
+  return result;
+}
+
+/* inherits documentation from base class */
+QCPRange QCPColorMap::getValueRange(bool &foundRange, SignDomain inSignDomain) const
+{
+  foundRange = true;
+  QCPRange result = mMapData->valueRange();
+  result.normalize();
+  if (inSignDomain == QCPAbstractPlottable::sdPositive)
+  {
+    if (result.lower <= 0 && result.upper > 0)
+      result.lower = result.upper*1e-3;
+    else if (result.lower <= 0 && result.upper <= 0)
+      foundRange = false;
+  } else if (inSignDomain == QCPAbstractPlottable::sdNegative)
+  {
+    if (result.upper >= 0 && result.lower < 0)
+      result.upper = result.lower*1e-3;
+    else if (result.upper >= 0 && result.lower >= 0)
+      foundRange = false;
+  }
+  return result;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPFinancialData
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPFinancialData
+  \brief Holds the data of one single data point for QCPFinancial.
+  
+  The container for storing multiple data points is \ref QCPFinancialDataMap.
+  
+  The stored data is:
+  \li \a key: coordinate on the key axis of this data point
+  \li \a open: The opening value at the data point
+  \li \a high: The high/maximum value at the data point
+  \li \a low: The low/minimum value at the data point
+  \li \a close: The closing value at the data point
+  
+  \see QCPFinancialDataMap
+*/
+
+/*!
+  Constructs a data point with key and all values set to zero.
+*/
+QCPFinancialData::QCPFinancialData() :
+  key(0),
+  open(0),
+  high(0),
+  low(0),
+  close(0)
+{
+}
+
+/*!
+  Constructs a data point with the specified \a key and OHLC values.
+*/
+QCPFinancialData::QCPFinancialData(double key, double open, double high, double low, double close) :
+  key(key),
+  open(open),
+  high(high),
+  low(low),
+  close(close)
+{
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPFinancial
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPFinancial
+  \brief A plottable representing a financial stock chart
+
+  \image html QCPFinancial.png
+  
+  This plottable represents time series data binned to certain intervals, mainly used for stock
+  charts. The two common representations OHLC (Open-High-Low-Close) bars and Candlesticks can be
+  set via \ref setChartStyle.
+  
+  The data is passed via \ref setData as a set of open/high/low/close values at certain keys
+  (typically times). This means the data must be already binned appropriately. If data is only
+  available as a series of values (e.g. \a price against \a time), you can use the static
+  convenience function \ref timeSeriesToOhlc to generate binned OHLC-data which can then be passed
+  to \ref setData.
+  
+  The width of the OHLC bars/candlesticks can be controlled with \ref setWidth and is given in plot
+  key coordinates. A typical choice is to set it to (or slightly less than) one bin interval width.
+  
+  \section appearance Changing the appearance
+  
+  Charts can be either single- or two-colored (\ref setTwoColored). If set to be single-colored,
+  lines are drawn with the plottable's pen (\ref setPen) and fills with the brush (\ref setBrush).
+  
+  If set to two-colored, positive changes of the value during an interval (\a close >= \a open) are
+  represented with a different pen and brush than negative changes (\a close < \a open). These can
+  be configured with \ref setPenPositive, \ref setPenNegative, \ref setBrushPositive, and \ref
+  setBrushNegative. In two-colored mode, the normal plottable pen/brush is ignored. Upon selection
+  however, the normal selected pen/brush (\ref setSelectedPen, \ref setSelectedBrush) is used,
+  irrespective of whether the chart is single- or two-colored.
+  
+*/
+
+/* start of documentation of inline functions */
+
+/*! \fn QCPFinancialDataMap *QCPFinancial::data() const
+  
+  Returns a pointer to the internal data storage of type \ref QCPFinancialDataMap. You may use it to
+  directly manipulate the data, which may be more convenient and faster than using the regular \ref
+  setData or \ref addData methods, in certain situations.
+*/
+
+/* end of documentation of inline functions */
+
+/*!
+  Constructs a financial chart which uses \a keyAxis as its key axis ("x") and \a valueAxis as its value
+  axis ("y"). \a keyAxis and \a valueAxis must reside in the same QCustomPlot instance and not have
+  the same orientation. If either of these restrictions is violated, a corresponding message is
+  printed to the debug output (qDebug), the construction is not aborted, though.
+  
+  The constructed QCPFinancial can be added to the plot with QCustomPlot::addPlottable, QCustomPlot
+  then takes ownership of the financial chart.
+*/
+QCPFinancial::QCPFinancial(QCPAxis *keyAxis, QCPAxis *valueAxis) :
+  QCPAbstractPlottable(keyAxis, valueAxis),
+  mData(0),
+  mChartStyle(csOhlc),
+  mWidth(0.5),
+  mTwoColored(false),
+  mBrushPositive(QBrush(QColor(210, 210, 255))),
+  mBrushNegative(QBrush(QColor(255, 210, 210))),
+  mPenPositive(QPen(QColor(10, 40, 180))),
+  mPenNegative(QPen(QColor(180, 40, 10)))
+{
+  mData = new QCPFinancialDataMap;
+  
+  setSelectedPen(QPen(QColor(80, 80, 255), 2.5));
+  setSelectedBrush(QBrush(QColor(80, 80, 255)));
+}
+
+QCPFinancial::~QCPFinancial()
+{
+  delete mData;
+}
+
+/*!
+  Replaces the current data with the provided \a data.
+  
+  If \a copy is set to true, data points in \a data will only be copied. if false, the plottable
+  takes ownership of the passed data and replaces the internal data pointer with it. This is
+  significantly faster than copying for large datasets.
+  
+  Alternatively, you can also access and modify the plottable's data via the \ref data method, which
+  returns a pointer to the internal \ref QCPFinancialDataMap.
+  
+  \see timeSeriesToOhlc
+*/
+void QCPFinancial::setData(QCPFinancialDataMap *data, bool copy)
+{
+  if (mData == data)
+  {
+    qDebug() << Q_FUNC_INFO << "The data pointer is already in (and owned by) this plottable" << reinterpret_cast<quintptr>(data);
+    return;
+  }
+  if (copy)
+  {
+    *mData = *data;
+  } else
+  {
+    delete mData;
+    mData = data;
+  }
+}
+
+/*! \overload
+  
+  Replaces the current data with the provided open/high/low/close data. The provided vectors should
+  have equal length. Else, the number of added points will be the size of the smallest vector.
+  
+  \see timeSeriesToOhlc
+*/
+void QCPFinancial::setData(const QVector<double> &key, const QVector<double> &open, const QVector<double> &high, const QVector<double> &low, const QVector<double> &close)
+{
+  mData->clear();
+  int n = key.size();
+  n = qMin(n, open.size());
+  n = qMin(n, high.size());
+  n = qMin(n, low.size());
+  n = qMin(n, close.size());
+  for (int i=0; i<n; ++i)
+  {
+    mData->insertMulti(key[i], QCPFinancialData(key[i], open[i], high[i], low[i], close[i]));
+  }
+}
+
+/*!
+  Sets which representation style shall be used to display the OHLC data.
+*/
+void QCPFinancial::setChartStyle(QCPFinancial::ChartStyle style)
+{
+  mChartStyle = style;
+}
+
+/*!
+  Sets the width of the individual bars/candlesticks to \a width in plot key coordinates.
+  
+  A typical choice is to set it to (or slightly less than) one bin interval width.
+*/
+void QCPFinancial::setWidth(double width)
+{
+  mWidth = width;
+}
+
+/*!
+  Sets whether this chart shall contrast positive from negative trends per data point by using two
+  separate colors to draw the respective bars/candlesticks.
+  
+  If \a twoColored is false, the normal plottable's pen and brush are used (\ref setPen, \ref
+  setBrush).
+  
+  \see setPenPositive, setPenNegative, setBrushPositive, setBrushNegative
+*/
+void QCPFinancial::setTwoColored(bool twoColored)
+{
+  mTwoColored = twoColored;
+}
+
+/*!
+  If \ref setTwoColored is set to true, this function controls the brush that is used to draw fills
+  of data points with a positive trend (i.e. bars/candlesticks with close >= open).
+  
+  If \a twoColored is false, the normal plottable's pen and brush are used (\ref setPen, \ref
+  setBrush).
+  
+  \see setBrushNegative, setPenPositive, setPenNegative
+*/
+void QCPFinancial::setBrushPositive(const QBrush &brush)
+{
+  mBrushPositive = brush;
+}
+
+/*!
+  If \ref setTwoColored is set to true, this function controls the brush that is used to draw fills
+  of data points with a negative trend (i.e. bars/candlesticks with close < open).
+  
+  If \a twoColored is false, the normal plottable's pen and brush are used (\ref setPen, \ref
+  setBrush).
+  
+  \see setBrushPositive, setPenNegative, setPenPositive
+*/
+void QCPFinancial::setBrushNegative(const QBrush &brush)
+{
+  mBrushNegative = brush;
+}
+
+/*!
+  If \ref setTwoColored is set to true, this function controls the pen that is used to draw
+  outlines of data points with a positive trend (i.e. bars/candlesticks with close >= open).
+  
+  If \a twoColored is false, the normal plottable's pen and brush are used (\ref setPen, \ref
+  setBrush).
+  
+  \see setPenNegative, setBrushPositive, setBrushNegative
+*/
+void QCPFinancial::setPenPositive(const QPen &pen)
+{
+  mPenPositive = pen;
+}
+
+/*!
+  If \ref setTwoColored is set to true, this function controls the pen that is used to draw
+  outlines of data points with a negative trend (i.e. bars/candlesticks with close < open).
+  
+  If \a twoColored is false, the normal plottable's pen and brush are used (\ref setPen, \ref
+  setBrush).
+  
+  \see setPenPositive, setBrushNegative, setBrushPositive
+*/
+void QCPFinancial::setPenNegative(const QPen &pen)
+{
+  mPenNegative = pen;
+}
+
+/*!
+  Adds the provided data points in \a dataMap to the current data.
+  
+  Alternatively, you can also access and modify the data via the \ref data method, which returns a
+  pointer to the internal \ref QCPFinancialDataMap.
+  
+  \see removeData
+*/
+void QCPFinancial::addData(const QCPFinancialDataMap &dataMap)
+{
+  mData->unite(dataMap);
+}
+
+/*! \overload
+  
+  Adds the provided single data point in \a data to the current data.
+  
+  Alternatively, you can also access and modify the data via the \ref data method, which returns a
+  pointer to the internal \ref QCPFinancialData.
+  
+  \see removeData
+*/
+void QCPFinancial::addData(const QCPFinancialData &data)
+{
+  mData->insertMulti(data.key, data);
+}
+
+/*! \overload
+  
+  Adds the provided single data point given by \a key, \a open, \a high, \a low, and \a close to
+  the current data.
+  
+  Alternatively, you can also access and modify the data via the \ref data method, which returns a
+  pointer to the internal \ref QCPFinancialData.
+  
+  \see removeData
+*/
+void QCPFinancial::addData(double key, double open, double high, double low, double close)
+{
+  mData->insertMulti(key, QCPFinancialData(key, open, high, low, close));
+}
+
+/*! \overload
+  
+  Adds the provided open/high/low/close data to the current data.
+  
+  Alternatively, you can also access and modify the data via the \ref data method, which returns a
+  pointer to the internal \ref QCPFinancialData.
+  
+  \see removeData
+*/
+void QCPFinancial::addData(const QVector<double> &key, const QVector<double> &open, const QVector<double> &high, const QVector<double> &low, const QVector<double> &close)
+{
+  int n = key.size();
+  n = qMin(n, open.size());
+  n = qMin(n, high.size());
+  n = qMin(n, low.size());
+  n = qMin(n, close.size());
+  for (int i=0; i<n; ++i)
+  {
+    mData->insertMulti(key[i], QCPFinancialData(key[i], open[i], high[i], low[i], close[i]));
+  }
+}
+
+/*!
+  Removes all data points with keys smaller than \a key.
+  
+  \see addData, clearData
+*/
+void QCPFinancial::removeDataBefore(double key)
+{
+  QCPFinancialDataMap::iterator it = mData->begin();
+  while (it != mData->end() && it.key() < key)
+    it = mData->erase(it);
+}
+
+/*!
+  Removes all data points with keys greater than \a key.
+  
+  \see addData, clearData
+*/
+void QCPFinancial::removeDataAfter(double key)
+{
+  if (mData->isEmpty()) return;
+  QCPFinancialDataMap::iterator it = mData->upperBound(key);
+  while (it != mData->end())
+    it = mData->erase(it);
+}
+
+/*!
+  Removes all data points with keys between \a fromKey and \a toKey. if \a fromKey is greater or
+  equal to \a toKey, the function does nothing. To remove a single data point with known key, use
+  \ref removeData(double key).
+  
+  \see addData, clearData
+*/
+void QCPFinancial::removeData(double fromKey, double toKey)
+{
+  if (fromKey >= toKey || mData->isEmpty()) return;
+  QCPFinancialDataMap::iterator it = mData->upperBound(fromKey);
+  QCPFinancialDataMap::iterator itEnd = mData->upperBound(toKey);
+  while (it != itEnd)
+    it = mData->erase(it);
+}
+
+/*! \overload
+  
+  Removes a single data point at \a key. If the position is not known with absolute precision,
+  consider using \ref removeData(double fromKey, double toKey) with a small fuzziness interval
+  around the suspected position, depeding on the precision with which the key is known.
+
+  \see addData, clearData
+*/
+void QCPFinancial::removeData(double key)
+{
+  mData->remove(key);
+}
+
+/*!
+  Removes all data points.
+  
+  \see removeData, removeDataAfter, removeDataBefore
+*/
+void QCPFinancial::clearData()
+{
+  mData->clear();
+}
+
+/* inherits documentation from base class */
+double QCPFinancial::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  if (onlySelectable && !mSelectable)
+    return -1;
+  if (!mKeyAxis || !mValueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return -1; }
+  
+  if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))
+  {
+    // get visible data range:
+    QCPFinancialDataMap::const_iterator lower, upper; // note that upper is the actual upper point, and not 1 step after the upper point
+    getVisibleDataBounds(lower, upper);
+    if (lower == mData->constEnd() || upper == mData->constEnd())
+      return -1;
+    // perform select test according to configured style:
+    switch (mChartStyle)
+    {
+      case QCPFinancial::csOhlc:
+        return ohlcSelectTest(pos, lower, upper+1); break;
+      case QCPFinancial::csCandlestick:
+        return candlestickSelectTest(pos, lower, upper+1); break;
+    }
+  }
+  return -1;
+}
+
+/*!
+  A convenience function that converts time series data (\a value against \a time) to OHLC binned
+  data points. The return value can then be passed on to \ref setData.
+  
+  The size of the bins can be controlled with \a timeBinSize in the same units as \a time is given.
+  For example, if the unit of \a time is seconds and single OHLC/Candlesticks should span an hour
+  each, set \a timeBinSize to 3600.
+  
+  \a timeBinOffset allows to control precisely at what \a time coordinate a bin should start. The
+  value passed as \a timeBinOffset doesn't need to be in the range encompassed by the \a time keys.
+  It merely defines the mathematical offset/phase of the bins that will be used to process the
+  data.
+*/
+QCPFinancialDataMap QCPFinancial::timeSeriesToOhlc(const QVector<double> &time, const QVector<double> &value, double timeBinSize, double timeBinOffset)
+{
+  QCPFinancialDataMap map;
+  int count = qMin(time.size(), value.size());
+  if (count == 0)
+    return QCPFinancialDataMap();
+  
+  QCPFinancialData currentBinData(0, value.first(), value.first(), value.first(), value.first());
+  int currentBinIndex = qFloor((time.first()-timeBinOffset)/timeBinSize+0.5);
+  for (int i=0; i<count; ++i)
+  {
+    int index = qFloor((time.at(i)-timeBinOffset)/timeBinSize+0.5);
+    if (currentBinIndex == index) // data point still in current bin, extend high/low:
+    {
+      if (value.at(i) < currentBinData.low) currentBinData.low = value.at(i);
+      if (value.at(i) > currentBinData.high) currentBinData.high = value.at(i);
+      if (i == count-1) // last data point is in current bin, finalize bin:
+      {
+        currentBinData.close = value.at(i);
+        currentBinData.key = timeBinOffset+(index)*timeBinSize;
+        map.insert(currentBinData.key, currentBinData);
+      }
+    } else // data point not anymore in current bin, set close of old and open of new bin, and add old to map:
+    {
+      // finalize current bin:
+      currentBinData.close = value.at(i-1);
+      currentBinData.key = timeBinOffset+(index-1)*timeBinSize;
+      map.insert(currentBinData.key, currentBinData);
+      // start next bin:
+      currentBinIndex = index;
+      currentBinData.open = value.at(i);
+      currentBinData.high = value.at(i);
+      currentBinData.low = value.at(i);
+    }
+  }
+  
+  return map;
+}
+
+/* inherits documentation from base class */
+void QCPFinancial::draw(QCPPainter *painter)
+{
+  // get visible data range:
+  QCPFinancialDataMap::const_iterator lower, upper; // note that upper is the actual upper point, and not 1 step after the upper point
+  getVisibleDataBounds(lower, upper);
+  if (lower == mData->constEnd() || upper == mData->constEnd())
+    return;
+  
+  // draw visible data range according to configured style:
+  switch (mChartStyle)
+  {
+    case QCPFinancial::csOhlc:
+      drawOhlcPlot(painter, lower, upper+1); break;
+    case QCPFinancial::csCandlestick:
+      drawCandlestickPlot(painter, lower, upper+1); break;
+  }
+}
+
+/* inherits documentation from base class */
+void QCPFinancial::drawLegendIcon(QCPPainter *painter, const QRectF &rect) const
+{
+  painter->setAntialiasing(false); // legend icon especially of csCandlestick looks better without antialiasing
+  if (mChartStyle == csOhlc)
+  {
+    if (mTwoColored)
+    {
+      // draw upper left half icon with positive color:
+      painter->setBrush(mBrushPositive);
+      painter->setPen(mPenPositive);
+      painter->setClipRegion(QRegion(QPolygon() << rect.bottomLeft().toPoint() << rect.topRight().toPoint() << rect.topLeft().toPoint()));
+      painter->drawLine(QLineF(0, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));
+      painter->drawLine(QLineF(rect.width()*0.2, rect.height()*0.3, rect.width()*0.2, rect.height()*0.5).translated(rect.topLeft()));
+      painter->drawLine(QLineF(rect.width()*0.8, rect.height()*0.5, rect.width()*0.8, rect.height()*0.7).translated(rect.topLeft()));
+      // draw bottom right hald icon with negative color:
+      painter->setBrush(mBrushNegative);
+      painter->setPen(mPenNegative);
+      painter->setClipRegion(QRegion(QPolygon() << rect.bottomLeft().toPoint() << rect.topRight().toPoint() << rect.bottomRight().toPoint()));
+      painter->drawLine(QLineF(0, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));
+      painter->drawLine(QLineF(rect.width()*0.2, rect.height()*0.3, rect.width()*0.2, rect.height()*0.5).translated(rect.topLeft()));
+      painter->drawLine(QLineF(rect.width()*0.8, rect.height()*0.5, rect.width()*0.8, rect.height()*0.7).translated(rect.topLeft()));
+    } else
+    {
+      painter->setBrush(mBrush);
+      painter->setPen(mPen);
+      painter->drawLine(QLineF(0, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));
+      painter->drawLine(QLineF(rect.width()*0.2, rect.height()*0.3, rect.width()*0.2, rect.height()*0.5).translated(rect.topLeft()));
+      painter->drawLine(QLineF(rect.width()*0.8, rect.height()*0.5, rect.width()*0.8, rect.height()*0.7).translated(rect.topLeft()));
+    }
+  } else if (mChartStyle == csCandlestick)
+  {
+    if (mTwoColored)
+    {
+      // draw upper left half icon with positive color:
+      painter->setBrush(mBrushPositive);
+      painter->setPen(mPenPositive);
+      painter->setClipRegion(QRegion(QPolygon() << rect.bottomLeft().toPoint() << rect.topRight().toPoint() << rect.topLeft().toPoint()));
+      painter->drawLine(QLineF(0, rect.height()*0.5, rect.width()*0.25, rect.height()*0.5).translated(rect.topLeft()));
+      painter->drawLine(QLineF(rect.width()*0.75, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));
+      painter->drawRect(QRectF(rect.width()*0.25, rect.height()*0.25, rect.width()*0.5, rect.height()*0.5).translated(rect.topLeft()));
+      // draw bottom right hald icon with negative color:
+      painter->setBrush(mBrushNegative);
+      painter->setPen(mPenNegative);
+      painter->setClipRegion(QRegion(QPolygon() << rect.bottomLeft().toPoint() << rect.topRight().toPoint() << rect.bottomRight().toPoint()));
+      painter->drawLine(QLineF(0, rect.height()*0.5, rect.width()*0.25, rect.height()*0.5).translated(rect.topLeft()));
+      painter->drawLine(QLineF(rect.width()*0.75, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));
+      painter->drawRect(QRectF(rect.width()*0.25, rect.height()*0.25, rect.width()*0.5, rect.height()*0.5).translated(rect.topLeft()));
+    } else
+    {
+      painter->setBrush(mBrush);
+      painter->setPen(mPen);
+      painter->drawLine(QLineF(0, rect.height()*0.5, rect.width()*0.25, rect.height()*0.5).translated(rect.topLeft()));
+      painter->drawLine(QLineF(rect.width()*0.75, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));
+      painter->drawRect(QRectF(rect.width()*0.25, rect.height()*0.25, rect.width()*0.5, rect.height()*0.5).translated(rect.topLeft()));
+    }
+  }
+}
+
+/* inherits documentation from base class */
+QCPRange QCPFinancial::getKeyRange(bool &foundRange, QCPAbstractPlottable::SignDomain inSignDomain) const
+{
+  QCPRange range;
+  bool haveLower = false;
+  bool haveUpper = false;
+  
+  double current;
+  QCPFinancialDataMap::const_iterator it = mData->constBegin();
+  while (it != mData->constEnd())
+  {
+    current = it.value().key;
+    if (inSignDomain == sdBoth || (inSignDomain == sdNegative && current < 0) || (inSignDomain == sdPositive && current > 0))
+    {
+      if (current < range.lower || !haveLower)
+      {
+        range.lower = current;
+        haveLower = true;
+      }
+      if (current > range.upper || !haveUpper)
+      {
+        range.upper = current;
+        haveUpper = true;
+      }
+    }
+    ++it;
+  }
+  // determine exact range by including width of bars/flags:
+  if (haveLower && mKeyAxis)
+    range.lower = range.lower-mWidth*0.5;
+  if (haveUpper && mKeyAxis)
+    range.upper = range.upper+mWidth*0.5;
+  foundRange = haveLower && haveUpper;
+  return range;
+}
+
+/* inherits documentation from base class */
+QCPRange QCPFinancial::getValueRange(bool &foundRange, QCPAbstractPlottable::SignDomain inSignDomain) const
+{
+  QCPRange range;
+  bool haveLower = false;
+  bool haveUpper = false;
+  
+  QCPFinancialDataMap::const_iterator it = mData->constBegin();
+  while (it != mData->constEnd())
+  {
+    // high:
+    if (inSignDomain == sdBoth || (inSignDomain == sdNegative && it.value().high < 0) || (inSignDomain == sdPositive && it.value().high > 0))
+    {
+      if (it.value().high < range.lower || !haveLower)
+      {
+        range.lower = it.value().high;
+        haveLower = true;
+      }
+      if (it.value().high > range.upper || !haveUpper)
+      {
+        range.upper = it.value().high;
+        haveUpper = true;
+      }
+    }
+    // low:
+    if (inSignDomain == sdBoth || (inSignDomain == sdNegative && it.value().low < 0) || (inSignDomain == sdPositive && it.value().low > 0))
+    {
+      if (it.value().low < range.lower || !haveLower)
+      {
+        range.lower = it.value().low;
+        haveLower = true;
+      }
+      if (it.value().low > range.upper || !haveUpper)
+      {
+        range.upper = it.value().low;
+        haveUpper = true;
+      }
+    }
+    ++it;
+  }
+  
+  foundRange = haveLower && haveUpper;
+  return range;
+}
+
+/*! \internal
+  
+  Draws the data from \a begin to \a end as OHLC bars with the provided \a painter.
+
+  This method is a helper function for \ref draw. It is used when the chart style is \ref csOhlc.
+*/
+void QCPFinancial::drawOhlcPlot(QCPPainter *painter, const QCPFinancialDataMap::const_iterator &begin, const QCPFinancialDataMap::const_iterator &end)
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
+  
+  QPen linePen;
+  
+  if (keyAxis->orientation() == Qt::Horizontal)
+  {
+    for (QCPFinancialDataMap::const_iterator it = begin; it != end; ++it)
+    {
+      if (mSelected)
+        linePen = mSelectedPen;
+      else if (mTwoColored)
+        linePen = it.value().close >= it.value().open ? mPenPositive : mPenNegative;
+      else
+        linePen = mPen;
+      painter->setPen(linePen);
+      double keyPixel = keyAxis->coordToPixel(it.value().key);
+      double openPixel = valueAxis->coordToPixel(it.value().open);
+      double closePixel = valueAxis->coordToPixel(it.value().close);
+      // draw backbone:
+      painter->drawLine(QPointF(keyPixel, valueAxis->coordToPixel(it.value().high)), QPointF(keyPixel, valueAxis->coordToPixel(it.value().low)));
+      // draw open:
+      double keyWidthPixels = keyPixel-keyAxis->coordToPixel(it.value().key-mWidth*0.5); // sign of this makes sure open/close are on correct sides
+      painter->drawLine(QPointF(keyPixel-keyWidthPixels, openPixel), QPointF(keyPixel, openPixel));
+      // draw close:
+      painter->drawLine(QPointF(keyPixel, closePixel), QPointF(keyPixel+keyWidthPixels, closePixel));
+    }
+  } else
+  {
+    for (QCPFinancialDataMap::const_iterator it = begin; it != end; ++it)
+    {
+      if (mSelected)
+        linePen = mSelectedPen;
+      else if (mTwoColored)
+        linePen = it.value().close >= it.value().open ? mPenPositive : mPenNegative;
+      else
+        linePen = mPen;
+      painter->setPen(linePen);
+      double keyPixel = keyAxis->coordToPixel(it.value().key);
+      double openPixel = valueAxis->coordToPixel(it.value().open);
+      double closePixel = valueAxis->coordToPixel(it.value().close);
+      // draw backbone:
+      painter->drawLine(QPointF(valueAxis->coordToPixel(it.value().high), keyPixel), QPointF(valueAxis->coordToPixel(it.value().low), keyPixel));
+      // draw open:
+      double keyWidthPixels = keyPixel-keyAxis->coordToPixel(it.value().key-mWidth*0.5); // sign of this makes sure open/close are on correct sides
+      painter->drawLine(QPointF(openPixel, keyPixel-keyWidthPixels), QPointF(openPixel, keyPixel));
+      // draw close:
+      painter->drawLine(QPointF(closePixel, keyPixel), QPointF(closePixel, keyPixel+keyWidthPixels));
+    }
+  }
+}
+
+/*! \internal
+  
+  Draws the data from \a begin to \a end as Candlesticks with the provided \a painter.
+
+  This method is a helper function for \ref draw. It is used when the chart style is \ref csCandlestick.
+*/
+void QCPFinancial::drawCandlestickPlot(QCPPainter *painter, const QCPFinancialDataMap::const_iterator &begin, const QCPFinancialDataMap::const_iterator &end)
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
+  
+  QPen linePen;
+  QBrush boxBrush;
+  
+  if (keyAxis->orientation() == Qt::Horizontal)
+  {
+    for (QCPFinancialDataMap::const_iterator it = begin; it != end; ++it)
+    {
+      if (mSelected)
+      {
+        linePen = mSelectedPen;
+        boxBrush = mSelectedBrush;
+      } else if (mTwoColored)
+      {
+        if (it.value().close >= it.value().open)
+        {
+          linePen = mPenPositive;
+          boxBrush = mBrushPositive;
+        } else
+        {
+          linePen = mPenNegative;
+          boxBrush = mBrushNegative;
+        }
+      } else
+      {
+        linePen = mPen;
+        boxBrush = mBrush;
+      }
+      painter->setPen(linePen);
+      painter->setBrush(boxBrush);
+      double keyPixel = keyAxis->coordToPixel(it.value().key);
+      double openPixel = valueAxis->coordToPixel(it.value().open);
+      double closePixel = valueAxis->coordToPixel(it.value().close);
+      // draw high:
+      painter->drawLine(QPointF(keyPixel, valueAxis->coordToPixel(it.value().high)), QPointF(keyPixel, valueAxis->coordToPixel(qMax(it.value().open, it.value().close))));
+      // draw low:
+      painter->drawLine(QPointF(keyPixel, valueAxis->coordToPixel(it.value().low)), QPointF(keyPixel, valueAxis->coordToPixel(qMin(it.value().open, it.value().close))));
+      // draw open-close box:
+      double keyWidthPixels = keyPixel-keyAxis->coordToPixel(it.value().key-mWidth*0.5);
+      painter->drawRect(QRectF(QPointF(keyPixel-keyWidthPixels, closePixel), QPointF(keyPixel+keyWidthPixels, openPixel)));
+    }
+  } else // keyAxis->orientation() == Qt::Vertical
+  {
+    for (QCPFinancialDataMap::const_iterator it = begin; it != end; ++it)
+    {
+      if (mSelected)
+      {
+        linePen = mSelectedPen;
+        boxBrush = mSelectedBrush;
+      } else if (mTwoColored)
+      {
+        if (it.value().close >= it.value().open)
+        {
+          linePen = mPenPositive;
+          boxBrush = mBrushPositive;
+        } else
+        {
+          linePen = mPenNegative;
+          boxBrush = mBrushNegative;
+        }
+      } else
+      {
+        linePen = mPen;
+        boxBrush = mBrush;
+      }
+      painter->setPen(linePen);
+      painter->setBrush(boxBrush);
+      double keyPixel = keyAxis->coordToPixel(it.value().key);
+      double openPixel = valueAxis->coordToPixel(it.value().open);
+      double closePixel = valueAxis->coordToPixel(it.value().close);
+      // draw high:
+      painter->drawLine(QPointF(valueAxis->coordToPixel(it.value().high), keyPixel), QPointF(valueAxis->coordToPixel(qMax(it.value().open, it.value().close)), keyPixel));
+      // draw low:
+      painter->drawLine(QPointF(valueAxis->coordToPixel(it.value().low), keyPixel), QPointF(valueAxis->coordToPixel(qMin(it.value().open, it.value().close)), keyPixel));
+      // draw open-close box:
+      double keyWidthPixels = keyPixel-keyAxis->coordToPixel(it.value().key-mWidth*0.5);
+      painter->drawRect(QRectF(QPointF(closePixel, keyPixel-keyWidthPixels), QPointF(openPixel, keyPixel+keyWidthPixels)));
+    }
+  }
+}
+
+/*! \internal
+  
+  This method is a helper function for \ref selectTest. It is used to test for selection when the
+  chart style is \ref csOhlc. It only tests against the data points between \a begin and \a end.
+*/
+double QCPFinancial::ohlcSelectTest(const QPointF &pos, const QCPFinancialDataMap::const_iterator &begin, const QCPFinancialDataMap::const_iterator &end) const
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return -1; }
+
+  double minDistSqr = std::numeric_limits<double>::max();
+  QCPFinancialDataMap::const_iterator it;
+  if (keyAxis->orientation() == Qt::Horizontal)
+  {
+    for (it = begin; it != end; ++it)
+    {
+      double keyPixel = keyAxis->coordToPixel(it.value().key);
+      // calculate distance to backbone:
+      double currentDistSqr = distSqrToLine(QPointF(keyPixel, valueAxis->coordToPixel(it.value().high)), QPointF(keyPixel, valueAxis->coordToPixel(it.value().low)), pos);
+      if (currentDistSqr < minDistSqr)
+        minDistSqr = currentDistSqr;
+    }
+  } else // keyAxis->orientation() == Qt::Vertical
+  {
+    for (it = begin; it != end; ++it)
+    {
+      double keyPixel = keyAxis->coordToPixel(it.value().key);
+      // calculate distance to backbone:
+      double currentDistSqr = distSqrToLine(QPointF(valueAxis->coordToPixel(it.value().high), keyPixel), QPointF(valueAxis->coordToPixel(it.value().low), keyPixel), pos);
+      if (currentDistSqr < minDistSqr)
+        minDistSqr = currentDistSqr;
+    }
+  }
+  return qSqrt(minDistSqr);
+}
+
+/*! \internal
+  
+  This method is a helper function for \ref selectTest. It is used to test for selection when the
+  chart style is \ref csCandlestick. It only tests against the data points between \a begin and \a
+  end.
+*/
+double QCPFinancial::candlestickSelectTest(const QPointF &pos, const QCPFinancialDataMap::const_iterator &begin, const QCPFinancialDataMap::const_iterator &end) const
+{
+  QCPAxis *keyAxis = mKeyAxis.data();
+  QCPAxis *valueAxis = mValueAxis.data();
+  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return -1; }
+
+  double minDistSqr = std::numeric_limits<double>::max();
+  QCPFinancialDataMap::const_iterator it;
+  if (keyAxis->orientation() == Qt::Horizontal)
+  {
+    for (it = begin; it != end; ++it)
+    {
+      double currentDistSqr;
+      // determine whether pos is in open-close-box:
+      QCPRange boxKeyRange(it.value().key-mWidth*0.5, it.value().key+mWidth*0.5);
+      QCPRange boxValueRange(it.value().close, it.value().open);
+      double posKey, posValue;
+      pixelsToCoords(pos, posKey, posValue);
+      if (boxKeyRange.contains(posKey) && boxValueRange.contains(posValue)) // is in open-close-box
+      {
+        currentDistSqr = mParentPlot->selectionTolerance()*0.99 * mParentPlot->selectionTolerance()*0.99;
+      } else
+      {
+        // calculate distance to high/low lines:
+        double keyPixel = keyAxis->coordToPixel(it.value().key);
+        double highLineDistSqr = distSqrToLine(QPointF(keyPixel, valueAxis->coordToPixel(it.value().high)), QPointF(keyPixel, valueAxis->coordToPixel(qMax(it.value().open, it.value().close))), pos);
+        double lowLineDistSqr = distSqrToLine(QPointF(keyPixel, valueAxis->coordToPixel(it.value().low)), QPointF(keyPixel, valueAxis->coordToPixel(qMin(it.value().open, it.value().close))), pos);
+        currentDistSqr = qMin(highLineDistSqr, lowLineDistSqr);
+      }
+      if (currentDistSqr < minDistSqr)
+        minDistSqr = currentDistSqr;
+    }
+  } else // keyAxis->orientation() == Qt::Vertical
+  {
+    for (it = begin; it != end; ++it)
+    {
+      double currentDistSqr;
+      // determine whether pos is in open-close-box:
+      QCPRange boxKeyRange(it.value().key-mWidth*0.5, it.value().key+mWidth*0.5);
+      QCPRange boxValueRange(it.value().close, it.value().open);
+      double posKey, posValue;
+      pixelsToCoords(pos, posKey, posValue);
+      if (boxKeyRange.contains(posKey) && boxValueRange.contains(posValue)) // is in open-close-box
+      {
+        currentDistSqr = mParentPlot->selectionTolerance()*0.99 * mParentPlot->selectionTolerance()*0.99;
+      } else
+      {
+        // calculate distance to high/low lines:
+        double keyPixel = keyAxis->coordToPixel(it.value().key);
+        double highLineDistSqr = distSqrToLine(QPointF(valueAxis->coordToPixel(it.value().high), keyPixel), QPointF(valueAxis->coordToPixel(qMax(it.value().open, it.value().close)), keyPixel), pos);
+        double lowLineDistSqr = distSqrToLine(QPointF(valueAxis->coordToPixel(it.value().low), keyPixel), QPointF(valueAxis->coordToPixel(qMin(it.value().open, it.value().close)), keyPixel), pos);
+        currentDistSqr = qMin(highLineDistSqr, lowLineDistSqr);
+      }
+      if (currentDistSqr < minDistSqr)
+        minDistSqr = currentDistSqr;
+    }
+  }
+  return qSqrt(minDistSqr);
+}
+
+/*!  \internal
+  
+  called by the drawing methods to determine which data (key) range is visible at the current key
+  axis range setting, so only that needs to be processed.
+  
+  \a lower returns an iterator to the lowest data point that needs to be taken into account when
+  plotting. Note that in order to get a clean plot all the way to the edge of the axis rect, \a
+  lower may still be just outside the visible range.
+  
+  \a upper returns an iterator to the highest data point. Same as before, \a upper may also lie
+  just outside of the visible range.
+  
+  if the plottable contains no data, both \a lower and \a upper point to constEnd.
+  
+  \see QCPGraph::getVisibleDataBounds
+*/
+void QCPFinancial::getVisibleDataBounds(QCPFinancialDataMap::const_iterator &lower, QCPFinancialDataMap::const_iterator &upper) const
+{
+  if (!mKeyAxis) { qDebug() << Q_FUNC_INFO << "invalid key axis"; return; }
+  if (mData->isEmpty())
+  {
+    lower = mData->constEnd();
+    upper = mData->constEnd();
+    return;
+  }
+  
+  // get visible data range as QMap iterators
+  QCPFinancialDataMap::const_iterator lbound = mData->lowerBound(mKeyAxis.data()->range().lower);
+  QCPFinancialDataMap::const_iterator ubound = mData->upperBound(mKeyAxis.data()->range().upper);
+  bool lowoutlier = lbound != mData->constBegin(); // indicates whether there exist points below axis range
+  bool highoutlier = ubound != mData->constEnd(); // indicates whether there exist points above axis range
+  
+  lower = (lowoutlier ? lbound-1 : lbound); // data point range that will be actually drawn
+  upper = (highoutlier ? ubound : ubound-1); // data point range that will be actually drawn
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPItemStraightLine
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPItemStraightLine
+  \brief A straight line that spans infinitely in both directions
+
+  \image html QCPItemStraightLine.png "Straight line example. Blue dotted circles are anchors, solid blue discs are positions."
+
+  It has two positions, \a point1 and \a point2, which define the straight line.
+*/
+
+/*!
+  Creates a straight line item and sets default values.
+  
+  The constructed item can be added to the plot with QCustomPlot::addItem.
+*/
+QCPItemStraightLine::QCPItemStraightLine(QCustomPlot *parentPlot) :
+  QCPAbstractItem(parentPlot),
+  point1(createPosition(QLatin1String("point1"))),
+  point2(createPosition(QLatin1String("point2")))
+{
+  point1->setCoords(0, 0);
+  point2->setCoords(1, 1);
+  
+  setPen(QPen(Qt::black));
+  setSelectedPen(QPen(Qt::blue,2));
+}
+
+QCPItemStraightLine::~QCPItemStraightLine()
+{
+}
+
+/*!
+  Sets the pen that will be used to draw the line
+  
+  \see setSelectedPen
+*/
+void QCPItemStraightLine::setPen(const QPen &pen)
+{
+  mPen = pen;
+}
+
+/*!
+  Sets the pen that will be used to draw the line when selected
+  
+  \see setPen, setSelected
+*/
+void QCPItemStraightLine::setSelectedPen(const QPen &pen)
+{
+  mSelectedPen = pen;
+}
+
+/* inherits documentation from base class */
+double QCPItemStraightLine::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  if (onlySelectable && !mSelectable)
+    return -1;
+  
+  return distToStraightLine(QVector2D(point1->pixelPoint()), QVector2D(point2->pixelPoint()-point1->pixelPoint()), QVector2D(pos));
+}
+
+/* inherits documentation from base class */
+void QCPItemStraightLine::draw(QCPPainter *painter)
+{
+  QVector2D start(point1->pixelPoint());
+  QVector2D end(point2->pixelPoint());
+  // get visible segment of straight line inside clipRect:
+  double clipPad = mainPen().widthF();
+  QLineF line = getRectClippedStraightLine(start, end-start, clipRect().adjusted(-clipPad, -clipPad, clipPad, clipPad));
+  // paint visible segment, if existent:
+  if (!line.isNull())
+  {
+    painter->setPen(mainPen());
+    painter->drawLine(line);
+  }
+}
+
+/*! \internal
+
+  finds the shortest distance of \a point to the straight line defined by the base point \a
+  base and the direction vector \a vec.
+  
+  This is a helper function for \ref selectTest.
+*/
+double QCPItemStraightLine::distToStraightLine(const QVector2D &base, const QVector2D &vec, const QVector2D &point) const
+{
+  return qAbs((base.y()-point.y())*vec.x()-(base.x()-point.x())*vec.y())/vec.length();
+}
+
+/*! \internal
+
+  Returns the section of the straight line defined by \a base and direction vector \a
+  vec, that is visible in the specified \a rect.
+  
+  This is a helper function for \ref draw.
+*/
+QLineF QCPItemStraightLine::getRectClippedStraightLine(const QVector2D &base, const QVector2D &vec, const QRect &rect) const
+{
+  double bx, by;
+  double gamma;
+  QLineF result;
+  if (vec.x() == 0 && vec.y() == 0)
+    return result;
+  if (qFuzzyIsNull(vec.x())) // line is vertical
+  {
+    // check top of rect:
+    bx = rect.left();
+    by = rect.top();
+    gamma = base.x()-bx + (by-base.y())*vec.x()/vec.y();
+    if (gamma >= 0 && gamma <= rect.width())
+      result.setLine(bx+gamma, rect.top(), bx+gamma, rect.bottom()); // no need to check bottom because we know line is vertical
+  } else if (qFuzzyIsNull(vec.y())) // line is horizontal
+  {
+    // check left of rect:
+    bx = rect.left();
+    by = rect.top();
+    gamma = base.y()-by + (bx-base.x())*vec.y()/vec.x();
+    if (gamma >= 0 && gamma <= rect.height())
+      result.setLine(rect.left(), by+gamma, rect.right(), by+gamma); // no need to check right because we know line is horizontal
+  } else // line is skewed
+  {
+    QList<QVector2D> pointVectors;
+    // check top of rect:
+    bx = rect.left();
+    by = rect.top();
+    gamma = base.x()-bx + (by-base.y())*vec.x()/vec.y();
+    if (gamma >= 0 && gamma <= rect.width())
+      pointVectors.append(QVector2D(bx+gamma, by));
+    // check bottom of rect:
+    bx = rect.left();
+    by = rect.bottom();
+    gamma = base.x()-bx + (by-base.y())*vec.x()/vec.y();
+    if (gamma >= 0 && gamma <= rect.width())
+      pointVectors.append(QVector2D(bx+gamma, by));
+    // check left of rect:
+    bx = rect.left();
+    by = rect.top();
+    gamma = base.y()-by + (bx-base.x())*vec.y()/vec.x();
+    if (gamma >= 0 && gamma <= rect.height())
+      pointVectors.append(QVector2D(bx, by+gamma));
+    // check right of rect:
+    bx = rect.right();
+    by = rect.top();
+    gamma = base.y()-by + (bx-base.x())*vec.y()/vec.x();
+    if (gamma >= 0 && gamma <= rect.height())
+      pointVectors.append(QVector2D(bx, by+gamma));
+    
+    // evaluate points:
+    if (pointVectors.size() == 2)
+    {
+      result.setPoints(pointVectors.at(0).toPointF(), pointVectors.at(1).toPointF());
+    } else if (pointVectors.size() > 2)
+    {
+      // line probably goes through corner of rect, and we got two points there. single out the point pair with greatest distance:
+      double distSqrMax = 0;
+      QVector2D pv1, pv2;
+      for (int i=0; i<pointVectors.size()-1; ++i)
+      {
+        for (int k=i+1; k<pointVectors.size(); ++k)
+        {
+          double distSqr = (pointVectors.at(i)-pointVectors.at(k)).lengthSquared();
+          if (distSqr > distSqrMax)
+          {
+            pv1 = pointVectors.at(i);
+            pv2 = pointVectors.at(k);
+            distSqrMax = distSqr;
+          }
+        }
+      }
+      result.setPoints(pv1.toPointF(), pv2.toPointF());
+    }
+  }
+  return result;
+}
+
+/*! \internal
+
+  Returns the pen that should be used for drawing lines. Returns mPen when the
+  item is not selected and mSelectedPen when it is.
+*/
+QPen QCPItemStraightLine::mainPen() const
+{
+  return mSelected ? mSelectedPen : mPen;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPItemLine
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPItemLine
+  \brief A line from one point to another
+
+  \image html QCPItemLine.png "Line example. Blue dotted circles are anchors, solid blue discs are positions."
+
+  It has two positions, \a start and \a end, which define the end points of the line.
+  
+  With \ref setHead and \ref setTail you may set different line ending styles, e.g. to create an arrow.
+*/
+
+/*!
+  Creates a line item and sets default values.
+  
+  The constructed item can be added to the plot with QCustomPlot::addItem.
+*/
+QCPItemLine::QCPItemLine(QCustomPlot *parentPlot) :
+  QCPAbstractItem(parentPlot),
+  start(createPosition(QLatin1String("start"))),
+  end(createPosition(QLatin1String("end")))
+{
+  start->setCoords(0, 0);
+  end->setCoords(1, 1);
+  
+  setPen(QPen(Qt::black));
+  setSelectedPen(QPen(Qt::blue,2));
+}
+
+QCPItemLine::~QCPItemLine()
+{
+}
+
+/*!
+  Sets the pen that will be used to draw the line
+  
+  \see setSelectedPen
+*/
+void QCPItemLine::setPen(const QPen &pen)
+{
+  mPen = pen;
+}
+
+/*!
+  Sets the pen that will be used to draw the line when selected
+  
+  \see setPen, setSelected
+*/
+void QCPItemLine::setSelectedPen(const QPen &pen)
+{
+  mSelectedPen = pen;
+}
+
+/*!
+  Sets the line ending style of the head. The head corresponds to the \a end position.
+  
+  Note that due to the overloaded QCPLineEnding constructor, you may directly specify
+  a QCPLineEnding::EndingStyle here, e.g. \code setHead(QCPLineEnding::esSpikeArrow) \endcode
+  
+  \see setTail
+*/
+void QCPItemLine::setHead(const QCPLineEnding &head)
+{
+  mHead = head;
+}
+
+/*!
+  Sets the line ending style of the tail. The tail corresponds to the \a start position.
+  
+  Note that due to the overloaded QCPLineEnding constructor, you may directly specify
+  a QCPLineEnding::EndingStyle here, e.g. \code setTail(QCPLineEnding::esSpikeArrow) \endcode
+  
+  \see setHead
+*/
+void QCPItemLine::setTail(const QCPLineEnding &tail)
+{
+  mTail = tail;
+}
+
+/* inherits documentation from base class */
+double QCPItemLine::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  if (onlySelectable && !mSelectable)
+    return -1;
+  
+  return qSqrt(distSqrToLine(start->pixelPoint(), end->pixelPoint(), pos));
+}
+
+/* inherits documentation from base class */
+void QCPItemLine::draw(QCPPainter *painter)
+{
+  QVector2D startVec(start->pixelPoint());
+  QVector2D endVec(end->pixelPoint());
+  if (startVec.toPoint() == endVec.toPoint())
+    return;
+  // get visible segment of straight line inside clipRect:
+  double clipPad = qMax(mHead.boundingDistance(), mTail.boundingDistance());
+  clipPad = qMax(clipPad, (double)mainPen().widthF());
+  QLineF line = getRectClippedLine(startVec, endVec, clipRect().adjusted(-clipPad, -clipPad, clipPad, clipPad));
+  // paint visible segment, if existent:
+  if (!line.isNull())
+  {
+    painter->setPen(mainPen());
+    painter->drawLine(line);
+    painter->setBrush(Qt::SolidPattern);
+    if (mTail.style() != QCPLineEnding::esNone)
+      mTail.draw(painter, startVec, startVec-endVec);
+    if (mHead.style() != QCPLineEnding::esNone)
+      mHead.draw(painter, endVec, endVec-startVec);
+  }
+}
+
+/*! \internal
+
+  Returns the section of the line defined by \a start and \a end, that is visible in the specified
+  \a rect.
+  
+  This is a helper function for \ref draw.
+*/
+QLineF QCPItemLine::getRectClippedLine(const QVector2D &start, const QVector2D &end, const QRect &rect) const
+{
+  bool containsStart = rect.contains(start.x(), start.y());
+  bool containsEnd = rect.contains(end.x(), end.y());
+  if (containsStart && containsEnd)
+    return QLineF(start.toPointF(), end.toPointF());
+  
+  QVector2D base = start;
+  QVector2D vec = end-start;
+  double bx, by;
+  double gamma, mu;
+  QLineF result;
+  QList<QVector2D> pointVectors;
+
+  if (!qFuzzyIsNull(vec.y())) // line is not horizontal
+  {
+    // check top of rect:
+    bx = rect.left();
+    by = rect.top();
+    mu = (by-base.y())/vec.y();
+    if (mu >= 0 && mu <= 1)
+    {
+      gamma = base.x()-bx + mu*vec.x();
+      if (gamma >= 0 && gamma <= rect.width())
+        pointVectors.append(QVector2D(bx+gamma, by));
+    }
+    // check bottom of rect:
+    bx = rect.left();
+    by = rect.bottom();
+    mu = (by-base.y())/vec.y();
+    if (mu >= 0 && mu <= 1)
+    {
+      gamma = base.x()-bx + mu*vec.x();
+      if (gamma >= 0 && gamma <= rect.width())
+        pointVectors.append(QVector2D(bx+gamma, by));
+    }
+  }
+  if (!qFuzzyIsNull(vec.x())) // line is not vertical
+  {
+    // check left of rect:
+    bx = rect.left();
+    by = rect.top();
+    mu = (bx-base.x())/vec.x();
+    if (mu >= 0 && mu <= 1)
+    {
+      gamma = base.y()-by + mu*vec.y();
+      if (gamma >= 0 && gamma <= rect.height())
+        pointVectors.append(QVector2D(bx, by+gamma));
+    }
+    // check right of rect:
+    bx = rect.right();
+    by = rect.top();
+    mu = (bx-base.x())/vec.x();
+    if (mu >= 0 && mu <= 1)
+    {
+      gamma = base.y()-by + mu*vec.y();
+      if (gamma >= 0 && gamma <= rect.height())
+        pointVectors.append(QVector2D(bx, by+gamma));
+    }
+  }
+  
+  if (containsStart)
+    pointVectors.append(start);
+  if (containsEnd)
+    pointVectors.append(end);
+  
+  // evaluate points:
+  if (pointVectors.size() == 2)
+  {
+    result.setPoints(pointVectors.at(0).toPointF(), pointVectors.at(1).toPointF());
+  } else if (pointVectors.size() > 2)
+  {
+    // line probably goes through corner of rect, and we got two points there. single out the point pair with greatest distance:
+    double distSqrMax = 0;
+    QVector2D pv1, pv2;
+    for (int i=0; i<pointVectors.size()-1; ++i)
+    {
+      for (int k=i+1; k<pointVectors.size(); ++k)
+      {
+        double distSqr = (pointVectors.at(i)-pointVectors.at(k)).lengthSquared();
+        if (distSqr > distSqrMax)
+        {
+          pv1 = pointVectors.at(i);
+          pv2 = pointVectors.at(k);
+          distSqrMax = distSqr;
+        }
+      }
+    }
+    result.setPoints(pv1.toPointF(), pv2.toPointF());
+  }
+  return result;
+}
+
+/*! \internal
+
+  Returns the pen that should be used for drawing lines. Returns mPen when the
+  item is not selected and mSelectedPen when it is.
+*/
+QPen QCPItemLine::mainPen() const
+{
+  return mSelected ? mSelectedPen : mPen;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPItemCurve
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPItemCurve
+  \brief A curved line from one point to another
+
+  \image html QCPItemCurve.png "Curve example. Blue dotted circles are anchors, solid blue discs are positions."
+
+  It has four positions, \a start and \a end, which define the end points of the line, and two
+  control points which define the direction the line exits from the start and the direction from
+  which it approaches the end: \a startDir and \a endDir.
+  
+  With \ref setHead and \ref setTail you may set different line ending styles, e.g. to create an
+  arrow.
+  
+  Often it is desirable for the control points to stay at fixed relative positions to the start/end
+  point. This can be achieved by setting the parent anchor e.g. of \a startDir simply to \a start,
+  and then specify the desired pixel offset with QCPItemPosition::setCoords on \a startDir.
+*/
+
+/*!
+  Creates a curve item and sets default values.
+  
+  The constructed item can be added to the plot with QCustomPlot::addItem.
+*/
+QCPItemCurve::QCPItemCurve(QCustomPlot *parentPlot) :
+  QCPAbstractItem(parentPlot),
+  start(createPosition(QLatin1String("start"))),
+  startDir(createPosition(QLatin1String("startDir"))),
+  endDir(createPosition(QLatin1String("endDir"))),
+  end(createPosition(QLatin1String("end")))
+{
+  start->setCoords(0, 0);
+  startDir->setCoords(0.5, 0);
+  endDir->setCoords(0, 0.5);
+  end->setCoords(1, 1);
+  
+  setPen(QPen(Qt::black));
+  setSelectedPen(QPen(Qt::blue,2));
+}
+
+QCPItemCurve::~QCPItemCurve()
+{
+}
+
+/*!
+  Sets the pen that will be used to draw the line
+  
+  \see setSelectedPen
+*/
+void QCPItemCurve::setPen(const QPen &pen)
+{
+  mPen = pen;
+}
+
+/*!
+  Sets the pen that will be used to draw the line when selected
+  
+  \see setPen, setSelected
+*/
+void QCPItemCurve::setSelectedPen(const QPen &pen)
+{
+  mSelectedPen = pen;
+}
+
+/*!
+  Sets the line ending style of the head. The head corresponds to the \a end position.
+  
+  Note that due to the overloaded QCPLineEnding constructor, you may directly specify
+  a QCPLineEnding::EndingStyle here, e.g. \code setHead(QCPLineEnding::esSpikeArrow) \endcode
+  
+  \see setTail
+*/
+void QCPItemCurve::setHead(const QCPLineEnding &head)
+{
+  mHead = head;
+}
+
+/*!
+  Sets the line ending style of the tail. The tail corresponds to the \a start position.
+  
+  Note that due to the overloaded QCPLineEnding constructor, you may directly specify
+  a QCPLineEnding::EndingStyle here, e.g. \code setTail(QCPLineEnding::esSpikeArrow) \endcode
+  
+  \see setHead
+*/
+void QCPItemCurve::setTail(const QCPLineEnding &tail)
+{
+  mTail = tail;
+}
+
+/* inherits documentation from base class */
+double QCPItemCurve::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  if (onlySelectable && !mSelectable)
+    return -1;
+  
+  QPointF startVec(start->pixelPoint());
+  QPointF startDirVec(startDir->pixelPoint());
+  QPointF endDirVec(endDir->pixelPoint());
+  QPointF endVec(end->pixelPoint());
+
+  QPainterPath cubicPath(startVec);
+  cubicPath.cubicTo(startDirVec, endDirVec, endVec);
+  
+  QPolygonF polygon = cubicPath.toSubpathPolygons().first();
+  double minDistSqr = std::numeric_limits<double>::max();
+  for (int i=1; i<polygon.size(); ++i)
+  {
+    double distSqr = distSqrToLine(polygon.at(i-1), polygon.at(i), pos);
+    if (distSqr < minDistSqr)
+      minDistSqr = distSqr;
+  }
+  return qSqrt(minDistSqr);
+}
+
+/* inherits documentation from base class */
+void QCPItemCurve::draw(QCPPainter *painter)
+{
+  QPointF startVec(start->pixelPoint());
+  QPointF startDirVec(startDir->pixelPoint());
+  QPointF endDirVec(endDir->pixelPoint());
+  QPointF endVec(end->pixelPoint());
+  if (QVector2D(endVec-startVec).length() > 1e10f) // too large curves cause crash
+    return;
+
+  QPainterPath cubicPath(startVec);
+  cubicPath.cubicTo(startDirVec, endDirVec, endVec);
+
+  // paint visible segment, if existent:
+  QRect clip = clipRect().adjusted(-mainPen().widthF(), -mainPen().widthF(), mainPen().widthF(), mainPen().widthF());
+  QRect cubicRect = cubicPath.controlPointRect().toRect();
+  if (cubicRect.isEmpty()) // may happen when start and end exactly on same x or y position
+    cubicRect.adjust(0, 0, 1, 1);
+  if (clip.intersects(cubicRect))
+  {
+    painter->setPen(mainPen());
+    painter->drawPath(cubicPath);
+    painter->setBrush(Qt::SolidPattern);
+    if (mTail.style() != QCPLineEnding::esNone)
+      mTail.draw(painter, QVector2D(startVec), M_PI-cubicPath.angleAtPercent(0)/180.0*M_PI);
+    if (mHead.style() != QCPLineEnding::esNone)
+      mHead.draw(painter, QVector2D(endVec), -cubicPath.angleAtPercent(1)/180.0*M_PI);
+  }
+}
+
+/*! \internal
+
+  Returns the pen that should be used for drawing lines. Returns mPen when the
+  item is not selected and mSelectedPen when it is.
+*/
+QPen QCPItemCurve::mainPen() const
+{
+  return mSelected ? mSelectedPen : mPen;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPItemRect
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPItemRect
+  \brief A rectangle
+
+  \image html QCPItemRect.png "Rectangle example. Blue dotted circles are anchors, solid blue discs are positions."
+
+  It has two positions, \a topLeft and \a bottomRight, which define the rectangle.
+*/
+
+/*!
+  Creates a rectangle item and sets default values.
+  
+  The constructed item can be added to the plot with QCustomPlot::addItem.
+*/
+QCPItemRect::QCPItemRect(QCustomPlot *parentPlot) :
+  QCPAbstractItem(parentPlot),
+  topLeft(createPosition(QLatin1String("topLeft"))),
+  bottomRight(createPosition(QLatin1String("bottomRight"))),
+  top(createAnchor(QLatin1String("top"), aiTop)),
+  topRight(createAnchor(QLatin1String("topRight"), aiTopRight)),
+  right(createAnchor(QLatin1String("right"), aiRight)),
+  bottom(createAnchor(QLatin1String("bottom"), aiBottom)),
+  bottomLeft(createAnchor(QLatin1String("bottomLeft"), aiBottomLeft)),
+  left(createAnchor(QLatin1String("left"), aiLeft))
+{
+  topLeft->setCoords(0, 1);
+  bottomRight->setCoords(1, 0);
+  
+  setPen(QPen(Qt::black));
+  setSelectedPen(QPen(Qt::blue,2));
+  setBrush(Qt::NoBrush);
+  setSelectedBrush(Qt::NoBrush);
+}
+
+QCPItemRect::~QCPItemRect()
+{
+}
+
+/*!
+  Sets the pen that will be used to draw the line of the rectangle
+  
+  \see setSelectedPen, setBrush
+*/
+void QCPItemRect::setPen(const QPen &pen)
+{
+  mPen = pen;
+}
+
+/*!
+  Sets the pen that will be used to draw the line of the rectangle when selected
+  
+  \see setPen, setSelected
+*/
+void QCPItemRect::setSelectedPen(const QPen &pen)
+{
+  mSelectedPen = pen;
+}
+
+/*!
+  Sets the brush that will be used to fill the rectangle. To disable filling, set \a brush to
+  Qt::NoBrush.
+  
+  \see setSelectedBrush, setPen
+*/
+void QCPItemRect::setBrush(const QBrush &brush)
+{
+  mBrush = brush;
+}
+
+/*!
+  Sets the brush that will be used to fill the rectangle when selected. To disable filling, set \a
+  brush to Qt::NoBrush.
+  
+  \see setBrush
+*/
+void QCPItemRect::setSelectedBrush(const QBrush &brush)
+{
+  mSelectedBrush = brush;
+}
+
+/* inherits documentation from base class */
+double QCPItemRect::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  if (onlySelectable && !mSelectable)
+    return -1;
+  
+  QRectF rect = QRectF(topLeft->pixelPoint(), bottomRight->pixelPoint()).normalized();
+  bool filledRect = mBrush.style() != Qt::NoBrush && mBrush.color().alpha() != 0;
+  return rectSelectTest(rect, pos, filledRect);
+}
+
+/* inherits documentation from base class */
+void QCPItemRect::draw(QCPPainter *painter)
+{
+  QPointF p1 = topLeft->pixelPoint();
+  QPointF p2 = bottomRight->pixelPoint();
+  if (p1.toPoint() == p2.toPoint())
+    return;
+  QRectF rect = QRectF(p1, p2).normalized();
+  double clipPad = mainPen().widthF();
+  QRectF boundingRect = rect.adjusted(-clipPad, -clipPad, clipPad, clipPad);
+  if (boundingRect.intersects(clipRect())) // only draw if bounding rect of rect item is visible in cliprect
+  {
+    painter->setPen(mainPen());
+    painter->setBrush(mainBrush());
+    painter->drawRect(rect);
+  }
+}
+
+/* inherits documentation from base class */
+QPointF QCPItemRect::anchorPixelPoint(int anchorId) const
+{
+  QRectF rect = QRectF(topLeft->pixelPoint(), bottomRight->pixelPoint());
+  switch (anchorId)
+  {
+    case aiTop:         return (rect.topLeft()+rect.topRight())*0.5;
+    case aiTopRight:    return rect.topRight();
+    case aiRight:       return (rect.topRight()+rect.bottomRight())*0.5;
+    case aiBottom:      return (rect.bottomLeft()+rect.bottomRight())*0.5;
+    case aiBottomLeft:  return rect.bottomLeft();
+    case aiLeft:        return (rect.topLeft()+rect.bottomLeft())*0.5;
+  }
+  
+  qDebug() << Q_FUNC_INFO << "invalid anchorId" << anchorId;
+  return QPointF();
+}
+
+/*! \internal
+
+  Returns the pen that should be used for drawing lines. Returns mPen when the item is not selected
+  and mSelectedPen when it is.
+*/
+QPen QCPItemRect::mainPen() const
+{
+  return mSelected ? mSelectedPen : mPen;
+}
+
+/*! \internal
+
+  Returns the brush that should be used for drawing fills of the item. Returns mBrush when the item
+  is not selected and mSelectedBrush when it is.
+*/
+QBrush QCPItemRect::mainBrush() const
+{
+  return mSelected ? mSelectedBrush : mBrush;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPItemText
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPItemText
+  \brief A text label
+
+  \image html QCPItemText.png "Text example. Blue dotted circles are anchors, solid blue discs are positions."
+
+  Its position is defined by the member \a position and the setting of \ref setPositionAlignment.
+  The latter controls which part of the text rect shall be aligned with \a position.
+  
+  The text alignment itself (i.e. left, center, right) can be controlled with \ref
+  setTextAlignment.
+  
+  The text may be rotated around the \a position point with \ref setRotation.
+*/
+
+/*!
+  Creates a text item and sets default values.
+  
+  The constructed item can be added to the plot with QCustomPlot::addItem.
+*/
+QCPItemText::QCPItemText(QCustomPlot *parentPlot) :
+  QCPAbstractItem(parentPlot),
+  position(createPosition(QLatin1String("position"))),
+  topLeft(createAnchor(QLatin1String("topLeft"), aiTopLeft)),
+  top(createAnchor(QLatin1String("top"), aiTop)),
+  topRight(createAnchor(QLatin1String("topRight"), aiTopRight)),
+  right(createAnchor(QLatin1String("right"), aiRight)),
+  bottomRight(createAnchor(QLatin1String("bottomRight"), aiBottomRight)),
+  bottom(createAnchor(QLatin1String("bottom"), aiBottom)),
+  bottomLeft(createAnchor(QLatin1String("bottomLeft"), aiBottomLeft)),
+  left(createAnchor(QLatin1String("left"), aiLeft))
+{
+  position->setCoords(0, 0);
+  
+  setRotation(0);
+  setTextAlignment(Qt::AlignTop|Qt::AlignHCenter);
+  setPositionAlignment(Qt::AlignCenter);
+  setText(QLatin1String("text"));
+  
+  setPen(Qt::NoPen);
+  setSelectedPen(Qt::NoPen);
+  setBrush(Qt::NoBrush);
+  setSelectedBrush(Qt::NoBrush);
+  setColor(Qt::black);
+  setSelectedColor(Qt::blue);
+}
+
+QCPItemText::~QCPItemText()
+{
+}
+
+/*!
+  Sets the color of the text.
+*/
+void QCPItemText::setColor(const QColor &color)
+{
+  mColor = color;
+}
+
+/*!
+  Sets the color of the text that will be used when the item is selected.
+*/
+void QCPItemText::setSelectedColor(const QColor &color)
+{
+  mSelectedColor = color;
+}
+
+/*!
+  Sets the pen that will be used do draw a rectangular border around the text. To disable the
+  border, set \a pen to Qt::NoPen.
+  
+  \see setSelectedPen, setBrush, setPadding
+*/
+void QCPItemText::setPen(const QPen &pen)
+{
+  mPen = pen;
+}
+
+/*!
+  Sets the pen that will be used do draw a rectangular border around the text, when the item is
+  selected. To disable the border, set \a pen to Qt::NoPen.
+  
+  \see setPen
+*/
+void QCPItemText::setSelectedPen(const QPen &pen)
+{
+  mSelectedPen = pen;
+}
+
+/*!
+  Sets the brush that will be used do fill the background of the text. To disable the
+  background, set \a brush to Qt::NoBrush.
+  
+  \see setSelectedBrush, setPen, setPadding
+*/
+void QCPItemText::setBrush(const QBrush &brush)
+{
+  mBrush = brush;
+}
+
+/*!
+  Sets the brush that will be used do fill the background of the text, when the item is selected. To disable the
+  background, set \a brush to Qt::NoBrush.
+  
+  \see setBrush
+*/
+void QCPItemText::setSelectedBrush(const QBrush &brush)
+{
+  mSelectedBrush = brush;
+}
+
+/*!
+  Sets the font of the text.
+  
+  \see setSelectedFont, setColor
+*/
+void QCPItemText::setFont(const QFont &font)
+{
+  mFont = font;
+}
+
+/*!
+  Sets the font of the text that will be used when the item is selected.
+  
+  \see setFont
+*/
+void QCPItemText::setSelectedFont(const QFont &font)
+{
+  mSelectedFont = font;
+}
+
+/*!
+  Sets the text that will be displayed. Multi-line texts are supported by inserting a line break
+  character, e.g. '\n'.
+  
+  \see setFont, setColor, setTextAlignment
+*/
+void QCPItemText::setText(const QString &text)
+{
+  mText = text;
+}
+
+/*!
+  Sets which point of the text rect shall be aligned with \a position.
+  
+  Examples:
+  \li If \a alignment is <tt>Qt::AlignHCenter | Qt::AlignTop</tt>, the text will be positioned such
+  that the top of the text rect will be horizontally centered on \a position.
+  \li If \a alignment is <tt>Qt::AlignLeft | Qt::AlignBottom</tt>, \a position will indicate the
+  bottom left corner of the text rect.
+  
+  If you want to control the alignment of (multi-lined) text within the text rect, use \ref
+  setTextAlignment.
+*/
+void QCPItemText::setPositionAlignment(Qt::Alignment alignment)
+{
+  mPositionAlignment = alignment;
+}
+
+/*!
+  Controls how (multi-lined) text is aligned inside the text rect (typically Qt::AlignLeft, Qt::AlignCenter or Qt::AlignRight).
+*/
+void QCPItemText::setTextAlignment(Qt::Alignment alignment)
+{
+  mTextAlignment = alignment;
+}
+
+/*!
+  Sets the angle in degrees by which the text (and the text rectangle, if visible) will be rotated
+  around \a position.
+*/
+void QCPItemText::setRotation(double degrees)
+{
+  mRotation = degrees;
+}
+
+/*!
+  Sets the distance between the border of the text rectangle and the text. The appearance (and
+  visibility) of the text rectangle can be controlled with \ref setPen and \ref setBrush.
+*/
+void QCPItemText::setPadding(const QMargins &padding)
+{
+  mPadding = padding;
+}
+
+/* inherits documentation from base class */
+double QCPItemText::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  if (onlySelectable && !mSelectable)
+    return -1;
+  
+  // The rect may be rotated, so we transform the actual clicked pos to the rotated
+  // coordinate system, so we can use the normal rectSelectTest function for non-rotated rects:
+  QPointF positionPixels(position->pixelPoint());
+  QTransform inputTransform;
+  inputTransform.translate(positionPixels.x(), positionPixels.y());
+  inputTransform.rotate(-mRotation);
+  inputTransform.translate(-positionPixels.x(), -positionPixels.y());
+  QPointF rotatedPos = inputTransform.map(pos);
+  QFontMetrics fontMetrics(mFont);
+  QRect textRect = fontMetrics.boundingRect(0, 0, 0, 0, Qt::TextDontClip|mTextAlignment, mText);
+  QRect textBoxRect = textRect.adjusted(-mPadding.left(), -mPadding.top(), mPadding.right(), mPadding.bottom());
+  QPointF textPos = getTextDrawPoint(positionPixels, textBoxRect, mPositionAlignment);
+  textBoxRect.moveTopLeft(textPos.toPoint());
+
+  return rectSelectTest(textBoxRect, rotatedPos, true);
+}
+
+/* inherits documentation from base class */
+void QCPItemText::draw(QCPPainter *painter)
+{
+  QPointF pos(position->pixelPoint());
+  QTransform transform = painter->transform();
+  transform.translate(pos.x(), pos.y());
+  if (!qFuzzyIsNull(mRotation))
+    transform.rotate(mRotation);
+  painter->setFont(mainFont());
+  QRect textRect = painter->fontMetrics().boundingRect(0, 0, 0, 0, Qt::TextDontClip|mTextAlignment, mText);
+  QRect textBoxRect = textRect.adjusted(-mPadding.left(), -mPadding.top(), mPadding.right(), mPadding.bottom());
+  QPointF textPos = getTextDrawPoint(QPointF(0, 0), textBoxRect, mPositionAlignment); // 0, 0 because the transform does the translation
+  textRect.moveTopLeft(textPos.toPoint()+QPoint(mPadding.left(), mPadding.top()));
+  textBoxRect.moveTopLeft(textPos.toPoint());
+  double clipPad = mainPen().widthF();
+  QRect boundingRect = textBoxRect.adjusted(-clipPad, -clipPad, clipPad, clipPad);
+  if (transform.mapRect(boundingRect).intersects(painter->transform().mapRect(clipRect())))
+  {
+    painter->setTransform(transform);
+    if ((mainBrush().style() != Qt::NoBrush && mainBrush().color().alpha() != 0) ||
+        (mainPen().style() != Qt::NoPen && mainPen().color().alpha() != 0))
+    {
+      painter->setPen(mainPen());
+      painter->setBrush(mainBrush());
+      painter->drawRect(textBoxRect);
+    }
+    painter->setBrush(Qt::NoBrush);
+    painter->setPen(QPen(mainColor()));
+    painter->drawText(textRect, Qt::TextDontClip|mTextAlignment, mText);
+  }
+}
+
+/* inherits documentation from base class */
+QPointF QCPItemText::anchorPixelPoint(int anchorId) const
+{
+  // get actual rect points (pretty much copied from draw function):
+  QPointF pos(position->pixelPoint());
+  QTransform transform;
+  transform.translate(pos.x(), pos.y());
+  if (!qFuzzyIsNull(mRotation))
+    transform.rotate(mRotation);
+  QFontMetrics fontMetrics(mainFont());
+  QRect textRect = fontMetrics.boundingRect(0, 0, 0, 0, Qt::TextDontClip|mTextAlignment, mText);
+  QRectF textBoxRect = textRect.adjusted(-mPadding.left(), -mPadding.top(), mPadding.right(), mPadding.bottom());
+  QPointF textPos = getTextDrawPoint(QPointF(0, 0), textBoxRect, mPositionAlignment); // 0, 0 because the transform does the translation
+  textBoxRect.moveTopLeft(textPos.toPoint());
+  QPolygonF rectPoly = transform.map(QPolygonF(textBoxRect));
+  
+  switch (anchorId)
+  {
+    case aiTopLeft:     return rectPoly.at(0);
+    case aiTop:         return (rectPoly.at(0)+rectPoly.at(1))*0.5;
+    case aiTopRight:    return rectPoly.at(1);
+    case aiRight:       return (rectPoly.at(1)+rectPoly.at(2))*0.5;
+    case aiBottomRight: return rectPoly.at(2);
+    case aiBottom:      return (rectPoly.at(2)+rectPoly.at(3))*0.5;
+    case aiBottomLeft:  return rectPoly.at(3);
+    case aiLeft:        return (rectPoly.at(3)+rectPoly.at(0))*0.5;
+  }
+  
+  qDebug() << Q_FUNC_INFO << "invalid anchorId" << anchorId;
+  return QPointF();
+}
+
+/*! \internal
+  
+  Returns the point that must be given to the QPainter::drawText function (which expects the top
+  left point of the text rect), according to the position \a pos, the text bounding box \a rect and
+  the requested \a positionAlignment.
+  
+  For example, if \a positionAlignment is <tt>Qt::AlignLeft | Qt::AlignBottom</tt> the returned point
+  will be shifted upward by the height of \a rect, starting from \a pos. So if the text is finally
+  drawn at that point, the lower left corner of the resulting text rect is at \a pos.
+*/
+QPointF QCPItemText::getTextDrawPoint(const QPointF &pos, const QRectF &rect, Qt::Alignment positionAlignment) const
+{
+  if (positionAlignment == 0 || positionAlignment == (Qt::AlignLeft|Qt::AlignTop))
+    return pos;
+  
+  QPointF result = pos; // start at top left
+  if (positionAlignment.testFlag(Qt::AlignHCenter))
+    result.rx() -= rect.width()/2.0;
+  else if (positionAlignment.testFlag(Qt::AlignRight))
+    result.rx() -= rect.width();
+  if (positionAlignment.testFlag(Qt::AlignVCenter))
+    result.ry() -= rect.height()/2.0;
+  else if (positionAlignment.testFlag(Qt::AlignBottom))
+    result.ry() -= rect.height();
+  return result;
+}
+
+/*! \internal
+
+  Returns the font that should be used for drawing text. Returns mFont when the item is not selected
+  and mSelectedFont when it is.
+*/
+QFont QCPItemText::mainFont() const
+{
+  return mSelected ? mSelectedFont : mFont;
+}
+
+/*! \internal
+
+  Returns the color that should be used for drawing text. Returns mColor when the item is not
+  selected and mSelectedColor when it is.
+*/
+QColor QCPItemText::mainColor() const
+{
+  return mSelected ? mSelectedColor : mColor;
+}
+
+/*! \internal
+
+  Returns the pen that should be used for drawing lines. Returns mPen when the item is not selected
+  and mSelectedPen when it is.
+*/
+QPen QCPItemText::mainPen() const
+{
+  return mSelected ? mSelectedPen : mPen;
+}
+
+/*! \internal
+
+  Returns the brush that should be used for drawing fills of the item. Returns mBrush when the item
+  is not selected and mSelectedBrush when it is.
+*/
+QBrush QCPItemText::mainBrush() const
+{
+  return mSelected ? mSelectedBrush : mBrush;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPItemEllipse
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPItemEllipse
+  \brief An ellipse
+
+  \image html QCPItemEllipse.png "Ellipse example. Blue dotted circles are anchors, solid blue discs are positions."
+
+  It has two positions, \a topLeft and \a bottomRight, which define the rect the ellipse will be drawn in.
+*/
+
+/*!
+  Creates an ellipse item and sets default values.
+  
+  The constructed item can be added to the plot with QCustomPlot::addItem.
+*/
+QCPItemEllipse::QCPItemEllipse(QCustomPlot *parentPlot) :
+  QCPAbstractItem(parentPlot),
+  topLeft(createPosition(QLatin1String("topLeft"))),
+  bottomRight(createPosition(QLatin1String("bottomRight"))),
+  topLeftRim(createAnchor(QLatin1String("topLeftRim"), aiTopLeftRim)),
+  top(createAnchor(QLatin1String("top"), aiTop)),
+  topRightRim(createAnchor(QLatin1String("topRightRim"), aiTopRightRim)),
+  right(createAnchor(QLatin1String("right"), aiRight)),
+  bottomRightRim(createAnchor(QLatin1String("bottomRightRim"), aiBottomRightRim)),
+  bottom(createAnchor(QLatin1String("bottom"), aiBottom)),
+  bottomLeftRim(createAnchor(QLatin1String("bottomLeftRim"), aiBottomLeftRim)),
+  left(createAnchor(QLatin1String("left"), aiLeft)),
+  center(createAnchor(QLatin1String("center"), aiCenter))
+{
+  topLeft->setCoords(0, 1);
+  bottomRight->setCoords(1, 0);
+  
+  setPen(QPen(Qt::black));
+  setSelectedPen(QPen(Qt::blue, 2));
+  setBrush(Qt::NoBrush);
+  setSelectedBrush(Qt::NoBrush);
+}
+
+QCPItemEllipse::~QCPItemEllipse()
+{
+}
+
+/*!
+  Sets the pen that will be used to draw the line of the ellipse
+  
+  \see setSelectedPen, setBrush
+*/
+void QCPItemEllipse::setPen(const QPen &pen)
+{
+  mPen = pen;
+}
+
+/*!
+  Sets the pen that will be used to draw the line of the ellipse when selected
+  
+  \see setPen, setSelected
+*/
+void QCPItemEllipse::setSelectedPen(const QPen &pen)
+{
+  mSelectedPen = pen;
+}
+
+/*!
+  Sets the brush that will be used to fill the ellipse. To disable filling, set \a brush to
+  Qt::NoBrush.
+  
+  \see setSelectedBrush, setPen
+*/
+void QCPItemEllipse::setBrush(const QBrush &brush)
+{
+  mBrush = brush;
+}
+
+/*!
+  Sets the brush that will be used to fill the ellipse when selected. To disable filling, set \a
+  brush to Qt::NoBrush.
+  
+  \see setBrush
+*/
+void QCPItemEllipse::setSelectedBrush(const QBrush &brush)
+{
+  mSelectedBrush = brush;
+}
+
+/* inherits documentation from base class */
+double QCPItemEllipse::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  if (onlySelectable && !mSelectable)
+    return -1;
+  
+  double result = -1;
+  QPointF p1 = topLeft->pixelPoint();
+  QPointF p2 = bottomRight->pixelPoint();
+  QPointF center((p1+p2)/2.0);
+  double a = qAbs(p1.x()-p2.x())/2.0;
+  double b = qAbs(p1.y()-p2.y())/2.0;
+  double x = pos.x()-center.x();
+  double y = pos.y()-center.y();
+  
+  // distance to border:
+  double c = 1.0/qSqrt(x*x/(a*a)+y*y/(b*b));
+  result = qAbs(c-1)*qSqrt(x*x+y*y);
+  // filled ellipse, allow click inside to count as hit:
+  if (result > mParentPlot->selectionTolerance()*0.99 && mBrush.style() != Qt::NoBrush && mBrush.color().alpha() != 0)
+  {
+    if (x*x/(a*a) + y*y/(b*b) <= 1)
+      result = mParentPlot->selectionTolerance()*0.99;
+  }
+  return result;
+}
+
+/* inherits documentation from base class */
+void QCPItemEllipse::draw(QCPPainter *painter)
+{
+  QPointF p1 = topLeft->pixelPoint();
+  QPointF p2 = bottomRight->pixelPoint();
+  if (p1.toPoint() == p2.toPoint())
+    return;
+  QRectF ellipseRect = QRectF(p1, p2).normalized();
+  QRect clip = clipRect().adjusted(-mainPen().widthF(), -mainPen().widthF(), mainPen().widthF(), mainPen().widthF());
+  if (ellipseRect.intersects(clip)) // only draw if bounding rect of ellipse is visible in cliprect
+  {
+    painter->setPen(mainPen());
+    painter->setBrush(mainBrush());
+#ifdef __EXCEPTIONS
+    try // drawEllipse sometimes throws exceptions if ellipse is too big
+    {
+#endif
+      painter->drawEllipse(ellipseRect);
+#ifdef __EXCEPTIONS
+    } catch (...)
+    {
+      qDebug() << Q_FUNC_INFO << "Item too large for memory, setting invisible";
+      setVisible(false);
+    }
+#endif
+  }
+}
+
+/* inherits documentation from base class */
+QPointF QCPItemEllipse::anchorPixelPoint(int anchorId) const
+{
+  QRectF rect = QRectF(topLeft->pixelPoint(), bottomRight->pixelPoint());
+  switch (anchorId)
+  {
+    case aiTopLeftRim:     return rect.center()+(rect.topLeft()-rect.center())*1/qSqrt(2);
+    case aiTop:            return (rect.topLeft()+rect.topRight())*0.5;
+    case aiTopRightRim:    return rect.center()+(rect.topRight()-rect.center())*1/qSqrt(2);
+    case aiRight:          return (rect.topRight()+rect.bottomRight())*0.5;
+    case aiBottomRightRim: return rect.center()+(rect.bottomRight()-rect.center())*1/qSqrt(2);
+    case aiBottom:         return (rect.bottomLeft()+rect.bottomRight())*0.5;
+    case aiBottomLeftRim:  return rect.center()+(rect.bottomLeft()-rect.center())*1/qSqrt(2);
+    case aiLeft:           return (rect.topLeft()+rect.bottomLeft())*0.5;
+    case aiCenter:         return (rect.topLeft()+rect.bottomRight())*0.5;
+  }
+  
+  qDebug() << Q_FUNC_INFO << "invalid anchorId" << anchorId;
+  return QPointF();
+}
+
+/*! \internal
+
+  Returns the pen that should be used for drawing lines. Returns mPen when the item is not selected
+  and mSelectedPen when it is.
+*/
+QPen QCPItemEllipse::mainPen() const
+{
+  return mSelected ? mSelectedPen : mPen;
+}
+
+/*! \internal
+
+  Returns the brush that should be used for drawing fills of the item. Returns mBrush when the item
+  is not selected and mSelectedBrush when it is.
+*/
+QBrush QCPItemEllipse::mainBrush() const
+{
+  return mSelected ? mSelectedBrush : mBrush;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPItemPixmap
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPItemPixmap
+  \brief An arbitrary pixmap
+
+  \image html QCPItemPixmap.png "Pixmap example. Blue dotted circles are anchors, solid blue discs are positions."
+
+  It has two positions, \a topLeft and \a bottomRight, which define the rectangle the pixmap will
+  be drawn in. Depending on the scale setting (\ref setScaled), the pixmap will be either scaled to
+  fit the rectangle or be drawn aligned to the topLeft position.
+  
+  If scaling is enabled and \a topLeft is further to the bottom/right than \a bottomRight (as shown
+  on the right side of the example image), the pixmap will be flipped in the respective
+  orientations.
+*/
+
+/*!
+  Creates a rectangle item and sets default values.
+  
+  The constructed item can be added to the plot with QCustomPlot::addItem.
+*/
+QCPItemPixmap::QCPItemPixmap(QCustomPlot *parentPlot) :
+  QCPAbstractItem(parentPlot),
+  topLeft(createPosition(QLatin1String("topLeft"))),
+  bottomRight(createPosition(QLatin1String("bottomRight"))),
+  top(createAnchor(QLatin1String("top"), aiTop)),
+  topRight(createAnchor(QLatin1String("topRight"), aiTopRight)),
+  right(createAnchor(QLatin1String("right"), aiRight)),
+  bottom(createAnchor(QLatin1String("bottom"), aiBottom)),
+  bottomLeft(createAnchor(QLatin1String("bottomLeft"), aiBottomLeft)),
+  left(createAnchor(QLatin1String("left"), aiLeft)),
+  mScaledPixmapInvalidated(true)
+{
+  topLeft->setCoords(0, 1);
+  bottomRight->setCoords(1, 0);
+  
+  setPen(Qt::NoPen);
+  setSelectedPen(QPen(Qt::blue));
+  setScaled(false, Qt::KeepAspectRatio, Qt::SmoothTransformation);
+}
+
+QCPItemPixmap::~QCPItemPixmap()
+{
+}
+
+/*!
+  Sets the pixmap that will be displayed.
+*/
+void QCPItemPixmap::setPixmap(const QPixmap &pixmap)
+{
+  mPixmap = pixmap;
+  mScaledPixmapInvalidated = true;
+  if (mPixmap.isNull())
+    qDebug() << Q_FUNC_INFO << "pixmap is null";
+}
+
+/*!
+  Sets whether the pixmap will be scaled to fit the rectangle defined by the \a topLeft and \a
+  bottomRight positions.
+*/
+void QCPItemPixmap::setScaled(bool scaled, Qt::AspectRatioMode aspectRatioMode, Qt::TransformationMode transformationMode)
+{
+  mScaled = scaled;
+  mAspectRatioMode = aspectRatioMode;
+  mTransformationMode = transformationMode;
+  mScaledPixmapInvalidated = true;
+}
+
+/*!
+  Sets the pen that will be used to draw a border around the pixmap.
+  
+  \see setSelectedPen, setBrush
+*/
+void QCPItemPixmap::setPen(const QPen &pen)
+{
+  mPen = pen;
+}
+
+/*!
+  Sets the pen that will be used to draw a border around the pixmap when selected
+  
+  \see setPen, setSelected
+*/
+void QCPItemPixmap::setSelectedPen(const QPen &pen)
+{
+  mSelectedPen = pen;
+}
+
+/* inherits documentation from base class */
+double QCPItemPixmap::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  if (onlySelectable && !mSelectable)
+    return -1;
+  
+  return rectSelectTest(getFinalRect(), pos, true);
+}
+
+/* inherits documentation from base class */
+void QCPItemPixmap::draw(QCPPainter *painter)
+{
+  bool flipHorz = false;
+  bool flipVert = false;
+  QRect rect = getFinalRect(&flipHorz, &flipVert);
+  double clipPad = mainPen().style() == Qt::NoPen ? 0 : mainPen().widthF();
+  QRect boundingRect = rect.adjusted(-clipPad, -clipPad, clipPad, clipPad);
+  if (boundingRect.intersects(clipRect()))
+  {
+    updateScaledPixmap(rect, flipHorz, flipVert);
+    painter->drawPixmap(rect.topLeft(), mScaled ? mScaledPixmap : mPixmap);
+    QPen pen = mainPen();
+    if (pen.style() != Qt::NoPen)
+    {
+      painter->setPen(pen);
+      painter->setBrush(Qt::NoBrush);
+      painter->drawRect(rect);
+    }
+  }
+}
+
+/* inherits documentation from base class */
+QPointF QCPItemPixmap::anchorPixelPoint(int anchorId) const
+{
+  bool flipHorz;
+  bool flipVert;
+  QRect rect = getFinalRect(&flipHorz, &flipVert);
+  // we actually want denormal rects (negative width/height) here, so restore
+  // the flipped state:
+  if (flipHorz)
+    rect.adjust(rect.width(), 0, -rect.width(), 0);
+  if (flipVert)
+    rect.adjust(0, rect.height(), 0, -rect.height());
+  
+  switch (anchorId)
+  {
+    case aiTop:         return (rect.topLeft()+rect.topRight())*0.5;
+    case aiTopRight:    return rect.topRight();
+    case aiRight:       return (rect.topRight()+rect.bottomRight())*0.5;
+    case aiBottom:      return (rect.bottomLeft()+rect.bottomRight())*0.5;
+    case aiBottomLeft:  return rect.bottomLeft();
+    case aiLeft:        return (rect.topLeft()+rect.bottomLeft())*0.5;;
+  }
+  
+  qDebug() << Q_FUNC_INFO << "invalid anchorId" << anchorId;
+  return QPointF();
+}
+
+/*! \internal
+  
+  Creates the buffered scaled image (\a mScaledPixmap) to fit the specified \a finalRect. The
+  parameters \a flipHorz and \a flipVert control whether the resulting image shall be flipped
+  horizontally or vertically. (This is used when \a topLeft is further to the bottom/right than \a
+  bottomRight.)
+  
+  This function only creates the scaled pixmap when the buffered pixmap has a different size than
+  the expected result, so calling this function repeatedly, e.g. in the \ref draw function, does
+  not cause expensive rescaling every time.
+  
+  If scaling is disabled, sets mScaledPixmap to a null QPixmap.
+*/
+void QCPItemPixmap::updateScaledPixmap(QRect finalRect, bool flipHorz, bool flipVert)
+{
+  if (mPixmap.isNull())
+    return;
+  
+  if (mScaled)
+  {
+    if (finalRect.isNull())
+      finalRect = getFinalRect(&flipHorz, &flipVert);
+    if (mScaledPixmapInvalidated || finalRect.size() != mScaledPixmap.size())
+    {
+      mScaledPixmap = mPixmap.scaled(finalRect.size(), mAspectRatioMode, mTransformationMode);
+      if (flipHorz || flipVert)
+        mScaledPixmap = QPixmap::fromImage(mScaledPixmap.toImage().mirrored(flipHorz, flipVert));
+    }
+  } else if (!mScaledPixmap.isNull())
+    mScaledPixmap = QPixmap();
+  mScaledPixmapInvalidated = false;
+}
+
+/*! \internal
+  
+  Returns the final (tight) rect the pixmap is drawn in, depending on the current item positions
+  and scaling settings.
+  
+  The output parameters \a flippedHorz and \a flippedVert return whether the pixmap should be drawn
+  flipped horizontally or vertically in the returned rect. (The returned rect itself is always
+  normalized, i.e. the top left corner of the rect is actually further to the top/left than the
+  bottom right corner). This is the case when the item position \a topLeft is further to the
+  bottom/right than \a bottomRight.
+  
+  If scaling is disabled, returns a rect with size of the original pixmap and the top left corner
+  aligned with the item position \a topLeft. The position \a bottomRight is ignored.
+*/
+QRect QCPItemPixmap::getFinalRect(bool *flippedHorz, bool *flippedVert) const
+{
+  QRect result;
+  bool flipHorz = false;
+  bool flipVert = false;
+  QPoint p1 = topLeft->pixelPoint().toPoint();
+  QPoint p2 = bottomRight->pixelPoint().toPoint();
+  if (p1 == p2)
+    return QRect(p1, QSize(0, 0));
+  if (mScaled)
+  {
+    QSize newSize = QSize(p2.x()-p1.x(), p2.y()-p1.y());
+    QPoint topLeft = p1;
+    if (newSize.width() < 0)
+    {
+      flipHorz = true;
+      newSize.rwidth() *= -1;
+      topLeft.setX(p2.x());
+    }
+    if (newSize.height() < 0)
+    {
+      flipVert = true;
+      newSize.rheight() *= -1;
+      topLeft.setY(p2.y());
+    }
+    QSize scaledSize = mPixmap.size();
+    scaledSize.scale(newSize, mAspectRatioMode);
+    result = QRect(topLeft, scaledSize);
+  } else
+  {
+    result = QRect(p1, mPixmap.size());
+  }
+  if (flippedHorz)
+    *flippedHorz = flipHorz;
+  if (flippedVert)
+    *flippedVert = flipVert;
+  return result;
+}
+
+/*! \internal
+
+  Returns the pen that should be used for drawing lines. Returns mPen when the item is not selected
+  and mSelectedPen when it is.
+*/
+QPen QCPItemPixmap::mainPen() const
+{
+  return mSelected ? mSelectedPen : mPen;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPItemTracer
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPItemTracer
+  \brief Item that sticks to QCPGraph data points
+
+  \image html QCPItemTracer.png "Tracer example. Blue dotted circles are anchors, solid blue discs are positions."
+
+  The tracer can be connected with a QCPGraph via \ref setGraph. Then it will automatically adopt
+  the coordinate axes of the graph and update its \a position to be on the graph's data. This means
+  the key stays controllable via \ref setGraphKey, but the value will follow the graph data. If a
+  QCPGraph is connected, note that setting the coordinates of the tracer item directly via \a
+  position will have no effect because they will be overriden in the next redraw (this is when the
+  coordinate update happens).
+  
+  If the specified key in \ref setGraphKey is outside the key bounds of the graph, the tracer will
+  stay at the corresponding end of the graph.
+  
+  With \ref setInterpolating you may specify whether the tracer may only stay exactly on data
+  points or whether it interpolates data points linearly, if given a key that lies between two data
+  points of the graph.
+  
+  The tracer has different visual styles, see \ref setStyle. It is also possible to make the tracer
+  have no own visual appearance (set the style to \ref tsNone), and just connect other item
+  positions to the tracer \a position (used as an anchor) via \ref
+  QCPItemPosition::setParentAnchor.
+  
+  \note The tracer position is only automatically updated upon redraws. So when the data of the
+  graph changes and immediately afterwards (without a redraw) the a position coordinates of the
+  tracer are retrieved, they will not reflect the updated data of the graph. In this case \ref
+  updatePosition must be called manually, prior to reading the tracer coordinates.
+*/
+
+/*!
+  Creates a tracer item and sets default values.
+  
+  The constructed item can be added to the plot with QCustomPlot::addItem.
+*/
+QCPItemTracer::QCPItemTracer(QCustomPlot *parentPlot) :
+  QCPAbstractItem(parentPlot),
+  position(createPosition(QLatin1String("position"))),
+  mGraph(0)
+{
+  position->setCoords(0, 0);
+
+  setBrush(Qt::NoBrush);
+  setSelectedBrush(Qt::NoBrush);
+  setPen(QPen(Qt::black));
+  setSelectedPen(QPen(Qt::blue, 2));
+  setStyle(tsCrosshair);
+  setSize(6);
+  setInterpolating(false);
+  setGraphKey(0);
+}
+
+QCPItemTracer::~QCPItemTracer()
+{
+}
+
+/*!
+  Sets the pen that will be used to draw the line of the tracer
+  
+  \see setSelectedPen, setBrush
+*/
+void QCPItemTracer::setPen(const QPen &pen)
+{
+  mPen = pen;
+}
+
+/*!
+  Sets the pen that will be used to draw the line of the tracer when selected
+  
+  \see setPen, setSelected
+*/
+void QCPItemTracer::setSelectedPen(const QPen &pen)
+{
+  mSelectedPen = pen;
+}
+
+/*!
+  Sets the brush that will be used to draw any fills of the tracer
+  
+  \see setSelectedBrush, setPen
+*/
+void QCPItemTracer::setBrush(const QBrush &brush)
+{
+  mBrush = brush;
+}
+
+/*!
+  Sets the brush that will be used to draw any fills of the tracer, when selected.
+  
+  \see setBrush, setSelected
+*/
+void QCPItemTracer::setSelectedBrush(const QBrush &brush)
+{
+  mSelectedBrush = brush;
+}
+
+/*!
+  Sets the size of the tracer in pixels, if the style supports setting a size (e.g. \ref tsSquare
+  does, \ref tsCrosshair does not).
+*/
+void QCPItemTracer::setSize(double size)
+{
+  mSize = size;
+}
+
+/*!
+  Sets the style/visual appearance of the tracer.
+  
+  If you only want to use the tracer \a position as an anchor for other items, set \a style to
+  \ref tsNone.
+*/
+void QCPItemTracer::setStyle(QCPItemTracer::TracerStyle style)
+{
+  mStyle = style;
+}
+
+/*!
+  Sets the QCPGraph this tracer sticks to. The tracer \a position will be set to type
+  QCPItemPosition::ptPlotCoords and the axes will be set to the axes of \a graph.
+  
+  To free the tracer from any graph, set \a graph to 0. The tracer \a position can then be placed
+  freely like any other item position. This is the state the tracer will assume when its graph gets
+  deleted while still attached to it.
+  
+  \see setGraphKey
+*/
+void QCPItemTracer::setGraph(QCPGraph *graph)
+{
+  if (graph)
+  {
+    if (graph->parentPlot() == mParentPlot)
+    {
+      position->setType(QCPItemPosition::ptPlotCoords);
+      position->setAxes(graph->keyAxis(), graph->valueAxis());
+      mGraph = graph;
+      updatePosition();
+    } else
+      qDebug() << Q_FUNC_INFO << "graph isn't in same QCustomPlot instance as this item";
+  } else
+  {
+    mGraph = 0;
+  }
+}
+
+/*!
+  Sets the key of the graph's data point the tracer will be positioned at. This is the only free
+  coordinate of a tracer when attached to a graph.
+  
+  Depending on \ref setInterpolating, the tracer will be either positioned on the data point
+  closest to \a key, or will stay exactly at \a key and interpolate the value linearly.
+  
+  \see setGraph, setInterpolating
+*/
+void QCPItemTracer::setGraphKey(double key)
+{
+  mGraphKey = key;
+}
+
+/*!
+  Sets whether the value of the graph's data points shall be interpolated, when positioning the
+  tracer.
+  
+  If \a enabled is set to false and a key is given with \ref setGraphKey, the tracer is placed on
+  the data point of the graph which is closest to the key, but which is not necessarily exactly
+  there. If \a enabled is true, the tracer will be positioned exactly at the specified key, and
+  the appropriate value will be interpolated from the graph's data points linearly.
+  
+  \see setGraph, setGraphKey
+*/
+void QCPItemTracer::setInterpolating(bool enabled)
+{
+  mInterpolating = enabled;
+}
+
+/* inherits documentation from base class */
+double QCPItemTracer::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  if (onlySelectable && !mSelectable)
+    return -1;
+
+  QPointF center(position->pixelPoint());
+  double w = mSize/2.0;
+  QRect clip = clipRect();
+  switch (mStyle)
+  {
+    case tsNone: return -1;
+    case tsPlus:
+    {
+      if (clipRect().intersects(QRectF(center-QPointF(w, w), center+QPointF(w, w)).toRect()))
+        return qSqrt(qMin(distSqrToLine(center+QPointF(-w, 0), center+QPointF(w, 0), pos),
+                          distSqrToLine(center+QPointF(0, -w), center+QPointF(0, w), pos)));
+      break;
+    }
+    case tsCrosshair:
+    {
+      return qSqrt(qMin(distSqrToLine(QPointF(clip.left(), center.y()), QPointF(clip.right(), center.y()), pos),
+                        distSqrToLine(QPointF(center.x(), clip.top()), QPointF(center.x(), clip.bottom()), pos)));
+    }
+    case tsCircle:
+    {
+      if (clip.intersects(QRectF(center-QPointF(w, w), center+QPointF(w, w)).toRect()))
+      {
+        // distance to border:
+        double centerDist = QVector2D(center-pos).length();
+        double circleLine = w;
+        double result = qAbs(centerDist-circleLine);
+        // filled ellipse, allow click inside to count as hit:
+        if (result > mParentPlot->selectionTolerance()*0.99 && mBrush.style() != Qt::NoBrush && mBrush.color().alpha() != 0)
+        {
+          if (centerDist <= circleLine)
+            result = mParentPlot->selectionTolerance()*0.99;
+        }
+        return result;
+      }
+      break;
+    }
+    case tsSquare:
+    {
+      if (clip.intersects(QRectF(center-QPointF(w, w), center+QPointF(w, w)).toRect()))
+      {
+        QRectF rect = QRectF(center-QPointF(w, w), center+QPointF(w, w));
+        bool filledRect = mBrush.style() != Qt::NoBrush && mBrush.color().alpha() != 0;
+        return rectSelectTest(rect, pos, filledRect);
+      }
+      break;
+    }
+  }
+  return -1;
+}
+
+/* inherits documentation from base class */
+void QCPItemTracer::draw(QCPPainter *painter)
+{
+  updatePosition();
+  if (mStyle == tsNone)
+    return;
+
+  painter->setPen(mainPen());
+  painter->setBrush(mainBrush());
+  QPointF center(position->pixelPoint());
+  double w = mSize/2.0;
+  QRect clip = clipRect();
+  switch (mStyle)
+  {
+    case tsNone: return;
+    case tsPlus:
+    {
+      if (clip.intersects(QRectF(center-QPointF(w, w), center+QPointF(w, w)).toRect()))
+      {
+        painter->drawLine(QLineF(center+QPointF(-w, 0), center+QPointF(w, 0)));
+        painter->drawLine(QLineF(center+QPointF(0, -w), center+QPointF(0, w)));
+      }
+      break;
+    }
+    case tsCrosshair:
+    {
+      if (center.y() > clip.top() && center.y() < clip.bottom())
+        painter->drawLine(QLineF(clip.left(), center.y(), clip.right(), center.y()));
+      if (center.x() > clip.left() && center.x() < clip.right())
+        painter->drawLine(QLineF(center.x(), clip.top(), center.x(), clip.bottom()));
+      break;
+    }
+    case tsCircle:
+    {
+      if (clip.intersects(QRectF(center-QPointF(w, w), center+QPointF(w, w)).toRect()))
+        painter->drawEllipse(center, w, w);
+      break;
+    }
+    case tsSquare:
+    {
+      if (clip.intersects(QRectF(center-QPointF(w, w), center+QPointF(w, w)).toRect()))
+        painter->drawRect(QRectF(center-QPointF(w, w), center+QPointF(w, w)));
+      break;
+    }
+  }
+}
+
+/*!
+  If the tracer is connected with a graph (\ref setGraph), this function updates the tracer's \a
+  position to reside on the graph data, depending on the configured key (\ref setGraphKey).
+  
+  It is called automatically on every redraw and normally doesn't need to be called manually. One
+  exception is when you want to read the tracer coordinates via \a position and are not sure that
+  the graph's data (or the tracer key with \ref setGraphKey) hasn't changed since the last redraw.
+  In that situation, call this function before accessing \a position, to make sure you don't get
+  out-of-date coordinates.
+  
+  If there is no graph set on this tracer, this function does nothing.
+*/
+void QCPItemTracer::updatePosition()
+{
+  if (mGraph)
+  {
+    if (mParentPlot->hasPlottable(mGraph))
+    {
+      if (mGraph->data()->size() > 1)
+      {
+        QCPDataMap::const_iterator first = mGraph->data()->constBegin();
+        QCPDataMap::const_iterator last = mGraph->data()->constEnd()-1;
+        if (mGraphKey < first.key())
+          position->setCoords(first.key(), first.value().value);
+        else if (mGraphKey > last.key())
+          position->setCoords(last.key(), last.value().value);
+        else
+        {
+          QCPDataMap::const_iterator it = mGraph->data()->lowerBound(mGraphKey);
+          if (it != first) // mGraphKey is somewhere between iterators
+          {
+            QCPDataMap::const_iterator prevIt = it-1;
+            if (mInterpolating)
+            {
+              // interpolate between iterators around mGraphKey:
+              double slope = 0;
+              if (!qFuzzyCompare((double)it.key(), (double)prevIt.key()))
+                slope = (it.value().value-prevIt.value().value)/(it.key()-prevIt.key());
+              position->setCoords(mGraphKey, (mGraphKey-prevIt.key())*slope+prevIt.value().value);
+            } else
+            {
+              // find iterator with key closest to mGraphKey:
+              if (mGraphKey < (prevIt.key()+it.key())*0.5)
+                it = prevIt;
+              position->setCoords(it.key(), it.value().value);
+            }
+          } else // mGraphKey is exactly on first iterator
+            position->setCoords(it.key(), it.value().value);
+        }
+      } else if (mGraph->data()->size() == 1)
+      {
+        QCPDataMap::const_iterator it = mGraph->data()->constBegin();
+        position->setCoords(it.key(), it.value().value);
+      } else
+        qDebug() << Q_FUNC_INFO << "graph has no data";
+    } else
+      qDebug() << Q_FUNC_INFO << "graph not contained in QCustomPlot instance (anymore)";
+  }
+}
+
+/*! \internal
+
+  Returns the pen that should be used for drawing lines. Returns mPen when the item is not selected
+  and mSelectedPen when it is.
+*/
+QPen QCPItemTracer::mainPen() const
+{
+  return mSelected ? mSelectedPen : mPen;
+}
+
+/*! \internal
+
+  Returns the brush that should be used for drawing fills of the item. Returns mBrush when the item
+  is not selected and mSelectedBrush when it is.
+*/
+QBrush QCPItemTracer::mainBrush() const
+{
+  return mSelected ? mSelectedBrush : mBrush;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPItemBracket
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPItemBracket
+  \brief A bracket for referencing/highlighting certain parts in the plot.
+
+  \image html QCPItemBracket.png "Bracket example. Blue dotted circles are anchors, solid blue discs are positions."
+
+  It has two positions, \a left and \a right, which define the span of the bracket. If \a left is
+  actually farther to the left than \a right, the bracket is opened to the bottom, as shown in the
+  example image.
+  
+  The bracket supports multiple styles via \ref setStyle. The length, i.e. how far the bracket
+  stretches away from the embraced span, can be controlled with \ref setLength.
+  
+  \image html QCPItemBracket-length.png
+  <center>Demonstrating the effect of different values for \ref setLength, for styles \ref
+  bsCalligraphic and \ref bsSquare. Anchors and positions are displayed for reference.</center>
+  
+  It provides an anchor \a center, to allow connection of other items, e.g. an arrow (QCPItemLine
+  or QCPItemCurve) or a text label (QCPItemText), to the bracket.
+*/
+
+/*!
+  Creates a bracket item and sets default values.
+  
+  The constructed item can be added to the plot with QCustomPlot::addItem.
+*/
+QCPItemBracket::QCPItemBracket(QCustomPlot *parentPlot) :
+  QCPAbstractItem(parentPlot),
+  left(createPosition(QLatin1String("left"))),
+  right(createPosition(QLatin1String("right"))),
+  center(createAnchor(QLatin1String("center"), aiCenter))
+{
+  left->setCoords(0, 0);
+  right->setCoords(1, 1);
+  
+  setPen(QPen(Qt::black));
+  setSelectedPen(QPen(Qt::blue, 2));
+  setLength(8);
+  setStyle(bsCalligraphic);
+}
+
+QCPItemBracket::~QCPItemBracket()
+{
+}
+
+/*!
+  Sets the pen that will be used to draw the bracket.
+  
+  Note that when the style is \ref bsCalligraphic, only the color will be taken from the pen, the
+  stroke and width are ignored. To change the apparent stroke width of a calligraphic bracket, use
+  \ref setLength, which has a similar effect.
+  
+  \see setSelectedPen
+*/
+void QCPItemBracket::setPen(const QPen &pen)
+{
+  mPen = pen;
+}
+
+/*!
+  Sets the pen that will be used to draw the bracket when selected
+  
+  \see setPen, setSelected
+*/
+void QCPItemBracket::setSelectedPen(const QPen &pen)
+{
+  mSelectedPen = pen;
+}
+
+/*!
+  Sets the \a length in pixels how far the bracket extends in the direction towards the embraced
+  span of the bracket (i.e. perpendicular to the <i>left</i>-<i>right</i>-direction)
+  
+  \image html QCPItemBracket-length.png
+  <center>Demonstrating the effect of different values for \ref setLength, for styles \ref
+  bsCalligraphic and \ref bsSquare. Anchors and positions are displayed for reference.</center>
+*/
+void QCPItemBracket::setLength(double length)
+{
+  mLength = length;
+}
+
+/*!
+  Sets the style of the bracket, i.e. the shape/visual appearance.
+  
+  \see setPen
+*/
+void QCPItemBracket::setStyle(QCPItemBracket::BracketStyle style)
+{
+  mStyle = style;
+}
+
+/* inherits documentation from base class */
+double QCPItemBracket::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
+{
+  Q_UNUSED(details)
+  if (onlySelectable && !mSelectable)
+    return -1;
+  
+  QVector2D leftVec(left->pixelPoint());
+  QVector2D rightVec(right->pixelPoint());
+  if (leftVec.toPoint() == rightVec.toPoint())
+    return -1;
+  
+  QVector2D widthVec = (rightVec-leftVec)*0.5f;
+  QVector2D lengthVec(-widthVec.y(), widthVec.x());
+  lengthVec = lengthVec.normalized()*mLength;
+  QVector2D centerVec = (rightVec+leftVec)*0.5f-lengthVec;
+  
+  switch (mStyle)
+  {
+    case QCPItemBracket::bsSquare:
+    case QCPItemBracket::bsRound:
+    {
+      double a = distSqrToLine((centerVec-widthVec).toPointF(), (centerVec+widthVec).toPointF(), pos);
+      double b = distSqrToLine((centerVec-widthVec+lengthVec).toPointF(), (centerVec-widthVec).toPointF(), pos);
+      double c = distSqrToLine((centerVec+widthVec+lengthVec).toPointF(), (centerVec+widthVec).toPointF(), pos);
+      return qSqrt(qMin(qMin(a, b), c));
+    }
+    case QCPItemBracket::bsCurly:
+    case QCPItemBracket::bsCalligraphic:
+    {
+      double a = distSqrToLine((centerVec-widthVec*0.75f+lengthVec*0.15f).toPointF(), (centerVec+lengthVec*0.3f).toPointF(), pos);
+      double b = distSqrToLine((centerVec-widthVec+lengthVec*0.7f).toPointF(), (centerVec-widthVec*0.75f+lengthVec*0.15f).toPointF(), pos);
+      double c = distSqrToLine((centerVec+widthVec*0.75f+lengthVec*0.15f).toPointF(), (centerVec+lengthVec*0.3f).toPointF(), pos);
+      double d = distSqrToLine((centerVec+widthVec+lengthVec*0.7f).toPointF(), (centerVec+widthVec*0.75f+lengthVec*0.15f).toPointF(), pos);
+      return qSqrt(qMin(qMin(a, b), qMin(c, d)));
+    }
+  }
+  return -1;
+}
+
+/* inherits documentation from base class */
+void QCPItemBracket::draw(QCPPainter *painter)
+{
+  QVector2D leftVec(left->pixelPoint());
+  QVector2D rightVec(right->pixelPoint());
+  if (leftVec.toPoint() == rightVec.toPoint())
+    return;
+  
+  QVector2D widthVec = (rightVec-leftVec)*0.5f;
+  QVector2D lengthVec(-widthVec.y(), widthVec.x());
+  lengthVec = lengthVec.normalized()*mLength;
+  QVector2D centerVec = (rightVec+leftVec)*0.5f-lengthVec;
+
+  QPolygon boundingPoly;
+  boundingPoly << leftVec.toPoint() << rightVec.toPoint()
+               << (rightVec-lengthVec).toPoint() << (leftVec-lengthVec).toPoint();
+  QRect clip = clipRect().adjusted(-mainPen().widthF(), -mainPen().widthF(), mainPen().widthF(), mainPen().widthF());
+  if (clip.intersects(boundingPoly.boundingRect()))
+  {
+    painter->setPen(mainPen());
+    switch (mStyle)
+    {
+      case bsSquare:
+      {
+        painter->drawLine((centerVec+widthVec).toPointF(), (centerVec-widthVec).toPointF());
+        painter->drawLine((centerVec+widthVec).toPointF(), (centerVec+widthVec+lengthVec).toPointF());
+        painter->drawLine((centerVec-widthVec).toPointF(), (centerVec-widthVec+lengthVec).toPointF());
+        break;
+      }
+      case bsRound:
+      {
+        painter->setBrush(Qt::NoBrush);
+        QPainterPath path;
+        path.moveTo((centerVec+widthVec+lengthVec).toPointF());
+        path.cubicTo((centerVec+widthVec).toPointF(), (centerVec+widthVec).toPointF(), centerVec.toPointF());
+        path.cubicTo((centerVec-widthVec).toPointF(), (centerVec-widthVec).toPointF(), (centerVec-widthVec+lengthVec).toPointF());
+        painter->drawPath(path);
+        break;
+      }
+      case bsCurly:
+      {
+        painter->setBrush(Qt::NoBrush);
+        QPainterPath path;
+        path.moveTo((centerVec+widthVec+lengthVec).toPointF());
+        path.cubicTo((centerVec+widthVec-lengthVec*0.8f).toPointF(), (centerVec+0.4f*widthVec+lengthVec).toPointF(), centerVec.toPointF());
+        path.cubicTo((centerVec-0.4f*widthVec+lengthVec).toPointF(), (centerVec-widthVec-lengthVec*0.8f).toPointF(), (centerVec-widthVec+lengthVec).toPointF());
+        painter->drawPath(path);
+        break;
+      }
+      case bsCalligraphic:
+      {
+        painter->setPen(Qt::NoPen);
+        painter->setBrush(QBrush(mainPen().color()));
+        QPainterPath path;
+        path.moveTo((centerVec+widthVec+lengthVec).toPointF());
+        
+        path.cubicTo((centerVec+widthVec-lengthVec*0.8f).toPointF(), (centerVec+0.4f*widthVec+0.8f*lengthVec).toPointF(), centerVec.toPointF());
+        path.cubicTo((centerVec-0.4f*widthVec+0.8f*lengthVec).toPointF(), (centerVec-widthVec-lengthVec*0.8f).toPointF(), (centerVec-widthVec+lengthVec).toPointF());
+        
+        path.cubicTo((centerVec-widthVec-lengthVec*0.5f).toPointF(), (centerVec-0.2f*widthVec+1.2f*lengthVec).toPointF(), (centerVec+lengthVec*0.2f).toPointF());
+        path.cubicTo((centerVec+0.2f*widthVec+1.2f*lengthVec).toPointF(), (centerVec+widthVec-lengthVec*0.5f).toPointF(), (centerVec+widthVec+lengthVec).toPointF());
+        
+        painter->drawPath(path);
+        break;
+      }
+    }
+  }
+}
+
+/* inherits documentation from base class */
+QPointF QCPItemBracket::anchorPixelPoint(int anchorId) const
+{
+  QVector2D leftVec(left->pixelPoint());
+  QVector2D rightVec(right->pixelPoint());
+  if (leftVec.toPoint() == rightVec.toPoint())
+    return leftVec.toPointF();
+  
+  QVector2D widthVec = (rightVec-leftVec)*0.5f;
+  QVector2D lengthVec(-widthVec.y(), widthVec.x());
+  lengthVec = lengthVec.normalized()*mLength;
+  QVector2D centerVec = (rightVec+leftVec)*0.5f-lengthVec;
+  
+  switch (anchorId)
+  {
+    case aiCenter:
+      return centerVec.toPointF();
+  }
+  qDebug() << Q_FUNC_INFO << "invalid anchorId" << anchorId;
+  return QPointF();
+}
+
+/*! \internal
+
+  Returns the pen that should be used for drawing lines. Returns mPen when the
+  item is not selected and mSelectedPen when it is.
+*/
+QPen QCPItemBracket::mainPen() const
+{
+    return mSelected ? mSelectedPen : mPen;
+}
+
diff --git a/meta-services/recipes-services/lcd-app/files/qcustomplot.h b/meta-services/recipes-services/lcd-app/files/qcustomplot.h
new file mode 100644
index 0000000..bb998f1
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/qcustomplot.h
@@ -0,0 +1,3768 @@
+/***************************************************************************
+**                                                                        **
+**  QCustomPlot, an easy to use, modern plotting widget for Qt            **
+**  Copyright (C) 2011-2015 Emanuel Eichhammer                            **
+**                                                                        **
+**  This program is free software: you can redistribute it and/or modify  **
+**  it under the terms of the GNU General Public License as published by  **
+**  the Free Software Foundation, either version 3 of the License, or     **
+**  (at your option) any later version.                                   **
+**                                                                        **
+**  This program is distributed in the hope that it will be useful,       **
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of        **
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         **
+**  GNU General Public License for more details.                          **
+**                                                                        **
+**  You should have received a copy of the GNU General Public License     **
+**  along with this program.  If not, see http://www.gnu.org/licenses/.   **
+**                                                                        **
+****************************************************************************
+**           Author: Emanuel Eichhammer                                   **
+**  Website/Contact: http://www.qcustomplot.com/                          **
+**             Date: 22.12.15                                             **
+**          Version: 1.3.2                                                **
+****************************************************************************/
+
+#ifndef QCUSTOMPLOT_H
+#define QCUSTOMPLOT_H
+
+#include <QObject>
+#include <QPointer>
+#include <QWidget>
+#include <QPainter>
+#include <QPaintEvent>
+#include <QMouseEvent>
+#include <QPixmap>
+#include <QVector>
+#include <QString>
+#include <QDateTime>
+#include <QMultiMap>
+#include <QFlags>
+#include <QDebug>
+#include <QVector2D>
+#include <QStack>
+#include <QCache>
+#include <QMargins>
+#include <qmath.h>
+#include <limits>
+#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)
+#  include <qnumeric.h>
+#  include <QPrinter>
+#  include <QPrintEngine>
+#else
+#  include <QtNumeric>
+#  include <QtPrintSupport/QtPrintSupport>
+#endif
+
+class QCPPainter;
+class QCustomPlot;
+class QCPLayerable;
+class QCPLayoutElement;
+class QCPLayout;
+class QCPAxis;
+class QCPAxisRect;
+class QCPAxisPainterPrivate;
+class QCPAbstractPlottable;
+class QCPGraph;
+class QCPAbstractItem;
+class QCPItemPosition;
+class QCPLayer;
+class QCPPlotTitle;
+class QCPLegend;
+class QCPAbstractLegendItem;
+class QCPColorMap;
+class QCPColorScale;
+class QCPBars;
+
+
+/*! \file */
+
+
+// decl definitions for shared library compilation/usage:
+#if defined(QCUSTOMPLOT_COMPILE_LIBRARY)
+#  define QCP_LIB_DECL Q_DECL_EXPORT
+#elif defined(QCUSTOMPLOT_USE_LIBRARY)
+#  define QCP_LIB_DECL Q_DECL_IMPORT
+#else
+#  define QCP_LIB_DECL
+#endif
+
+/*!
+  The QCP Namespace contains general enums and QFlags used throughout the QCustomPlot library
+*/
+namespace QCP
+{
+/*!
+  Defines the sides of a rectangular entity to which margins can be applied.
+  
+  \see QCPLayoutElement::setAutoMargins, QCPAxisRect::setAutoMargins
+*/
+enum MarginSide { msLeft     = 0x01 ///< <tt>0x01</tt> left margin
+                  ,msRight   = 0x02 ///< <tt>0x02</tt> right margin
+                  ,msTop     = 0x04 ///< <tt>0x04</tt> top margin
+                  ,msBottom  = 0x08 ///< <tt>0x08</tt> bottom margin
+                  ,msAll     = 0xFF ///< <tt>0xFF</tt> all margins
+                  ,msNone    = 0x00 ///< <tt>0x00</tt> no margin
+                };
+Q_DECLARE_FLAGS(MarginSides, MarginSide)
+
+/*!
+  Defines what objects of a plot can be forcibly drawn antialiased/not antialiased. If an object is
+  neither forcibly drawn antialiased nor forcibly drawn not antialiased, it is up to the respective
+  element how it is drawn. Typically it provides a \a setAntialiased function for this.
+  
+  \c AntialiasedElements is a flag of or-combined elements of this enum type.
+  
+  \see QCustomPlot::setAntialiasedElements, QCustomPlot::setNotAntialiasedElements
+*/
+enum AntialiasedElement { aeAxes           = 0x0001 ///< <tt>0x0001</tt> Axis base line and tick marks
+                          ,aeGrid          = 0x0002 ///< <tt>0x0002</tt> Grid lines
+                          ,aeSubGrid       = 0x0004 ///< <tt>0x0004</tt> Sub grid lines
+                          ,aeLegend        = 0x0008 ///< <tt>0x0008</tt> Legend box
+                          ,aeLegendItems   = 0x0010 ///< <tt>0x0010</tt> Legend items
+                          ,aePlottables    = 0x0020 ///< <tt>0x0020</tt> Main lines of plottables (excluding error bars, see element \ref aeErrorBars)
+                          ,aeItems         = 0x0040 ///< <tt>0x0040</tt> Main lines of items
+                          ,aeScatters      = 0x0080 ///< <tt>0x0080</tt> Scatter symbols of plottables (excluding scatter symbols of type ssPixmap)
+                          ,aeErrorBars     = 0x0100 ///< <tt>0x0100</tt> Error bars
+                          ,aeFills         = 0x0200 ///< <tt>0x0200</tt> Borders of fills (e.g. under or between graphs)
+                          ,aeZeroLine      = 0x0400 ///< <tt>0x0400</tt> Zero-lines, see \ref QCPGrid::setZeroLinePen
+                          ,aeAll           = 0xFFFF ///< <tt>0xFFFF</tt> All elements
+                          ,aeNone          = 0x0000 ///< <tt>0x0000</tt> No elements
+                        };
+Q_DECLARE_FLAGS(AntialiasedElements, AntialiasedElement)
+
+/*!
+  Defines plotting hints that control various aspects of the quality and speed of plotting.
+  
+  \see QCustomPlot::setPlottingHints
+*/
+enum PlottingHint { phNone            = 0x000 ///< <tt>0x000</tt> No hints are set
+                    ,phFastPolylines  = 0x001 ///< <tt>0x001</tt> Graph/Curve lines are drawn with a faster method. This reduces the quality
+                                              ///<                especially of the line segment joins. (Only relevant for solid line pens.)
+                    ,phForceRepaint   = 0x002 ///< <tt>0x002</tt> causes an immediate repaint() instead of a soft update() when QCustomPlot::replot() is called with parameter \ref QCustomPlot::rpHint.
+                                              ///<                This is set by default to prevent the plot from freezing on fast consecutive replots (e.g. user drags ranges with mouse).
+                    ,phCacheLabels    = 0x004 ///< <tt>0x004</tt> axis (tick) labels will be cached as pixmaps, increasing replot performance.
+                  };
+Q_DECLARE_FLAGS(PlottingHints, PlottingHint)
+
+/*!
+  Defines the mouse interactions possible with QCustomPlot.
+  
+  \c Interactions is a flag of or-combined elements of this enum type.
+  
+  \see QCustomPlot::setInteractions
+*/
+enum Interaction { iRangeDrag         = 0x001 ///< <tt>0x001</tt> Axis ranges are draggable (see \ref QCPAxisRect::setRangeDrag, \ref QCPAxisRect::setRangeDragAxes)
+                   ,iRangeZoom        = 0x002 ///< <tt>0x002</tt> Axis ranges are zoomable with the mouse wheel (see \ref QCPAxisRect::setRangeZoom, \ref QCPAxisRect::setRangeZoomAxes)
+                   ,iMultiSelect      = 0x004 ///< <tt>0x004</tt> The user can select multiple objects by holding the modifier set by \ref QCustomPlot::setMultiSelectModifier while clicking
+                   ,iSelectPlottables = 0x008 ///< <tt>0x008</tt> Plottables are selectable (e.g. graphs, curves, bars,... see QCPAbstractPlottable)
+                   ,iSelectAxes       = 0x010 ///< <tt>0x010</tt> Axes are selectable (or parts of them, see QCPAxis::setSelectableParts)
+                   ,iSelectLegend     = 0x020 ///< <tt>0x020</tt> Legends are selectable (or their child items, see QCPLegend::setSelectableParts)
+                   ,iSelectItems      = 0x040 ///< <tt>0x040</tt> Items are selectable (Rectangles, Arrows, Textitems, etc. see \ref QCPAbstractItem)
+                   ,iSelectOther      = 0x080 ///< <tt>0x080</tt> All other objects are selectable (e.g. your own derived layerables, the plot title,...)
+                 };
+Q_DECLARE_FLAGS(Interactions, Interaction)
+
+/*! \internal
+  
+  Returns whether the specified \a value is considered an invalid data value for plottables (i.e.
+  is \e nan or \e +/-inf). This function is used to check data validity upon replots, when the
+  compiler flag \c QCUSTOMPLOT_CHECK_DATA is set.
+*/
+inline bool isInvalidData(double value)
+{
+  return qIsNaN(value) || qIsInf(value);
+}
+
+/*! \internal
+  \overload
+  
+  Checks two arguments instead of one.
+*/
+inline bool isInvalidData(double value1, double value2)
+{
+  return isInvalidData(value1) || isInvalidData(value2);
+}
+
+/*! \internal
+  
+  Sets the specified \a side of \a margins to \a value
+  
+  \see getMarginValue
+*/
+inline void setMarginValue(QMargins &margins, QCP::MarginSide side, int value)
+{
+  switch (side)
+  {
+    case QCP::msLeft: margins.setLeft(value); break;
+    case QCP::msRight: margins.setRight(value); break;
+    case QCP::msTop: margins.setTop(value); break;
+    case QCP::msBottom: margins.setBottom(value); break;
+    case QCP::msAll: margins = QMargins(value, value, value, value); break;
+    default: break;
+  }
+}
+
+/*! \internal
+  
+  Returns the value of the specified \a side of \a margins. If \a side is \ref QCP::msNone or
+  \ref QCP::msAll, returns 0.
+  
+  \see setMarginValue
+*/
+inline int getMarginValue(const QMargins &margins, QCP::MarginSide side)
+{
+  switch (side)
+  {
+    case QCP::msLeft: return margins.left();
+    case QCP::msRight: return margins.right();
+    case QCP::msTop: return margins.top();
+    case QCP::msBottom: return margins.bottom();
+    default: break;
+  }
+  return 0;
+}
+
+} // end of namespace QCP
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(QCP::AntialiasedElements)
+Q_DECLARE_OPERATORS_FOR_FLAGS(QCP::PlottingHints)
+Q_DECLARE_OPERATORS_FOR_FLAGS(QCP::MarginSides)
+Q_DECLARE_OPERATORS_FOR_FLAGS(QCP::Interactions)
+
+
+class QCP_LIB_DECL QCPScatterStyle
+{
+  Q_GADGET
+public:
+  /*!
+    Defines the shape used for scatter points.
+
+    On plottables/items that draw scatters, the sizes of these visualizations (with exception of
+    \ref ssDot and \ref ssPixmap) can be controlled with the \ref setSize function. Scatters are
+    drawn with the pen and brush specified with \ref setPen and \ref setBrush.
+  */
+  Q_ENUMS(ScatterShape)
+  enum ScatterShape { ssNone       ///< no scatter symbols are drawn (e.g. in QCPGraph, data only represented with lines)
+                      ,ssDot       ///< \enumimage{ssDot.png} a single pixel (use \ref ssDisc or \ref ssCircle if you want a round shape with a certain radius)
+                      ,ssCross     ///< \enumimage{ssCross.png} a cross
+                      ,ssPlus      ///< \enumimage{ssPlus.png} a plus
+                      ,ssCircle    ///< \enumimage{ssCircle.png} a circle
+                      ,ssDisc      ///< \enumimage{ssDisc.png} a circle which is filled with the pen's color (not the brush as with ssCircle)
+                      ,ssSquare    ///< \enumimage{ssSquare.png} a square
+                      ,ssDiamond   ///< \enumimage{ssDiamond.png} a diamond
+                      ,ssStar      ///< \enumimage{ssStar.png} a star with eight arms, i.e. a combination of cross and plus
+                      ,ssTriangle  ///< \enumimage{ssTriangle.png} an equilateral triangle, standing on baseline
+                      ,ssTriangleInverted ///< \enumimage{ssTriangleInverted.png} an equilateral triangle, standing on corner
+                      ,ssCrossSquare      ///< \enumimage{ssCrossSquare.png} a square with a cross inside
+                      ,ssPlusSquare       ///< \enumimage{ssPlusSquare.png} a square with a plus inside
+                      ,ssCrossCircle      ///< \enumimage{ssCrossCircle.png} a circle with a cross inside
+                      ,ssPlusCircle       ///< \enumimage{ssPlusCircle.png} a circle with a plus inside
+                      ,ssPeace     ///< \enumimage{ssPeace.png} a circle, with one vertical and two downward diagonal lines
+                      ,ssPixmap    ///< a custom pixmap specified by \ref setPixmap, centered on the data point coordinates
+                      ,ssCustom    ///< custom painter operations are performed per scatter (As QPainterPath, see \ref setCustomPath)
+                    };
+
+  QCPScatterStyle();
+  QCPScatterStyle(ScatterShape shape, double size=6);
+  QCPScatterStyle(ScatterShape shape, const QColor &color, double size);
+  QCPScatterStyle(ScatterShape shape, const QColor &color, const QColor &fill, double size);
+  QCPScatterStyle(ScatterShape shape, const QPen &pen, const QBrush &brush, double size);
+  QCPScatterStyle(const QPixmap &pixmap);
+  QCPScatterStyle(const QPainterPath &customPath, const QPen &pen, const QBrush &brush=Qt::NoBrush, double size=6);
+  
+  // getters:
+  double size() const { return mSize; }
+  ScatterShape shape() const { return mShape; }
+  QPen pen() const { return mPen; }
+  QBrush brush() const { return mBrush; }
+  QPixmap pixmap() const { return mPixmap; }
+  QPainterPath customPath() const { return mCustomPath; }
+
+  // setters:
+  void setSize(double size);
+  void setShape(ScatterShape shape);
+  void setPen(const QPen &pen);
+  void setBrush(const QBrush &brush);
+  void setPixmap(const QPixmap &pixmap);
+  void setCustomPath(const QPainterPath &customPath);
+
+  // non-property methods:
+  bool isNone() const { return mShape == ssNone; }
+  bool isPenDefined() const { return mPenDefined; }
+  void applyTo(QCPPainter *painter, const QPen &defaultPen) const;
+  void drawShape(QCPPainter *painter, QPointF pos) const;
+  void drawShape(QCPPainter *painter, double x, double y) const;
+
+protected:
+  // property members:
+  double mSize;
+  ScatterShape mShape;
+  QPen mPen;
+  QBrush mBrush;
+  QPixmap mPixmap;
+  QPainterPath mCustomPath;
+  
+  // non-property members:
+  bool mPenDefined;
+};
+Q_DECLARE_TYPEINFO(QCPScatterStyle, Q_MOVABLE_TYPE);
+
+
+class QCP_LIB_DECL QCPPainter : public QPainter
+{
+  Q_GADGET
+public:
+  /*!
+    Defines special modes the painter can operate in. They disable or enable certain subsets of features/fixes/workarounds,
+    depending on whether they are wanted on the respective output device.
+  */
+  enum PainterMode { pmDefault       = 0x00   ///< <tt>0x00</tt> Default mode for painting on screen devices
+                     ,pmVectorized   = 0x01   ///< <tt>0x01</tt> Mode for vectorized painting (e.g. PDF export). For example, this prevents some antialiasing fixes.
+                     ,pmNoCaching    = 0x02   ///< <tt>0x02</tt> Mode for all sorts of exports (e.g. PNG, PDF,...). For example, this prevents using cached pixmap labels
+                     ,pmNonCosmetic  = 0x04   ///< <tt>0x04</tt> Turns pen widths 0 to 1, i.e. disables cosmetic pens. (A cosmetic pen is always drawn with width 1 pixel in the vector image/pdf viewer, independent of zoom.)
+                   };
+  Q_FLAGS(PainterMode PainterModes)
+  Q_DECLARE_FLAGS(PainterModes, PainterMode)
+  
+  QCPPainter();
+  QCPPainter(QPaintDevice *device);
+  ~QCPPainter();
+  
+  // getters:
+  bool antialiasing() const { return testRenderHint(QPainter::Antialiasing); }
+  PainterModes modes() const { return mModes; }
+
+  // setters:
+  void setAntialiasing(bool enabled);
+  void setMode(PainterMode mode, bool enabled=true);
+  void setModes(PainterModes modes);
+
+  // methods hiding non-virtual base class functions (QPainter bug workarounds):
+  bool begin(QPaintDevice *device);
+  void setPen(const QPen &pen);
+  void setPen(const QColor &color);
+  void setPen(Qt::PenStyle penStyle);
+  void drawLine(const QLineF &line);
+  void drawLine(const QPointF &p1, const QPointF &p2) {drawLine(QLineF(p1, p2));}
+  void save();
+  void restore();
+  
+  // non-virtual methods:
+  void makeNonCosmetic();
+  
+protected:
+  // property members:
+  PainterModes mModes;
+  bool mIsAntialiasing;
+  
+  // non-property members:
+  QStack<bool> mAntialiasingStack;
+};
+Q_DECLARE_OPERATORS_FOR_FLAGS(QCPPainter::PainterModes)
+
+
+class QCP_LIB_DECL QCPLayer : public QObject
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QCustomPlot* parentPlot READ parentPlot)
+  Q_PROPERTY(QString name READ name)
+  Q_PROPERTY(int index READ index)
+  Q_PROPERTY(QList<QCPLayerable*> children READ children)
+  Q_PROPERTY(bool visible READ visible WRITE setVisible)
+  /// \endcond
+public:
+  QCPLayer(QCustomPlot* parentPlot, const QString &layerName);
+  ~QCPLayer();
+  
+  // getters:
+  QCustomPlot *parentPlot() const { return mParentPlot; }
+  QString name() const { return mName; }
+  int index() const { return mIndex; }
+  QList<QCPLayerable*> children() const { return mChildren; }
+  bool visible() const { return mVisible; }
+  
+  // setters:
+  void setVisible(bool visible);
+  
+protected:
+  // property members:
+  QCustomPlot *mParentPlot;
+  QString mName;
+  int mIndex;
+  QList<QCPLayerable*> mChildren;
+  bool mVisible;
+  
+  // non-virtual methods:
+  void addChild(QCPLayerable *layerable, bool prepend);
+  void removeChild(QCPLayerable *layerable);
+  
+private:
+  Q_DISABLE_COPY(QCPLayer)
+  
+  friend class QCustomPlot;
+  friend class QCPLayerable;
+};
+
+class QCP_LIB_DECL QCPLayerable : public QObject
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(bool visible READ visible WRITE setVisible)
+  Q_PROPERTY(QCustomPlot* parentPlot READ parentPlot)
+  Q_PROPERTY(QCPLayerable* parentLayerable READ parentLayerable)
+  Q_PROPERTY(QCPLayer* layer READ layer WRITE setLayer NOTIFY layerChanged)
+  Q_PROPERTY(bool antialiased READ antialiased WRITE setAntialiased)
+  /// \endcond
+public:
+  QCPLayerable(QCustomPlot *plot, QString targetLayer=QString(), QCPLayerable *parentLayerable=0);
+  ~QCPLayerable();
+  
+  // getters:
+  bool visible() const { return mVisible; }
+  QCustomPlot *parentPlot() const { return mParentPlot; }
+  QCPLayerable *parentLayerable() const { return mParentLayerable.data(); }
+  QCPLayer *layer() const { return mLayer; }
+  bool antialiased() const { return mAntialiased; }
+  
+  // setters:
+  void setVisible(bool on);
+  Q_SLOT bool setLayer(QCPLayer *layer);
+  bool setLayer(const QString &layerName);
+  void setAntialiased(bool enabled);
+  
+  // introduced virtual methods:
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+  // non-property methods:
+  bool realVisibility() const;
+  
+signals:
+  void layerChanged(QCPLayer *newLayer);
+  
+protected:
+  // property members:
+  bool mVisible;
+  QCustomPlot *mParentPlot;
+  QPointer<QCPLayerable> mParentLayerable;
+  QCPLayer *mLayer;
+  bool mAntialiased;
+  
+  // introduced virtual methods:
+  virtual void parentPlotInitialized(QCustomPlot *parentPlot);
+  virtual QCP::Interaction selectionCategory() const;
+  virtual QRect clipRect() const;
+  virtual void applyDefaultAntialiasingHint(QCPPainter *painter) const = 0;
+  virtual void draw(QCPPainter *painter) = 0;
+  // events:
+  virtual void selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged);
+  virtual void deselectEvent(bool *selectionStateChanged);
+  
+  // non-property methods:
+  void initializeParentPlot(QCustomPlot *parentPlot);
+  void setParentLayerable(QCPLayerable* parentLayerable);
+  bool moveToLayer(QCPLayer *layer, bool prepend);
+  void applyAntialiasingHint(QCPPainter *painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const;
+  
+private:
+  Q_DISABLE_COPY(QCPLayerable)
+  
+  friend class QCustomPlot;
+  friend class QCPAxisRect;
+};
+
+
+class QCP_LIB_DECL QCPRange
+{
+public:
+  double lower, upper;
+  
+  QCPRange();
+  QCPRange(double lower, double upper);
+  
+  bool operator==(const QCPRange& other) const { return lower == other.lower && upper == other.upper; }
+  bool operator!=(const QCPRange& other) const { return !(*this == other); }
+  
+  QCPRange &operator+=(const double& value) { lower+=value; upper+=value; return *this; }
+  QCPRange &operator-=(const double& value) { lower-=value; upper-=value; return *this; }
+  QCPRange &operator*=(const double& value) { lower*=value; upper*=value; return *this; }
+  QCPRange &operator/=(const double& value) { lower/=value; upper/=value; return *this; }
+  friend inline const QCPRange operator+(const QCPRange&, double);
+  friend inline const QCPRange operator+(double, const QCPRange&);
+  friend inline const QCPRange operator-(const QCPRange& range, double value);
+  friend inline const QCPRange operator*(const QCPRange& range, double value);
+  friend inline const QCPRange operator*(double value, const QCPRange& range);
+  friend inline const QCPRange operator/(const QCPRange& range, double value);
+  
+  double size() const;
+  double center() const;
+  void normalize();
+  void expand(const QCPRange &otherRange);
+  QCPRange expanded(const QCPRange &otherRange) const;
+  QCPRange sanitizedForLogScale() const;
+  QCPRange sanitizedForLinScale() const;
+  bool contains(double value) const;
+  
+  static bool validRange(double lower, double upper);
+  static bool validRange(const QCPRange &range);
+  static const double minRange; //1e-280;
+  static const double maxRange; //1e280;
+  
+};
+Q_DECLARE_TYPEINFO(QCPRange, Q_MOVABLE_TYPE);
+
+/* documentation of inline functions */
+
+/*! \fn QCPRange &QCPRange::operator+=(const double& value)
+  
+  Adds \a value to both boundaries of the range.
+*/
+
+/*! \fn QCPRange &QCPRange::operator-=(const double& value)
+  
+  Subtracts \a value from both boundaries of the range.
+*/
+
+/*! \fn QCPRange &QCPRange::operator*=(const double& value)
+  
+  Multiplies both boundaries of the range by \a value.
+*/
+
+/*! \fn QCPRange &QCPRange::operator/=(const double& value)
+  
+  Divides both boundaries of the range by \a value.
+*/
+
+/* end documentation of inline functions */
+
+/*!
+  Adds \a value to both boundaries of the range.
+*/
+inline const QCPRange operator+(const QCPRange& range, double value)
+{
+  QCPRange result(range);
+  result += value;
+  return result;
+}
+
+/*!
+  Adds \a value to both boundaries of the range.
+*/
+inline const QCPRange operator+(double value, const QCPRange& range)
+{
+  QCPRange result(range);
+  result += value;
+  return result;
+}
+
+/*!
+  Subtracts \a value from both boundaries of the range.
+*/
+inline const QCPRange operator-(const QCPRange& range, double value)
+{
+  QCPRange result(range);
+  result -= value;
+  return result;
+}
+
+/*!
+  Multiplies both boundaries of the range by \a value.
+*/
+inline const QCPRange operator*(const QCPRange& range, double value)
+{
+  QCPRange result(range);
+  result *= value;
+  return result;
+}
+
+/*!
+  Multiplies both boundaries of the range by \a value.
+*/
+inline const QCPRange operator*(double value, const QCPRange& range)
+{
+  QCPRange result(range);
+  result *= value;
+  return result;
+}
+
+/*!
+  Divides both boundaries of the range by \a value.
+*/
+inline const QCPRange operator/(const QCPRange& range, double value)
+{
+  QCPRange result(range);
+  result /= value;
+  return result;
+}
+
+
+class QCP_LIB_DECL QCPMarginGroup : public QObject
+{
+  Q_OBJECT
+public:
+  QCPMarginGroup(QCustomPlot *parentPlot);
+  ~QCPMarginGroup();
+  
+  // non-virtual methods:
+  QList<QCPLayoutElement*> elements(QCP::MarginSide side) const { return mChildren.value(side); }
+  bool isEmpty() const;
+  void clear();
+  
+protected:
+  // non-property members:
+  QCustomPlot *mParentPlot;
+  QHash<QCP::MarginSide, QList<QCPLayoutElement*> > mChildren;
+  
+  // non-virtual methods:
+  int commonMargin(QCP::MarginSide side) const;
+  void addChild(QCP::MarginSide side, QCPLayoutElement *element);
+  void removeChild(QCP::MarginSide side, QCPLayoutElement *element);
+  
+private:
+  Q_DISABLE_COPY(QCPMarginGroup)
+  
+  friend class QCPLayoutElement;
+};
+
+
+class QCP_LIB_DECL QCPLayoutElement : public QCPLayerable
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QCPLayout* layout READ layout)
+  Q_PROPERTY(QRect rect READ rect)
+  Q_PROPERTY(QRect outerRect READ outerRect WRITE setOuterRect)
+  Q_PROPERTY(QMargins margins READ margins WRITE setMargins)
+  Q_PROPERTY(QMargins minimumMargins READ minimumMargins WRITE setMinimumMargins)
+  Q_PROPERTY(QSize minimumSize READ minimumSize WRITE setMinimumSize)
+  Q_PROPERTY(QSize maximumSize READ maximumSize WRITE setMaximumSize)
+  /// \endcond
+public:
+  /*!
+    Defines the phases of the update process, that happens just before a replot. At each phase,
+    \ref update is called with the according UpdatePhase value.
+  */
+  enum UpdatePhase { upPreparation ///< Phase used for any type of preparation that needs to be done before margin calculation and layout
+                     ,upMargins    ///< Phase in which the margins are calculated and set
+                     ,upLayout     ///< Final phase in which the layout system places the rects of the elements
+                   };
+  Q_ENUMS(UpdatePhase)
+
+  explicit QCPLayoutElement(QCustomPlot *parentPlot=0);
+  virtual ~QCPLayoutElement();
+  
+  // getters:
+  QCPLayout *layout() const { return mParentLayout; }
+  QRect rect() const { return mRect; }
+  QRect outerRect() const { return mOuterRect; }
+  QMargins margins() const { return mMargins; }
+  QMargins minimumMargins() const { return mMinimumMargins; }
+  QCP::MarginSides autoMargins() const { return mAutoMargins; }
+  QSize minimumSize() const { return mMinimumSize; }
+  QSize maximumSize() const { return mMaximumSize; }
+  QCPMarginGroup *marginGroup(QCP::MarginSide side) const { return mMarginGroups.value(side, (QCPMarginGroup*)0); }
+  QHash<QCP::MarginSide, QCPMarginGroup*> marginGroups() const { return mMarginGroups; }
+  
+  // setters:
+  void setOuterRect(const QRect &rect);
+  void setMargins(const QMargins &margins);
+  void setMinimumMargins(const QMargins &margins);
+  void setAutoMargins(QCP::MarginSides sides);
+  void setMinimumSize(const QSize &size);
+  void setMinimumSize(int width, int height);
+  void setMaximumSize(const QSize &size);
+  void setMaximumSize(int width, int height);
+  void setMarginGroup(QCP::MarginSides sides, QCPMarginGroup *group);
+  
+  // introduced virtual methods:
+  virtual void update(UpdatePhase phase);
+  virtual QSize minimumSizeHint() const;
+  virtual QSize maximumSizeHint() const;
+  virtual QList<QCPLayoutElement*> elements(bool recursive) const;
+  
+  // reimplemented virtual methods:
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+protected:
+  // property members:
+  QCPLayout *mParentLayout;
+  QSize mMinimumSize, mMaximumSize;
+  QRect mRect, mOuterRect;
+  QMargins mMargins, mMinimumMargins;
+  QCP::MarginSides mAutoMargins;
+  QHash<QCP::MarginSide, QCPMarginGroup*> mMarginGroups;
+  
+  // introduced virtual methods:
+  virtual int calculateAutoMargin(QCP::MarginSide side);
+  // events:
+  virtual void mousePressEvent(QMouseEvent *event) {Q_UNUSED(event)}
+  virtual void mouseMoveEvent(QMouseEvent *event) {Q_UNUSED(event)}
+  virtual void mouseReleaseEvent(QMouseEvent *event) {Q_UNUSED(event)}
+  virtual void mouseDoubleClickEvent(QMouseEvent *event) {Q_UNUSED(event)}
+  virtual void wheelEvent(QWheelEvent *event) {Q_UNUSED(event)}
+  
+  // reimplemented virtual methods:
+  virtual void applyDefaultAntialiasingHint(QCPPainter *painter) const { Q_UNUSED(painter) }
+  virtual void draw(QCPPainter *painter) { Q_UNUSED(painter) }
+  virtual void parentPlotInitialized(QCustomPlot *parentPlot);
+
+private:
+  Q_DISABLE_COPY(QCPLayoutElement)
+  
+  friend class QCustomPlot;
+  friend class QCPLayout;
+  friend class QCPMarginGroup;
+};
+
+
+class QCP_LIB_DECL QCPLayout : public QCPLayoutElement
+{
+  Q_OBJECT
+public:
+  explicit QCPLayout();
+  
+  // reimplemented virtual methods:
+  virtual void update(UpdatePhase phase);
+  virtual QList<QCPLayoutElement*> elements(bool recursive) const;
+  
+  // introduced virtual methods:
+  virtual int elementCount() const = 0;
+  virtual QCPLayoutElement* elementAt(int index) const = 0;
+  virtual QCPLayoutElement* takeAt(int index) = 0;
+  virtual bool take(QCPLayoutElement* element) = 0;
+  virtual void simplify();
+  
+  // non-virtual methods:
+  bool removeAt(int index);
+  bool remove(QCPLayoutElement* element);
+  void clear();
+  
+protected:
+  // introduced virtual methods:
+  virtual void updateLayout();
+  
+  // non-virtual methods:
+  void sizeConstraintsChanged() const;
+  void adoptElement(QCPLayoutElement *el);
+  void releaseElement(QCPLayoutElement *el);
+  QVector<int> getSectionSizes(QVector<int> maxSizes, QVector<int> minSizes, QVector<double> stretchFactors, int totalSize) const;
+  
+private:
+  Q_DISABLE_COPY(QCPLayout)
+  friend class QCPLayoutElement;
+};
+
+
+class QCP_LIB_DECL QCPLayoutGrid : public QCPLayout
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(int rowCount READ rowCount)
+  Q_PROPERTY(int columnCount READ columnCount)
+  Q_PROPERTY(QList<double> columnStretchFactors READ columnStretchFactors WRITE setColumnStretchFactors)
+  Q_PROPERTY(QList<double> rowStretchFactors READ rowStretchFactors WRITE setRowStretchFactors)
+  Q_PROPERTY(int columnSpacing READ columnSpacing WRITE setColumnSpacing)
+  Q_PROPERTY(int rowSpacing READ rowSpacing WRITE setRowSpacing)
+  /// \endcond
+public:
+  explicit QCPLayoutGrid();
+  virtual ~QCPLayoutGrid();
+  
+  // getters:
+  int rowCount() const;
+  int columnCount() const;
+  QList<double> columnStretchFactors() const { return mColumnStretchFactors; }
+  QList<double> rowStretchFactors() const { return mRowStretchFactors; }
+  int columnSpacing() const { return mColumnSpacing; }
+  int rowSpacing() const { return mRowSpacing; }
+  
+  // setters:
+  void setColumnStretchFactor(int column, double factor);
+  void setColumnStretchFactors(const QList<double> &factors);
+  void setRowStretchFactor(int row, double factor);
+  void setRowStretchFactors(const QList<double> &factors);
+  void setColumnSpacing(int pixels);
+  void setRowSpacing(int pixels);
+  
+  // reimplemented virtual methods:
+  virtual void updateLayout();
+  virtual int elementCount() const;
+  virtual QCPLayoutElement* elementAt(int index) const;
+  virtual QCPLayoutElement* takeAt(int index);
+  virtual bool take(QCPLayoutElement* element);
+  virtual QList<QCPLayoutElement*> elements(bool recursive) const;
+  virtual void simplify();
+  virtual QSize minimumSizeHint() const;
+  virtual QSize maximumSizeHint() const;
+  
+  // non-virtual methods:
+  QCPLayoutElement *element(int row, int column) const;
+  bool addElement(int row, int column, QCPLayoutElement *element);
+  bool hasElement(int row, int column);
+  void expandTo(int newRowCount, int newColumnCount);
+  void insertRow(int newIndex);
+  void insertColumn(int newIndex);
+  
+protected:
+  // property members:
+  QList<QList<QCPLayoutElement*> > mElements;
+  QList<double> mColumnStretchFactors;
+  QList<double> mRowStretchFactors;
+  int mColumnSpacing, mRowSpacing;
+  
+  // non-virtual methods:
+  void getMinimumRowColSizes(QVector<int> *minColWidths, QVector<int> *minRowHeights) const;
+  void getMaximumRowColSizes(QVector<int> *maxColWidths, QVector<int> *maxRowHeights) const;
+  
+private:
+  Q_DISABLE_COPY(QCPLayoutGrid)
+};
+
+
+class QCP_LIB_DECL QCPLayoutInset : public QCPLayout
+{
+  Q_OBJECT
+public:
+  /*!
+    Defines how the placement and sizing is handled for a certain element in a QCPLayoutInset.
+  */
+  enum InsetPlacement { ipFree            ///< The element may be positioned/sized arbitrarily, see \ref setInsetRect
+                        ,ipBorderAligned  ///< The element is aligned to one of the layout sides, see \ref setInsetAlignment
+                      };
+  
+  explicit QCPLayoutInset();
+  virtual ~QCPLayoutInset();
+  
+  // getters:
+  InsetPlacement insetPlacement(int index) const;
+  Qt::Alignment insetAlignment(int index) const;
+  QRectF insetRect(int index) const;
+  
+  // setters:
+  void setInsetPlacement(int index, InsetPlacement placement);
+  void setInsetAlignment(int index, Qt::Alignment alignment);
+  void setInsetRect(int index, const QRectF &rect);
+  
+  // reimplemented virtual methods:
+  virtual void updateLayout();
+  virtual int elementCount() const;
+  virtual QCPLayoutElement* elementAt(int index) const;
+  virtual QCPLayoutElement* takeAt(int index);
+  virtual bool take(QCPLayoutElement* element);
+  virtual void simplify() {}
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+  // non-virtual methods:
+  void addElement(QCPLayoutElement *element, Qt::Alignment alignment);
+  void addElement(QCPLayoutElement *element, const QRectF &rect);
+  
+protected:
+  // property members:
+  QList<QCPLayoutElement*> mElements;
+  QList<InsetPlacement> mInsetPlacement;
+  QList<Qt::Alignment> mInsetAlignment;
+  QList<QRectF> mInsetRect;
+  
+private:
+  Q_DISABLE_COPY(QCPLayoutInset)
+};
+
+
+class QCP_LIB_DECL QCPLineEnding
+{
+  Q_GADGET
+public:
+  /*!
+    Defines the type of ending decoration for line-like items, e.g. an arrow.
+    
+    \image html QCPLineEnding.png
+    
+    The width and length of these decorations can be controlled with the functions \ref setWidth
+    and \ref setLength. Some decorations like \ref esDisc, \ref esSquare, \ref esDiamond and \ref esBar only
+    support a width, the length property is ignored.
+    
+    \see QCPItemLine::setHead, QCPItemLine::setTail, QCPItemCurve::setHead, QCPItemCurve::setTail, QCPAxis::setLowerEnding, QCPAxis::setUpperEnding
+  */
+  Q_ENUMS(EndingStyle)
+  enum EndingStyle { esNone          ///< No ending decoration
+                     ,esFlatArrow    ///< A filled arrow head with a straight/flat back (a triangle)
+                     ,esSpikeArrow   ///< A filled arrow head with an indented back
+                     ,esLineArrow    ///< A non-filled arrow head with open back
+                     ,esDisc         ///< A filled circle
+                     ,esSquare       ///< A filled square
+                     ,esDiamond      ///< A filled diamond (45° rotated square)
+                     ,esBar          ///< A bar perpendicular to the line
+                     ,esHalfBar      ///< A bar perpendicular to the line, pointing out to only one side (to which side can be changed with \ref setInverted)
+                     ,esSkewedBar    ///< A bar that is skewed (skew controllable via \ref setLength)
+                   };
+  
+  QCPLineEnding();
+  QCPLineEnding(EndingStyle style, double width=8, double length=10, bool inverted=false);
+  
+  // getters:
+  EndingStyle style() const { return mStyle; }
+  double width() const { return mWidth; }
+  double length() const { return mLength; }
+  bool inverted() const { return mInverted; }
+  
+  // setters:
+  void setStyle(EndingStyle style);
+  void setWidth(double width);
+  void setLength(double length);
+  void setInverted(bool inverted);
+  
+  // non-property methods:
+  double boundingDistance() const;
+  double realLength() const;
+  void draw(QCPPainter *painter, const QVector2D &pos, const QVector2D &dir) const;
+  void draw(QCPPainter *painter, const QVector2D &pos, double angle) const;
+  
+protected:
+  // property members:
+  EndingStyle mStyle;
+  double mWidth, mLength;
+  bool mInverted;
+};
+Q_DECLARE_TYPEINFO(QCPLineEnding, Q_MOVABLE_TYPE);
+
+
+class QCP_LIB_DECL QCPGrid :public QCPLayerable
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(bool subGridVisible READ subGridVisible WRITE setSubGridVisible)
+  Q_PROPERTY(bool antialiasedSubGrid READ antialiasedSubGrid WRITE setAntialiasedSubGrid)
+  Q_PROPERTY(bool antialiasedZeroLine READ antialiasedZeroLine WRITE setAntialiasedZeroLine)
+  Q_PROPERTY(QPen pen READ pen WRITE setPen)
+  Q_PROPERTY(QPen subGridPen READ subGridPen WRITE setSubGridPen)
+  Q_PROPERTY(QPen zeroLinePen READ zeroLinePen WRITE setZeroLinePen)
+  /// \endcond
+public:
+  QCPGrid(QCPAxis *parentAxis);
+  
+  // getters:
+  bool subGridVisible() const { return mSubGridVisible; }
+  bool antialiasedSubGrid() const { return mAntialiasedSubGrid; }
+  bool antialiasedZeroLine() const { return mAntialiasedZeroLine; }
+  QPen pen() const { return mPen; }
+  QPen subGridPen() const { return mSubGridPen; }
+  QPen zeroLinePen() const { return mZeroLinePen; }
+  
+  // setters:
+  void setSubGridVisible(bool visible);
+  void setAntialiasedSubGrid(bool enabled);
+  void setAntialiasedZeroLine(bool enabled);
+  void setPen(const QPen &pen);
+  void setSubGridPen(const QPen &pen);
+  void setZeroLinePen(const QPen &pen);
+  
+protected:
+  // property members:
+  bool mSubGridVisible;
+  bool mAntialiasedSubGrid, mAntialiasedZeroLine;
+  QPen mPen, mSubGridPen, mZeroLinePen;
+  // non-property members:
+  QCPAxis *mParentAxis;
+  
+  // reimplemented virtual methods:
+  virtual void applyDefaultAntialiasingHint(QCPPainter *painter) const;
+  virtual void draw(QCPPainter *painter);
+  
+  // non-virtual methods:
+  void drawGridLines(QCPPainter *painter) const;
+  void drawSubGridLines(QCPPainter *painter) const;
+  
+  friend class QCPAxis;
+};
+
+
+class QCP_LIB_DECL QCPAxis : public QCPLayerable
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(AxisType axisType READ axisType)
+  Q_PROPERTY(QCPAxisRect* axisRect READ axisRect)
+  Q_PROPERTY(ScaleType scaleType READ scaleType WRITE setScaleType NOTIFY scaleTypeChanged)
+  Q_PROPERTY(double scaleLogBase READ scaleLogBase WRITE setScaleLogBase)
+  Q_PROPERTY(QCPRange range READ range WRITE setRange NOTIFY rangeChanged)
+  Q_PROPERTY(bool rangeReversed READ rangeReversed WRITE setRangeReversed)
+  Q_PROPERTY(bool autoTicks READ autoTicks WRITE setAutoTicks)
+  Q_PROPERTY(int autoTickCount READ autoTickCount WRITE setAutoTickCount)
+  Q_PROPERTY(bool autoTickLabels READ autoTickLabels WRITE setAutoTickLabels)
+  Q_PROPERTY(bool autoTickStep READ autoTickStep WRITE setAutoTickStep)
+  Q_PROPERTY(bool autoSubTicks READ autoSubTicks WRITE setAutoSubTicks)
+  Q_PROPERTY(bool ticks READ ticks WRITE setTicks)
+  Q_PROPERTY(bool tickLabels READ tickLabels WRITE setTickLabels)
+  Q_PROPERTY(int tickLabelPadding READ tickLabelPadding WRITE setTickLabelPadding)
+  Q_PROPERTY(LabelType tickLabelType READ tickLabelType WRITE setTickLabelType)
+  Q_PROPERTY(QFont tickLabelFont READ tickLabelFont WRITE setTickLabelFont)
+  Q_PROPERTY(QColor tickLabelColor READ tickLabelColor WRITE setTickLabelColor)
+  Q_PROPERTY(double tickLabelRotation READ tickLabelRotation WRITE setTickLabelRotation)
+  Q_PROPERTY(LabelSide tickLabelSide READ tickLabelSide WRITE setTickLabelSide)
+  Q_PROPERTY(QString dateTimeFormat READ dateTimeFormat WRITE setDateTimeFormat)
+  Q_PROPERTY(Qt::TimeSpec dateTimeSpec READ dateTimeSpec WRITE setDateTimeSpec)
+  Q_PROPERTY(QString numberFormat READ numberFormat WRITE setNumberFormat)
+  Q_PROPERTY(int numberPrecision READ numberPrecision WRITE setNumberPrecision)
+  Q_PROPERTY(double tickStep READ tickStep WRITE setTickStep)
+  Q_PROPERTY(QVector<double> tickVector READ tickVector WRITE setTickVector)
+  Q_PROPERTY(QVector<QString> tickVectorLabels READ tickVectorLabels WRITE setTickVectorLabels)
+  Q_PROPERTY(int tickLengthIn READ tickLengthIn WRITE setTickLengthIn)
+  Q_PROPERTY(int tickLengthOut READ tickLengthOut WRITE setTickLengthOut)
+  Q_PROPERTY(int subTickCount READ subTickCount WRITE setSubTickCount)
+  Q_PROPERTY(int subTickLengthIn READ subTickLengthIn WRITE setSubTickLengthIn)
+  Q_PROPERTY(int subTickLengthOut READ subTickLengthOut WRITE setSubTickLengthOut)
+  Q_PROPERTY(QPen basePen READ basePen WRITE setBasePen)
+  Q_PROPERTY(QPen tickPen READ tickPen WRITE setTickPen)
+  Q_PROPERTY(QPen subTickPen READ subTickPen WRITE setSubTickPen)
+  Q_PROPERTY(QFont labelFont READ labelFont WRITE setLabelFont)
+  Q_PROPERTY(QColor labelColor READ labelColor WRITE setLabelColor)
+  Q_PROPERTY(QString label READ label WRITE setLabel)
+  Q_PROPERTY(int labelPadding READ labelPadding WRITE setLabelPadding)
+  Q_PROPERTY(int padding READ padding WRITE setPadding)
+  Q_PROPERTY(int offset READ offset WRITE setOffset)
+  Q_PROPERTY(SelectableParts selectedParts READ selectedParts WRITE setSelectedParts NOTIFY selectionChanged)
+  Q_PROPERTY(SelectableParts selectableParts READ selectableParts WRITE setSelectableParts NOTIFY selectableChanged)
+  Q_PROPERTY(QFont selectedTickLabelFont READ selectedTickLabelFont WRITE setSelectedTickLabelFont)
+  Q_PROPERTY(QFont selectedLabelFont READ selectedLabelFont WRITE setSelectedLabelFont)
+  Q_PROPERTY(QColor selectedTickLabelColor READ selectedTickLabelColor WRITE setSelectedTickLabelColor)
+  Q_PROPERTY(QColor selectedLabelColor READ selectedLabelColor WRITE setSelectedLabelColor)
+  Q_PROPERTY(QPen selectedBasePen READ selectedBasePen WRITE setSelectedBasePen)
+  Q_PROPERTY(QPen selectedTickPen READ selectedTickPen WRITE setSelectedTickPen)
+  Q_PROPERTY(QPen selectedSubTickPen READ selectedSubTickPen WRITE setSelectedSubTickPen)
+  Q_PROPERTY(QCPLineEnding lowerEnding READ lowerEnding WRITE setLowerEnding)
+  Q_PROPERTY(QCPLineEnding upperEnding READ upperEnding WRITE setUpperEnding)
+  Q_PROPERTY(QCPGrid* grid READ grid)
+  /// \endcond
+public:
+  /*!
+    Defines at which side of the axis rect the axis will appear. This also affects how the tick
+    marks are drawn, on which side the labels are placed etc.
+  */
+  enum AxisType { atLeft    = 0x01  ///< <tt>0x01</tt> Axis is vertical and on the left side of the axis rect
+                  ,atRight  = 0x02  ///< <tt>0x02</tt> Axis is vertical and on the right side of the axis rect
+                  ,atTop    = 0x04  ///< <tt>0x04</tt> Axis is horizontal and on the top side of the axis rect
+                  ,atBottom = 0x08  ///< <tt>0x08</tt> Axis is horizontal and on the bottom side of the axis rect
+                };
+  Q_FLAGS(AxisType AxisTypes)
+  Q_DECLARE_FLAGS(AxisTypes, AxisType)
+  /*!
+    When automatic tick label generation is enabled (\ref setAutoTickLabels), defines how the
+    coordinate of the tick is interpreted, i.e. translated into a string.
+    
+    \see setTickLabelType
+  */
+  enum LabelType { ltNumber    ///< Tick coordinate is regarded as normal number and will be displayed as such. (see \ref setNumberFormat)
+                   ,ltDateTime ///< Tick coordinate is regarded as a date/time (seconds since 1970-01-01T00:00:00 UTC) and will be displayed and formatted as such. (for details, see \ref setDateTimeFormat)
+                 };
+  Q_ENUMS(LabelType)
+  /*!
+    Defines on which side of the axis the tick labels (numbers) shall appear.
+    
+    \see setTickLabelSide
+  */
+  enum LabelSide { lsInside    ///< Tick labels will be displayed inside the axis rect and clipped to the inner axis rect
+                   ,lsOutside  ///< Tick labels will be displayed outside the axis rect
+                 };
+  Q_ENUMS(LabelSide)
+  /*!
+    Defines the scale of an axis.
+    \see setScaleType
+  */
+  enum ScaleType { stLinear       ///< Linear scaling
+                   ,stLogarithmic ///< Logarithmic scaling with correspondingly transformed plots and (major) tick marks at every base power (see \ref setScaleLogBase).
+                 };
+  Q_ENUMS(ScaleType)
+  /*!
+    Defines the selectable parts of an axis.
+    \see setSelectableParts, setSelectedParts
+  */
+  enum SelectablePart { spNone        = 0      ///< None of the selectable parts
+                        ,spAxis       = 0x001  ///< The axis backbone and tick marks
+                        ,spTickLabels = 0x002  ///< Tick labels (numbers) of this axis (as a whole, not individually)
+                        ,spAxisLabel  = 0x004  ///< The axis label
+                      };
+  Q_FLAGS(SelectablePart SelectableParts)
+  Q_DECLARE_FLAGS(SelectableParts, SelectablePart)
+  
+  explicit QCPAxis(QCPAxisRect *parent, AxisType type);
+  virtual ~QCPAxis();
+  
+  // getters:
+  AxisType axisType() const { return mAxisType; }
+  QCPAxisRect *axisRect() const { return mAxisRect; }
+  ScaleType scaleType() const { return mScaleType; }
+  double scaleLogBase() const { return mScaleLogBase; }
+  const QCPRange range() const { return mRange; }
+  bool rangeReversed() const { return mRangeReversed; }
+  bool autoTicks() const { return mAutoTicks; }
+  int autoTickCount() const { return mAutoTickCount; }
+  bool autoTickLabels() const { return mAutoTickLabels; }
+  bool autoTickStep() const { return mAutoTickStep; }
+  bool autoSubTicks() const { return mAutoSubTicks; }
+  bool ticks() const { return mTicks; }
+  bool tickLabels() const { return mTickLabels; }
+  int tickLabelPadding() const;
+  LabelType tickLabelType() const { return mTickLabelType; }
+  QFont tickLabelFont() const { return mTickLabelFont; }
+  QColor tickLabelColor() const { return mTickLabelColor; }
+  double tickLabelRotation() const;
+  LabelSide tickLabelSide() const;
+  QString dateTimeFormat() const { return mDateTimeFormat; }
+  Qt::TimeSpec dateTimeSpec() const { return mDateTimeSpec; }
+  QString numberFormat() const;
+  int numberPrecision() const { return mNumberPrecision; }
+  double tickStep() const { return mTickStep; }
+  QVector<double> tickVector() const { return mTickVector; }
+  QVector<QString> tickVectorLabels() const { return mTickVectorLabels; }
+  int tickLengthIn() const;
+  int tickLengthOut() const;
+  int subTickCount() const { return mSubTickCount; }
+  int subTickLengthIn() const;
+  int subTickLengthOut() const;
+  QPen basePen() const { return mBasePen; }
+  QPen tickPen() const { return mTickPen; }
+  QPen subTickPen() const { return mSubTickPen; }
+  QFont labelFont() const { return mLabelFont; }
+  QColor labelColor() const { return mLabelColor; }
+  QString label() const { return mLabel; }
+  int labelPadding() const;
+  int padding() const { return mPadding; }
+  int offset() const;
+  SelectableParts selectedParts() const { return mSelectedParts; }
+  SelectableParts selectableParts() const { return mSelectableParts; }
+  QFont selectedTickLabelFont() const { return mSelectedTickLabelFont; }
+  QFont selectedLabelFont() const { return mSelectedLabelFont; }
+  QColor selectedTickLabelColor() const { return mSelectedTickLabelColor; }
+  QColor selectedLabelColor() const { return mSelectedLabelColor; }
+  QPen selectedBasePen() const { return mSelectedBasePen; }
+  QPen selectedTickPen() const { return mSelectedTickPen; }
+  QPen selectedSubTickPen() const { return mSelectedSubTickPen; }
+  QCPLineEnding lowerEnding() const;
+  QCPLineEnding upperEnding() const;
+  QCPGrid *grid() const { return mGrid; }
+  
+  // setters:
+  Q_SLOT void setScaleType(QCPAxis::ScaleType type);
+  void setScaleLogBase(double base);
+  Q_SLOT void setRange(const QCPRange &range);
+  void setRange(double lower, double upper);
+  void setRange(double position, double size, Qt::AlignmentFlag alignment);
+  void setRangeLower(double lower);
+  void setRangeUpper(double upper);
+  void setRangeReversed(bool reversed);
+  void setAutoTicks(bool on);
+  void setAutoTickCount(int approximateCount);
+  void setAutoTickLabels(bool on);
+  void setAutoTickStep(bool on);
+  void setAutoSubTicks(bool on);
+  void setTicks(bool show);
+  void setTickLabels(bool show);
+  void setTickLabelPadding(int padding);
+  void setTickLabelType(LabelType type);
+  void setTickLabelFont(const QFont &font);
+  void setTickLabelColor(const QColor &color);
+  void setTickLabelRotation(double degrees);
+  void setTickLabelSide(LabelSide side);
+  void setDateTimeFormat(const QString &format);
+  void setDateTimeSpec(const Qt::TimeSpec &timeSpec);
+  void setNumberFormat(const QString &formatCode);
+  void setNumberPrecision(int precision);
+  void setTickStep(double step);
+  void setTickVector(const QVector<double> &vec);
+  void setTickVectorLabels(const QVector<QString> &vec);
+  void setTickLength(int inside, int outside=0);
+  void setTickLengthIn(int inside);
+  void setTickLengthOut(int outside);
+  void setSubTickCount(int count);
+  void setSubTickLength(int inside, int outside=0);
+  void setSubTickLengthIn(int inside);
+  void setSubTickLengthOut(int outside);
+  void setBasePen(const QPen &pen);
+  void setTickPen(const QPen &pen);
+  void setSubTickPen(const QPen &pen);
+  void setLabelFont(const QFont &font);
+  void setLabelColor(const QColor &color);
+  void setLabel(const QString &str);
+  void setLabelPadding(int padding);
+  void setPadding(int padding);
+  void setOffset(int offset);
+  void setSelectedTickLabelFont(const QFont &font);
+  void setSelectedLabelFont(const QFont &font);
+  void setSelectedTickLabelColor(const QColor &color);
+  void setSelectedLabelColor(const QColor &color);
+  void setSelectedBasePen(const QPen &pen);
+  void setSelectedTickPen(const QPen &pen);
+  void setSelectedSubTickPen(const QPen &pen);
+  Q_SLOT void setSelectableParts(const QCPAxis::SelectableParts &selectableParts);
+  Q_SLOT void setSelectedParts(const QCPAxis::SelectableParts &selectedParts);
+  void setLowerEnding(const QCPLineEnding &ending);
+  void setUpperEnding(const QCPLineEnding &ending);
+  
+  // reimplemented virtual methods:
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+  // non-property methods:
+  Qt::Orientation orientation() const { return mOrientation; }
+  void moveRange(double diff);
+  void scaleRange(double factor, double center);
+  void setScaleRatio(const QCPAxis *otherAxis, double ratio=1.0);
+  void rescale(bool onlyVisiblePlottables=false);
+  double pixelToCoord(double value) const;
+  double coordToPixel(double value) const;
+  SelectablePart getPartAt(const QPointF &pos) const;
+  QList<QCPAbstractPlottable*> plottables() const;
+  QList<QCPGraph*> graphs() const;
+  QList<QCPAbstractItem*> items() const;
+  
+  static AxisType marginSideToAxisType(QCP::MarginSide side);
+  static Qt::Orientation orientation(AxisType type) { return type==atBottom||type==atTop ? Qt::Horizontal : Qt::Vertical; }
+  static AxisType opposite(AxisType type);
+  
+signals:
+  void ticksRequest();
+  void rangeChanged(const QCPRange &newRange);
+  void rangeChanged(const QCPRange &newRange, const QCPRange &oldRange);
+  void scaleTypeChanged(QCPAxis::ScaleType scaleType);
+  void selectionChanged(const QCPAxis::SelectableParts &parts);
+  void selectableChanged(const QCPAxis::SelectableParts &parts);
+
+protected:
+  // property members:
+  // axis base:
+  AxisType mAxisType;
+  QCPAxisRect *mAxisRect;
+  //int mOffset; // in QCPAxisPainter
+  int mPadding;
+  Qt::Orientation mOrientation;
+  SelectableParts mSelectableParts, mSelectedParts;
+  QPen mBasePen, mSelectedBasePen;
+  //QCPLineEnding mLowerEnding, mUpperEnding; // in QCPAxisPainter
+  // axis label:
+  //int mLabelPadding; // in QCPAxisPainter
+  QString mLabel;
+  QFont mLabelFont, mSelectedLabelFont;
+  QColor mLabelColor, mSelectedLabelColor;
+  // tick labels:
+  //int mTickLabelPadding; // in QCPAxisPainter
+  bool mTickLabels, mAutoTickLabels;
+  //double mTickLabelRotation; // in QCPAxisPainter
+  LabelType mTickLabelType;
+  QFont mTickLabelFont, mSelectedTickLabelFont;
+  QColor mTickLabelColor, mSelectedTickLabelColor;
+  QString mDateTimeFormat;
+  Qt::TimeSpec mDateTimeSpec;
+  int mNumberPrecision;
+  QLatin1Char mNumberFormatChar;
+  bool mNumberBeautifulPowers;
+  //bool mNumberMultiplyCross; // QCPAxisPainter
+  // ticks and subticks:
+  bool mTicks;
+  double mTickStep;
+  int mSubTickCount, mAutoTickCount;
+  bool mAutoTicks, mAutoTickStep, mAutoSubTicks;
+  //int mTickLengthIn, mTickLengthOut, mSubTickLengthIn, mSubTickLengthOut; // QCPAxisPainter
+  QPen mTickPen, mSelectedTickPen;
+  QPen mSubTickPen, mSelectedSubTickPen;
+  // scale and range:
+  QCPRange mRange;
+  bool mRangeReversed;
+  ScaleType mScaleType;
+  double mScaleLogBase, mScaleLogBaseLogInv;
+  
+  // non-property members:
+  QCPGrid *mGrid;
+  QCPAxisPainterPrivate *mAxisPainter;
+  int mLowestVisibleTick, mHighestVisibleTick;
+  QVector<double> mTickVector;
+  QVector<QString> mTickVectorLabels;
+  QVector<double> mSubTickVector;
+  bool mCachedMarginValid;
+  int mCachedMargin;
+  
+  // introduced virtual methods:
+  virtual void setupTickVectors();
+  virtual void generateAutoTicks();
+  virtual int calculateAutoSubTickCount(double tickStep) const;
+  virtual int calculateMargin();
+  
+  // reimplemented virtual methods:
+  virtual void applyDefaultAntialiasingHint(QCPPainter *painter) const;
+  virtual void draw(QCPPainter *painter);
+  virtual QCP::Interaction selectionCategory() const;
+  // events:
+  virtual void selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged);
+  virtual void deselectEvent(bool *selectionStateChanged);
+  
+  // non-virtual methods:
+  void visibleTickBounds(int &lowIndex, int &highIndex) const;
+  double baseLog(double value) const;
+  double basePow(double value) const;
+  QPen getBasePen() const;
+  QPen getTickPen() const;
+  QPen getSubTickPen() const;
+  QFont getTickLabelFont() const;
+  QFont getLabelFont() const;
+  QColor getTickLabelColor() const;
+  QColor getLabelColor() const;
+  
+private:
+  Q_DISABLE_COPY(QCPAxis)
+  
+  friend class QCustomPlot;
+  friend class QCPGrid;
+  friend class QCPAxisRect;
+};
+Q_DECLARE_OPERATORS_FOR_FLAGS(QCPAxis::SelectableParts)
+Q_DECLARE_OPERATORS_FOR_FLAGS(QCPAxis::AxisTypes)
+Q_DECLARE_METATYPE(QCPAxis::SelectablePart)
+
+
+class QCPAxisPainterPrivate
+{
+public:
+  explicit QCPAxisPainterPrivate(QCustomPlot *parentPlot);
+  virtual ~QCPAxisPainterPrivate();
+  
+  virtual void draw(QCPPainter *painter);
+  virtual int size() const;
+  void clearCache();
+  
+  QRect axisSelectionBox() const { return mAxisSelectionBox; }
+  QRect tickLabelsSelectionBox() const { return mTickLabelsSelectionBox; }
+  QRect labelSelectionBox() const { return mLabelSelectionBox; }
+  
+  // public property members:
+  QCPAxis::AxisType type;
+  QPen basePen;
+  QCPLineEnding lowerEnding, upperEnding; // directly accessed by QCPAxis setters/getters
+  int labelPadding; // directly accessed by QCPAxis setters/getters
+  QFont labelFont;
+  QColor labelColor;
+  QString label;
+  int tickLabelPadding; // directly accessed by QCPAxis setters/getters
+  double tickLabelRotation; // directly accessed by QCPAxis setters/getters
+  QCPAxis::LabelSide tickLabelSide; // directly accessed by QCPAxis setters/getters
+  bool substituteExponent;
+  bool numberMultiplyCross; // directly accessed by QCPAxis setters/getters
+  int tickLengthIn, tickLengthOut, subTickLengthIn, subTickLengthOut; // directly accessed by QCPAxis setters/getters
+  QPen tickPen, subTickPen;
+  QFont tickLabelFont;
+  QColor tickLabelColor;
+  QRect axisRect, viewportRect;
+  double offset; // directly accessed by QCPAxis setters/getters
+  bool abbreviateDecimalPowers;
+  bool reversedEndings;
+  
+  QVector<double> subTickPositions;
+  QVector<double> tickPositions;
+  QVector<QString> tickLabels;
+  
+protected:
+  struct CachedLabel
+  {
+    QPointF offset;
+    QPixmap pixmap;
+  };
+  struct TickLabelData
+  {
+    QString basePart, expPart;
+    QRect baseBounds, expBounds, totalBounds, rotatedTotalBounds;
+    QFont baseFont, expFont;
+  };
+  QCustomPlot *mParentPlot;
+  QByteArray mLabelParameterHash; // to determine whether mLabelCache needs to be cleared due to changed parameters
+  QCache<QString, CachedLabel> mLabelCache;
+  QRect mAxisSelectionBox, mTickLabelsSelectionBox, mLabelSelectionBox;
+  
+  virtual QByteArray generateLabelParameterHash() const;
+  
+  virtual void placeTickLabel(QCPPainter *painter, double position, int distanceToAxis, const QString &text, QSize *tickLabelsSize);
+  virtual void drawTickLabel(QCPPainter *painter, double x, double y, const TickLabelData &labelData) const;
+  virtual TickLabelData getTickLabelData(const QFont &font, const QString &text) const;
+  virtual QPointF getTickLabelDrawOffset(const TickLabelData &labelData) const;
+  virtual void getMaxTickLabelSize(const QFont &font, const QString &text, QSize *tickLabelsSize) const;
+};
+
+
+class QCP_LIB_DECL QCPAbstractPlottable : public QCPLayerable
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QString name READ name WRITE setName)
+  Q_PROPERTY(bool antialiasedFill READ antialiasedFill WRITE setAntialiasedFill)
+  Q_PROPERTY(bool antialiasedScatters READ antialiasedScatters WRITE setAntialiasedScatters)
+  Q_PROPERTY(bool antialiasedErrorBars READ antialiasedErrorBars WRITE setAntialiasedErrorBars)
+  Q_PROPERTY(QPen pen READ pen WRITE setPen)
+  Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)
+  Q_PROPERTY(QBrush brush READ brush WRITE setBrush)
+  Q_PROPERTY(QBrush selectedBrush READ selectedBrush WRITE setSelectedBrush)
+  Q_PROPERTY(QCPAxis* keyAxis READ keyAxis WRITE setKeyAxis)
+  Q_PROPERTY(QCPAxis* valueAxis READ valueAxis WRITE setValueAxis)
+  Q_PROPERTY(bool selectable READ selectable WRITE setSelectable NOTIFY selectableChanged)
+  Q_PROPERTY(bool selected READ selected WRITE setSelected NOTIFY selectionChanged)
+  /// \endcond
+public:
+  QCPAbstractPlottable(QCPAxis *keyAxis, QCPAxis *valueAxis);
+  
+  // getters:
+  QString name() const { return mName; }
+  bool antialiasedFill() const { return mAntialiasedFill; }
+  bool antialiasedScatters() const { return mAntialiasedScatters; }
+  bool antialiasedErrorBars() const { return mAntialiasedErrorBars; }
+  QPen pen() const { return mPen; }
+  QPen selectedPen() const { return mSelectedPen; }
+  QBrush brush() const { return mBrush; }
+  QBrush selectedBrush() const { return mSelectedBrush; }
+  QCPAxis *keyAxis() const { return mKeyAxis.data(); }
+  QCPAxis *valueAxis() const { return mValueAxis.data(); }
+  bool selectable() const { return mSelectable; }
+  bool selected() const { return mSelected; }
+  
+  // setters:
+  void setName(const QString &name);
+  void setAntialiasedFill(bool enabled);
+  void setAntialiasedScatters(bool enabled);
+  void setAntialiasedErrorBars(bool enabled);
+  void setPen(const QPen &pen);
+  void setSelectedPen(const QPen &pen);
+  void setBrush(const QBrush &brush);
+  void setSelectedBrush(const QBrush &brush);
+  void setKeyAxis(QCPAxis *axis);
+  void setValueAxis(QCPAxis *axis);
+  Q_SLOT void setSelectable(bool selectable);
+  Q_SLOT void setSelected(bool selected);
+
+  // introduced virtual methods:
+  virtual void clearData() = 0;
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const = 0;
+  virtual bool addToLegend();
+  virtual bool removeFromLegend() const;
+  
+  // non-property methods:
+  void rescaleAxes(bool onlyEnlarge=false) const;
+  void rescaleKeyAxis(bool onlyEnlarge=false) const;
+  void rescaleValueAxis(bool onlyEnlarge=false) const;
+  
+signals:
+  void selectionChanged(bool selected);
+  void selectableChanged(bool selectable);
+  
+protected:
+  /*!
+    Represents negative and positive sign domain for passing to \ref getKeyRange and \ref getValueRange.
+  */
+  enum SignDomain { sdNegative  ///< The negative sign domain, i.e. numbers smaller than zero
+                    ,sdBoth     ///< Both sign domains, including zero, i.e. all (rational) numbers
+                    ,sdPositive ///< The positive sign domain, i.e. numbers greater than zero
+                  };
+  
+  // property members:
+  QString mName;
+  bool mAntialiasedFill, mAntialiasedScatters, mAntialiasedErrorBars;
+  QPen mPen, mSelectedPen;
+  QBrush mBrush, mSelectedBrush;
+  QPointer<QCPAxis> mKeyAxis, mValueAxis;
+  bool mSelectable, mSelected;
+  
+  // reimplemented virtual methods:
+  virtual QRect clipRect() const;
+  virtual void draw(QCPPainter *painter) = 0;
+  virtual QCP::Interaction selectionCategory() const;
+  void applyDefaultAntialiasingHint(QCPPainter *painter) const;
+  // events:
+  virtual void selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged);
+  virtual void deselectEvent(bool *selectionStateChanged);
+  
+  // introduced virtual methods:
+  virtual void drawLegendIcon(QCPPainter *painter, const QRectF &rect) const = 0;
+  virtual QCPRange getKeyRange(bool &foundRange, SignDomain inSignDomain=sdBoth) const = 0;
+  virtual QCPRange getValueRange(bool &foundRange, SignDomain inSignDomain=sdBoth) const = 0;
+  
+  // non-virtual methods:
+  void coordsToPixels(double key, double value, double &x, double &y) const;
+  const QPointF coordsToPixels(double key, double value) const;
+  void pixelsToCoords(double x, double y, double &key, double &value) const;
+  void pixelsToCoords(const QPointF &pixelPos, double &key, double &value) const;
+  QPen mainPen() const;
+  QBrush mainBrush() const;
+  void applyFillAntialiasingHint(QCPPainter *painter) const;
+  void applyScattersAntialiasingHint(QCPPainter *painter) const;
+  void applyErrorBarsAntialiasingHint(QCPPainter *painter) const;
+  double distSqrToLine(const QPointF &start, const QPointF &end, const QPointF &point) const;
+
+private:
+  Q_DISABLE_COPY(QCPAbstractPlottable)
+  
+  friend class QCustomPlot;
+  friend class QCPAxis;
+  friend class QCPPlottableLegendItem;
+};
+
+
+class QCP_LIB_DECL QCPItemAnchor
+{
+public:
+  QCPItemAnchor(QCustomPlot *parentPlot, QCPAbstractItem *parentItem, const QString name, int anchorId=-1);
+  virtual ~QCPItemAnchor();
+  
+  // getters:
+  QString name() const { return mName; }
+  virtual QPointF pixelPoint() const;
+  
+protected:
+  // property members:
+  QString mName;
+  
+  // non-property members:
+  QCustomPlot *mParentPlot;
+  QCPAbstractItem *mParentItem;
+  int mAnchorId;
+  QSet<QCPItemPosition*> mChildrenX, mChildrenY;
+  
+  // introduced virtual methods:
+  virtual QCPItemPosition *toQCPItemPosition() { return 0; }
+  
+  // non-virtual methods:
+  void addChildX(QCPItemPosition* pos); // called from pos when this anchor is set as parent
+  void removeChildX(QCPItemPosition *pos); // called from pos when its parent anchor is reset or pos deleted
+  void addChildY(QCPItemPosition* pos); // called from pos when this anchor is set as parent
+  void removeChildY(QCPItemPosition *pos); // called from pos when its parent anchor is reset or pos deleted
+  
+private:
+  Q_DISABLE_COPY(QCPItemAnchor)
+  
+  friend class QCPItemPosition;
+};
+
+
+
+class QCP_LIB_DECL QCPItemPosition : public QCPItemAnchor
+{
+public:
+  /*!
+    Defines the ways an item position can be specified. Thus it defines what the numbers passed to
+    \ref setCoords actually mean.
+    
+    \see setType
+  */
+  enum PositionType { ptAbsolute        ///< Static positioning in pixels, starting from the top left corner of the viewport/widget.
+                      ,ptViewportRatio  ///< Static positioning given by a fraction of the viewport size. For example, if you call setCoords(0, 0), the position will be at the top
+                                        ///< left corner of the viewport/widget. setCoords(1, 1) will be at the bottom right corner, setCoords(0.5, 0) will be horizontally centered and
+                                        ///< vertically at the top of the viewport/widget, etc.
+                      ,ptAxisRectRatio  ///< Static positioning given by a fraction of the axis rect size (see \ref setAxisRect). For example, if you call setCoords(0, 0), the position will be at the top
+                                        ///< left corner of the axis rect. setCoords(1, 1) will be at the bottom right corner, setCoords(0.5, 0) will be horizontally centered and
+                                        ///< vertically at the top of the axis rect, etc. You can also go beyond the axis rect by providing negative coordinates or coordinates larger than 1.
+                      ,ptPlotCoords     ///< Dynamic positioning at a plot coordinate defined by two axes (see \ref setAxes).
+                    };
+  
+  QCPItemPosition(QCustomPlot *parentPlot, QCPAbstractItem *parentItem, const QString name);
+  virtual ~QCPItemPosition();
+  
+  // getters:
+  PositionType type() const { return typeX(); }
+  PositionType typeX() const { return mPositionTypeX; }
+  PositionType typeY() const { return mPositionTypeY; }
+  QCPItemAnchor *parentAnchor() const { return parentAnchorX(); }
+  QCPItemAnchor *parentAnchorX() const { return mParentAnchorX; }
+  QCPItemAnchor *parentAnchorY() const { return mParentAnchorY; }
+  double key() const { return mKey; }
+  double value() const { return mValue; }
+  QPointF coords() const { return QPointF(mKey, mValue); }
+  QCPAxis *keyAxis() const { return mKeyAxis.data(); }
+  QCPAxis *valueAxis() const { return mValueAxis.data(); }
+  QCPAxisRect *axisRect() const;
+  virtual QPointF pixelPoint() const;
+  
+  // setters:
+  void setType(PositionType type);
+  void setTypeX(PositionType type);
+  void setTypeY(PositionType type);
+  bool setParentAnchor(QCPItemAnchor *parentAnchor, bool keepPixelPosition=false);
+  bool setParentAnchorX(QCPItemAnchor *parentAnchor, bool keepPixelPosition=false);
+  bool setParentAnchorY(QCPItemAnchor *parentAnchor, bool keepPixelPosition=false);
+  void setCoords(double key, double value);
+  void setCoords(const QPointF &coords);
+  void setAxes(QCPAxis* keyAxis, QCPAxis* valueAxis);
+  void setAxisRect(QCPAxisRect *axisRect);
+  void setPixelPoint(const QPointF &pixelPoint);
+  
+protected:
+  // property members:
+  PositionType mPositionTypeX, mPositionTypeY;
+  QPointer<QCPAxis> mKeyAxis, mValueAxis;
+  QPointer<QCPAxisRect> mAxisRect;
+  double mKey, mValue;
+  QCPItemAnchor *mParentAnchorX, *mParentAnchorY;
+  
+  // reimplemented virtual methods:
+  virtual QCPItemPosition *toQCPItemPosition() { return this; }
+  
+private:
+  Q_DISABLE_COPY(QCPItemPosition)
+  
+};
+
+
+class QCP_LIB_DECL QCPAbstractItem : public QCPLayerable
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(bool clipToAxisRect READ clipToAxisRect WRITE setClipToAxisRect)
+  Q_PROPERTY(QCPAxisRect* clipAxisRect READ clipAxisRect WRITE setClipAxisRect)
+  Q_PROPERTY(bool selectable READ selectable WRITE setSelectable NOTIFY selectableChanged)
+  Q_PROPERTY(bool selected READ selected WRITE setSelected NOTIFY selectionChanged)
+  /// \endcond
+public:
+  QCPAbstractItem(QCustomPlot *parentPlot);
+  virtual ~QCPAbstractItem();
+  
+  // getters:
+  bool clipToAxisRect() const { return mClipToAxisRect; }
+  QCPAxisRect *clipAxisRect() const;
+  bool selectable() const { return mSelectable; }
+  bool selected() const { return mSelected; }
+  
+  // setters:
+  void setClipToAxisRect(bool clip);
+  void setClipAxisRect(QCPAxisRect *rect);
+  Q_SLOT void setSelectable(bool selectable);
+  Q_SLOT void setSelected(bool selected);
+  
+  // reimplemented virtual methods:
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const = 0;
+  
+  // non-virtual methods:
+  QList<QCPItemPosition*> positions() const { return mPositions; }
+  QList<QCPItemAnchor*> anchors() const { return mAnchors; }
+  QCPItemPosition *position(const QString &name) const;
+  QCPItemAnchor *anchor(const QString &name) const;
+  bool hasAnchor(const QString &name) const;
+  
+signals:
+  void selectionChanged(bool selected);
+  void selectableChanged(bool selectable);
+  
+protected:
+  // property members:
+  bool mClipToAxisRect;
+  QPointer<QCPAxisRect> mClipAxisRect;
+  QList<QCPItemPosition*> mPositions;
+  QList<QCPItemAnchor*> mAnchors;
+  bool mSelectable, mSelected;
+  
+  // reimplemented virtual methods:
+  virtual QCP::Interaction selectionCategory() const;
+  virtual QRect clipRect() const;
+  virtual void applyDefaultAntialiasingHint(QCPPainter *painter) const;
+  virtual void draw(QCPPainter *painter) = 0;
+  // events:
+  virtual void selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged);
+  virtual void deselectEvent(bool *selectionStateChanged);
+  
+  // introduced virtual methods:
+  virtual QPointF anchorPixelPoint(int anchorId) const;
+  
+  // non-virtual methods:
+  double distSqrToLine(const QPointF &start, const QPointF &end, const QPointF &point) const;
+  double rectSelectTest(const QRectF &rect, const QPointF &pos, bool filledRect) const;
+  QCPItemPosition *createPosition(const QString &name);
+  QCPItemAnchor *createAnchor(const QString &name, int anchorId);
+  
+private:
+  Q_DISABLE_COPY(QCPAbstractItem)
+  
+  friend class QCustomPlot;
+  friend class QCPItemAnchor;
+};
+
+
+class QCP_LIB_DECL QCustomPlot : public QWidget
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QRect viewport READ viewport WRITE setViewport)
+  Q_PROPERTY(QPixmap background READ background WRITE setBackground)
+  Q_PROPERTY(bool backgroundScaled READ backgroundScaled WRITE setBackgroundScaled)
+  Q_PROPERTY(Qt::AspectRatioMode backgroundScaledMode READ backgroundScaledMode WRITE setBackgroundScaledMode)
+  Q_PROPERTY(QCPLayoutGrid* plotLayout READ plotLayout)
+  Q_PROPERTY(bool autoAddPlottableToLegend READ autoAddPlottableToLegend WRITE setAutoAddPlottableToLegend)
+  Q_PROPERTY(int selectionTolerance READ selectionTolerance WRITE setSelectionTolerance)
+  Q_PROPERTY(bool noAntialiasingOnDrag READ noAntialiasingOnDrag WRITE setNoAntialiasingOnDrag)
+  Q_PROPERTY(Qt::KeyboardModifier multiSelectModifier READ multiSelectModifier WRITE setMultiSelectModifier)
+  /// \endcond
+public:
+  /*!
+    Defines how a layer should be inserted relative to an other layer.
+
+    \see addLayer, moveLayer
+  */
+  enum LayerInsertMode { limBelow  ///< Layer is inserted below other layer
+                         ,limAbove ///< Layer is inserted above other layer
+                       };
+  Q_ENUMS(LayerInsertMode)
+  
+  /*!
+    Defines with what timing the QCustomPlot surface is refreshed after a replot.
+
+    \see replot
+  */
+  enum RefreshPriority { rpImmediate ///< The QCustomPlot surface is immediately refreshed, by calling QWidget::repaint() after the replot
+                         ,rpQueued   ///< Queues the refresh such that it is performed at a slightly delayed point in time after the replot, by calling QWidget::update() after the replot
+                         ,rpHint     ///< Whether to use immediate repaint or queued update depends on whether the plotting hint \ref QCP::phForceRepaint is set, see \ref setPlottingHints.
+                       };
+  
+  explicit QCustomPlot(QWidget *parent = 0);
+  virtual ~QCustomPlot();
+  
+  // getters:
+  QRect viewport() const { return mViewport; }
+  QPixmap background() const { return mBackgroundPixmap; }
+  bool backgroundScaled() const { return mBackgroundScaled; }
+  Qt::AspectRatioMode backgroundScaledMode() const { return mBackgroundScaledMode; }
+  QCPLayoutGrid *plotLayout() const { return mPlotLayout; }
+  QCP::AntialiasedElements antialiasedElements() const { return mAntialiasedElements; }
+  QCP::AntialiasedElements notAntialiasedElements() const { return mNotAntialiasedElements; }
+  bool autoAddPlottableToLegend() const { return mAutoAddPlottableToLegend; }
+  const QCP::Interactions interactions() const { return mInteractions; }
+  int selectionTolerance() const { return mSelectionTolerance; }
+  bool noAntialiasingOnDrag() const { return mNoAntialiasingOnDrag; }
+  QCP::PlottingHints plottingHints() const { return mPlottingHints; }
+  Qt::KeyboardModifier multiSelectModifier() const { return mMultiSelectModifier; }
+
+  // setters:
+  void setViewport(const QRect &rect);
+  void setBackground(const QPixmap &pm);
+  void setBackground(const QPixmap &pm, bool scaled, Qt::AspectRatioMode mode=Qt::KeepAspectRatioByExpanding);
+  void setBackground(const QBrush &brush);
+  void setBackgroundScaled(bool scaled);
+  void setBackgroundScaledMode(Qt::AspectRatioMode mode);
+  void setAntialiasedElements(const QCP::AntialiasedElements &antialiasedElements);
+  void setAntialiasedElement(QCP::AntialiasedElement antialiasedElement, bool enabled=true);
+  void setNotAntialiasedElements(const QCP::AntialiasedElements &notAntialiasedElements);
+  void setNotAntialiasedElement(QCP::AntialiasedElement notAntialiasedElement, bool enabled=true);
+  void setAutoAddPlottableToLegend(bool on);
+  void setInteractions(const QCP::Interactions &interactions);
+  void setInteraction(const QCP::Interaction &interaction, bool enabled=true);
+  void setSelectionTolerance(int pixels);
+  void setNoAntialiasingOnDrag(bool enabled);
+  void setPlottingHints(const QCP::PlottingHints &hints);
+  void setPlottingHint(QCP::PlottingHint hint, bool enabled=true);
+  void setMultiSelectModifier(Qt::KeyboardModifier modifier);
+  
+  // non-property methods:
+  // plottable interface:
+  QCPAbstractPlottable *plottable(int index);
+  QCPAbstractPlottable *plottable();
+  bool addPlottable(QCPAbstractPlottable *plottable);
+  bool removePlottable(QCPAbstractPlottable *plottable);
+  bool removePlottable(int index);
+  int clearPlottables();
+  int plottableCount() const;
+  QList<QCPAbstractPlottable*> selectedPlottables() const;
+  QCPAbstractPlottable *plottableAt(const QPointF &pos, bool onlySelectable=false) const;
+  bool hasPlottable(QCPAbstractPlottable *plottable) const;
+ 
+  // specialized interface for QCPGraph:
+  QCPGraph *graph(int index) const;
+  QCPGraph *graph() const;
+  QCPGraph *addGraph(QCPAxis *keyAxis=0, QCPAxis *valueAxis=0);
+  bool removeGraph(QCPGraph *graph);
+  bool removeGraph(int index);
+  int clearGraphs();
+  int graphCount() const;
+  QList<QCPGraph*> selectedGraphs() const;
+
+  // item interface:
+  QCPAbstractItem *item(int index) const;
+  QCPAbstractItem *item() const;
+  bool addItem(QCPAbstractItem* item);
+  bool removeItem(QCPAbstractItem *item);
+  bool removeItem(int index);
+  int clearItems();
+  int itemCount() const;
+  QList<QCPAbstractItem*> selectedItems() const;
+  QCPAbstractItem *itemAt(const QPointF &pos, bool onlySelectable=false) const;
+  bool hasItem(QCPAbstractItem *item) const;
+  
+  // layer interface:
+  QCPLayer *layer(const QString &name) const;
+  QCPLayer *layer(int index) const;
+  QCPLayer *currentLayer() const;
+  bool setCurrentLayer(const QString &name);
+  bool setCurrentLayer(QCPLayer *layer);
+  int layerCount() const;
+  bool addLayer(const QString &name, QCPLayer *otherLayer=0, LayerInsertMode insertMode=limAbove);
+  bool removeLayer(QCPLayer *layer);
+  bool moveLayer(QCPLayer *layer, QCPLayer *otherLayer, LayerInsertMode insertMode=limAbove);
+  
+  // axis rect/layout interface:
+  int axisRectCount() const;
+  QCPAxisRect* axisRect(int index=0) const;
+  QList<QCPAxisRect*> axisRects() const;
+  QCPLayoutElement* layoutElementAt(const QPointF &pos) const;
+  Q_SLOT void rescaleAxes(bool onlyVisiblePlottables=false);
+  
+  QList<QCPAxis*> selectedAxes() const;
+  QList<QCPLegend*> selectedLegends() const;
+  Q_SLOT void deselectAll();
+  
+  bool savePdf(const QString &fileName, bool noCosmeticPen=false, int width=0, int height=0, const QString &pdfCreator=QString(), const QString &pdfTitle=QString());
+  bool savePng(const QString &fileName, int width=0, int height=0, double scale=1.0, int quality=-1);
+  bool saveJpg(const QString &fileName, int width=0, int height=0, double scale=1.0, int quality=-1);
+  bool saveBmp(const QString &fileName, int width=0, int height=0, double scale=1.0);
+  bool saveRastered(const QString &fileName, int width, int height, double scale, const char *format, int quality=-1);
+  QPixmap toPixmap(int width=0, int height=0, double scale=1.0);
+  void toPainter(QCPPainter *painter, int width=0, int height=0);
+  Q_SLOT void replot(QCustomPlot::RefreshPriority refreshPriority=QCustomPlot::rpHint);
+  
+  QCPAxis *xAxis, *yAxis, *xAxis2, *yAxis2;
+  QCPLegend *legend;
+  
+signals:
+  void mouseDoubleClick(QMouseEvent *event);
+  void mousePress(QMouseEvent *event);
+  void mouseMove(QMouseEvent *event);
+  void mouseRelease(QMouseEvent *event);
+  void mouseWheel(QWheelEvent *event);
+  
+  void plottableClick(QCPAbstractPlottable *plottable, QMouseEvent *event);
+  void plottableDoubleClick(QCPAbstractPlottable *plottable, QMouseEvent *event);
+  void itemClick(QCPAbstractItem *item, QMouseEvent *event);
+  void itemDoubleClick(QCPAbstractItem *item, QMouseEvent *event);
+  void axisClick(QCPAxis *axis, QCPAxis::SelectablePart part, QMouseEvent *event);
+  void axisDoubleClick(QCPAxis *axis, QCPAxis::SelectablePart part, QMouseEvent *event);
+  void legendClick(QCPLegend *legend, QCPAbstractLegendItem *item, QMouseEvent *event);
+  void legendDoubleClick(QCPLegend *legend,  QCPAbstractLegendItem *item, QMouseEvent *event);
+  void titleClick(QMouseEvent *event, QCPPlotTitle *title);
+  void titleDoubleClick(QMouseEvent *event, QCPPlotTitle *title);
+  
+  void selectionChangedByUser();
+  void beforeReplot();
+  void afterReplot();
+  
+protected:
+  // property members:
+  QRect mViewport;
+  QCPLayoutGrid *mPlotLayout;
+  bool mAutoAddPlottableToLegend;
+  QList<QCPAbstractPlottable*> mPlottables;
+  QList<QCPGraph*> mGraphs; // extra list of plottables also in mPlottables that are of type QCPGraph
+  QList<QCPAbstractItem*> mItems;
+  QList<QCPLayer*> mLayers;
+  QCP::AntialiasedElements mAntialiasedElements, mNotAntialiasedElements;
+  QCP::Interactions mInteractions;
+  int mSelectionTolerance;
+  bool mNoAntialiasingOnDrag;
+  QBrush mBackgroundBrush;
+  QPixmap mBackgroundPixmap;
+  QPixmap mScaledBackgroundPixmap;
+  bool mBackgroundScaled;
+  Qt::AspectRatioMode mBackgroundScaledMode;
+  QCPLayer *mCurrentLayer;
+  QCP::PlottingHints mPlottingHints;
+  Qt::KeyboardModifier mMultiSelectModifier;
+  
+  // non-property members:
+  QPixmap mPaintBuffer;
+  QPoint mMousePressPos;
+  QPointer<QCPLayoutElement> mMouseEventElement;
+  bool mReplotting;
+  
+  // reimplemented virtual methods:
+  virtual QSize minimumSizeHint() const;
+  virtual QSize sizeHint() const;
+  virtual void paintEvent(QPaintEvent *event);
+  virtual void resizeEvent(QResizeEvent *event);
+  virtual void mouseDoubleClickEvent(QMouseEvent *event);
+  virtual void mousePressEvent(QMouseEvent *event);
+  virtual void mouseMoveEvent(QMouseEvent *event);
+  virtual void mouseReleaseEvent(QMouseEvent *event);
+  virtual void wheelEvent(QWheelEvent *event);
+  
+  // introduced virtual methods:
+  virtual void draw(QCPPainter *painter);
+  virtual void axisRemoved(QCPAxis *axis);
+  virtual void legendRemoved(QCPLegend *legend);
+  
+  // non-virtual methods:
+  void updateLayerIndices() const;
+  QCPLayerable *layerableAt(const QPointF &pos, bool onlySelectable, QVariant *selectionDetails=0) const;
+  void drawBackground(QCPPainter *painter);
+  
+  friend class QCPLegend;
+  friend class QCPAxis;
+  friend class QCPLayer;
+  friend class QCPAxisRect;
+};
+
+
+class QCP_LIB_DECL QCPColorGradient
+{
+  Q_GADGET
+public:
+  /*!
+    Defines the color spaces in which color interpolation between gradient stops can be performed.
+    
+    \see setColorInterpolation
+  */
+  enum ColorInterpolation { ciRGB  ///< Color channels red, green and blue are linearly interpolated
+                            ,ciHSV ///< Color channels hue, saturation and value are linearly interpolated (The hue is interpolated over the shortest angle distance)
+                          };
+  Q_ENUMS(ColorInterpolation)
+  
+  /*!
+    Defines the available presets that can be loaded with \ref loadPreset. See the documentation
+    there for an image of the presets.
+  */
+  enum GradientPreset { gpGrayscale  ///< Continuous lightness from black to white (suited for non-biased data representation)
+                        ,gpHot       ///< Continuous lightness from black over firey colors to white (suited for non-biased data representation)
+                        ,gpCold      ///< Continuous lightness from black over icey colors to white (suited for non-biased data representation)
+                        ,gpNight     ///< Continuous lightness from black over weak blueish colors to white (suited for non-biased data representation)
+                        ,gpCandy     ///< Blue over pink to white
+                        ,gpGeography ///< Colors suitable to represent different elevations on geographical maps
+                        ,gpIon       ///< Half hue spectrum from black over purple to blue and finally green (creates banding illusion but allows more precise magnitude estimates)
+                        ,gpThermal   ///< Colors suitable for thermal imaging, ranging from dark blue over purple to orange, yellow and white
+                        ,gpPolar     ///< Colors suitable to emphasize polarity around the center, with blue for negative, black in the middle and red for positive values
+                        ,gpSpectrum  ///< An approximation of the visible light spectrum (creates banding illusion but allows more precise magnitude estimates)
+                        ,gpJet       ///< Hue variation similar to a spectrum, often used in numerical visualization (creates banding illusion but allows more precise magnitude estimates)
+                        ,gpHues      ///< Full hue cycle, with highest and lowest color red (suitable for periodic data, such as angles and phases, see \ref setPeriodic)
+                      };
+  Q_ENUMS(GradientPreset)
+  
+  QCPColorGradient(GradientPreset preset=gpCold);
+  bool operator==(const QCPColorGradient &other) const;
+  bool operator!=(const QCPColorGradient &other) const { return !(*this == other); }
+  
+  // getters:
+  int levelCount() const { return mLevelCount; }
+  QMap<double, QColor> colorStops() const { return mColorStops; }
+  ColorInterpolation colorInterpolation() const { return mColorInterpolation; }
+  bool periodic() const { return mPeriodic; }
+  
+  // setters:
+  void setLevelCount(int n);
+  void setColorStops(const QMap<double, QColor> &colorStops);
+  void setColorStopAt(double position, const QColor &color);
+  void setColorInterpolation(ColorInterpolation interpolation);
+  void setPeriodic(bool enabled);
+  
+  // non-property methods:
+  void colorize(const double *data, const QCPRange &range, QRgb *scanLine, int n, int dataIndexFactor=1, bool logarithmic=false);
+  QRgb color(double position, const QCPRange &range, bool logarithmic=false);
+  void loadPreset(GradientPreset preset);
+  void clearColorStops();
+  QCPColorGradient inverted() const;
+  
+protected:
+  void updateColorBuffer();
+  
+  // property members:
+  int mLevelCount;
+  QMap<double, QColor> mColorStops;
+  ColorInterpolation mColorInterpolation;
+  bool mPeriodic;
+  
+  // non-property members:
+  QVector<QRgb> mColorBuffer;
+  bool mColorBufferInvalidated;
+};
+
+
+class QCP_LIB_DECL QCPAxisRect : public QCPLayoutElement
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QPixmap background READ background WRITE setBackground)
+  Q_PROPERTY(bool backgroundScaled READ backgroundScaled WRITE setBackgroundScaled)
+  Q_PROPERTY(Qt::AspectRatioMode backgroundScaledMode READ backgroundScaledMode WRITE setBackgroundScaledMode)
+  Q_PROPERTY(Qt::Orientations rangeDrag READ rangeDrag WRITE setRangeDrag)
+  Q_PROPERTY(Qt::Orientations rangeZoom READ rangeZoom WRITE setRangeZoom)
+  /// \endcond
+public:
+  explicit QCPAxisRect(QCustomPlot *parentPlot, bool setupDefaultAxes=true);
+  virtual ~QCPAxisRect();
+  
+  // getters:
+  QPixmap background() const { return mBackgroundPixmap; }
+  bool backgroundScaled() const { return mBackgroundScaled; }
+  Qt::AspectRatioMode backgroundScaledMode() const { return mBackgroundScaledMode; }
+  Qt::Orientations rangeDrag() const { return mRangeDrag; }
+  Qt::Orientations rangeZoom() const { return mRangeZoom; }
+  QCPAxis *rangeDragAxis(Qt::Orientation orientation);
+  QCPAxis *rangeZoomAxis(Qt::Orientation orientation);
+  double rangeZoomFactor(Qt::Orientation orientation);
+  
+  // setters:
+  void setBackground(const QPixmap &pm);
+  void setBackground(const QPixmap &pm, bool scaled, Qt::AspectRatioMode mode=Qt::KeepAspectRatioByExpanding);
+  void setBackground(const QBrush &brush);
+  void setBackgroundScaled(bool scaled);
+  void setBackgroundScaledMode(Qt::AspectRatioMode mode);
+  void setRangeDrag(Qt::Orientations orientations);
+  void setRangeZoom(Qt::Orientations orientations);
+  void setRangeDragAxes(QCPAxis *horizontal, QCPAxis *vertical);
+  void setRangeZoomAxes(QCPAxis *horizontal, QCPAxis *vertical);
+  void setRangeZoomFactor(double horizontalFactor, double verticalFactor);
+  void setRangeZoomFactor(double factor);
+  
+  // non-property methods:
+  int axisCount(QCPAxis::AxisType type) const;
+  QCPAxis *axis(QCPAxis::AxisType type, int index=0) const;
+  QList<QCPAxis*> axes(QCPAxis::AxisTypes types) const;
+  QList<QCPAxis*> axes() const;
+  QCPAxis *addAxis(QCPAxis::AxisType type, QCPAxis *axis=0);
+  QList<QCPAxis*> addAxes(QCPAxis::AxisTypes types);
+  bool removeAxis(QCPAxis *axis);
+  QCPLayoutInset *insetLayout() const { return mInsetLayout; }
+  
+  void setupFullAxesBox(bool connectRanges=false);
+  QList<QCPAbstractPlottable*> plottables() const;
+  QList<QCPGraph*> graphs() const;
+  QList<QCPAbstractItem*> items() const;
+  
+  // read-only interface imitating a QRect:
+  int left() const { return mRect.left(); }
+  int right() const { return mRect.right(); }
+  int top() const { return mRect.top(); }
+  int bottom() const { return mRect.bottom(); }
+  int width() const { return mRect.width(); }
+  int height() const { return mRect.height(); }
+  QSize size() const { return mRect.size(); }
+  QPoint topLeft() const { return mRect.topLeft(); }
+  QPoint topRight() const { return mRect.topRight(); }
+  QPoint bottomLeft() const { return mRect.bottomLeft(); }
+  QPoint bottomRight() const { return mRect.bottomRight(); }
+  QPoint center() const { return mRect.center(); }
+  
+  // reimplemented virtual methods:
+  virtual void update(UpdatePhase phase);
+  virtual QList<QCPLayoutElement*> elements(bool recursive) const;
+
+protected:
+  // property members:
+  QBrush mBackgroundBrush;
+  QPixmap mBackgroundPixmap;
+  QPixmap mScaledBackgroundPixmap;
+  bool mBackgroundScaled;
+  Qt::AspectRatioMode mBackgroundScaledMode;
+  QCPLayoutInset *mInsetLayout;
+  Qt::Orientations mRangeDrag, mRangeZoom;
+  QPointer<QCPAxis> mRangeDragHorzAxis, mRangeDragVertAxis, mRangeZoomHorzAxis, mRangeZoomVertAxis;
+  double mRangeZoomFactorHorz, mRangeZoomFactorVert;
+  // non-property members:
+  QCPRange mDragStartHorzRange, mDragStartVertRange;
+  QCP::AntialiasedElements mAADragBackup, mNotAADragBackup;
+  QPoint mDragStart;
+  bool mDragging;
+  QHash<QCPAxis::AxisType, QList<QCPAxis*> > mAxes;
+  
+  // reimplemented virtual methods:
+  virtual void applyDefaultAntialiasingHint(QCPPainter *painter) const;
+  virtual void draw(QCPPainter *painter);
+  virtual int calculateAutoMargin(QCP::MarginSide side);
+  // events:
+  virtual void mousePressEvent(QMouseEvent *event);
+  virtual void mouseMoveEvent(QMouseEvent *event);
+  virtual void mouseReleaseEvent(QMouseEvent *event);
+  virtual void wheelEvent(QWheelEvent *event);
+  
+  // non-property methods:
+  void drawBackground(QCPPainter *painter);
+  void updateAxesOffset(QCPAxis::AxisType type);
+  
+private:
+  Q_DISABLE_COPY(QCPAxisRect)
+  
+  friend class QCustomPlot;
+};
+
+
+class QCP_LIB_DECL QCPAbstractLegendItem : public QCPLayoutElement
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QCPLegend* parentLegend READ parentLegend)
+  Q_PROPERTY(QFont font READ font WRITE setFont)
+  Q_PROPERTY(QColor textColor READ textColor WRITE setTextColor)
+  Q_PROPERTY(QFont selectedFont READ selectedFont WRITE setSelectedFont)
+  Q_PROPERTY(QColor selectedTextColor READ selectedTextColor WRITE setSelectedTextColor)
+  Q_PROPERTY(bool selectable READ selectable WRITE setSelectable NOTIFY selectionChanged)
+  Q_PROPERTY(bool selected READ selected WRITE setSelected NOTIFY selectableChanged)
+  /// \endcond
+public:
+  explicit QCPAbstractLegendItem(QCPLegend *parent);
+  
+  // getters:
+  QCPLegend *parentLegend() const { return mParentLegend; }
+  QFont font() const { return mFont; }
+  QColor textColor() const { return mTextColor; }
+  QFont selectedFont() const { return mSelectedFont; }
+  QColor selectedTextColor() const { return mSelectedTextColor; }
+  bool selectable() const { return mSelectable; }
+  bool selected() const { return mSelected; }
+  
+  // setters:
+  void setFont(const QFont &font);
+  void setTextColor(const QColor &color);
+  void setSelectedFont(const QFont &font);
+  void setSelectedTextColor(const QColor &color);
+  Q_SLOT void setSelectable(bool selectable);
+  Q_SLOT void setSelected(bool selected);
+  
+  // reimplemented virtual methods:
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+signals:
+  void selectionChanged(bool selected);
+  void selectableChanged(bool selectable);
+  
+protected:
+  // property members:
+  QCPLegend *mParentLegend;
+  QFont mFont;
+  QColor mTextColor;
+  QFont mSelectedFont;
+  QColor mSelectedTextColor;
+  bool mSelectable, mSelected;
+  
+  // reimplemented virtual methods:
+  virtual QCP::Interaction selectionCategory() const;
+  virtual void applyDefaultAntialiasingHint(QCPPainter *painter) const;
+  virtual QRect clipRect() const;
+  virtual void draw(QCPPainter *painter) = 0;
+  // events:
+  virtual void selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged);
+  virtual void deselectEvent(bool *selectionStateChanged);
+  
+private:
+  Q_DISABLE_COPY(QCPAbstractLegendItem)
+  
+  friend class QCPLegend;
+};
+
+
+class QCP_LIB_DECL QCPPlottableLegendItem : public QCPAbstractLegendItem
+{
+  Q_OBJECT
+public:
+  QCPPlottableLegendItem(QCPLegend *parent, QCPAbstractPlottable *plottable);
+  
+  // getters:
+  QCPAbstractPlottable *plottable() { return mPlottable; }
+  
+protected:
+  // property members:
+  QCPAbstractPlottable *mPlottable;
+  
+  // reimplemented virtual methods:
+  virtual void draw(QCPPainter *painter);
+  virtual QSize minimumSizeHint() const;
+  
+  // non-virtual methods:
+  QPen getIconBorderPen() const;
+  QColor getTextColor() const;
+  QFont getFont() const;
+};
+
+
+class QCP_LIB_DECL QCPLegend : public QCPLayoutGrid
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QPen borderPen READ borderPen WRITE setBorderPen)
+  Q_PROPERTY(QBrush brush READ brush WRITE setBrush)
+  Q_PROPERTY(QFont font READ font WRITE setFont)
+  Q_PROPERTY(QColor textColor READ textColor WRITE setTextColor)
+  Q_PROPERTY(QSize iconSize READ iconSize WRITE setIconSize)
+  Q_PROPERTY(int iconTextPadding READ iconTextPadding WRITE setIconTextPadding)
+  Q_PROPERTY(QPen iconBorderPen READ iconBorderPen WRITE setIconBorderPen)
+  Q_PROPERTY(SelectableParts selectableParts READ selectableParts WRITE setSelectableParts NOTIFY selectionChanged)
+  Q_PROPERTY(SelectableParts selectedParts READ selectedParts WRITE setSelectedParts NOTIFY selectableChanged)
+  Q_PROPERTY(QPen selectedBorderPen READ selectedBorderPen WRITE setSelectedBorderPen)
+  Q_PROPERTY(QPen selectedIconBorderPen READ selectedIconBorderPen WRITE setSelectedIconBorderPen)
+  Q_PROPERTY(QBrush selectedBrush READ selectedBrush WRITE setSelectedBrush)
+  Q_PROPERTY(QFont selectedFont READ selectedFont WRITE setSelectedFont)
+  Q_PROPERTY(QColor selectedTextColor READ selectedTextColor WRITE setSelectedTextColor)
+  /// \endcond
+public:
+  /*!
+    Defines the selectable parts of a legend
+    
+    \see setSelectedParts, setSelectableParts
+  */
+  enum SelectablePart { spNone       = 0x000  ///< <tt>0x000</tt> None
+                        ,spLegendBox  = 0x001 ///< <tt>0x001</tt> The legend box (frame)
+                        ,spItems      = 0x002 ///< <tt>0x002</tt> Legend items individually (see \ref selectedItems)
+                      };
+  Q_FLAGS(SelectablePart SelectableParts)
+  Q_DECLARE_FLAGS(SelectableParts, SelectablePart)
+  
+  explicit QCPLegend();
+  virtual ~QCPLegend();
+  
+  // getters:
+  QPen borderPen() const { return mBorderPen; }
+  QBrush brush() const { return mBrush; }
+  QFont font() const { return mFont; }
+  QColor textColor() const { return mTextColor; }
+  QSize iconSize() const { return mIconSize; }
+  int iconTextPadding() const { return mIconTextPadding; }
+  QPen iconBorderPen() const { return mIconBorderPen; }
+  SelectableParts selectableParts() const { return mSelectableParts; }
+  SelectableParts selectedParts() const;
+  QPen selectedBorderPen() const { return mSelectedBorderPen; }
+  QPen selectedIconBorderPen() const { return mSelectedIconBorderPen; }
+  QBrush selectedBrush() const { return mSelectedBrush; }
+  QFont selectedFont() const { return mSelectedFont; }
+  QColor selectedTextColor() const { return mSelectedTextColor; }
+  
+  // setters:
+  void setBorderPen(const QPen &pen);
+  void setBrush(const QBrush &brush);
+  void setFont(const QFont &font);
+  void setTextColor(const QColor &color);
+  void setIconSize(const QSize &size);
+  void setIconSize(int width, int height);
+  void setIconTextPadding(int padding);
+  void setIconBorderPen(const QPen &pen);
+  Q_SLOT void setSelectableParts(const SelectableParts &selectableParts);
+  Q_SLOT void setSelectedParts(const SelectableParts &selectedParts);
+  void setSelectedBorderPen(const QPen &pen);
+  void setSelectedIconBorderPen(const QPen &pen);
+  void setSelectedBrush(const QBrush &brush);
+  void setSelectedFont(const QFont &font);
+  void setSelectedTextColor(const QColor &color);
+  
+  // reimplemented virtual methods:
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+  // non-virtual methods:
+  QCPAbstractLegendItem *item(int index) const;
+  QCPPlottableLegendItem *itemWithPlottable(const QCPAbstractPlottable *plottable) const;
+  int itemCount() const;
+  bool hasItem(QCPAbstractLegendItem *item) const;
+  bool hasItemWithPlottable(const QCPAbstractPlottable *plottable) const;
+  bool addItem(QCPAbstractLegendItem *item);
+  bool removeItem(int index);
+  bool removeItem(QCPAbstractLegendItem *item);
+  void clearItems();
+  QList<QCPAbstractLegendItem*> selectedItems() const;
+  
+signals:
+  void selectionChanged(QCPLegend::SelectableParts parts);
+  void selectableChanged(QCPLegend::SelectableParts parts);
+  
+protected:
+  // property members:
+  QPen mBorderPen, mIconBorderPen;
+  QBrush mBrush;
+  QFont mFont;
+  QColor mTextColor;
+  QSize mIconSize;
+  int mIconTextPadding;
+  SelectableParts mSelectedParts, mSelectableParts;
+  QPen mSelectedBorderPen, mSelectedIconBorderPen;
+  QBrush mSelectedBrush;
+  QFont mSelectedFont;
+  QColor mSelectedTextColor;
+  
+  // reimplemented virtual methods:
+  virtual void parentPlotInitialized(QCustomPlot *parentPlot);
+  virtual QCP::Interaction selectionCategory() const;
+  virtual void applyDefaultAntialiasingHint(QCPPainter *painter) const;
+  virtual void draw(QCPPainter *painter);
+  // events:
+  virtual void selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged);
+  virtual void deselectEvent(bool *selectionStateChanged);
+  
+  // non-virtual methods:
+  QPen getBorderPen() const;
+  QBrush getBrush() const;
+  
+private:
+  Q_DISABLE_COPY(QCPLegend)
+  
+  friend class QCustomPlot;
+  friend class QCPAbstractLegendItem;
+};
+Q_DECLARE_OPERATORS_FOR_FLAGS(QCPLegend::SelectableParts)
+Q_DECLARE_METATYPE(QCPLegend::SelectablePart)
+
+
+class QCP_LIB_DECL QCPPlotTitle : public QCPLayoutElement
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QString text READ text WRITE setText)
+  Q_PROPERTY(QFont font READ font WRITE setFont)
+  Q_PROPERTY(QColor textColor READ textColor WRITE setTextColor)
+  Q_PROPERTY(QFont selectedFont READ selectedFont WRITE setSelectedFont)
+  Q_PROPERTY(QColor selectedTextColor READ selectedTextColor WRITE setSelectedTextColor)
+  Q_PROPERTY(bool selectable READ selectable WRITE setSelectable NOTIFY selectableChanged)
+  Q_PROPERTY(bool selected READ selected WRITE setSelected NOTIFY selectionChanged)
+  /// \endcond
+public:
+  explicit QCPPlotTitle(QCustomPlot *parentPlot);
+  explicit QCPPlotTitle(QCustomPlot *parentPlot, const QString &text);
+  
+  // getters:
+  QString text() const { return mText; }
+  QFont font() const { return mFont; }
+  QColor textColor() const { return mTextColor; }
+  QFont selectedFont() const { return mSelectedFont; }
+  QColor selectedTextColor() const { return mSelectedTextColor; }
+  bool selectable() const { return mSelectable; }
+  bool selected() const { return mSelected; }
+  
+  // setters:
+  void setText(const QString &text);
+  void setFont(const QFont &font);
+  void setTextColor(const QColor &color);
+  void setSelectedFont(const QFont &font);
+  void setSelectedTextColor(const QColor &color);
+  Q_SLOT void setSelectable(bool selectable);
+  Q_SLOT void setSelected(bool selected);
+  
+  // reimplemented virtual methods:
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+signals:
+  void selectionChanged(bool selected);
+  void selectableChanged(bool selectable);
+  
+protected:
+  // property members:
+  QString mText;
+  QFont mFont;
+  QColor mTextColor;
+  QFont mSelectedFont;
+  QColor mSelectedTextColor;
+  QRect mTextBoundingRect;
+  bool mSelectable, mSelected;
+  
+  // reimplemented virtual methods:
+  virtual void applyDefaultAntialiasingHint(QCPPainter *painter) const;
+  virtual void draw(QCPPainter *painter);
+  virtual QSize minimumSizeHint() const;
+  virtual QSize maximumSizeHint() const;
+  // events:
+  virtual void selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged);
+  virtual void deselectEvent(bool *selectionStateChanged);
+  
+  // non-virtual methods:
+  QFont mainFont() const;
+  QColor mainTextColor() const;
+  
+private:
+  Q_DISABLE_COPY(QCPPlotTitle)
+};
+
+
+class QCPColorScaleAxisRectPrivate : public QCPAxisRect
+{
+  Q_OBJECT
+public:
+  explicit QCPColorScaleAxisRectPrivate(QCPColorScale *parentColorScale);
+protected:
+  QCPColorScale *mParentColorScale;
+  QImage mGradientImage;
+  bool mGradientImageInvalidated;
+  // re-using some methods of QCPAxisRect to make them available to friend class QCPColorScale
+  using QCPAxisRect::calculateAutoMargin;
+  using QCPAxisRect::mousePressEvent;
+  using QCPAxisRect::mouseMoveEvent;
+  using QCPAxisRect::mouseReleaseEvent;
+  using QCPAxisRect::wheelEvent;
+  using QCPAxisRect::update;
+  virtual void draw(QCPPainter *painter);
+  void updateGradientImage();
+  Q_SLOT void axisSelectionChanged(QCPAxis::SelectableParts selectedParts);
+  Q_SLOT void axisSelectableChanged(QCPAxis::SelectableParts selectableParts);
+  friend class QCPColorScale;
+};
+
+
+class QCP_LIB_DECL QCPColorScale : public QCPLayoutElement
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QCPAxis::AxisType type READ type WRITE setType)
+  Q_PROPERTY(QCPRange dataRange READ dataRange WRITE setDataRange NOTIFY dataRangeChanged)
+  Q_PROPERTY(QCPAxis::ScaleType dataScaleType READ dataScaleType WRITE setDataScaleType NOTIFY dataScaleTypeChanged)
+  Q_PROPERTY(QCPColorGradient gradient READ gradient WRITE setGradient NOTIFY gradientChanged)
+  Q_PROPERTY(QString label READ label WRITE setLabel)
+  Q_PROPERTY(int barWidth READ barWidth WRITE setBarWidth)
+  Q_PROPERTY(bool rangeDrag READ rangeDrag WRITE setRangeDrag)
+  Q_PROPERTY(bool rangeZoom READ rangeZoom WRITE setRangeZoom)
+  /// \endcond
+public:
+  explicit QCPColorScale(QCustomPlot *parentPlot);
+  virtual ~QCPColorScale();
+  
+  // getters:
+  QCPAxis *axis() const { return mColorAxis.data(); }
+  QCPAxis::AxisType type() const { return mType; }
+  QCPRange dataRange() const { return mDataRange; }
+  QCPAxis::ScaleType dataScaleType() const { return mDataScaleType; }
+  QCPColorGradient gradient() const { return mGradient; }
+  QString label() const;
+  int barWidth () const { return mBarWidth; }
+  bool rangeDrag() const;
+  bool rangeZoom() const;
+  
+  // setters:
+  void setType(QCPAxis::AxisType type);
+  Q_SLOT void setDataRange(const QCPRange &dataRange);
+  Q_SLOT void setDataScaleType(QCPAxis::ScaleType scaleType);
+  Q_SLOT void setGradient(const QCPColorGradient &gradient);
+  void setLabel(const QString &str);
+  void setBarWidth(int width);
+  void setRangeDrag(bool enabled);
+  void setRangeZoom(bool enabled);
+  
+  // non-property methods:
+  QList<QCPColorMap*> colorMaps() const;
+  void rescaleDataRange(bool onlyVisibleMaps);
+  
+  // reimplemented virtual methods:
+  virtual void update(UpdatePhase phase);
+  
+signals:
+  void dataRangeChanged(QCPRange newRange);
+  void dataScaleTypeChanged(QCPAxis::ScaleType scaleType);
+  void gradientChanged(QCPColorGradient newGradient);
+
+protected:
+  // property members:
+  QCPAxis::AxisType mType;
+  QCPRange mDataRange;
+  QCPAxis::ScaleType mDataScaleType;
+  QCPColorGradient mGradient;
+  int mBarWidth;
+  
+  // non-property members:
+  QPointer<QCPColorScaleAxisRectPrivate> mAxisRect;
+  QPointer<QCPAxis> mColorAxis;
+  
+  // reimplemented virtual methods:
+  virtual void applyDefaultAntialiasingHint(QCPPainter *painter) const;
+  // events:
+  virtual void mousePressEvent(QMouseEvent *event);
+  virtual void mouseMoveEvent(QMouseEvent *event);
+  virtual void mouseReleaseEvent(QMouseEvent *event);
+  virtual void wheelEvent(QWheelEvent *event);
+  
+private:
+  Q_DISABLE_COPY(QCPColorScale)
+  
+  friend class QCPColorScaleAxisRectPrivate;
+};
+
+
+/*! \file */
+
+
+
+class QCP_LIB_DECL QCPData
+{
+public:
+  QCPData();
+  QCPData(double key, double value);
+  double key, value;
+  double keyErrorPlus, keyErrorMinus;
+  double valueErrorPlus, valueErrorMinus;
+};
+Q_DECLARE_TYPEINFO(QCPData, Q_MOVABLE_TYPE);
+
+/*! \typedef QCPDataMap
+  Container for storing \ref QCPData items in a sorted fashion. The key of the map
+  is the key member of the QCPData instance.
+  
+  This is the container in which QCPGraph holds its data.
+  \see QCPData, QCPGraph::setData
+*/
+typedef QMap<double, QCPData> QCPDataMap;
+typedef QMapIterator<double, QCPData> QCPDataMapIterator;
+typedef QMutableMapIterator<double, QCPData> QCPDataMutableMapIterator;
+
+
+class QCP_LIB_DECL QCPGraph : public QCPAbstractPlottable
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(LineStyle lineStyle READ lineStyle WRITE setLineStyle)
+  Q_PROPERTY(QCPScatterStyle scatterStyle READ scatterStyle WRITE setScatterStyle)
+  Q_PROPERTY(ErrorType errorType READ errorType WRITE setErrorType)
+  Q_PROPERTY(QPen errorPen READ errorPen WRITE setErrorPen)
+  Q_PROPERTY(double errorBarSize READ errorBarSize WRITE setErrorBarSize)
+  Q_PROPERTY(bool errorBarSkipSymbol READ errorBarSkipSymbol WRITE setErrorBarSkipSymbol)
+  Q_PROPERTY(QCPGraph* channelFillGraph READ channelFillGraph WRITE setChannelFillGraph)
+  Q_PROPERTY(bool adaptiveSampling READ adaptiveSampling WRITE setAdaptiveSampling)
+  /// \endcond
+public:
+  /*!
+    Defines how the graph's line is represented visually in the plot. The line is drawn with the
+    current pen of the graph (\ref setPen).
+    \see setLineStyle
+  */
+  enum LineStyle { lsNone        ///< data points are not connected with any lines (e.g. data only represented
+                                 ///< with symbols according to the scatter style, see \ref setScatterStyle)
+                   ,lsLine       ///< data points are connected by a straight line
+                   ,lsStepLeft   ///< line is drawn as steps where the step height is the value of the left data point
+                   ,lsStepRight  ///< line is drawn as steps where the step height is the value of the right data point
+                   ,lsStepCenter ///< line is drawn as steps where the step is in between two data points
+                   ,lsImpulse    ///< each data point is represented by a line parallel to the value axis, which reaches from the data point to the zero-value-line
+                 };
+  Q_ENUMS(LineStyle)
+  /*!
+    Defines what kind of error bars are drawn for each data point
+  */
+  enum ErrorType { etNone   ///< No error bars are shown
+                   ,etKey   ///< Error bars for the key dimension of the data point are shown
+                   ,etValue ///< Error bars for the value dimension of the data point are shown
+                   ,etBoth  ///< Error bars for both key and value dimensions of the data point are shown
+                 };
+  Q_ENUMS(ErrorType)
+  
+  explicit QCPGraph(QCPAxis *keyAxis, QCPAxis *valueAxis);
+  virtual ~QCPGraph();
+  
+  // getters:
+  QCPDataMap *data() const { return mData; }
+  LineStyle lineStyle() const { return mLineStyle; }
+  QCPScatterStyle scatterStyle() const { return mScatterStyle; }
+  ErrorType errorType() const { return mErrorType; }
+  QPen errorPen() const { return mErrorPen; }
+  double errorBarSize() const { return mErrorBarSize; }
+  bool errorBarSkipSymbol() const { return mErrorBarSkipSymbol; }
+  QCPGraph *channelFillGraph() const { return mChannelFillGraph.data(); }
+  bool adaptiveSampling() const { return mAdaptiveSampling; }
+  
+  // setters:
+  void setData(QCPDataMap *data, bool copy=false);
+  void setData(const QVector<double> &key, const QVector<double> &value);
+  void setDataKeyError(const QVector<double> &key, const QVector<double> &value, const QVector<double> &keyError);
+  void setDataKeyError(const QVector<double> &key, const QVector<double> &value, const QVector<double> &keyErrorMinus, const QVector<double> &keyErrorPlus);
+  void setDataValueError(const QVector<double> &key, const QVector<double> &value, const QVector<double> &valueError);
+  void setDataValueError(const QVector<double> &key, const QVector<double> &value, const QVector<double> &valueErrorMinus, const QVector<double> &valueErrorPlus);
+  void setDataBothError(const QVector<double> &key, const QVector<double> &value, const QVector<double> &keyError, const QVector<double> &valueError);
+  void setDataBothError(const QVector<double> &key, const QVector<double> &value, const QVector<double> &keyErrorMinus, const QVector<double> &keyErrorPlus, const QVector<double> &valueErrorMinus, const QVector<double> &valueErrorPlus);
+  void setLineStyle(LineStyle ls);
+  void setScatterStyle(const QCPScatterStyle &style);
+  void setErrorType(ErrorType errorType);
+  void setErrorPen(const QPen &pen);
+  void setErrorBarSize(double size);
+  void setErrorBarSkipSymbol(bool enabled);
+  void setChannelFillGraph(QCPGraph *targetGraph);
+  void setAdaptiveSampling(bool enabled);
+  
+  // non-property methods:
+  void addData(const QCPDataMap &dataMap);
+  void addData(const QCPData &data);
+  void addData(double key, double value);
+  void addData(const QVector<double> &keys, const QVector<double> &values);
+  void removeDataBefore(double key);
+  void removeDataAfter(double key);
+  void removeData(double fromKey, double toKey);
+  void removeData(double key);
+  
+  // reimplemented virtual methods:
+  virtual void clearData();
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  using QCPAbstractPlottable::rescaleAxes;
+  using QCPAbstractPlottable::rescaleKeyAxis;
+  using QCPAbstractPlottable::rescaleValueAxis;
+  void rescaleAxes(bool onlyEnlarge, bool includeErrorBars) const; // overloads base class interface
+  void rescaleKeyAxis(bool onlyEnlarge, bool includeErrorBars) const; // overloads base class interface
+  void rescaleValueAxis(bool onlyEnlarge, bool includeErrorBars) const; // overloads base class interface
+  
+protected:
+  // property members:
+  QCPDataMap *mData;
+  QPen mErrorPen;
+  LineStyle mLineStyle;
+  QCPScatterStyle mScatterStyle;
+  ErrorType mErrorType;
+  double mErrorBarSize;
+  bool mErrorBarSkipSymbol;
+  QPointer<QCPGraph> mChannelFillGraph;
+  bool mAdaptiveSampling;
+  
+  // reimplemented virtual methods:
+  virtual void draw(QCPPainter *painter);
+  virtual void drawLegendIcon(QCPPainter *painter, const QRectF &rect) const;
+  virtual QCPRange getKeyRange(bool &foundRange, SignDomain inSignDomain=sdBoth) const;
+  virtual QCPRange getValueRange(bool &foundRange, SignDomain inSignDomain=sdBoth) const;
+  virtual QCPRange getKeyRange(bool &foundRange, SignDomain inSignDomain, bool includeErrors) const; // overloads base class interface
+  virtual QCPRange getValueRange(bool &foundRange, SignDomain inSignDomain, bool includeErrors) const; // overloads base class interface
+  
+  // introduced virtual methods:
+  virtual void drawFill(QCPPainter *painter, QVector<QPointF> *lineData) const;
+  virtual void drawScatterPlot(QCPPainter *painter, QVector<QCPData> *scatterData) const;
+  virtual void drawLinePlot(QCPPainter *painter, QVector<QPointF> *lineData) const;
+  virtual void drawImpulsePlot(QCPPainter *painter, QVector<QPointF> *lineData) const;
+  
+  // non-virtual methods:
+  void getPreparedData(QVector<QCPData> *lineData, QVector<QCPData> *scatterData) const;
+  void getPlotData(QVector<QPointF> *lineData, QVector<QCPData> *scatterData) const;
+  void getScatterPlotData(QVector<QCPData> *scatterData) const;
+  void getLinePlotData(QVector<QPointF> *linePixelData, QVector<QCPData> *scatterData) const;
+  void getStepLeftPlotData(QVector<QPointF> *linePixelData, QVector<QCPData> *scatterData) const;
+  void getStepRightPlotData(QVector<QPointF> *linePixelData, QVector<QCPData> *scatterData) const;
+  void getStepCenterPlotData(QVector<QPointF> *linePixelData, QVector<QCPData> *scatterData) const;
+  void getImpulsePlotData(QVector<QPointF> *linePixelData, QVector<QCPData> *scatterData) const;
+  void drawError(QCPPainter *painter, double x, double y, const QCPData &data) const;
+  void getVisibleDataBounds(QCPDataMap::const_iterator &lower, QCPDataMap::const_iterator &upper) const;
+  int countDataInBounds(const QCPDataMap::const_iterator &lower, const QCPDataMap::const_iterator &upper, int maxCount) const;
+  void addFillBasePoints(QVector<QPointF> *lineData) const;
+  void removeFillBasePoints(QVector<QPointF> *lineData) const;
+  QPointF lowerFillBasePoint(double lowerKey) const;
+  QPointF upperFillBasePoint(double upperKey) const;
+  const QPolygonF getChannelFillPolygon(const QVector<QPointF> *lineData) const;
+  int findIndexBelowX(const QVector<QPointF> *data, double x) const;
+  int findIndexAboveX(const QVector<QPointF> *data, double x) const;
+  int findIndexBelowY(const QVector<QPointF> *data, double y) const;
+  int findIndexAboveY(const QVector<QPointF> *data, double y) const;
+  double pointDistance(const QPointF &pixelPoint) const;
+  
+  friend class QCustomPlot;
+  friend class QCPLegend;
+};
+
+
+/*! \file */
+
+
+
+class QCP_LIB_DECL QCPCurveData
+{
+public:
+  QCPCurveData();
+  QCPCurveData(double t, double key, double value);
+  double t, key, value;
+};
+Q_DECLARE_TYPEINFO(QCPCurveData, Q_MOVABLE_TYPE);
+
+/*! \typedef QCPCurveDataMap
+  Container for storing \ref QCPCurveData items in a sorted fashion. The key of the map
+  is the t member of the QCPCurveData instance.
+  
+  This is the container in which QCPCurve holds its data.
+  \see QCPCurveData, QCPCurve::setData
+*/
+
+typedef QMap<double, QCPCurveData> QCPCurveDataMap;
+typedef QMapIterator<double, QCPCurveData> QCPCurveDataMapIterator;
+typedef QMutableMapIterator<double, QCPCurveData> QCPCurveDataMutableMapIterator;
+
+
+class QCP_LIB_DECL QCPCurve : public QCPAbstractPlottable
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QCPScatterStyle scatterStyle READ scatterStyle WRITE setScatterStyle)
+  Q_PROPERTY(LineStyle lineStyle READ lineStyle WRITE setLineStyle)
+  /// \endcond
+public:
+  /*!
+    Defines how the curve's line is represented visually in the plot. The line is drawn with the
+    current pen of the curve (\ref setPen).
+    \see setLineStyle
+  */
+  enum LineStyle { lsNone  ///< No line is drawn between data points (e.g. only scatters)
+                   ,lsLine ///< Data points are connected with a straight line
+                 };
+  explicit QCPCurve(QCPAxis *keyAxis, QCPAxis *valueAxis);
+  virtual ~QCPCurve();
+  
+  // getters:
+  QCPCurveDataMap *data() const { return mData; }
+  QCPScatterStyle scatterStyle() const { return mScatterStyle; }
+  LineStyle lineStyle() const { return mLineStyle; }
+  
+  // setters:
+  void setData(QCPCurveDataMap *data, bool copy=false);
+  void setData(const QVector<double> &t, const QVector<double> &key, const QVector<double> &value);
+  void setData(const QVector<double> &key, const QVector<double> &value);
+  void setScatterStyle(const QCPScatterStyle &style);
+  void setLineStyle(LineStyle style);
+  
+  // non-property methods:
+  void addData(const QCPCurveDataMap &dataMap);
+  void addData(const QCPCurveData &data);
+  void addData(double t, double key, double value);
+  void addData(double key, double value);
+  void addData(const QVector<double> &ts, const QVector<double> &keys, const QVector<double> &values);
+  void removeDataBefore(double t);
+  void removeDataAfter(double t);
+  void removeData(double fromt, double tot);
+  void removeData(double t);
+  
+  // reimplemented virtual methods:
+  virtual void clearData();
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+protected:
+  // property members:
+  QCPCurveDataMap *mData;
+  QCPScatterStyle mScatterStyle;
+  LineStyle mLineStyle;
+  
+  // reimplemented virtual methods:
+  virtual void draw(QCPPainter *painter);
+  virtual void drawLegendIcon(QCPPainter *painter, const QRectF &rect) const;
+  virtual QCPRange getKeyRange(bool &foundRange, SignDomain inSignDomain=sdBoth) const;
+  virtual QCPRange getValueRange(bool &foundRange, SignDomain inSignDomain=sdBoth) const;
+  
+  // introduced virtual methods:
+  virtual void drawScatterPlot(QCPPainter *painter, const QVector<QPointF> *pointData) const;
+  
+  // non-virtual methods:
+  void getCurveData(QVector<QPointF> *lineData) const;
+  int getRegion(double x, double y, double rectLeft, double rectTop, double rectRight, double rectBottom) const;
+  QPointF getOptimizedPoint(int prevRegion, double prevKey, double prevValue, double key, double value, double rectLeft, double rectTop, double rectRight, double rectBottom) const;
+  QVector<QPointF> getOptimizedCornerPoints(int prevRegion, int currentRegion, double prevKey, double prevValue, double key, double value, double rectLeft, double rectTop, double rectRight, double rectBottom) const;
+  bool mayTraverse(int prevRegion, int currentRegion) const;
+  bool getTraverse(double prevKey, double prevValue, double key, double value, double rectLeft, double rectTop, double rectRight, double rectBottom, QPointF &crossA, QPointF &crossB) const;
+  void getTraverseCornerPoints(int prevRegion, int currentRegion, double rectLeft, double rectTop, double rectRight, double rectBottom, QVector<QPointF> &beforeTraverse, QVector<QPointF> &afterTraverse) const;
+  double pointDistance(const QPointF &pixelPoint) const;
+  
+  friend class QCustomPlot;
+  friend class QCPLegend;
+};
+
+
+/*! \file */
+
+
+
+class QCP_LIB_DECL QCPBarsGroup : public QObject
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(SpacingType spacingType READ spacingType WRITE setSpacingType)
+  Q_PROPERTY(double spacing READ spacing WRITE setSpacing)
+  /// \endcond
+public:
+  /*!
+    Defines the ways the spacing between bars in the group can be specified. Thus it defines what
+    the number passed to \ref setSpacing actually means.
+    
+    \see setSpacingType, setSpacing
+  */
+  enum SpacingType { stAbsolute       ///< Bar spacing is in absolute pixels
+                     ,stAxisRectRatio ///< Bar spacing is given by a fraction of the axis rect size
+                     ,stPlotCoords    ///< Bar spacing is in key coordinates and thus scales with the key axis range
+                 };
+  QCPBarsGroup(QCustomPlot *parentPlot);
+  ~QCPBarsGroup();
+  
+  // getters:
+  SpacingType spacingType() const { return mSpacingType; }
+  double spacing() const { return mSpacing; }
+  
+  // setters:
+  void setSpacingType(SpacingType spacingType);
+  void setSpacing(double spacing);
+  
+  // non-virtual methods:
+  QList<QCPBars*> bars() const { return mBars; }
+  QCPBars* bars(int index) const;
+  int size() const { return mBars.size(); }
+  bool isEmpty() const { return mBars.isEmpty(); }
+  void clear();
+  bool contains(QCPBars *bars) const { return mBars.contains(bars); }
+  void append(QCPBars *bars);
+  void insert(int i, QCPBars *bars);
+  void remove(QCPBars *bars);
+  
+protected:
+  // non-property members:
+  QCustomPlot *mParentPlot;
+  SpacingType mSpacingType;
+  double mSpacing;
+  QList<QCPBars*> mBars;
+  
+  // non-virtual methods:
+  void registerBars(QCPBars *bars);
+  void unregisterBars(QCPBars *bars);
+  
+  // virtual methods:
+  double keyPixelOffset(const QCPBars *bars, double keyCoord);
+  double getPixelSpacing(const QCPBars *bars, double keyCoord);
+  
+private:
+  Q_DISABLE_COPY(QCPBarsGroup)
+  
+  friend class QCPBars;
+};
+
+
+class QCP_LIB_DECL QCPBarData
+{
+public:
+  QCPBarData();
+  QCPBarData(double key, double value);
+  double key, value;
+};
+Q_DECLARE_TYPEINFO(QCPBarData, Q_MOVABLE_TYPE);
+
+/*! \typedef QCPBarDataMap
+  Container for storing \ref QCPBarData items in a sorted fashion. The key of the map
+  is the key member of the QCPBarData instance.
+  
+  This is the container in which QCPBars holds its data.
+  \see QCPBarData, QCPBars::setData
+*/
+typedef QMap<double, QCPBarData> QCPBarDataMap;
+typedef QMapIterator<double, QCPBarData> QCPBarDataMapIterator;
+typedef QMutableMapIterator<double, QCPBarData> QCPBarDataMutableMapIterator;
+
+
+class QCP_LIB_DECL QCPBars : public QCPAbstractPlottable
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(double width READ width WRITE setWidth)
+  Q_PROPERTY(WidthType widthType READ widthType WRITE setWidthType)
+  Q_PROPERTY(QCPBarsGroup* barsGroup READ barsGroup WRITE setBarsGroup)
+  Q_PROPERTY(double baseValue READ baseValue WRITE setBaseValue)
+  Q_PROPERTY(QCPBars* barBelow READ barBelow)
+  Q_PROPERTY(QCPBars* barAbove READ barAbove)
+  /// \endcond
+public:
+  /*!
+    Defines the ways the width of the bar can be specified. Thus it defines what the number passed
+    to \ref setWidth actually means.
+    
+    \see setWidthType, setWidth
+  */
+  enum WidthType { wtAbsolute       ///< Bar width is in absolute pixels
+                   ,wtAxisRectRatio ///< Bar width is given by a fraction of the axis rect size
+                   ,wtPlotCoords    ///< Bar width is in key coordinates and thus scales with the key axis range
+                 };
+   Q_ENUMS(WidthType)
+  
+  explicit QCPBars(QCPAxis *keyAxis, QCPAxis *valueAxis);
+  virtual ~QCPBars();
+  
+  // getters:
+  double width() const { return mWidth; }
+  WidthType widthType() const { return mWidthType; }
+  QCPBarsGroup *barsGroup() const { return mBarsGroup; }
+  double baseValue() const { return mBaseValue; }
+  QCPBars *barBelow() const { return mBarBelow.data(); }
+  QCPBars *barAbove() const { return mBarAbove.data(); }
+  QCPBarDataMap *data() const { return mData; }
+  
+  // setters:
+  void setWidth(double width);
+  void setWidthType(WidthType widthType);
+  void setBarsGroup(QCPBarsGroup *barsGroup);
+  void setBaseValue(double baseValue);
+  void setData(QCPBarDataMap *data, bool copy=false);
+  void setData(const QVector<double> &key, const QVector<double> &value);
+  
+  // non-property methods:
+  void moveBelow(QCPBars *bars);
+  void moveAbove(QCPBars *bars);
+  void addData(const QCPBarDataMap &dataMap);
+  void addData(const QCPBarData &data);
+  void addData(double key, double value);
+  void addData(const QVector<double> &keys, const QVector<double> &values);
+  void removeDataBefore(double key);
+  void removeDataAfter(double key);
+  void removeData(double fromKey, double toKey);
+  void removeData(double key);
+  
+  // reimplemented virtual methods:
+  virtual void clearData();
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+protected:
+  // property members:
+  QCPBarDataMap *mData;
+  double mWidth;
+  WidthType mWidthType;
+  QCPBarsGroup *mBarsGroup;
+  double mBaseValue;
+  QPointer<QCPBars> mBarBelow, mBarAbove;
+  
+  // reimplemented virtual methods:
+  virtual void draw(QCPPainter *painter);
+  virtual void drawLegendIcon(QCPPainter *painter, const QRectF &rect) const;
+  virtual QCPRange getKeyRange(bool &foundRange, SignDomain inSignDomain=sdBoth) const;
+  virtual QCPRange getValueRange(bool &foundRange, SignDomain inSignDomain=sdBoth) const;
+  
+  // non-virtual methods:
+  void getVisibleDataBounds(QCPBarDataMap::const_iterator &lower, QCPBarDataMap::const_iterator &upperEnd) const;
+  QPolygonF getBarPolygon(double key, double value) const;
+  void getPixelWidth(double key, double &lower, double &upper) const;
+  double getStackedBaseValue(double key, bool positive) const;
+  static void connectBars(QCPBars* lower, QCPBars* upper);
+  
+  friend class QCustomPlot;
+  friend class QCPLegend;
+  friend class QCPBarsGroup;
+};
+
+
+/*! \file */
+
+
+
+class QCP_LIB_DECL QCPStatisticalBox : public QCPAbstractPlottable
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(double key READ key WRITE setKey)
+  Q_PROPERTY(double minimum READ minimum WRITE setMinimum)
+  Q_PROPERTY(double lowerQuartile READ lowerQuartile WRITE setLowerQuartile)
+  Q_PROPERTY(double median READ median WRITE setMedian)
+  Q_PROPERTY(double upperQuartile READ upperQuartile WRITE setUpperQuartile)
+  Q_PROPERTY(double maximum READ maximum WRITE setMaximum)
+  Q_PROPERTY(QVector<double> outliers READ outliers WRITE setOutliers)
+  Q_PROPERTY(double width READ width WRITE setWidth)
+  Q_PROPERTY(double whiskerWidth READ whiskerWidth WRITE setWhiskerWidth)
+  Q_PROPERTY(QPen whiskerPen READ whiskerPen WRITE setWhiskerPen)
+  Q_PROPERTY(QPen whiskerBarPen READ whiskerBarPen WRITE setWhiskerBarPen)
+  Q_PROPERTY(QPen medianPen READ medianPen WRITE setMedianPen)
+  Q_PROPERTY(QCPScatterStyle outlierStyle READ outlierStyle WRITE setOutlierStyle)
+  /// \endcond
+public:
+  explicit QCPStatisticalBox(QCPAxis *keyAxis, QCPAxis *valueAxis);
+  
+  // getters:
+  double key() const { return mKey; }
+  double minimum() const { return mMinimum; }
+  double lowerQuartile() const { return mLowerQuartile; }
+  double median() const { return mMedian; }
+  double upperQuartile() const { return mUpperQuartile; }
+  double maximum() const { return mMaximum; }
+  QVector<double> outliers() const { return mOutliers; }
+  double width() const { return mWidth; }
+  double whiskerWidth() const { return mWhiskerWidth; }
+  QPen whiskerPen() const { return mWhiskerPen; }
+  QPen whiskerBarPen() const { return mWhiskerBarPen; }
+  QPen medianPen() const { return mMedianPen; }
+  QCPScatterStyle outlierStyle() const { return mOutlierStyle; }
+
+  // setters:
+  void setKey(double key);
+  void setMinimum(double value);
+  void setLowerQuartile(double value);
+  void setMedian(double value);
+  void setUpperQuartile(double value);
+  void setMaximum(double value);
+  void setOutliers(const QVector<double> &values);
+  void setData(double key, double minimum, double lowerQuartile, double median, double upperQuartile, double maximum);
+  void setWidth(double width);
+  void setWhiskerWidth(double width);
+  void setWhiskerPen(const QPen &pen);
+  void setWhiskerBarPen(const QPen &pen);
+  void setMedianPen(const QPen &pen);
+  void setOutlierStyle(const QCPScatterStyle &style);
+  
+  // non-property methods:
+  virtual void clearData();
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+protected:
+  // property members:
+  QVector<double> mOutliers;
+  double mKey, mMinimum, mLowerQuartile, mMedian, mUpperQuartile, mMaximum;
+  double mWidth;
+  double mWhiskerWidth;
+  QPen mWhiskerPen, mWhiskerBarPen, mMedianPen;
+  QCPScatterStyle mOutlierStyle;
+  
+  // reimplemented virtual methods:
+  virtual void draw(QCPPainter *painter);
+  virtual void drawLegendIcon(QCPPainter *painter, const QRectF &rect) const;
+  virtual QCPRange getKeyRange(bool &foundRange, SignDomain inSignDomain=sdBoth) const;
+  virtual QCPRange getValueRange(bool &foundRange, SignDomain inSignDomain=sdBoth) const;
+  
+  // introduced virtual methods:
+  virtual void drawQuartileBox(QCPPainter *painter, QRectF *quartileBox=0) const;
+  virtual void drawMedian(QCPPainter *painter) const;
+  virtual void drawWhiskers(QCPPainter *painter) const;
+  virtual void drawOutliers(QCPPainter *painter) const;
+  
+  friend class QCustomPlot;
+  friend class QCPLegend;
+};
+
+
+class QCP_LIB_DECL QCPColorMapData
+{
+public:
+  QCPColorMapData(int keySize, int valueSize, const QCPRange &keyRange, const QCPRange &valueRange);
+  ~QCPColorMapData();
+  QCPColorMapData(const QCPColorMapData &other);
+  QCPColorMapData &operator=(const QCPColorMapData &other);
+  
+  // getters:
+  int keySize() const { return mKeySize; }
+  int valueSize() const { return mValueSize; }
+  QCPRange keyRange() const { return mKeyRange; }
+  QCPRange valueRange() const { return mValueRange; }
+  QCPRange dataBounds() const { return mDataBounds; }
+  double data(double key, double value);
+  double cell(int keyIndex, int valueIndex);
+  
+  // setters:
+  void setSize(int keySize, int valueSize);
+  void setKeySize(int keySize);
+  void setValueSize(int valueSize);
+  void setRange(const QCPRange &keyRange, const QCPRange &valueRange);
+  void setKeyRange(const QCPRange &keyRange);
+  void setValueRange(const QCPRange &valueRange);
+  void setData(double key, double value, double z);
+  void setCell(int keyIndex, int valueIndex, double z);
+  
+  // non-property methods:
+  void recalculateDataBounds();
+  void clear();
+  void fill(double z);
+  bool isEmpty() const { return mIsEmpty; }
+  void coordToCell(double key, double value, int *keyIndex, int *valueIndex) const;
+  void cellToCoord(int keyIndex, int valueIndex, double *key, double *value) const;
+  
+protected:
+  // property members:
+  int mKeySize, mValueSize;
+  QCPRange mKeyRange, mValueRange;
+  bool mIsEmpty;
+  // non-property members:
+  double *mData;
+  QCPRange mDataBounds;
+  bool mDataModified;
+  
+  friend class QCPColorMap;
+};
+
+
+class QCP_LIB_DECL QCPColorMap : public QCPAbstractPlottable
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QCPRange dataRange READ dataRange WRITE setDataRange NOTIFY dataRangeChanged)
+  Q_PROPERTY(QCPAxis::ScaleType dataScaleType READ dataScaleType WRITE setDataScaleType NOTIFY dataScaleTypeChanged)
+  Q_PROPERTY(QCPColorGradient gradient READ gradient WRITE setGradient NOTIFY gradientChanged)
+  Q_PROPERTY(bool interpolate READ interpolate WRITE setInterpolate)
+  Q_PROPERTY(bool tightBoundary READ tightBoundary WRITE setTightBoundary)
+  Q_PROPERTY(QCPColorScale* colorScale READ colorScale WRITE setColorScale)
+  /// \endcond
+public:
+  explicit QCPColorMap(QCPAxis *keyAxis, QCPAxis *valueAxis);
+  virtual ~QCPColorMap();
+  
+  // getters:
+  QCPColorMapData *data() const { return mMapData; }
+  QCPRange dataRange() const { return mDataRange; }
+  QCPAxis::ScaleType dataScaleType() const { return mDataScaleType; }
+  bool interpolate() const { return mInterpolate; }
+  bool tightBoundary() const { return mTightBoundary; }
+  QCPColorGradient gradient() const { return mGradient; }
+  QCPColorScale *colorScale() const { return mColorScale.data(); }
+  
+  // setters:
+  void setData(QCPColorMapData *data, bool copy=false);
+  Q_SLOT void setDataRange(const QCPRange &dataRange);
+  Q_SLOT void setDataScaleType(QCPAxis::ScaleType scaleType);
+  Q_SLOT void setGradient(const QCPColorGradient &gradient);
+  void setInterpolate(bool enabled);
+  void setTightBoundary(bool enabled);
+  void setColorScale(QCPColorScale *colorScale);
+  
+  // non-property methods:
+  void rescaleDataRange(bool recalculateDataBounds=false);
+  Q_SLOT void updateLegendIcon(Qt::TransformationMode transformMode=Qt::SmoothTransformation, const QSize &thumbSize=QSize(32, 18));
+  
+  // reimplemented virtual methods:
+  virtual void clearData();
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+signals:
+  void dataRangeChanged(QCPRange newRange);
+  void dataScaleTypeChanged(QCPAxis::ScaleType scaleType);
+  void gradientChanged(QCPColorGradient newGradient);
+  
+protected:
+  // property members:
+  QCPRange mDataRange;
+  QCPAxis::ScaleType mDataScaleType;
+  QCPColorMapData *mMapData;
+  QCPColorGradient mGradient;
+  bool mInterpolate;
+  bool mTightBoundary;
+  QPointer<QCPColorScale> mColorScale;
+  // non-property members:
+  QImage mMapImage, mUndersampledMapImage;
+  QPixmap mLegendIcon;
+  bool mMapImageInvalidated;
+  
+  // introduced virtual methods:
+  virtual void updateMapImage();
+  
+  // reimplemented virtual methods:
+  virtual void draw(QCPPainter *painter);
+  virtual void drawLegendIcon(QCPPainter *painter, const QRectF &rect) const;
+  virtual QCPRange getKeyRange(bool &foundRange, SignDomain inSignDomain=sdBoth) const;
+  virtual QCPRange getValueRange(bool &foundRange, SignDomain inSignDomain=sdBoth) const;
+  
+  friend class QCustomPlot;
+  friend class QCPLegend;
+};
+
+
+/*! \file */
+
+
+
+class QCP_LIB_DECL QCPFinancialData
+{
+public:
+  QCPFinancialData();
+  QCPFinancialData(double key, double open, double high, double low, double close);
+  double key, open, high, low, close;
+};
+Q_DECLARE_TYPEINFO(QCPFinancialData, Q_MOVABLE_TYPE);
+
+/*! \typedef QCPFinancialDataMap
+  Container for storing \ref QCPFinancialData items in a sorted fashion. The key of the map
+  is the key member of the QCPFinancialData instance.
+  
+  This is the container in which QCPFinancial holds its data.
+  \see QCPFinancial, QCPFinancial::setData
+*/
+typedef QMap<double, QCPFinancialData> QCPFinancialDataMap;
+typedef QMapIterator<double, QCPFinancialData> QCPFinancialDataMapIterator;
+typedef QMutableMapIterator<double, QCPFinancialData> QCPFinancialDataMutableMapIterator;
+
+
+class QCP_LIB_DECL QCPFinancial : public QCPAbstractPlottable
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(ChartStyle chartStyle READ chartStyle WRITE setChartStyle)
+  Q_PROPERTY(double width READ width WRITE setWidth)
+  Q_PROPERTY(bool twoColored READ twoColored WRITE setTwoColored)
+  Q_PROPERTY(QBrush brushPositive READ brushPositive WRITE setBrushPositive)
+  Q_PROPERTY(QBrush brushNegative READ brushNegative WRITE setBrushNegative)
+  Q_PROPERTY(QPen penPositive READ penPositive WRITE setPenPositive)
+  Q_PROPERTY(QPen penNegative READ penNegative WRITE setPenNegative)
+  /// \endcond
+public:
+  /*!
+    Defines the possible representations of OHLC data in the plot.
+    
+    \see setChartStyle
+  */
+  enum ChartStyle { csOhlc         ///< Open-High-Low-Close bar representation
+                   ,csCandlestick  ///< Candlestick representation
+                  };
+  Q_ENUMS(ChartStyle)
+  
+  explicit QCPFinancial(QCPAxis *keyAxis, QCPAxis *valueAxis);
+  virtual ~QCPFinancial();
+  
+  // getters:
+  QCPFinancialDataMap *data() const { return mData; }
+  ChartStyle chartStyle() const { return mChartStyle; }
+  double width() const { return mWidth; }
+  bool twoColored() const { return mTwoColored; }
+  QBrush brushPositive() const { return mBrushPositive; }
+  QBrush brushNegative() const { return mBrushNegative; }
+  QPen penPositive() const { return mPenPositive; }
+  QPen penNegative() const { return mPenNegative; }
+  
+  
+  // setters:
+  void setData(QCPFinancialDataMap *data, bool copy=false);
+  void setData(const QVector<double> &key, const QVector<double> &open, const QVector<double> &high, const QVector<double> &low, const QVector<double> &close);
+  void setChartStyle(ChartStyle style);
+  void setWidth(double width);
+  void setTwoColored(bool twoColored);
+  void setBrushPositive(const QBrush &brush);
+  void setBrushNegative(const QBrush &brush);
+  void setPenPositive(const QPen &pen);
+  void setPenNegative(const QPen &pen);
+  
+  // non-property methods:
+  void addData(const QCPFinancialDataMap &dataMap);
+  void addData(const QCPFinancialData &data);
+  void addData(double key, double open, double high, double low, double close);
+  void addData(const QVector<double> &key, const QVector<double> &open, const QVector<double> &high, const QVector<double> &low, const QVector<double> &close);
+  void removeDataBefore(double key);
+  void removeDataAfter(double key);
+  void removeData(double fromKey, double toKey);
+  void removeData(double key);
+  
+  // reimplemented virtual methods:
+  virtual void clearData();
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+  // static methods:
+  static QCPFinancialDataMap timeSeriesToOhlc(const QVector<double> &time, const QVector<double> &value, double timeBinSize, double timeBinOffset = 0);
+  
+protected:
+  // property members:
+  QCPFinancialDataMap *mData;
+  ChartStyle mChartStyle;
+  double mWidth;
+  bool mTwoColored;
+  QBrush mBrushPositive, mBrushNegative;
+  QPen mPenPositive, mPenNegative;
+  
+  // reimplemented virtual methods:
+  virtual void draw(QCPPainter *painter);
+  virtual void drawLegendIcon(QCPPainter *painter, const QRectF &rect) const;
+  virtual QCPRange getKeyRange(bool &foundRange, SignDomain inSignDomain=sdBoth) const;
+  virtual QCPRange getValueRange(bool &foundRange, SignDomain inSignDomain=sdBoth) const;
+  
+  // non-virtual methods:
+  void drawOhlcPlot(QCPPainter *painter, const QCPFinancialDataMap::const_iterator &begin, const QCPFinancialDataMap::const_iterator &end);
+  void drawCandlestickPlot(QCPPainter *painter, const QCPFinancialDataMap::const_iterator &begin, const QCPFinancialDataMap::const_iterator &end);
+  double ohlcSelectTest(const QPointF &pos, const QCPFinancialDataMap::const_iterator &begin, const QCPFinancialDataMap::const_iterator &end) const;
+  double candlestickSelectTest(const QPointF &pos, const QCPFinancialDataMap::const_iterator &begin, const QCPFinancialDataMap::const_iterator &end) const;
+  void getVisibleDataBounds(QCPFinancialDataMap::const_iterator &lower, QCPFinancialDataMap::const_iterator &upper) const;
+  
+  friend class QCustomPlot;
+  friend class QCPLegend;
+};
+
+
+class QCP_LIB_DECL QCPItemStraightLine : public QCPAbstractItem
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QPen pen READ pen WRITE setPen)
+  Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)
+  /// \endcond
+public:
+  QCPItemStraightLine(QCustomPlot *parentPlot);
+  virtual ~QCPItemStraightLine();
+  
+  // getters:
+  QPen pen() const { return mPen; }
+  QPen selectedPen() const { return mSelectedPen; }
+  
+  // setters;
+  void setPen(const QPen &pen);
+  void setSelectedPen(const QPen &pen);
+  
+  // reimplemented virtual methods:
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+  QCPItemPosition * const point1;
+  QCPItemPosition * const point2;
+  
+protected:
+  // property members:
+  QPen mPen, mSelectedPen;
+  
+  // reimplemented virtual methods:
+  virtual void draw(QCPPainter *painter);
+  
+  // non-virtual methods:
+  double distToStraightLine(const QVector2D &point1, const QVector2D &vec, const QVector2D &point) const;
+  QLineF getRectClippedStraightLine(const QVector2D &point1, const QVector2D &vec, const QRect &rect) const;
+  QPen mainPen() const;
+};
+
+
+class QCP_LIB_DECL QCPItemLine : public QCPAbstractItem
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QPen pen READ pen WRITE setPen)
+  Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)
+  Q_PROPERTY(QCPLineEnding head READ head WRITE setHead)
+  Q_PROPERTY(QCPLineEnding tail READ tail WRITE setTail)
+  /// \endcond
+public:
+  QCPItemLine(QCustomPlot *parentPlot);
+  virtual ~QCPItemLine();
+  
+  // getters:
+  QPen pen() const { return mPen; }
+  QPen selectedPen() const { return mSelectedPen; }
+  QCPLineEnding head() const { return mHead; }
+  QCPLineEnding tail() const { return mTail; }
+  
+  // setters;
+  void setPen(const QPen &pen);
+  void setSelectedPen(const QPen &pen);
+  void setHead(const QCPLineEnding &head);
+  void setTail(const QCPLineEnding &tail);
+  
+  // reimplemented virtual methods:
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+  QCPItemPosition * const start;
+  QCPItemPosition * const end;
+  
+protected:
+  // property members:
+  QPen mPen, mSelectedPen;
+  QCPLineEnding mHead, mTail;
+  
+  // reimplemented virtual methods:
+  virtual void draw(QCPPainter *painter);
+  
+  // non-virtual methods:
+  QLineF getRectClippedLine(const QVector2D &start, const QVector2D &end, const QRect &rect) const;
+  QPen mainPen() const;
+};
+
+
+class QCP_LIB_DECL QCPItemCurve : public QCPAbstractItem
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QPen pen READ pen WRITE setPen)
+  Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)
+  Q_PROPERTY(QCPLineEnding head READ head WRITE setHead)
+  Q_PROPERTY(QCPLineEnding tail READ tail WRITE setTail)
+  /// \endcond
+public:
+  QCPItemCurve(QCustomPlot *parentPlot);
+  virtual ~QCPItemCurve();
+  
+  // getters:
+  QPen pen() const { return mPen; }
+  QPen selectedPen() const { return mSelectedPen; }
+  QCPLineEnding head() const { return mHead; }
+  QCPLineEnding tail() const { return mTail; }
+  
+  // setters;
+  void setPen(const QPen &pen);
+  void setSelectedPen(const QPen &pen);
+  void setHead(const QCPLineEnding &head);
+  void setTail(const QCPLineEnding &tail);
+  
+  // reimplemented virtual methods:
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+  QCPItemPosition * const start;
+  QCPItemPosition * const startDir;
+  QCPItemPosition * const endDir;
+  QCPItemPosition * const end;
+  
+protected:
+  // property members:
+  QPen mPen, mSelectedPen;
+  QCPLineEnding mHead, mTail;
+  
+  // reimplemented virtual methods:
+  virtual void draw(QCPPainter *painter);
+  
+  // non-virtual methods:
+  QPen mainPen() const;
+};
+
+
+class QCP_LIB_DECL QCPItemRect : public QCPAbstractItem
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QPen pen READ pen WRITE setPen)
+  Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)
+  Q_PROPERTY(QBrush brush READ brush WRITE setBrush)
+  Q_PROPERTY(QBrush selectedBrush READ selectedBrush WRITE setSelectedBrush)
+  /// \endcond
+public:
+  QCPItemRect(QCustomPlot *parentPlot);
+  virtual ~QCPItemRect();
+  
+  // getters:
+  QPen pen() const { return mPen; }
+  QPen selectedPen() const { return mSelectedPen; }
+  QBrush brush() const { return mBrush; }
+  QBrush selectedBrush() const { return mSelectedBrush; }
+  
+  // setters;
+  void setPen(const QPen &pen);
+  void setSelectedPen(const QPen &pen);
+  void setBrush(const QBrush &brush);
+  void setSelectedBrush(const QBrush &brush);
+  
+  // reimplemented virtual methods:
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+  QCPItemPosition * const topLeft;
+  QCPItemPosition * const bottomRight;
+  QCPItemAnchor * const top;
+  QCPItemAnchor * const topRight;
+  QCPItemAnchor * const right;
+  QCPItemAnchor * const bottom;
+  QCPItemAnchor * const bottomLeft;
+  QCPItemAnchor * const left;
+  
+protected:
+  enum AnchorIndex {aiTop, aiTopRight, aiRight, aiBottom, aiBottomLeft, aiLeft};
+  
+  // property members:
+  QPen mPen, mSelectedPen;
+  QBrush mBrush, mSelectedBrush;
+  
+  // reimplemented virtual methods:
+  virtual void draw(QCPPainter *painter);
+  virtual QPointF anchorPixelPoint(int anchorId) const;
+  
+  // non-virtual methods:
+  QPen mainPen() const;
+  QBrush mainBrush() const;
+};
+
+
+class QCP_LIB_DECL QCPItemText : public QCPAbstractItem
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QColor color READ color WRITE setColor)
+  Q_PROPERTY(QColor selectedColor READ selectedColor WRITE setSelectedColor)
+  Q_PROPERTY(QPen pen READ pen WRITE setPen)
+  Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)
+  Q_PROPERTY(QBrush brush READ brush WRITE setBrush)
+  Q_PROPERTY(QBrush selectedBrush READ selectedBrush WRITE setSelectedBrush)
+  Q_PROPERTY(QFont font READ font WRITE setFont)
+  Q_PROPERTY(QFont selectedFont READ selectedFont WRITE setSelectedFont)
+  Q_PROPERTY(QString text READ text WRITE setText)
+  Q_PROPERTY(Qt::Alignment positionAlignment READ positionAlignment WRITE setPositionAlignment)
+  Q_PROPERTY(Qt::Alignment textAlignment READ textAlignment WRITE setTextAlignment)
+  Q_PROPERTY(double rotation READ rotation WRITE setRotation)
+  Q_PROPERTY(QMargins padding READ padding WRITE setPadding)
+  /// \endcond
+public:
+  QCPItemText(QCustomPlot *parentPlot);
+  virtual ~QCPItemText();
+  
+  // getters:
+  QColor color() const { return mColor; }
+  QColor selectedColor() const { return mSelectedColor; }
+  QPen pen() const { return mPen; }
+  QPen selectedPen() const { return mSelectedPen; }
+  QBrush brush() const { return mBrush; }
+  QBrush selectedBrush() const { return mSelectedBrush; }
+  QFont font() const { return mFont; }
+  QFont selectedFont() const { return mSelectedFont; }
+  QString text() const { return mText; }
+  Qt::Alignment positionAlignment() const { return mPositionAlignment; }
+  Qt::Alignment textAlignment() const { return mTextAlignment; }
+  double rotation() const { return mRotation; }
+  QMargins padding() const { return mPadding; }
+  
+  // setters;
+  void setColor(const QColor &color);
+  void setSelectedColor(const QColor &color);
+  void setPen(const QPen &pen);
+  void setSelectedPen(const QPen &pen);
+  void setBrush(const QBrush &brush);
+  void setSelectedBrush(const QBrush &brush);
+  void setFont(const QFont &font);
+  void setSelectedFont(const QFont &font);
+  void setText(const QString &text);
+  void setPositionAlignment(Qt::Alignment alignment);
+  void setTextAlignment(Qt::Alignment alignment);
+  void setRotation(double degrees);
+  void setPadding(const QMargins &padding);
+  
+  // reimplemented virtual methods:
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+  QCPItemPosition * const position;
+  QCPItemAnchor * const topLeft;
+  QCPItemAnchor * const top;
+  QCPItemAnchor * const topRight;
+  QCPItemAnchor * const right;
+  QCPItemAnchor * const bottomRight;
+  QCPItemAnchor * const bottom;
+  QCPItemAnchor * const bottomLeft;
+  QCPItemAnchor * const left;
+  
+protected:
+  enum AnchorIndex {aiTopLeft, aiTop, aiTopRight, aiRight, aiBottomRight, aiBottom, aiBottomLeft, aiLeft};
+  
+  // property members:
+  QColor mColor, mSelectedColor;
+  QPen mPen, mSelectedPen;
+  QBrush mBrush, mSelectedBrush;
+  QFont mFont, mSelectedFont;
+  QString mText;
+  Qt::Alignment mPositionAlignment;
+  Qt::Alignment mTextAlignment;
+  double mRotation;
+  QMargins mPadding;
+  
+  // reimplemented virtual methods:
+  virtual void draw(QCPPainter *painter);
+  virtual QPointF anchorPixelPoint(int anchorId) const;
+  
+  // non-virtual methods:
+  QPointF getTextDrawPoint(const QPointF &pos, const QRectF &rect, Qt::Alignment positionAlignment) const;
+  QFont mainFont() const;
+  QColor mainColor() const;
+  QPen mainPen() const;
+  QBrush mainBrush() const;
+};
+
+
+class QCP_LIB_DECL QCPItemEllipse : public QCPAbstractItem
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QPen pen READ pen WRITE setPen)
+  Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)
+  Q_PROPERTY(QBrush brush READ brush WRITE setBrush)
+  Q_PROPERTY(QBrush selectedBrush READ selectedBrush WRITE setSelectedBrush)
+  /// \endcond
+public:
+  QCPItemEllipse(QCustomPlot *parentPlot);
+  virtual ~QCPItemEllipse();
+  
+  // getters:
+  QPen pen() const { return mPen; }
+  QPen selectedPen() const { return mSelectedPen; }
+  QBrush brush() const { return mBrush; }
+  QBrush selectedBrush() const { return mSelectedBrush; }
+  
+  // setters;
+  void setPen(const QPen &pen);
+  void setSelectedPen(const QPen &pen);
+  void setBrush(const QBrush &brush);
+  void setSelectedBrush(const QBrush &brush);
+  
+  // reimplemented virtual methods:
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+  QCPItemPosition * const topLeft;
+  QCPItemPosition * const bottomRight;
+  QCPItemAnchor * const topLeftRim;
+  QCPItemAnchor * const top;
+  QCPItemAnchor * const topRightRim;
+  QCPItemAnchor * const right;
+  QCPItemAnchor * const bottomRightRim;
+  QCPItemAnchor * const bottom;
+  QCPItemAnchor * const bottomLeftRim;
+  QCPItemAnchor * const left;
+  QCPItemAnchor * const center;
+  
+protected:
+  enum AnchorIndex {aiTopLeftRim, aiTop, aiTopRightRim, aiRight, aiBottomRightRim, aiBottom, aiBottomLeftRim, aiLeft, aiCenter};
+  
+  // property members:
+  QPen mPen, mSelectedPen;
+  QBrush mBrush, mSelectedBrush;
+  
+  // reimplemented virtual methods:
+  virtual void draw(QCPPainter *painter);
+  virtual QPointF anchorPixelPoint(int anchorId) const;
+  
+  // non-virtual methods:
+  QPen mainPen() const;
+  QBrush mainBrush() const;
+};
+
+
+class QCP_LIB_DECL QCPItemPixmap : public QCPAbstractItem
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QPixmap pixmap READ pixmap WRITE setPixmap)
+  Q_PROPERTY(bool scaled READ scaled WRITE setScaled)
+  Q_PROPERTY(Qt::AspectRatioMode aspectRatioMode READ aspectRatioMode)
+  Q_PROPERTY(Qt::TransformationMode transformationMode READ transformationMode)
+  Q_PROPERTY(QPen pen READ pen WRITE setPen)
+  Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)
+  /// \endcond
+public:
+  QCPItemPixmap(QCustomPlot *parentPlot);
+  virtual ~QCPItemPixmap();
+  
+  // getters:
+  QPixmap pixmap() const { return mPixmap; }
+  bool scaled() const { return mScaled; }
+  Qt::AspectRatioMode aspectRatioMode() const { return mAspectRatioMode; }
+  Qt::TransformationMode transformationMode() const { return mTransformationMode; }
+  QPen pen() const { return mPen; }
+  QPen selectedPen() const { return mSelectedPen; }
+  
+  // setters;
+  void setPixmap(const QPixmap &pixmap);
+  void setScaled(bool scaled, Qt::AspectRatioMode aspectRatioMode=Qt::KeepAspectRatio, Qt::TransformationMode transformationMode=Qt::SmoothTransformation);
+  void setPen(const QPen &pen);
+  void setSelectedPen(const QPen &pen);
+  
+  // reimplemented virtual methods:
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+  QCPItemPosition * const topLeft;
+  QCPItemPosition * const bottomRight;
+  QCPItemAnchor * const top;
+  QCPItemAnchor * const topRight;
+  QCPItemAnchor * const right;
+  QCPItemAnchor * const bottom;
+  QCPItemAnchor * const bottomLeft;
+  QCPItemAnchor * const left;
+  
+protected:
+  enum AnchorIndex {aiTop, aiTopRight, aiRight, aiBottom, aiBottomLeft, aiLeft};
+  
+  // property members:
+  QPixmap mPixmap;
+  QPixmap mScaledPixmap;
+  bool mScaled;
+  bool mScaledPixmapInvalidated;
+  Qt::AspectRatioMode mAspectRatioMode;
+  Qt::TransformationMode mTransformationMode;
+  QPen mPen, mSelectedPen;
+  
+  // reimplemented virtual methods:
+  virtual void draw(QCPPainter *painter);
+  virtual QPointF anchorPixelPoint(int anchorId) const;
+  
+  // non-virtual methods:
+  void updateScaledPixmap(QRect finalRect=QRect(), bool flipHorz=false, bool flipVert=false);
+  QRect getFinalRect(bool *flippedHorz=0, bool *flippedVert=0) const;
+  QPen mainPen() const;
+};
+
+
+class QCP_LIB_DECL QCPItemTracer : public QCPAbstractItem
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QPen pen READ pen WRITE setPen)
+  Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)
+  Q_PROPERTY(QBrush brush READ brush WRITE setBrush)
+  Q_PROPERTY(QBrush selectedBrush READ selectedBrush WRITE setSelectedBrush)
+  Q_PROPERTY(double size READ size WRITE setSize)
+  Q_PROPERTY(TracerStyle style READ style WRITE setStyle)
+  Q_PROPERTY(QCPGraph* graph READ graph WRITE setGraph)
+  Q_PROPERTY(double graphKey READ graphKey WRITE setGraphKey)
+  Q_PROPERTY(bool interpolating READ interpolating WRITE setInterpolating)
+  /// \endcond
+public:
+  /*!
+    The different visual appearances a tracer item can have. Some styles size may be controlled with \ref setSize.
+    
+    \see setStyle
+  */
+  enum TracerStyle { tsNone        ///< The tracer is not visible
+                     ,tsPlus       ///< A plus shaped crosshair with limited size
+                     ,tsCrosshair  ///< A plus shaped crosshair which spans the complete axis rect
+                     ,tsCircle     ///< A circle
+                     ,tsSquare     ///< A square
+                   };
+  Q_ENUMS(TracerStyle)
+
+  QCPItemTracer(QCustomPlot *parentPlot);
+  virtual ~QCPItemTracer();
+
+  // getters:
+  QPen pen() const { return mPen; }
+  QPen selectedPen() const { return mSelectedPen; }
+  QBrush brush() const { return mBrush; }
+  QBrush selectedBrush() const { return mSelectedBrush; }
+  double size() const { return mSize; }
+  TracerStyle style() const { return mStyle; }
+  QCPGraph *graph() const { return mGraph; }
+  double graphKey() const { return mGraphKey; }
+  bool interpolating() const { return mInterpolating; }
+
+  // setters;
+  void setPen(const QPen &pen);
+  void setSelectedPen(const QPen &pen);
+  void setBrush(const QBrush &brush);
+  void setSelectedBrush(const QBrush &brush);
+  void setSize(double size);
+  void setStyle(TracerStyle style);
+  void setGraph(QCPGraph *graph);
+  void setGraphKey(double key);
+  void setInterpolating(bool enabled);
+
+  // reimplemented virtual methods:
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+  // non-virtual methods:
+  void updatePosition();
+
+  QCPItemPosition * const position;
+
+protected:
+  // property members:
+  QPen mPen, mSelectedPen;
+  QBrush mBrush, mSelectedBrush;
+  double mSize;
+  TracerStyle mStyle;
+  QCPGraph *mGraph;
+  double mGraphKey;
+  bool mInterpolating;
+
+  // reimplemented virtual methods:
+  virtual void draw(QCPPainter *painter);
+
+  // non-virtual methods:
+  QPen mainPen() const;
+  QBrush mainBrush() const;
+};
+
+
+class QCP_LIB_DECL QCPItemBracket : public QCPAbstractItem
+{
+  Q_OBJECT
+  /// \cond INCLUDE_QPROPERTIES
+  Q_PROPERTY(QPen pen READ pen WRITE setPen)
+  Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)
+  Q_PROPERTY(double length READ length WRITE setLength)
+  Q_PROPERTY(BracketStyle style READ style WRITE setStyle)
+  /// \endcond
+public:
+  enum BracketStyle { bsSquare  ///< A brace with angled edges
+                      ,bsRound  ///< A brace with round edges
+                      ,bsCurly  ///< A curly brace
+                      ,bsCalligraphic ///< A curly brace with varying stroke width giving a calligraphic impression
+  };
+
+  QCPItemBracket(QCustomPlot *parentPlot);
+  virtual ~QCPItemBracket();
+  
+  // getters:
+  QPen pen() const { return mPen; }
+  QPen selectedPen() const { return mSelectedPen; }
+  double length() const { return mLength; }
+  BracketStyle style() const { return mStyle; }
+  
+  // setters;
+  void setPen(const QPen &pen);
+  void setSelectedPen(const QPen &pen);
+  void setLength(double length);
+  void setStyle(BracketStyle style);
+  
+  // reimplemented virtual methods:
+  virtual double selectTest(const QPointF &pos, bool onlySelectable, QVariant *details=0) const;
+  
+  QCPItemPosition * const left;
+  QCPItemPosition * const right;
+  QCPItemAnchor * const center;
+  
+protected:
+  // property members:
+  enum AnchorIndex {aiCenter};
+  QPen mPen, mSelectedPen;
+  double mLength;
+  BracketStyle mStyle;
+  
+  // reimplemented virtual methods:
+  virtual void draw(QCPPainter *painter);
+  virtual QPointF anchorPixelPoint(int anchorId) const;
+  
+  // non-virtual methods:
+  QPen mainPen() const;
+};
+
+#endif // QCUSTOMPLOT_H
+
diff --git a/meta-services/recipes-services/lcd-app/files/release_note.txt b/meta-services/recipes-services/lcd-app/files/release_note.txt
new file mode 100644
index 0000000..8019b0d
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/release_note.txt
@@ -0,0 +1,12 @@
+GaugingSystem-1.0.0
+
+1. This is the first release with the changes told after the Demo with the TVS people.
+2. Made Changes in UI and Graph.
+3. Used Mysql instead of sqlite.
+4. Parameters synced with ttys.
+5. Thorugh testing on PC is done with four hardwares and five parameters.
+
+GaugingSystem-1.0.1 (4 Jan 2017)
+1. This is the project with which binary is released to TVS.
+2. With this release everything was working stable from software, hardware point of view.
+
diff --git a/meta-services/recipes-services/lcd-app/files/sqltabledelegate.cpp b/meta-services/recipes-services/lcd-app/files/sqltabledelegate.cpp
new file mode 100644
index 0000000..0e8d461
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/sqltabledelegate.cpp
@@ -0,0 +1,113 @@
+#include "sqltabledelegate.h"
+#include <QPainter>
+#include <QDebug>
+
+SqlTableDelegate::SqlTableDelegate(QObject *parent) : QStyledItemDelegate(parent)
+{
+
+}
+
+/**
+ * @brief SqlTableDelegate::paint This is called to draw every Item of the Table view.\n
+ * It does the following\n
+ * 1. It reads the each column data from the mysqltablemodel by specifying the role.\n
+ * 2. And draws the Item in table view with setting the background colour green or red.\n
+ * @param painter Used to do low level painting in widget and other painting devices.\n
+ * @param option  describe the parameters used to draw an item in a view widget.
+ * @param index Locates the data in the data model
+ */
+
+void SqlTableDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const
+{
+    QString gaugeName = index.data(Qt::DisplayRole).toString();
+    float Lsl = index.data(Tvs::LSLRole).toFloat();
+    float Usl = index.data(Tvs::USLRole).toFloat();
+    float Maxval = index.data(Tvs::MaxValRole).toFloat();
+    float MinVal = index.data(Tvs::MinValRole).toFloat();
+
+    QRect totalRect = option.rect;
+    painter->setRenderHint(QPainter::Antialiasing);
+    painter->setRenderHint(QPainter::HighQualityAntialiasing);
+
+    if(index.column() == 0)
+    {
+        QRect textRect = totalRect;
+        textRect.setLeft(textRect.left()+5);
+        painter->save();
+        painter->setRenderHint(QPainter::SmoothPixmapTransform, true);
+        painter->setPen(Qt::RichText);
+        painter->drawText(textRect, Qt::AlignLeft | Qt::AlignVCenter,"  "+gaugeName );
+        painter->restore();
+    }
+   else if(index.column() == 1)
+    {
+        QRect textRect = totalRect;
+        textRect.setLeft(textRect.left()+5);
+        painter->save();
+        painter->setRenderHint(QPainter::SmoothPixmapTransform, true);
+        painter->setPen(Qt::RichText);
+        painter->drawText(textRect, Qt::AlignLeft | Qt::AlignVCenter,"  "+ QString::number(Usl) );
+        painter->restore();
+    }
+    else if(index.column() == 2)
+    {
+        painter->save();
+
+        if((Maxval >= Lsl) && (Maxval <= Usl))
+        {
+          // painter->setPen(Qt::green);
+            painter->fillRect(totalRect,QColor("#006600"));
+
+        }
+        else
+        {
+          //painter->setPen(Qt::red);
+            painter->fillRect(totalRect,Qt::red);
+
+        }
+
+        QRect textRect = totalRect;
+        textRect.setLeft(textRect.left()+5);
+        painter->setPen(Qt::white);
+        painter->setRenderHint(QPainter::SmoothPixmapTransform, true);
+        painter->drawText(textRect, Qt::AlignLeft | Qt::AlignVCenter,"  "+QString::number(Maxval));
+        painter->restore();
+    }
+    else if(index.column() == 3)
+    {
+        QRect textRect = totalRect;
+        textRect.setLeft(textRect.left()+5);
+        painter->save();
+
+        if((MinVal >= Lsl) && (MinVal <= Usl))
+        {
+          // painter->setPen(Qt::green);
+            painter->fillRect(totalRect,QColor("#006600"));
+        }
+        else
+        {
+          //painter->setPen(Qt::red);
+            painter->fillRect(totalRect,Qt::red);
+
+        }
+        painter->setRenderHint(QPainter::SmoothPixmapTransform, true);
+        painter->setPen(Qt::white);
+        painter->drawText(textRect, Qt::AlignLeft | Qt::AlignVCenter,"  "+QString::number(MinVal) );
+        painter->restore();
+    }
+    else if(index.column() == 4)
+    {
+        QRect textRect = totalRect;
+        textRect.setLeft(textRect.left()+5);
+        painter->save();
+        painter->setRenderHint(QPainter::SmoothPixmapTransform, true);
+        painter->setPen(Qt::RichText);
+        painter->drawText(textRect, Qt::AlignLeft | Qt::AlignVCenter,"  "+QString::number(Lsl));
+        painter->restore();
+    }
+}
+
+QSize SqlTableDelegate::sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const
+{
+    return QSize(80,30);
+}
diff --git a/meta-services/recipes-services/lcd-app/files/sqltabledelegate.h b/meta-services/recipes-services/lcd-app/files/sqltabledelegate.h
new file mode 100644
index 0000000..b9386db
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/files/sqltabledelegate.h
@@ -0,0 +1,20 @@
+#ifndef SQLTABLEDELEGATE_H
+#define SQLTABLEDELEGATE_H
+
+
+#include <QStyledItemDelegate>
+#include "include.h"
+#include "gaugedata.h"
+
+
+class SqlTableDelegate : public QStyledItemDelegate
+{
+    Q_OBJECT
+public:
+    explicit SqlTableDelegate(QObject *parent =0);
+
+    void paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const;
+    QSize sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const;
+};
+
+#endif // SQLTABLEDELEGATE_H
diff --git a/meta-services/recipes-services/lcd-app/files/tvs1.jpg b/meta-services/recipes-services/lcd-app/files/tvs1.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..b445f76d39b497a3c67ce267b49ac2155af43f87
GIT binary patch
literal 6697
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

literal 0
HcmV?d00001

diff --git a/meta-services/recipes-services/lcd-app/files/tvs2.jpg b/meta-services/recipes-services/lcd-app/files/tvs2.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..d60203a57e954660eb520120eb23b49f47b162c3
GIT binary patch
literal 6865
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

literal 0
HcmV?d00001

diff --git a/meta-services/recipes-services/lcd-app/files/tvs3.jpg b/meta-services/recipes-services/lcd-app/files/tvs3.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..2ad2ffdacecb2976dbc585f26cc0719e2e2bbee9
GIT binary patch
literal 5159
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
A3jhEB

literal 0
HcmV?d00001

diff --git a/meta-services/recipes-services/lcd-app/files/tvs_horse.png b/meta-services/recipes-services/lcd-app/files/tvs_horse.png
new file mode 100644
index 0000000000000000000000000000000000000000..472f65184c7982545f1fe3cf10351a1d95cfded7
GIT binary patch
literal 4176
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
a1@Lbha%v$sDz2&k0000<MNUMnLSTY(@X`nX

literal 0
HcmV?d00001

diff --git a/meta-services/recipes-services/lcd-app/files/tvs_logo.png b/meta-services/recipes-services/lcd-app/files/tvs_logo.png
new file mode 100644
index 0000000000000000000000000000000000000000..1a4ecaddcbebd7079a26efd6732d13f079d87e99
GIT binary patch
literal 8851
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
V5}{YJQfB}F002ovPDHLkV1oP7HQWFI

literal 0
HcmV?d00001

diff --git a/meta-services/recipes-services/lcd-app/files/tvs_spare.png b/meta-services/recipes-services/lcd-app/files/tvs_spare.png
new file mode 100644
index 0000000000000000000000000000000000000000..bf3038d58314aedd65d8b6589b9b3726f541b5e0
GIT binary patch
literal 44922
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

literal 0
HcmV?d00001

diff --git a/meta-services/recipes-services/lcd-app/lcd-app_0.1.bb b/meta-services/recipes-services/lcd-app/lcd-app_0.1.bb
new file mode 100644
index 0000000..1b01ce6
--- /dev/null
+++ b/meta-services/recipes-services/lcd-app/lcd-app_0.1.bb
@@ -0,0 +1,77 @@
+DESCRIPTION = "LCD Application using Qt"
+HOMEPAGE = "http://www.phytec.in"
+LICENSE = "MIT & CC-BY-3.0"
+LIC_FILES_CHKSUM = " \
+    file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302 \
+    file://${COMMON_LICENSE_DIR}/CC-BY-3.0;md5=dfa02b5755629022e267f10b9c0a2ab7 \
+"
+
+DEPENDS = "qtbase qtbase-native qtdeclarative qtmultimedia qtvirtualkeyboard qtquickcontrols2"
+
+# The resutling packages are machine dependent, because the phytec-qtdemo.service
+# unit is different for ti33x machines.
+PACKAGE_ARCH = "${MACHINE_ARCH}"
+PR = "r0"
+
+SRC_URI = "file://GaugingSystem.pro \
+        file://componentdialog.cpp \
+        file://mainwindow.cpp \
+        file://qcustomplot.cpp \
+        file://sqltabledelegate.cpp \
+        file://main.cpp \
+        file://gaugedatabasemanager.cpp \
+        file://mysqltablemodel.cpp \
+        file://gaugedatabasemanager.h \
+        file://qcustomplot.h \
+        file://sqltabledelegate.h \
+        file://mysqltablemodel.h \
+        file://componentdialog.h \
+        file://gaugedata.h \
+        file://include.h \
+        file://mainwindow.h \
+        file://gauge_system_master.xml \
+        file://gauge_system_master_1.xml \
+        file://tvs1.jpg \
+        file://tvs_horse.png \
+        file://tvs3.jpg \
+        file://tvs_spare.png \
+        file://tvs2.jpg \
+        file://tvs_logo.png \
+"
+
+S = "${WORKDIR}"
+
+inherit qmake5 systemd
+
+#SYSTEMD_SERVICE_${PN} = "lcd-app.service"
+
+FILES_${PN} = "${datadir} ${bindir} ${systemd_unitdir} /home/root/.config"
+
+RDEPENDS_${PN} += "\
+    qtmultimedia-qmlplugins \
+    qtvirtualkeyboard \
+    qtquickcontrols2-qmlplugins \
+    gstreamer1.0-libav \
+    gstreamer1.0-plugins-base-audioconvert \
+    gstreamer1.0-plugins-base-audioresample \
+    gstreamer1.0-plugins-base-playback \
+    gstreamer1.0-plugins-base-typefindfunctions \
+    gstreamer1.0-plugins-base-videoconvert \
+    gstreamer1.0-plugins-base-videoscale \
+    gstreamer1.0-plugins-base-volume \
+    gstreamer1.0-plugins-base-vorbis \
+    gstreamer1.0-plugins-good-autodetect \
+    gstreamer1.0-plugins-good-matroska \
+    gstreamer1.0-plugins-good-ossaudio \
+    gstreamer1.0-plugins-good-videofilter \
+"
+
+#RDEPENDS_${PN}_remove_mx6ul = "\
+#    qtmultimedia-qmlplugins \
+#"
+
+
+do_install_append() {
+    install -d ${D}${bindir}
+    install -m 0644 ${datadir}/${PN}/GaugingSystem ${D}${bindir}/GaugingSystem
+}
diff --git a/meta-services/recipes-services/qtexample/files/qtexample.cpp b/meta-services/recipes-services/qtexample/files/qtexample.cpp
new file mode 100644
index 0000000..107ecc8
--- /dev/null
+++ b/meta-services/recipes-services/qtexample/files/qtexample.cpp
@@ -0,0 +1,10 @@
+#include <QCoreApplication>
+#include <QDebug>
+int main(int argc, char *argv[])
+{
+    QCoreApplication a(argc, argv);
+    
+    qDebug() << "Hello World";
+
+    return a.exec();
+}
diff --git a/meta-services/recipes-services/qtexample/files/qtexample.pro b/meta-services/recipes-services/qtexample/files/qtexample.pro
new file mode 100644
index 0000000..72b7608
--- /dev/null
+++ b/meta-services/recipes-services/qtexample/files/qtexample.pro
@@ -0,0 +1,2 @@
+QT += core
+SOURCES += qtexample.cpp
diff --git a/meta-services/recipes-services/qtexample/qt_example_0.1.bb_bckup b/meta-services/recipes-services/qtexample/qt_example_0.1.bb_bckup
new file mode 100644
index 0000000..6bcc7fe
--- /dev/null
+++ b/meta-services/recipes-services/qtexample/qt_example_0.1.bb_bckup
@@ -0,0 +1,12 @@
+SUMMARY = "QT Example Recipe"
+LICENSE = "CLOSED"
+
+SRC_URI = "file://qtexample.pro \
+           file://qtexample.cpp"
+
+DEPENDS += "qtbase"
+RDEPENDS_${PN} += "qtwayland"
+
+S = "${WORKDIR}"
+
+inherit qmake5
diff --git a/meta-services/recipes-services/qtexample/qtexample_0.1.bb b/meta-services/recipes-services/qtexample/qtexample_0.1.bb
new file mode 100644
index 0000000..9a6db1d
--- /dev/null
+++ b/meta-services/recipes-services/qtexample/qtexample_0.1.bb
@@ -0,0 +1,83 @@
+DESCRIPTION = "LCD Application using Qt"
+HOMEPAGE = "http://www.phytec.in"
+LICENSE = "MIT & CC-BY-3.0"
+LIC_FILES_CHKSUM = " \
+    file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302 \
+    file://${COMMON_LICENSE_DIR}/CC-BY-3.0;md5=dfa02b5755629022e267f10b9c0a2ab7 \
+"
+
+DEPENDS = "qtbase qtdeclarative"
+
+# The resutling packages are machine dependent, because the phytec-qtdemo.service
+# unit is different for ti33x machines.
+PACKAGE_ARCH = "${MACHINE_ARCH}"
+PR = "r0"
+
+#SRC_URI = " \
+#    git://git.phytec.de/phyRDKDemo \
+#    file://phytec-qtdemo.service \
+#    file://PhyKitDemo.conf \
+#"
+
+SRC_URI = "file://qtexample.pro \
+           file://qtexample.cpp"
+
+#SRCREV = "00a3740aa8eb7df85e818058a334fb3e36770369"
+#PV = "1.3+git${SRCPV}"
+
+#S = "${WORKDIR}/git"
+S = "${WORKDIR}"
+
+inherit qmake5 systemd
+
+#SYSTEMD_SERVICE_${PN} = "phytec-qtdemo.service"
+
+#PACKAGES += "${PN}-democontent ${PN}-videos"
+
+FILES_${PN} = "${datadir} ${bindir} ${systemd_unitdir} /home/root/.config"
+#FILES_${PN}-dbg = "${datadir}/${PN}/.debug"
+#FILES_${PN}-dev = "/usr/src"
+#FILES_${PN}-democontent = "${datadir}/${PN}/images"
+#FILES_${PN}-video = "${datadir}/${PN}/videos"
+#LICENSE_${PN}-video = "CC-BY-3.0"
+
+RDEPENDS_${PN} += "\
+    qtmultimedia-qmlplugins \
+    qtvirtualkeyboard \
+    qtquickcontrols2-qmlplugins \
+    gstreamer1.0-libav \
+    gstreamer1.0-plugins-base-audioconvert \
+    gstreamer1.0-plugins-base-audioresample \
+    gstreamer1.0-plugins-base-playback \
+    gstreamer1.0-plugins-base-typefindfunctions \
+    gstreamer1.0-plugins-base-videoconvert \
+    gstreamer1.0-plugins-base-videoscale \
+    gstreamer1.0-plugins-base-volume \
+    gstreamer1.0-plugins-base-vorbis \
+    gstreamer1.0-plugins-good-autodetect \
+    gstreamer1.0-plugins-good-matroska \
+    gstreamer1.0-plugins-good-ossaudio \
+    gstreamer1.0-plugins-good-videofilter \
+"
+
+RDEPENDS_${PN}_remove_mx6ul = "\
+    qtmultimedia-qmlplugins \
+"
+
+#RRECOMMENDS_${PN} += "${PN}-democontent ${PN}-videos"
+
+do_install_append() {
+    install -d ${D}${bindir}
+    ln -sf ${datadir}/${PN}/qtexample ${D}${bindir}/qtexample
+    #install -Dm 0644 ${WORKDIR}/phytec-qtdemo.service ${D}${systemd_system_unitdir}/phytec-qtdemo.service
+    #install -Dm 0644 ${WORKDIR}/PhyKitDemo.conf ${D}/home/root/.config/Phytec/PhyKitDemo.conf
+
+    # democontent
+    #install -d ${D}${datadir}/${PN}/images
+    #for f in ${S}/images/page_phytec_*.png; do \
+    #    install -Dm 0644 $f ${D}${datadir}/${PN}/images/
+    #done
+
+    # videos
+    #install -Dm 0644 ${S}/media/caminandes.webm ${D}${datadir}/${PN}/videos/caminandes.webm
+}
diff --git a/meta-services/recipes-services/smart-app/files/CMakeLists.txt b/meta-services/recipes-services/smart-app/files/CMakeLists.txt
new file mode 100755
index 0000000..4c5c9ce
--- /dev/null
+++ b/meta-services/recipes-services/smart-app/files/CMakeLists.txt
@@ -0,0 +1,33 @@
+cmake_minimum_required(VERSION 3.5)
+project(smart-app)
+
+include_directories(
+        ${CMAKE_CURRENT_SOURCE_DIR}/inc}
+        )
+
+link_directories(
+        ${THISDIR}/../../../dbus-wrapper/0.1-r0/build/
+        )
+
+SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-unknown-pragmas -g -D_GNU_SOURCE \
+                   -D_USINGLIBC -lrt -Wall -lpthread -g -ljson-c \
+                   -I${THISDIR}/../../dbus-wrapper/0.1-r0/inc" 
+   )
+
+set(DBUS_WRAPPER "-ldbus-wrapper" )
+set(JSON_LIBRARY "-ljson-c" )
+
+find_package(PkgConfig REQUIRED)
+pkg_check_modules(DBUS-1  REQUIRED IMPORTED_TARGET dbus-1)
+
+include_directories(${JSON_INCLUDE_DIR})
+
+add_executable (smart_app
+           ${CMAKE_CURRENT_SOURCE_DIR}/src/smart_app.c
+       )
+
+target_link_libraries(smart_app PUBLIC
+                      ${DBUS_WRAPPER}
+                      ${JSON_LIBRARY}
+                      PkgConfig::DBUS-1
+)
diff --git a/meta-services/recipes-services/smart-app/files/inc/log.h b/meta-services/recipes-services/smart-app/files/inc/log.h
new file mode 100644
index 0000000..dacfc2a
--- /dev/null
+++ b/meta-services/recipes-services/smart-app/files/inc/log.h
@@ -0,0 +1,67 @@
+#ifndef LOG_H
+#define LOG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+
+#define LOG_EMERG	0
+#define LOG_ALERT	1
+#define LOG_CRIT	2
+#define LOG_ERR		3
+#define LOG_WARN	4
+#define LOG_NOTICE	5
+#define LOG_INFO	6
+#define LOG_DEBUG	7
+
+#define LOG_LEVEL	6
+
+#define STD_OUT stdout
+#define STD_ERR stderr
+
+#define log_msg(prio, stream, msg, ...) \
+    do {\
+        char *str;\
+        if ((prio == LOG_EMERG) && (LOG_LEVEL >= LOG_EMERG)) {\
+            str = "EMERG";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_ALERT) && (LOG_LEVEL >= LOG_ALERT)) {\
+            str = "ALERT";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_CRIT) && (LOG_LEVEL >= LOG_CRIT)) {\
+            str = "CRIT";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_ERR) && (LOG_LEVEL >= LOG_ERR)) {\
+            str = "ERR";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_WARN) && (LOG_LEVEL >= LOG_WARN)) {\
+            str = "WARN";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_NOTICE) && (LOG_LEVEL >= LOG_NOTICE)) {\
+            str = "NOTICE";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_INFO) && (LOG_LEVEL >= LOG_INFO)) {\
+            str = "INFO";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_DEBUG) && (LOG_LEVEL >= LOG_DEBUG)) {\
+            str = "DEBUG";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+    } while(0)
+
+//log_msg(LOG_ERR, STD_ERR, "\nError in opening %s", filename);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/meta-services/recipes-services/smart-app/files/inc/smart_app.h b/meta-services/recipes-services/smart-app/files/inc/smart_app.h
new file mode 100644
index 0000000..493a17d
--- /dev/null
+++ b/meta-services/recipes-services/smart-app/files/inc/smart_app.h
@@ -0,0 +1,61 @@
+#ifndef DBUS_EMITTER_H
+#define DBUS_EMITTER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <time.h>
+#include <signal.h>
+#include <pthread.h>
+#include <dbus/dbus.h>
+#include <dbus_interface.h>
+#include <dbus_wrapper.h>
+#include <json-c/json.h>
+#include <json-c/json_object.h>
+#include <ctype.h>
+#include <errno.h>
+
+#include "log.h"
+
+#define CAN_ID      0x7E0
+#define DATA_SIZE   500
+#define SIG_DATA    "{\"request\": {\"port_id\": 2, \"action\": \"set\", \"voltage\": 48.45}}"
+#define ACTIVE      "active"
+#define INACTIVE    "inactive"
+#define STATION_ID  12345
+
+struct json_obj_t json_data;
+struct json_obj_t jdata;
+struct signal_data_t signal_data;
+
+struct ev_station_properties
+{
+    char status[20];
+    int cause;
+    int id;
+}station_property;
+
+pthread_mutex_t data_lock;
+static volatile unsigned char dbus_listen = 1;
+static bool is_req_valid = false;
+
+void smart_app_dbus_emitter(int signal_cmd);
+void *dbus_listener();
+void handle_msg_from_AWS_MQTT_module();
+void handle_msg_from_LCD_module();
+void handle_msg_from_CAN_module();
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/meta-services/recipes-services/smart-app/files/src/smart_app.c b/meta-services/recipes-services/smart-app/files/src/smart_app.c
new file mode 100644
index 0000000..d223c47
--- /dev/null
+++ b/meta-services/recipes-services/smart-app/files/src/smart_app.c
@@ -0,0 +1,172 @@
+#include "../inc/smart_app.h"
+
+void smart_app_dbus_emitter(int signal_cmd)
+{
+    struct dbus_var_t dbus_info;
+    char db_payload[DATA_SIZE] = {0};
+
+    dbus_info.obj = SMART_CHARGER_APP_SER_DATA_OBJECT;
+    dbus_info.interface = SMART_CHARGER_APP_SER_DATA_INTERFACE;
+    dbus_info.sig_name = SMART_CHARGER_APP_SER_DATA_SIG_NAME;
+
+    signal_data.cmd = signal_cmd;
+
+    write_init(&dbus_info);
+
+    pthread_mutex_lock(&data_lock);
+
+    compose_data(&json_data, db_payload, signal_data);
+    log_msg(LOG_INFO, STD_OUT, "db_payload Check: %s", db_payload);
+    write_data(db_payload, dbus_info);
+    
+    pthread_mutex_unlock(&data_lock);
+
+    signal_data.payload = NULL;
+    free(signal_data.payload);
+}
+
+int main(int argc, char* argv[])
+{
+    int ret = 0;
+    pthread_t db_listener;
+
+    signal_data.signal_id = SMART_CHARGER_APP_SER_SIGNAL_ID;
+    signal_data.can_id = CAN_ID;
+    signal_data.cmd = 0;
+    
+    station_property.cause = 0;
+    station_property.id = STATION_ID;
+    strcpy(station_property.status, ACTIVE);
+
+    // Thread for D-Bus listener
+    ret = pthread_create(&db_listener, NULL, &dbus_listener, NULL);
+    if(ret != 0)
+    {
+        log_msg(LOG_ERR, STD_ERR, "Error: dbus_listener thread creation Failed!, Error_code:[%d]\n", ret);
+        exit(EXIT_FAILURE);
+    }
+
+    // Waiting for the created thread to terminate
+    pthread_join(db_listener, NULL);
+    return 0;
+}
+
+
+void *dbus_listener()
+{
+    struct dbus_var_t dbus_info;
+
+    uint32_t signal_id = 0;
+    char signal_id_str[10] = {0};
+
+    //init dbus and add filters
+    read_init(&dbus_info);
+    add_filter(&dbus_info, CAN_SER_DATA_RCVR);
+    add_filter(&dbus_info, LCD_SER_DATA_RCVR);
+    add_filter(&dbus_info, AWS_MQTT_APP_SER_DATA_RCVR);
+
+    while(dbus_listen)
+    {
+        if(check_data(&dbus_info) == 0)
+        {
+            jdata = read_data(&dbus_info);
+
+            json_object_object_get_ex(jdata.obj, "sig_id", &jdata.sig);
+            json_object_object_get_ex(jdata.obj, "dlc", &jdata.dlc);
+            json_object_object_get_ex(jdata.obj, "can_id", &jdata.can_id);
+            json_object_object_get_ex(jdata.obj, "cmd", &jdata.cmd);
+            json_object_object_get_ex(jdata.obj, "payload", &jdata.payload);
+
+            // get signal_id
+            if(jdata.sig != NULL)
+            {
+                sprintf(signal_id_str, "%s", json_object_get_string(jdata.sig));
+                signal_id = (int)strtol(signal_id_str, NULL, 16);
+                log_msg(LOG_DEBUG, STD_OUT, "signal id : %04x", signal_id);
+            }
+            switch(signal_id)
+            {
+                case CAN_SER_SIGNAL_ID:
+                    log_msg(LOG_DEBUG, STD_OUT, "Msg from CAN Module");
+                    handle_msg_from_CAN_module();
+                    break;
+                case LCD_SER_SIGNAL_ID:
+                    log_msg(LOG_DEBUG, STD_OUT, "Msg from LCD Module");
+                    handle_msg_from_LCD_module();
+                    break;
+                case AWS_MQTT_APP_SER_SIGNAL_ID:
+                    log_msg(LOG_DEBUG, STD_OUT, "Msg from AWS_MQTT Module");
+                    handle_msg_from_AWS_MQTT_module();
+                    break;
+                default:
+                    log_msg(LOG_DEBUG, STD_OUT, "IN the default switch case");
+                    break;
+            }
+        }
+    }
+    //pthread_exit(NULL);
+    return NULL;
+}
+
+void handle_msg_from_AWS_MQTT_module()
+{
+    char get_json_dbus_payload[DATA_SIZE] = {0};
+    uint32_t sig_cmd = 0;
+
+    // get sig_cmd
+    if(jdata.cmd == NULL)
+    {
+        log_msg(LOG_WARN, STD_OUT, "No signal command");
+        return;
+    }
+
+    if(jdata.payload == NULL)
+    {
+        log_msg(LOG_WARN, STD_OUT, "No signal payload");
+        return;
+    }
+
+    sprintf(get_json_dbus_payload, "%s", json_object_get_string(jdata.cmd));
+    sig_cmd = (int)strtol(get_json_dbus_payload, NULL, 16);
+    log_msg(LOG_DEBUG, STD_OUT, "signal cmd : %04x", sig_cmd);
+
+    if(sig_cmd != REQUEST_SIGNAL)
+    {
+        log_msg(LOG_DEBUG, STD_OUT, "Invalid signal command from AWS_MQTT module");
+    }
+
+    sprintf(get_json_dbus_payload, "%s", json_object_get_string(jdata.payload));
+    log_msg(LOG_INFO, STD_OUT, "D-Bus signal payload : %s", get_json_dbus_payload);
+    log_msg(LOG_INFO, STD_OUT, "D-Bus signal payload len : %ld", strlen(get_json_dbus_payload));
+
+    json_object *jobj = json_tokener_parse(get_json_dbus_payload);
+
+    if(jobj == NULL)
+    {
+        log_msg(LOG_ERR, STD_ERR, "Invalid JSON string");
+
+        // Sending Invalid AWS_MQTT request JSON format error
+        signal_data.payload = (char *)calloc(DATA_SIZE, sizeof(char));
+        sprintf(signal_data.payload, "{\"ev_station\":{\"status\":\"%s\",\"cause\":%d,\"id\":%d,\"event\":{\"type\":\"error\",\"trigger_from\":\"ev_station\",\"is_request\":false,\"is_err\":true,\"err_code\":%d,\"request\":null,\"reponse\":null}}}", station_property.status, station_property.cause, station_property.id, SMART_APP_INVALID_JSON);
+        log_msg(LOG_INFO, STD_OUT, "%s\n", signal_data.payload);
+        smart_app_dbus_emitter(ERROR_SIGNAL);
+
+        is_req_valid = false;
+        return;
+    }
+
+    log_msg(LOG_DEBUG, STD_OUT, "A valid JSON string is passed");
+    is_req_valid = true;
+    //json_parse(jobj);
+}
+
+void handle_msg_from_LCD_module()
+{
+
+}
+
+void handle_msg_from_CAN_module()
+{
+
+}
+
diff --git a/meta-services/recipes-services/smart-app/smart-app_0.1.bb b/meta-services/recipes-services/smart-app/smart-app_0.1.bb
new file mode 100644
index 0000000..77f8426
--- /dev/null
+++ b/meta-services/recipes-services/smart-app/smart-app_0.1.bb
@@ -0,0 +1,26 @@
+SUMMARY = "Central controll application of EV charger"
+SECTION = "App"
+LICENSE = "MIT"
+LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302"
+
+DEPENDS += " \
+    json-c \
+    dbus-wrapper \
+"
+
+SRC_URI = "file://src/smart_app.c \
+            file://inc/log.h \
+            file://inc/smart_app.h \
+            file://CMakeLists.txt \
+"
+
+S = "${WORKDIR}"
+
+inherit cmake
+
+EXTRA_OECMAKE = ""
+
+do_install() {
+    install -d ${D}${bindir}
+    install -m 0755 smart_app ${D}${bindir}
+}
diff --git a/meta-utils/conf/layer.conf b/meta-utils/conf/layer.conf
index 990dc2a..e2b069c 100644
--- a/meta-utils/conf/layer.conf
+++ b/meta-utils/conf/layer.conf
@@ -13,4 +13,4 @@ LAYERDEPENDS_meta-utils = "core"
 LAYERSERIES_COMPAT_meta-utils = "sumo"
 
 # Add main package or features to the image
-# IMAGE_INSTALL_append = " spidev-test"
+IMAGE_INSTALL_append = " dbus-example"
diff --git a/meta-utils/recipes-utils/dbus-example/dbus-example_0.1.bb b/meta-utils/recipes-utils/dbus-example/dbus-example_0.1.bb
new file mode 100644
index 0000000..18974da
--- /dev/null
+++ b/meta-utils/recipes-utils/dbus-example/dbus-example_0.1.bb
@@ -0,0 +1,29 @@
+SUMMARY = "A demo example(emitter/listener) for dbus-wrapper shared library"
+SECTION = "App"
+LICENSE = "MIT"
+LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302"
+
+DEPENDS += " \
+    json-c \
+    dbus-wrapper \
+"
+
+SRC_URI = "file://src/dbus_emitter.c \
+            file://src/dbus_listener.c \
+            file://inc/log.h \
+            file://inc/dbus_listener.h \
+            file://inc/dbus_emitter.h \
+            file://CMakeLists.txt \
+"
+
+S = "${WORKDIR}"
+
+inherit cmake
+
+EXTRA_OECMAKE = ""
+
+do_install() {
+    install -d ${D}${bindir}
+    install -m 0755 dbus_emitter ${D}${bindir}
+    install -m 0755 dbus_listener ${D}${bindir}
+}
diff --git a/meta-utils/recipes-utils/dbus-example/files/CMakeLists.txt b/meta-utils/recipes-utils/dbus-example/files/CMakeLists.txt
new file mode 100755
index 0000000..d9b6221
--- /dev/null
+++ b/meta-utils/recipes-utils/dbus-example/files/CMakeLists.txt
@@ -0,0 +1,42 @@
+cmake_minimum_required(VERSION 3.5)
+project(dbus-example)
+
+include_directories(
+        ${CMAKE_CURRENT_SOURCE_DIR}/inc}
+        )
+
+link_directories(
+        ${THISDIR}/../../../dbus-wrapper/0.1-r0/build/
+        )
+
+SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-unknown-pragmas -g -D_GNU_SOURCE \
+                   -D_USINGLIBC -lrt -Wall -lpthread -g -ljson-c \
+                   -I${THISDIR}/../../dbus-wrapper/0.1-r0/inc" 
+   )
+
+set(DBUS_WRAPPER "-ldbus-wrapper" )
+set(JSON_LIBRARY "-ljson-c" )
+find_package(PkgConfig REQUIRED)
+pkg_check_modules(DBUS-1  REQUIRED IMPORTED_TARGET dbus-1)
+
+add_executable (dbus_listener
+           ${CMAKE_CURRENT_SOURCE_DIR}/src/dbus_listener.c
+       )
+
+include_directories(${JSON_INCLUDE_DIR})
+
+target_link_libraries(dbus_listener PUBLIC
+                      ${DBUS_WRAPPER}
+                      ${JSON_LIBRARY}
+                      PkgConfig::DBUS-1
+)
+
+add_executable (dbus_emitter
+           ${CMAKE_CURRENT_SOURCE_DIR}/src/dbus_emitter.c
+       )
+
+target_link_libraries(dbus_emitter PUBLIC
+                      ${DBUS_WRAPPER}
+                      ${JSON_LIBRARY}
+                      PkgConfig::DBUS-1
+)
diff --git a/meta-utils/recipes-utils/dbus-example/files/cmakelist_bckup b/meta-utils/recipes-utils/dbus-example/files/cmakelist_bckup
new file mode 100755
index 0000000..5dcc1c6
--- /dev/null
+++ b/meta-utils/recipes-utils/dbus-example/files/cmakelist_bckup
@@ -0,0 +1,74 @@
+cmake_minimum_required(VERSION 3.5)
+project(dbus-example)
+
+include_directories(
+        ${CMAKE_CURRENT_SOURCE_DIR}/inc}
+        )
+
+link_directories(
+        ${THISDIR}/../../../dbus-wrapper/0.1-r0/build/
+        )
+
+SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-unknown-pragmas -g -D_GNU_SOURCE \
+                   -D_USINGLIBC -lrt -Wall -lpthread -g \
+                   -I${THISDIR}/../../dbus-wrapper/0.1-r0/inc" 
+   )
+
+set(DBUS_WRAPPER "-ldbus-wrapper" )
+
+find_package(PkgConfig REQUIRED)
+pkg_check_modules(DBUS-1  REQUIRED IMPORTED_TARGET dbus-1)
+
+add_executable (dbus_listener
+           ${CMAKE_CURRENT_SOURCE_DIR}/src/dbus_listener.c
+       )
+
+target_link_libraries(dbus_listener PUBLIC
+                      ${DBUS_WRAPPER}
+                      PkgConfig::DBUS-1
+)
+
+add_executable (dbus_emitter
+           ${CMAKE_CURRENT_SOURCE_DIR}/src/dbus_emitter.c
+       )
+
+target_link_libraries(dbus_emitter PUBLIC
+                      ${DBUS_WRAPPER}
+                      PkgConfig::DBUS-1
+)
+
+add_executable (dbus_read
+           ${CMAKE_CURRENT_SOURCE_DIR}/src/dbus_read.c
+       )
+
+target_link_libraries(dbus_read PUBLIC
+                      ${DBUS_WRAPPER}
+                      PkgConfig::DBUS-1
+)
+
+add_executable (dbus_write
+           ${CMAKE_CURRENT_SOURCE_DIR}/src/dbus_write.c
+       )
+
+target_link_libraries(dbus_write PUBLIC
+                      ${DBUS_WRAPPER}
+                      PkgConfig::DBUS-1
+)
+
+add_executable (listener
+           ${CMAKE_CURRENT_SOURCE_DIR}/src/listener.c
+       )
+
+target_link_libraries(listener PUBLIC
+                      ${DBUS_WRAPPER}
+                      PkgConfig::DBUS-1
+)
+
+add_executable (emitter
+           ${CMAKE_CURRENT_SOURCE_DIR}/src/emitter.c
+       )
+
+target_link_libraries(emitter PUBLIC
+                      ${DBUS_WRAPPER}
+                      PkgConfig::DBUS-1
+)
diff --git a/meta-utils/recipes-utils/dbus-example/files/inc/dbus_emitter.h b/meta-utils/recipes-utils/dbus-example/files/inc/dbus_emitter.h
new file mode 100644
index 0000000..4166c89
--- /dev/null
+++ b/meta-utils/recipes-utils/dbus-example/files/inc/dbus_emitter.h
@@ -0,0 +1,49 @@
+#ifndef DBUS_EMITTER_H
+#define DBUS_EMITTER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <time.h>
+#include <signal.h>
+#include <pthread.h>
+#include <dbus/dbus.h>
+#include <dbus_interface.h>
+#include <dbus_wrapper.h>
+#include <json-c/json.h>
+#include <json-c/json_object.h>
+#include <ctype.h>
+#include <errno.h>
+
+#include "log.h"
+
+#define CAN_ID      0x7E0
+#define DATA_SIZE   500
+#define SIG_DATA    "{\"request\": {\"port_id\": 2, \"action\": \"set\", \"voltage\": 48.45}}"
+
+#define PORT_A_ON       "{\"request\": {\"port_id\": 1, \"action\": \"set\", \"voltage\": 48.45}}"
+#define PORT_B_ON       "{\"request\": {\"port_id\": 2, \"action\": \"set\", \"voltage\": 48.45}}"
+#define PORT_C_ON       "{\"request\": {\"port_id\": 3, \"action\": \"set\", \"voltage\": 48.45}}"
+#define PORT_A_OFF      "{\"request\": {\"port_id\": 1, \"action\": \"reset\", \"voltage\": 48.45}}"
+#define PORT_B_OFF      "{\"request\": {\"port_id\": 2, \"action\": \"reset\", \"voltage\": 48.45}}"
+#define PORT_C_OFF      "{\"request\": {\"port_id\": 3, \"action\": \"reset\", \"voltage\": 48.45}}"
+
+//#define SIG_DATA    "{\"ev_station\":{\"status\":\"active\",\"cause\":0,\"id\":12345,\"event\":{\"type\":\"request\",\"trigger_from\":\"cloud\",\"is_request\":true,\"is_err\":false,\"err_code\":0,\"request\":{\"port_id\":1,\"action\":\"set\",\"voltage\":48.45},\"reponse\":{\"port_id\":0,\"is_avail\":false,\"voltage\":0,\"current\":0}}}}"
+struct json_obj_t json_data;
+struct signal_data_t signal_data;
+pthread_mutex_t data_lock;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/meta-utils/recipes-utils/dbus-example/files/inc/dbus_listener.h b/meta-utils/recipes-utils/dbus-example/files/inc/dbus_listener.h
new file mode 100644
index 0000000..a8ae56b
--- /dev/null
+++ b/meta-utils/recipes-utils/dbus-example/files/inc/dbus_listener.h
@@ -0,0 +1,41 @@
+#ifndef DBUS_LISTENER_H
+#define DBUS_LISTENER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <time.h>
+#include <signal.h>
+#include <pthread.h>
+#include <dbus/dbus.h>
+#include <dbus_interface.h>
+#include <dbus_wrapper.h>
+#include <json-c/json.h>
+#include <json-c/json_object.h>
+#include <ctype.h>
+#include <errno.h>
+
+#include "log.h"
+
+#define DATA_SIZE   500
+#define SIG_DATA    "Helloworld"
+
+pthread_mutex_t data_lock;
+
+struct signal_data_t signal_data;
+int dbus_listen = 1;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/meta-utils/recipes-utils/dbus-example/files/inc/log.h b/meta-utils/recipes-utils/dbus-example/files/inc/log.h
new file mode 100644
index 0000000..dacfc2a
--- /dev/null
+++ b/meta-utils/recipes-utils/dbus-example/files/inc/log.h
@@ -0,0 +1,67 @@
+#ifndef LOG_H
+#define LOG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+
+#define LOG_EMERG	0
+#define LOG_ALERT	1
+#define LOG_CRIT	2
+#define LOG_ERR		3
+#define LOG_WARN	4
+#define LOG_NOTICE	5
+#define LOG_INFO	6
+#define LOG_DEBUG	7
+
+#define LOG_LEVEL	6
+
+#define STD_OUT stdout
+#define STD_ERR stderr
+
+#define log_msg(prio, stream, msg, ...) \
+    do {\
+        char *str;\
+        if ((prio == LOG_EMERG) && (LOG_LEVEL >= LOG_EMERG)) {\
+            str = "EMERG";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_ALERT) && (LOG_LEVEL >= LOG_ALERT)) {\
+            str = "ALERT";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_CRIT) && (LOG_LEVEL >= LOG_CRIT)) {\
+            str = "CRIT";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_ERR) && (LOG_LEVEL >= LOG_ERR)) {\
+            str = "ERR";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_WARN) && (LOG_LEVEL >= LOG_WARN)) {\
+            str = "WARN";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_NOTICE) && (LOG_LEVEL >= LOG_NOTICE)) {\
+            str = "NOTICE";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_INFO) && (LOG_LEVEL >= LOG_INFO)) {\
+            str = "INFO";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+        else if ((prio == LOG_DEBUG) && (LOG_LEVEL >= LOG_DEBUG)) {\
+            str = "DEBUG";\
+            fprintf(stream, "[%s] : %s : %s : "msg" \n", str, __FILE__, __func__, ##__VA_ARGS__);\
+        }\
+    } while(0)
+
+//log_msg(LOG_ERR, STD_ERR, "\nError in opening %s", filename);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/meta-utils/recipes-utils/dbus-example/files/src/dbus_emitter.c b/meta-utils/recipes-utils/dbus-example/files/src/dbus_emitter.c
new file mode 100644
index 0000000..6d2b6c7
--- /dev/null
+++ b/meta-utils/recipes-utils/dbus-example/files/src/dbus_emitter.c
@@ -0,0 +1,160 @@
+#include "../inc/dbus_emitter.h"
+
+//void *dbus_emitter()
+void dbus_emitter()
+{
+    struct dbus_var_t dbus_info;
+    char db_payload[DATA_SIZE] = {0};
+
+    /*dbus_info.obj = AWS_MQTT_APP_SER_DATA_OBJECT;
+    dbus_info.interface = AWS_MQTT_APP_SER_DATA_INTERFACE;
+    dbus_info.sig_name = AWS_MQTT_APP_SER_DATA_SIG_NAME;*/
+    
+    dbus_info.obj = SMART_CHARGER_APP_SER_DATA_OBJECT;
+    dbus_info.interface = SMART_CHARGER_APP_SER_DATA_INTERFACE;
+    dbus_info.sig_name = SMART_CHARGER_APP_SER_DATA_SIG_NAME;
+
+    write_init(&dbus_info);
+
+    pthread_mutex_lock(&data_lock);
+
+    compose_data(&json_data, db_payload, signal_data);
+    log_msg(LOG_INFO, STD_OUT, "db_payload Check: %s", db_payload);
+    write_data(db_payload, dbus_info);
+    
+    pthread_mutex_unlock(&data_lock);
+
+    signal_data.payload = NULL;
+    free(signal_data.payload);
+
+    //return NULL;
+}
+
+int main(int argc, char* argv[])
+{
+    int retval_em = 0;
+    pthread_t db_emitter;
+
+    //signal_data.signal_id = AWS_MQTT_APP_SER_SIGNAL_ID;
+    signal_data.signal_id = SMART_CHARGER_APP_SER_SIGNAL_ID;
+    signal_data.can_id = 0;
+    signal_data.cmd = REQUEST_SIGNAL;
+    //signal_data.payload= (char *)malloc(sizeof(char)*DATA_SIZE);
+/*
+    if(argc < 2)
+    {
+        memcpy(signal_data.payload, SIG_DATA, strlen(SIG_DATA));
+    }
+    else
+    {
+        memcpy(signal_data.payload, argv[1], strlen(argv[1]));
+    }
+
+    signal_data.dlc = strlen(signal_data.payload);
+*/
+    while(1)
+    {
+        signal_data.payload= (char *)malloc(sizeof(char)*DATA_SIZE);
+        memcpy(signal_data.payload, PORT_A_ON, strlen(PORT_A_ON));
+        signal_data.dlc = strlen(signal_data.payload);
+
+        /*retval_em = pthread_create(&db_emitter, NULL, &dbus_emitter, NULL);
+        if(retval_em != 0)
+        {
+            log_msg(LOG_ERR, STD_ERR, "Error: dbus_emitter thread creation Failed!, Error_code:[%d]" ,retval_em);
+            exit(EXIT_FAILURE);
+        }
+
+        // Waiting for the created thread to terminate
+        pthread_join(db_emitter, NULL);*/
+        dbus_emitter();
+
+        sleep(5);
+
+        signal_data.payload= (char *)malloc(sizeof(char)*DATA_SIZE);
+        memcpy(signal_data.payload, PORT_B_ON, strlen(PORT_B_ON));
+        signal_data.dlc = strlen(signal_data.payload);
+
+        /*retval_em = pthread_create(&db_emitter, NULL, &dbus_emitter, NULL);
+        if(retval_em != 0)
+        {
+            log_msg(LOG_ERR, STD_ERR, "Error: dbus_emitter thread creation Failed!, Error_code:[%d]" ,retval_em);
+            exit(EXIT_FAILURE);
+        }
+
+        // Waiting for the created thread to terminate
+        pthread_join(db_emitter, NULL);*/
+        dbus_emitter();
+
+        sleep(5);
+
+        signal_data.payload= (char *)malloc(sizeof(char)*DATA_SIZE);
+        memcpy(signal_data.payload, PORT_C_ON, strlen(PORT_C_ON));
+        signal_data.dlc = strlen(signal_data.payload);
+
+        /*retval_em = pthread_create(&db_emitter, NULL, &dbus_emitter, NULL);
+        if(retval_em != 0)
+        {
+            log_msg(LOG_ERR, STD_ERR, "Error: dbus_emitter thread creation Failed!, Error_code:[%d]" ,retval_em);
+            exit(EXIT_FAILURE);
+        }
+
+        // Waiting for the created thread to terminate
+        pthread_join(db_emitter, NULL);*/
+        dbus_emitter();
+        
+        sleep(10);
+
+        signal_data.payload= (char *)malloc(sizeof(char)*DATA_SIZE);
+        memcpy(signal_data.payload, PORT_A_OFF, strlen(PORT_A_OFF));
+        signal_data.dlc = strlen(signal_data.payload);
+
+        /*retval_em = pthread_create(&db_emitter, NULL, &dbus_emitter, NULL);
+        if(retval_em != 0)
+        {
+            log_msg(LOG_ERR, STD_ERR, "Error: dbus_emitter thread creation Failed!, Error_code:[%d]" ,retval_em);
+            exit(EXIT_FAILURE);
+        }
+
+        // Waiting for the created thread to terminate
+        pthread_join(db_emitter, NULL);*/
+        dbus_emitter();
+
+        sleep(5);
+        
+        signal_data.payload= (char *)malloc(sizeof(char)*DATA_SIZE);
+        memcpy(signal_data.payload, PORT_B_OFF, strlen(PORT_B_OFF));
+        signal_data.dlc = strlen(signal_data.payload);
+
+        /*retval_em = pthread_create(&db_emitter, NULL, &dbus_emitter, NULL);
+        if(retval_em != 0)
+        {
+            log_msg(LOG_ERR, STD_ERR, "Error: dbus_emitter thread creation Failed!, Error_code:[%d]" ,retval_em);
+            exit(EXIT_FAILURE);
+        }
+
+        // Waiting for the created thread to terminate
+        pthread_join(db_emitter, NULL);*/
+        dbus_emitter();
+
+        sleep(5);
+
+        signal_data.payload= (char *)malloc(sizeof(char)*DATA_SIZE);
+        memcpy(signal_data.payload, PORT_C_OFF, strlen(PORT_C_OFF));
+        signal_data.dlc = strlen(signal_data.payload);
+
+        /*retval_em = pthread_create(&db_emitter, NULL, &dbus_emitter, NULL);
+        if(retval_em != 0)
+        {
+            log_msg(LOG_ERR, STD_ERR, "Error: dbus_emitter thread creation Failed!, Error_code:[%d]" ,retval_em);
+            exit(EXIT_FAILURE);
+        }
+
+        // Waiting for the created thread to terminate
+        pthread_join(db_emitter, NULL);*/
+        dbus_emitter();
+
+        sleep(10);
+    }
+    return 0;
+}
diff --git a/meta-utils/recipes-utils/dbus-example/files/src/dbus_listener.c b/meta-utils/recipes-utils/dbus-example/files/src/dbus_listener.c
new file mode 100644
index 0000000..1fca373
--- /dev/null
+++ b/meta-utils/recipes-utils/dbus-example/files/src/dbus_listener.c
@@ -0,0 +1,102 @@
+#include "../inc/dbus_listener.h"
+
+void sigintHandler(int sig_num)
+{
+    dbus_listen = 0;
+    log_msg(LOG_INFO, STD_OUT, "Ctrl + C signal is raised!");
+}
+
+void *dbus_listener()
+{
+    struct dbus_var_t dbus_info;
+    struct json_obj_t jdata;
+
+    // local json objected to extract data from dbus objects
+    struct json_object *sig_id;
+    struct json_object *sig_payload_len;
+    struct json_object *sig_cmd;
+    struct json_object *can_id;
+    struct json_object *sig_payload;
+
+    char get_json_data[DATA_SIZE];
+
+    //init dbus and add filters
+    read_init(&dbus_info);
+    add_filter(&dbus_info, CAN_SER_DATA_RCVR);
+
+    while(dbus_listen)
+    {
+        if(check_data(&dbus_info) == 0)
+        {
+            jdata = read_data(&dbus_info);
+
+            json_object_object_get_ex(jdata.obj, "payload", &jdata.payload);
+            json_object_object_get_ex(jdata.obj, "sig_id", &sig_id);
+            json_object_object_get_ex(jdata.obj, "dlc", &sig_payload_len);
+            json_object_object_get_ex(jdata.obj, "can_id", &can_id);
+            json_object_object_get_ex(jdata.obj, "cmd", &sig_cmd);
+            json_object_object_get_ex(jdata.obj, "payload", &sig_payload);
+
+            // get signal_id
+            if(sig_id != NULL)
+            {
+                sprintf(get_json_data, "%s", json_object_get_string(sig_id));
+                uint32_t signal_id = (int)strtol(get_json_data, NULL, 16);
+                log_msg(LOG_INFO, STD_OUT, "signal id : %04x", signal_id);
+            }
+            
+            // get signal payload len
+            if(sig_payload_len != NULL)
+            {
+                sprintf(get_json_data, "%s", json_object_get_string(sig_payload_len));
+                uint32_t signal_payload_len = (int)strtol(get_json_data, NULL, 16);
+                log_msg(LOG_INFO, STD_OUT, "signal payload len : %04x", signal_payload_len);
+            }
+
+            // get can_id
+            if(can_id != NULL)
+            {
+                sprintf(get_json_data, "%s", json_object_get_string(can_id));
+                uint32_t CAN_id = (int)strtol(get_json_data, NULL, 16);
+                log_msg(LOG_INFO, STD_OUT, "CAN id : %04x", CAN_id);
+            }
+            
+            // get sig_cmd
+            if(sig_cmd != NULL)
+            {
+                sprintf(get_json_data, "%s", json_object_get_string(sig_cmd));
+                uint32_t sig_cmd = (int)strtol(get_json_data, NULL, 16);
+                log_msg(LOG_INFO, STD_OUT, "signal cmd : %04x", sig_cmd);
+            }
+            
+            // get sig_payload
+            if(sig_payload != NULL)
+            {
+                sprintf(get_json_data, "%s", json_object_get_string(sig_payload));
+                log_msg(LOG_INFO, STD_OUT, "signal payload : %s", get_json_data);
+                log_msg(LOG_INFO, STD_OUT, "signal payload len : %ld", strlen(get_json_data));
+            }
+        }
+    }
+    //pthread_exit(NULL);
+    return NULL;
+}
+
+int main(int argc, char* argv[])
+{
+    int retval_lis = 0;
+    pthread_t db_listener;
+
+    //signal(SIGINT, sigintHandler);
+
+    retval_lis = pthread_create(&db_listener, NULL, &dbus_listener, NULL);
+    if(retval_lis != 0)
+    {
+        log_msg(LOG_ERR, STD_ERR, "Error: dbus_listener thread creation Failed!, Error_code:[%d]" ,retval_lis);
+        exit(EXIT_FAILURE);
+    }
+
+    // Waiting for the created thread to terminate
+    pthread_join(db_listener, NULL);
+    return 0;
+}
diff --git a/meta-utils/recipes-utils/dbus-example/files/src/dbus_reference_emitter.c b/meta-utils/recipes-utils/dbus-example/files/src/dbus_reference_emitter.c
new file mode 100644
index 0000000..e8d1c85
--- /dev/null
+++ b/meta-utils/recipes-utils/dbus-example/files/src/dbus_reference_emitter.c
@@ -0,0 +1,97 @@
+#include <dbus/dbus.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#define EMITTER_BUS_NAME        "test.signal.emitter"
+#define EMITTER_OBJECT_NAME     "/test/signal/emitter"
+#define EMITTER_INTERFACE       "test.signal.emitter"
+#define EMITTER_SIGNAL_NAME     "emitter"
+
+
+/**
+ * Connect to the DBUS bus and send a broadcast signal
+ */
+void sendsignal(char* sigvalue)
+{
+    DBusMessage* msg;
+    DBusMessageIter args;
+    DBusConnection* conn;
+    DBusError err;
+    int ret;
+    dbus_uint32_t serial = 0;
+    
+    printf("Sending signal with value %s\n", sigvalue);
+    
+    // initialise the error value
+    dbus_error_init(&err);
+    
+    // connect to the DBUS session bus, and check for errors
+    conn = dbus_bus_get(DBUS_BUS_SESSION, &err);
+    if(dbus_error_is_set(&err)) { 
+        fprintf(stderr, "Connection Error (%s)\n", err.message); 
+        dbus_error_free(&err); 
+    }
+    if(NULL == conn) { 
+        exit(1); 
+    }
+
+    dbus_bool_t rc = dbus_bus_name_has_owner(conn, EMITTER_BUS_NAME, &err);
+    if(dbus_error_is_set(&err))
+    {
+        dbus_error_free(&err);
+        printf("DBus Error: %s\n",err.message);
+        exit(1);
+    }    
+    // register our name on the bus, and check for errors
+    ret = dbus_bus_request_name(conn, EMITTER_BUS_NAME, DBUS_NAME_FLAG_REPLACE_EXISTING , &err);
+    if(dbus_error_is_set(&err)) { 
+        fprintf(stderr, "Name Error (%s)\n", err.message); 
+        dbus_error_free(&err); 
+    }
+    if(DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER != ret) { 
+        exit(1);
+    }
+    
+    // create a signal & check for errors 
+    msg = dbus_message_new_signal(EMITTER_OBJECT_NAME, EMITTER_INTERFACE, EMITTER_SIGNAL_NAME);
+    if(NULL == msg) 
+    { 
+        fprintf(stderr, "Message Null\n"); 
+        exit(1); 
+}
+
+    // append arguments onto signal
+    dbus_message_iter_init_append(msg, &args);
+    if(!dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &sigvalue)) {
+        fprintf(stderr, "Out Of Memory!\n"); 
+        exit(1);
+    }
+
+    // send the message and flush the connection
+    if (!dbus_connection_send(conn, msg, &serial)) {
+        fprintf(stderr, "Out Of Memory!\n"); 
+        exit(1);
+    }
+    dbus_connection_flush(conn);
+
+    printf("Signal Sent\n");
+
+    // free the message and close the connection
+    dbus_message_unref(msg);
+    // dbus_connection_close(conn);
+}
+
+int main(int argc, char** argv)
+{
+    if (argc < 2) {
+        printf ("Syntax: %s [<param>]\n", __FILE__);
+        return 1;
+    }
+    char* param = "no param";
+    if (argc <= 2 && argv[1] != NULL)
+        param = argv[1];
+    sendsignal(param);
+    return 0;
+}
diff --git a/meta-utils/recipes-utils/dbus-example/files/src/dbus_reference_listener.c b/meta-utils/recipes-utils/dbus-example/files/src/dbus_reference_listener.c
new file mode 100644
index 0000000..c5de078
--- /dev/null
+++ b/meta-utils/recipes-utils/dbus-example/files/src/dbus_reference_listener.c
@@ -0,0 +1,97 @@
+#include <dbus/dbus.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#define LISTERNER_BUS_NAME      "test.signal.listener"
+#define EMITTER_BUS_NAME        "test.signal.emitter"
+#define EMITTER_INTERFACE_NAME  "type='signal',interface='test.signal.emitter'"
+#define EMITTER_SIGNAL_NAME     "emitter"
+
+/**
+ * Listens for signals on the bus
+ */
+void dbus_listerner(char *sigvalue)
+{
+   DBusMessage* msg;
+   DBusMessageIter args;
+   DBusConnection* conn;
+   DBusError err;
+   int ret;
+
+   printf("Listening for signals\n");
+
+   // initialise the errors
+   dbus_error_init(&err);
+   
+   // connect to the D-Bus session bus and check for errors
+   conn = dbus_bus_get(DBUS_BUS_SESSION, &err);
+   if (dbus_error_is_set(&err)) { 
+      fprintf(stderr, "Connection Error (%s)\n", err.message);
+      dbus_error_free(&err); 
+   }
+   if (NULL == conn) { 
+      exit(1);
+   }
+   
+   // request our name on the bus and check for errors
+   ret = dbus_bus_request_name(conn, LISTERNER_BUS_NAME, DBUS_NAME_FLAG_REPLACE_EXISTING , &err);
+   if (dbus_error_is_set(&err)) { 
+      fprintf(stderr, "Name Error (%s)\n", err.message);
+      dbus_error_free(&err); 
+   }
+   if (DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER != ret) {
+      exit(1);
+   }
+
+   // add a rule for which messages we want to see
+   dbus_bus_add_match(conn, EMITTER_INTERFACE_NAME, &err); // see signals from the given interface
+   dbus_connection_flush(conn);
+   if (dbus_error_is_set(&err)) { 
+      fprintf(stderr, "Match Error (%s)\n", err.message);
+      exit(1); 
+   }
+   printf("Match rule sent\n");
+
+   // loop listening for signals being emmitted
+   while (true) {
+
+      // non blocking read of the next available message
+      dbus_connection_read_write(conn, 0);
+      msg = dbus_connection_pop_message(conn);
+
+      // loop again if we haven't read a message
+      if (NULL == msg) { 
+         sleep(1);
+         continue;
+      }
+
+      // check if the message is a signal from the correct interface and with the correct name
+      if (dbus_message_is_signal(msg, EMITTER_BUS_NAME, EMITTER_SIGNAL_NAME)) {
+         
+         // read the parameters
+         if (!dbus_message_iter_init(msg, &args))
+            fprintf(stderr, "Message Has No Parameters\n");
+         else if (DBUS_TYPE_STRING != dbus_message_iter_get_arg_type(&args)) 
+            fprintf(stderr, "Argument is not string!\n"); 
+         else
+            dbus_message_iter_get_basic(&args, &sigvalue);
+         
+         printf("Got Signal with value %s\n", sigvalue);
+      }
+
+      // free the message
+      dbus_message_unref(msg);
+   }
+   // close the connection
+   // dbus_connection_close(conn);
+}
+
+int main()
+{
+    char signal_payload[100];
+    dbus_listerner(signal_payload);
+    printf("\nSignal payload = %s\n", signal_payload);
+    return 0;
+}
diff --git a/meta-utils/recipes-utils/dbus-example/files/src/simple_dbus_emitter.c b/meta-utils/recipes-utils/dbus-example/files/src/simple_dbus_emitter.c
new file mode 100644
index 0000000..154cc25
--- /dev/null
+++ b/meta-utils/recipes-utils/dbus-example/files/src/simple_dbus_emitter.c
@@ -0,0 +1,39 @@
+#include "../inc/dbus_emitter.h"
+
+void send_signal()
+{
+    struct dbus_var_t dbus_info;
+    char db_payload[500] = {0};
+    
+    signal_data.payload= (char *)malloc(sizeof(char)*250);
+
+    dbus_info.obj = CAN_SER_DATA_OBJECT;
+    dbus_info.interface = CAN_SER_DATA_INTERFACE;
+    dbus_info.sig_name = CAN_SER_DATA_SIG_NAME;
+    
+    write_init(&dbus_info);
+    
+    signal_data.signal_id = CAN_SER_SIGNAL_ID;
+
+    strcpy(signal_data.payload, SIG_DATA);
+
+    pthread_mutex_lock(&data_lock);
+    compose_data(&json_data, db_payload,signal_data);
+    log_msg(LOG_INFO, STD_OUT, "db_payload Check: %s",db_payload);
+    write_data(db_payload,dbus_info);
+    pthread_mutex_unlock(&data_lock);
+    
+    signal_data.payload = NULL;
+    free(signal_data.payload);
+}
+
+int main()
+{
+    for(int i = 0; i < 100; i++)
+    {
+        sleep(1);
+        send_signal();
+    }
+    return 0;
+}
+
diff --git a/meta-utils/recipes-utils/dbus-example/files/src/simple_dbus_listener.c b/meta-utils/recipes-utils/dbus-example/files/src/simple_dbus_listener.c
new file mode 100644
index 0000000..e1bce00
--- /dev/null
+++ b/meta-utils/recipes-utils/dbus-example/files/src/simple_dbus_listener.c
@@ -0,0 +1,103 @@
+#include "../inc/dbus_listener.h"
+
+void *dbus_listener()
+{
+    static int recv_cnt = 0;
+    struct dbus_var_t dbus_info;
+    struct json_obj_t jdata;
+
+    // local json objected to extract data from dbus objects
+    struct json_object *sig;
+    struct json_object *dlc;
+    struct json_object *cmd;
+    struct json_object *can_id;
+    struct json_object *payload;
+
+    log_msg(LOG_INFO, STD_OUT, "In the thread");
+
+    char get_json_data[DATA_SIZE] = {0};
+
+    //init dbus and add filters
+    read_init(&dbus_info);
+    log_msg(LOG_INFO, STD_OUT, "2");
+    add_filter(&dbus_info, CAN_SER_DATA_RCVR);
+    log_msg(LOG_INFO, STD_OUT, "3");
+    while (dbus_run)
+    {
+        if (check_data(&dbus_info) == 0)
+        {
+            log_msg(LOG_INFO, STD_OUT, "4");
+
+            jdata = read_data(&dbus_info);
+            json_object_object_get_ex(jdata.obj, "payload", &jdata.payload);
+
+	    	json_object_object_get_ex(jdata.obj, "sig_id", &sig);
+            json_object_object_get_ex(jdata.obj, "dlc", &dlc);
+	    	json_object_object_get_ex(jdata.obj, "can_id", &can_id);
+            json_object_object_get_ex(jdata.obj, "cmd", &cmd);
+            json_object_object_get_ex(jdata.obj, "payload", &payload);
+
+            log_msg(LOG_INFO, STD_OUT, "5");
+            // get signal
+            if(sig != NULL)
+            {
+                sprintf(get_json_data, "%s", json_object_get_string(sig));
+                uint32_t signal_id = (int)strtol(get_json_data, NULL, 16);
+			    log_msg(LOG_INFO, STD_OUT, "SIGNAL ID : %04x",signal_id);
+            }
+            
+            if(dlc != NULL)
+            {
+                log_msg(LOG_INFO, STD_OUT, "6");
+                sprintf(get_json_data, "%s", json_object_get_string(dlc));
+                uint32_t signal_dlc = (int)strtol(get_json_data, NULL, 16);
+			    log_msg(LOG_INFO, STD_OUT, "SIGNAL payload DLC : %04x",signal_dlc);
+            }
+
+            if(can_id != NULL)
+            {
+                log_msg(LOG_INFO, STD_OUT, "7");
+                sprintf(get_json_data, "%s", json_object_get_string(can_id));
+                uint32_t signal_can_id = (int)strtol(get_json_data, NULL, 16);
+			    log_msg(LOG_INFO, STD_OUT, "SIGNAL can id : %04x",signal_can_id);
+            }
+           
+            if(cmd != NULL)
+            {
+                log_msg(LOG_INFO, STD_OUT, "8");
+                sprintf(get_json_data, "%s", json_object_get_string(cmd));
+                uint32_t signal_cmd = (int)strtol(get_json_data, NULL, 16);
+		    	log_msg(LOG_INFO, STD_OUT, "SIGNAL cmd : %04x",signal_cmd);
+            }
+
+            if(payload != NULL)
+            {
+                log_msg(LOG_INFO, STD_OUT, "9");
+                sprintf(get_json_data, "%s", json_object_get_string(payload));
+			    log_msg(LOG_INFO, STD_OUT, "SIGNAL payload : %s",get_json_data);
+                log_msg(LOG_INFO, STD_OUT, "10");
+            }
+            recv_cnt += 1;
+            log_msg(LOG_INFO, STD_OUT, "recv_cnt = %d", recv_cnt);
+        }
+    }
+    pthread_exit(NULL);
+}
+
+int main()
+{
+    int retval_lis = 0;
+    
+    pthread_t db_listener;
+  
+    retval_lis = pthread_create(&db_listener, NULL, &dbus_listener, NULL);
+    if(retval_lis != 0)
+    {
+        log_msg(LOG_ERR, STD_ERR, "Error: dbus_listener thread creation Failed!, Error_code:[%d]\n",retval_lis);
+        exit(0);
+    }
+
+    pthread_join(db_listener, NULL);
+    return 0;
+}
+
diff --git a/meta-utils/recipes-utils/dbus-example/files/src/test_dbus_emitter.c b/meta-utils/recipes-utils/dbus-example/files/src/test_dbus_emitter.c
new file mode 100644
index 0000000..9ab5fb5
--- /dev/null
+++ b/meta-utils/recipes-utils/dbus-example/files/src/test_dbus_emitter.c
@@ -0,0 +1,44 @@
+#include "../inc/dbus_emitter.h"
+
+void *dbus_emitter()
+{
+    struct dbus_var_t dbus_info;
+
+    dbus_info.obj = signal_object;
+    dbus_info.interface = signal_interface;
+    dbus_info.sig_name = signal_name;
+
+    dbus_init(&dbus_info);
+
+    write_data(signal_data, dbus_info);
+
+    return NULL;
+}
+
+int main(int argc, char* argv[])
+{
+    int retval_em = 0;
+    pthread_t db_emitter;
+
+    if(argc < 5)
+    {
+        log_msg(LOG_WARN, STD_OUT, "\nUsage: %s <signal object> <signal interface> <signal name> <signal data>.\n", argv[0]);
+        exit(EXIT_FAILURE);
+    }
+
+    memcpy(signal_object, argv[1], strlen(argv[1]));
+    memcpy(signal_interface, argv[2], strlen(argv[2]));
+    memcpy(signal_name, argv[3], strlen(argv[3]));
+    memcpy(signal_data, argv[4], strlen(argv[4]));
+
+    retval_em = pthread_create(&db_emitter, NULL, &dbus_emitter, NULL);
+    if(retval_em != 0)
+    {
+        log_msg(LOG_ERR, STD_ERR, "Error: dbus_emitter thread creation Failed!, Error_code:[%d]" ,retval_em);
+        exit(EXIT_FAILURE);
+    }
+
+    // Waiting for the created thread to terminate
+    pthread_join(db_emitter, NULL);
+    return 0;
+}
diff --git a/meta-utils/recipes-utils/dbus-example/files/src/test_dbus_listener.c b/meta-utils/recipes-utils/dbus-example/files/src/test_dbus_listener.c
new file mode 100644
index 0000000..97ba400
--- /dev/null
+++ b/meta-utils/recipes-utils/dbus-example/files/src/test_dbus_listener.c
@@ -0,0 +1,56 @@
+#include "../inc/dbus_listener.h"
+
+void sigintHandler(int sig_num)
+{
+    listening = 0;
+    log_msg(LOG_INFO, STD_OUT, "Ctrl + C signal is raised!");
+}
+
+void *dbus_listener()
+{
+    struct dbus_var_t dbus_info;
+    char get_dbus_signal_data[DATA_SIZE] = {0};
+
+    //init dbus and add filters
+    dbus_init(&dbus_info);
+    add_filter(&dbus_info, signal_match_rule);
+
+    while(listening)
+    {
+        if (check_data(&dbus_info) == 0)
+        {
+            read_data(&dbus_info, signal_interface, signal_name, get_dbus_signal_data);
+            log_msg(LOG_INFO, STD_OUT, "sigvalue = %s", get_dbus_signal_data);
+        }
+    }
+    return NULL;
+}
+
+int main(int argc, char* argv[])
+{
+    int retval_lis = 0;
+    pthread_t db_listener;
+
+    signal(SIGINT, sigintHandler);
+
+    if(argc < 4)
+    {
+        log_msg(LOG_WARN, STD_OUT, "\nUsage: %s <dbus signal interface> <signal name> <signal match rule>.\n", argv[0]);
+        exit(EXIT_FAILURE);
+    }
+
+    memcpy(signal_interface, argv[1], strlen(argv[1]));
+    memcpy(signal_name, argv[2], strlen(argv[2]));
+    memcpy(signal_match_rule, argv[3], strlen(argv[3]));
+
+    retval_lis = pthread_create(&db_listener, NULL, &dbus_listener, NULL);
+    if(retval_lis != 0)
+    {
+        log_msg(LOG_ERR, STD_ERR, "Error: dbus_listener thread creation Failed!, Error_code:[%d]" ,retval_lis);
+        exit(EXIT_FAILURE);
+    }
+
+    // Waiting for the created thread to terminate
+    pthread_join(db_listener, NULL);
+    return 0;
+}
-- 
2.17.1

